###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        16/Apr/2020  18:39:02
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\Marlin_main.cpp
#    Command line =  
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\Marlin_main.cpp
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -D USE_STM32F407VET -lC
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM\mksDLP/List\ -lA
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM\mksDLP/Obj\ --no_unroll
#        --no_inline --no_tbaa --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp --dlib_config
#        "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Inc\ -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Src\ -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/BSP/variant\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/BSP/Components/lcd\
#        -I D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/libstmf4\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/libstmf4/include\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../User/ui\ -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../User/ui/Multi_language\
#        -I D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../User/ui/QRENCODE\
#        -I D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Middlewares/GUI\
#        -Om --eec++ -I "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\"
#    List file    =  
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM\mksDLP/List\Marlin_main.lst
#    Object file  =  
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM\mksDLP/Obj\Marlin_main.o
#
###############################################################################

D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\Marlin_main.cpp
      1          /**
      2           * Marlin 3D Printer Firmware
      3           * Copyright (C) 2016, 2017 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
      4           *
      5           * Based on Sprinter and grbl.
      6           * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
      7           *
      8           * This program is free software: you can redistribute it and/or modify
      9           * it under the terms of the GNU General Public License as published by
     10           * the Free Software Foundation, either version 3 of the License, or
     11           * (at your option) any later version.
     12           *
     13           * This program is distributed in the hope that it will be useful,
     14           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     15           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     16           * GNU General Public License for more details.
     17           *
     18           * You should have received a copy of the GNU General Public License
     19           * along with this program.  If not, see <http://www.gnu.org/licenses/>.
     20           *
     21           */
     22          
     23          /**
     24           * About Marlin
     25           *
     26           * This firmware is a mashup between Sprinter and grbl.
     27           *  - https://github.com/kliment/Sprinter
     28           *  - https://github.com/simen/grbl/tree
     29           */
     30          
     31          /**
     32           * -----------------
     33           * G-Codes in Marlin
     34           * -----------------
     35           *
     36           * Helpful G-code references:
     37           *  - http://linuxcnc.org/handbook/gcode/g-code.html
     38           *  - http://objects.reprap.org/wiki/Mendel_User_Manual:_RepRapGCodes
     39           *
     40           * Help to document Marlin's G-codes online:
     41           *  - http://reprap.org/wiki/G-code
     42           *  - https://github.com/MarlinFirmware/MarlinDocumentation
     43           *
     44           * -----------------
     45           *
     46           * "G" Codes
     47           *
     48           * G0   -> G1
     49           * G1   - Coordinated Movement X Y Z E
     50           * G2   - CW ARC
     51           * G3   - CCW ARC
     52           * G4   - Dwell S<seconds> or P<milliseconds>
     53           * G5   - Cubic B-spline with XYZE destination and IJPQ offsets
     54           * G10  - Retract filament according to settings of M207 (Requires FWRETRACT)
     55           * G11  - Retract recover filament according to settings of M208 (Requires FWRETRACT)
     56           * G12  - Clean tool (Requires NOZZLE_CLEAN_FEATURE)
     57           * G17  - Select Plane XY (Requires CNC_WORKSPACE_PLANES)
     58           * G18  - Select Plane ZX (Requires CNC_WORKSPACE_PLANES)
     59           * G19  - Select Plane YZ (Requires CNC_WORKSPACE_PLANES)
     60           * G20  - Set input units to inches (Requires INCH_MODE_SUPPORT)
     61           * G21  - Set input units to millimeters (Requires INCH_MODE_SUPPORT)
     62           * G26  - Mesh Validation Pattern (Requires G26_MESH_VALIDATION)
     63           * G27  - Park Nozzle (Requires NOZZLE_PARK_FEATURE)
     64           * G28  - Home one or more axes
     65           * G29  - Start or continue the bed leveling probe procedure (Requires bed leveling)
     66           * G30  - Single Z probe, probes bed at X Y location (defaults to current XY location)
     67           * G31  - Dock sled (Z_PROBE_SLED only)
     68           * G32  - Undock sled (Z_PROBE_SLED only)
     69           * G33  - Delta Auto-Calibration (Requires DELTA_AUTO_CALIBRATION)
     70           * G38  - Probe in any direction using the Z_MIN_PROBE (Requires G38_PROBE_TARGET)
     71           * G42  - Coordinated move to a mesh point (Requires MESH_BED_LEVELING, AUTO_BED_LEVELING_BLINEAR, or AUTO_BED_LEVELING_UBL)
     72           * G90  - Use Absolute Coordinates
     73           * G91  - Use Relative Coordinates
     74           * G92  - Set current position to coordinates given
     75           *
     76           * "M" Codes
     77           *
     78           * M0   - Unconditional stop - Wait for user to press a button on the LCD (Only if ULTRA_LCD is enabled)
     79           * M1   -> M0
     80           * M3   - Turn laser/spindle on, set spindle/laser speed/power, set rotation to clockwise
     81           * M4   - Turn laser/spindle on, set spindle/laser speed/power, set rotation to counter-clockwise
     82           * M5   - Turn laser/spindle off
     83           * M17  - Enable/Power all stepper motors
     84           * M18  - Disable all stepper motors; same as M84
     85           * M20  - List SD card. (Requires SDSUPPORT)
     86           * M21  - Init SD card. (Requires SDSUPPORT)
     87           * M22  - Release SD card. (Requires SDSUPPORT)
     88           * M23  - Select SD file: "M23 /path/file.gco". (Requires SDSUPPORT)
     89           * M24  - Start/resume SD print. (Requires SDSUPPORT)
     90           * M25  - Pause SD print. (Requires SDSUPPORT)
     91           * M26  - Set SD position in bytes: "M26 S12345". (Requires SDSUPPORT)
     92           * M27  - Report SD print status. (Requires SDSUPPORT)
     93           * M28  - Start SD write: "M28 /path/file.gco". (Requires SDSUPPORT)
     94           * M29  - Stop SD write. (Requires SDSUPPORT)
     95           * M30  - Delete file from SD: "M30 /path/file.gco"
     96           * M31  - Report time since last M109 or SD card start to serial.
     97           * M32  - Select file and start SD print: "M32 [S<bytepos>] !/path/file.gco#". (Requires SDSUPPORT)
     98           *        Use P to run other files as sub-programs: "M32 P !filename#"
     99           *        The '#' is necessary when calling from within sd files, as it stops buffer prereading
    100           * M33  - Get the longname version of a path. (Requires LONG_FILENAME_HOST_SUPPORT)
    101           * M34  - Set SD Card sorting options. (Requires SDCARD_SORT_ALPHA)
    102           * M42  - Change pin status via gcode: M42 P<pin> S<value>. LED pin assumed if P is omitted.
    103           * M43  - Display pin status, watch pins for changes, watch endstops & toggle LED, Z servo probe test, toggle pins
    104           * M48  - Measure Z Probe repeatability: M48 P<points> X<pos> Y<pos> V<level> E<engage> L<legs>. (Requires Z_MIN_PROBE_REPEATABILITY_TEST)
    105           * M75  - Start the print job timer.
    106           * M76  - Pause the print job timer.
    107           * M77  - Stop the print job timer.
    108           * M78  - Show statistical information about the print jobs. (Requires PRINTCOUNTER)
    109           * M80  - Turn on Power Supply. (Requires POWER_SUPPLY > 0)
    110           * M81  - Turn off Power Supply. (Requires POWER_SUPPLY > 0)
    111           * M82  - Set E codes absolute (default).
    112           * M83  - Set E codes relative while in Absolute (G90) mode.
    113           * M84  - Disable steppers until next move, or use S<seconds> to specify an idle
    114           *        duration after which steppers should turn off. S0 disables the timeout.
    115           * M85  - Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
    116           * M92  - Set planner.axis_steps_per_mm for one or more axes.
    117           * M100 - Watch Free Memory (for debugging) (Requires M100_FREE_MEMORY_WATCHER)
    118           * M104 - Set extruder target temp.
    119           * M105 - Report current temperatures.
    120           * M106 - Set print fan speed.
    121           * M107 - Print fan off.
    122           * M108 - Break out of heating loops (M109, M190, M303). With no controller, breaks out of M0/M1. (Requires EMERGENCY_PARSER)
    123           * M109 - Sxxx Wait for extruder current temp to reach target temp. Waits only when heating
    124           *        Rxxx Wait for extruder current temp to reach target temp. Waits when heating and cooling
    125           *        If AUTOTEMP is enabled, S<mintemp> B<maxtemp> F<factor>. Exit autotemp by any M109 without F
    126           * M110 - Set the current line number. (Used by host printing)
    127           * M111 - Set debug flags: "M111 S<flagbits>". See flag bits defined in enum.h.
    128           * M112 - Emergency stop.
    129           * M113 - Get or set the timeout interval for Host Keepalive "busy" messages. (Requires HOST_KEEPALIVE_FEATURE)
    130           * M114 - Report current position.
    131           * M115 - Report capabilities. (Extended capabilities requires EXTENDED_CAPABILITIES_REPORT)
    132           * M117 - Display a message on the controller screen. (Requires an LCD)
    133           * M118 - Display a message in the host console.
    134           * M119 - Report endstops status.
    135           * M120 - Enable endstops detection.
    136           * M121 - Disable endstops detection.
    137           * M122 - Debug stepper (Requires HAVE_TMC2130)
    138           * M125 - Save current position and move to filament change position. (Requires PARK_HEAD_ON_PAUSE)
    139           * M126 - Solenoid Air Valve Open. (Requires BARICUDA)
    140           * M127 - Solenoid Air Valve Closed. (Requires BARICUDA)
    141           * M128 - EtoP Open. (Requires BARICUDA)
    142           * M129 - EtoP Closed. (Requires BARICUDA)
    143           * M140 - Set bed target temp. S<temp>
    144           * M145 - Set heatup values for materials on the LCD. H<hotend> B<bed> F<fan speed> for S<material> (0=PLA, 1=ABS)
    145           * M149 - Set temperature units. (Requires TEMPERATURE_UNITS_SUPPORT)
    146           * M150 - Set Status LED Color as R<red> U<green> B<blue> P<bright>. Values 0-255. (Requires BLINKM, RGB_LED, RGBW_LED, NEOPIXEL_LED, or PCA9632).
    147           * M155 - Auto-report temperatures with interval of S<seconds>. (Requires AUTO_REPORT_TEMPERATURES)
    148           * M163 - Set a single proportion for a mixing extruder. (Requires MIXING_EXTRUDER)
    149           * M164 - Save the mix as a virtual extruder. (Requires MIXING_EXTRUDER and MIXING_VIRTUAL_TOOLS)
    150           * M165 - Set the proportions for a mixing extruder. Use parameters ABCDHI to set the mixing factors. (Requires MIXING_EXTRUDER)
    151           * M190 - Sxxx Wait for bed current temp to reach target temp. ** Waits only when heating! **
    152           *        Rxxx Wait for bed current temp to reach target temp. ** Waits for heating or cooling. **
    153           * M200 - Set filament diameter, D<diameter>, setting E axis units to cubic. (Use S0 to revert to linear units.)
    154           * M201 - Set max acceleration in units/s^2 for print moves: "M201 X<accel> Y<accel> Z<accel> E<accel>"
    155           * M202 - Set max acceleration in units/s^2 for travel moves: "M202 X<accel> Y<accel> Z<accel> E<accel>" ** UNUSED IN MARLIN! **
    156           * M203 - Set maximum feedrate: "M203 X<fr> Y<fr> Z<fr> E<fr>" in units/sec.
    157           * M204 - Set default acceleration in units/sec^2: P<printing> R<extruder_only> T<travel>
    158           * M205 - Set advanced settings. Current units apply:
    159                      S<print> T<travel> minimum speeds
    160                      B<minimum segment time>
    161                      X<max X jerk>, Y<max Y jerk>, Z<max Z jerk>, E<max E jerk>
    162           * M206 - Set additional homing offset. (Disabled by NO_WORKSPACE_OFFSETS or DELTA)
    163           * M207 - Set Retract Length: S<length>, Feedrate: F<units/min>, and Z lift: Z<distance>. (Requires FWRETRACT)
    164           * M208 - Set Recover (unretract) Additional (!) Length: S<length> and Feedrate: F<units/min>. (Requires FWRETRACT)
    165           * M209 - Turn Automatic Retract Detection on/off: S<0|1> (For slicers that don't support G10/11). (Requires FWRETRACT)
    166                    Every normal extrude-only move will be classified as retract depending on the direction.
    167           * M211 - Enable, Disable, and/or Report software endstops: S<0|1> (Requires MIN_SOFTWARE_ENDSTOPS or MAX_SOFTWARE_ENDSTOPS)
    168           * M218 - Set a tool offset: "M218 T<index> X<offset> Y<offset>". (Requires 2 or more extruders)
    169           * M220 - Set Feedrate Percentage: "M220 S<percent>" (i.e., "FR" on the LCD)
    170           * M221 - Set Flow Percentage: "M221 S<percent>"
    171           * M226 - Wait until a pin is in a given state: "M226 P<pin> S<state>"
    172           * M240 - Trigger a camera to take a photograph. (Requires CHDK or PHOTOGRAPH_PIN)
    173           * M250 - Set LCD contrast: "M250 C<contrast>" (0-63). (Requires LCD support)
    174           * M260 - i2c Send Data (Requires EXPERIMENTAL_I2CBUS)
    175           * M261 - i2c Request Data (Requires EXPERIMENTAL_I2CBUS)
    176           * M280 - Set servo position absolute: "M280 P<index> S<angle|µs>". (Requires servos)
    177           * M290 - Babystepping (Requires BABYSTEPPING)
    178           * M300 - Play beep sound S<frequency Hz> P<duration ms>
    179           * M301 - Set PID parameters P I and D. (Requires PIDTEMP)
    180           * M302 - Allow cold extrudes, or set the minimum extrude S<temperature>. (Requires PREVENT_COLD_EXTRUSION)
    181           * M303 - PID relay autotune S<temperature> sets the target temperature. Default 150C. (Requires PIDTEMP)
    182           * M304 - Set bed PID parameters P I and D. (Requires PIDTEMPBED)
    183           * M350 - Set microstepping mode. (Requires digital microstepping pins.)
    184           * M351 - Toggle MS1 MS2 pins directly. (Requires digital microstepping pins.)
    185           * M355 - Set Case Light on/off and set brightness. (Requires CASE_LIGHT_PIN)
    186           * M380 - Activate solenoid on active extruder. (Requires EXT_SOLENOID)
    187           * M381 - Disable all solenoids. (Requires EXT_SOLENOID)
    188           * M400 - Finish all moves.
    189           * M401 - Lower Z probe. (Requires a probe)
    190           * M402 - Raise Z probe. (Requires a probe)
    191           * M404 - Display or set the Nominal Filament Width: "W<diameter>". (Requires FILAMENT_WIDTH_SENSOR)
    192           * M405 - Enable Filament Sensor flow control. "M405 D<delay_cm>". (Requires FILAMENT_WIDTH_SENSOR)
    193           * M406 - Disable Filament Sensor flow control. (Requires FILAMENT_WIDTH_SENSOR)
    194           * M407 - Display measured filament diameter in millimeters. (Requires FILAMENT_WIDTH_SENSOR)
    195           * M410 - Quickstop. Abort all planned moves.
    196           * M420 - Enable/Disable Leveling (with current values) S1=enable S0=disable (Requires MESH_BED_LEVELING or ABL)
    197           * M421 - Set a single Z coordinate in the Mesh Leveling grid. X<units> Y<units> Z<units> (Requires MESH_BED_LEVELING or AUTO_BED_LEVELING_UBL)
    198           * M428 - Set the home_offset based on the current_position. Nearest edge applies. (Disabled by NO_WORKSPACE_OFFSETS or DELTA)
    199           * M500 - Store parameters in EEPROM. (Requires EEPROM_SETTINGS)
    200           * M501 - Restore parameters from EEPROM. (Requires EEPROM_SETTINGS)
    201           * M502 - Revert to the default "factory settings". ** Does not write them to EEPROM! **
    202           * M503 - Print the current settings (in memory): "M503 S<verbose>". S0 specifies compact output.
    203           * M540 - Enable/disable SD card abort on endstop hit: "M540 S<state>". (Requires ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
    204           * M600 - Pause for filament change: "M600 X<pos> Y<pos> Z<raise> E<first_retract> L<later_retract>". (Requires ADVANCED_PAUSE_FEATURE)
    205           * M665 - Set delta configurations: "M665 L<diagonal rod> R<delta radius> S<segments/s> A<rod A trim mm> B<rod B trim mm> C<rod C trim mm> I<tower A trim angle> J<tower B trim angle> K<tower C trim angle>" (Requires DELTA)
    206           * M666 - Set delta endstop adjustment. (Requires DELTA)
    207           * M605 - Set dual x-carriage movement mode: "M605 S<mode> [X<x_offset>] [R<temp_offset>]". (Requires DUAL_X_CARRIAGE)
    208           * M851 - Set Z probe's Z offset in current units. (Negative = below the nozzle.)
    209           * M852 - Set skew factors: "M852 [I<xy>] [J<xz>] [K<yz>]". (Requires SKEW_CORRECTION_GCODE, and SKEW_CORRECTION_FOR_Z for IJ)
    210           * M860 - Report the position of position encoder modules.
    211           * M861 - Report the status of position encoder modules.
    212           * M862 - Perform an axis continuity test for position encoder modules.
    213           * M863 - Perform steps-per-mm calibration for position encoder modules.
    214           * M864 - Change position encoder module I2C address.
    215           * M865 - Check position encoder module firmware version.
    216           * M866 - Report or reset position encoder module error count.
    217           * M867 - Enable/disable or toggle error correction for position encoder modules.
    218           * M868 - Report or set position encoder module error correction threshold.
    219           * M869 - Report position encoder module error.
    220           * M900 - Get and/or Set advance K factor and WH/D ratio. (Requires LIN_ADVANCE)
    221           * M906 - Set or get motor current in milliamps using axis codes X, Y, Z, E. Report values if no axis codes given. (Requires HAVE_TMC2130 or HAVE_TMC2208)
    222           * M907 - Set digital trimpot motor current using axis codes. (Requires a board with digital trimpots)
    223           * M908 - Control digital trimpot directly. (Requires DAC_STEPPER_CURRENT or DIGIPOTSS_PIN)
    224           * M909 - Print digipot/DAC current value. (Requires DAC_STEPPER_CURRENT)
    225           * M910 - Commit digipot/DAC value to external EEPROM via I2C. (Requires DAC_STEPPER_CURRENT)
    226           * M911 - Report stepper driver overtemperature pre-warn condition. (Requires HAVE_TMC2130 or HAVE_TMC2208)
    227           * M912 - Clear stepper driver overtemperature pre-warn condition flag. (Requires HAVE_TMC2130 or HAVE_TMC2208)
    228           * M913 - Set HYBRID_THRESHOLD speed. (Requires HYBRID_THRESHOLD)
    229           * M914 - Set SENSORLESS_HOMING sensitivity. (Requires SENSORLESS_HOMING)
    230           *
    231           * M360 - SCARA calibration: Move to cal-position ThetaA (0 deg calibration)
    232           * M361 - SCARA calibration: Move to cal-position ThetaB (90 deg calibration - steps per degree)
    233           * M362 - SCARA calibration: Move to cal-position PsiA (0 deg calibration)
    234           * M363 - SCARA calibration: Move to cal-position PsiB (90 deg calibration - steps per degree)
    235           * M364 - SCARA calibration: Move to cal-position PSIC (90 deg to Theta calibration position)
    236           *
    237           * ************ Custom codes - This can change to suit future G-code regulations
    238           * M928 - Start SD logging: "M928 filename.gco". Stop with M29. (Requires SDSUPPORT)
    239           * M998	- Stop SD print. (Requires SDSUPPORT)
    240           * M999 - Restart after being stopped by error
    241           *
    242           * "T" Codes
    243           *
    244           * T0-T3 - Select an extruder (tool) by index: "T<n> F<units/min>"
    245           *
    246           */
    247          
    248          #include "Marlin.h"

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp char *strchr(char *, int)
   \                     _Z6strchrPci: (+1)
   \   00000000   0x.... 0x....      B.W      __iar_Strchr

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp char *strrchr(char *, int)
   \                     _Z7strrchrPci: (+1)
   \   00000000   0x.... 0x....      B.W      __iar_Strrchr

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp char *strstr(char *, char const *)
   \                     _Z6strstrPcPKc: (+1)
   \   00000000   0x.... 0x....      B.W      __iar_Strstr

    #define MIN_SOFTWARE_ENDSTOPS mksCfg.min_software_endstops	/*--mks cfg--*/
            ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\Configuration.h",824  Warning[Pe047]: 
          incompatible redefinition of macro "MIN_SOFTWARE_ENDSTOPS" (declared
          at line 819)

    #define MAX_SOFTWARE_ENDSTOPS mksCfg.max_software_endstops	/*--mks cfg--*/
            ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\Configuration.h",834  Warning[Pe047]: 
          incompatible redefinition of macro "MAX_SOFTWARE_ENDSTOPS" (declared
          at line 829)

  #define UNUSED(x) ((void)(x))
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_def.h",87  Warning[Pe047]: 
          incompatible redefinition of macro "UNUSED" (declared at line 101 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marl
          in\macros.h")

  		volatile volatile float desireBedTempBak;
  		         ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Inc\mks_cfg.h",407  Warning[Pe083]: 
          type qualifier specified more than once

  #define strcpy_P(dest, src) strcpy((dest), (src))
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",23  Warning[Pe047]: 
          incompatible redefinition of macro "strcpy_P" (declared at line 93
          of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marl
          in\Marlin_export.h")

  #define strstr_P(a, b) strstr((a), (b))
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",26  Warning[Pe047]: 
          incompatible redefinition of macro "strstr_P" (declared at line 94
          of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marl
          in\Marlin_export.h")

  #define sprintf_P(s, f, ...) sprintf((s), (f), __VA_ARGS__)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",28  Warning[Pe047]: 
          incompatible redefinition of macro "sprintf_P" (declared at line 95
          of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marl
          in\Marlin_export.h")

  #define pgm_read_word_near(addr) pgm_read_word(addr)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",38  Warning[Pe047]: 
          incompatible redefinition of macro "pgm_read_word_near" (declared at
          line 65 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marl
          in\Marlin_export.h")

  #define IS_IWDG_PRESCALER(PRESCALER) (((PRESCALER) == IWDG_Prescaler_4)  || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_iwdg.h",80  Warning[Pe047]: 
          incompatible redefinition of macro "IS_IWDG_PRESCALER" (declared at
          line 209 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_iwdg.h")

  #define IS_IWDG_RELOAD(RELOAD) ((RELOAD) <= 0xFFF)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_iwdg.h",97  Warning[Pe047]: 
          incompatible redefinition of macro "IS_IWDG_RELOAD" (declared at
          line 222 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_iwdg.h")

  #define IS_FSMC_NORSRAM_BANK(BANK) (((BANK) == FSMC_Bank1_NORSRAM1) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",272  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_NORSRAM_BANK" (declared
          at line 834 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_NAND_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",277  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_NAND_BANK" (declared at
          line 855 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_MUX(MUX) (((MUX) == FSMC_DataAddressMux_Disable) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",298  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_MUX" (declared at line
          839 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_MEMORY(MEMORY) (((MEMORY) == FSMC_MemoryType_SRAM) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",311  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_MEMORY" (declared at
          line 842 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_BURSTMODE(STATE) (((STATE) == FSMC_BurstAccessMode_Disable) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",336  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_BURSTMODE" (declared at
          line 894 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ASYNWAIT(STATE) (((STATE) == FSMC_AsynchronousWait_Disable) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",347  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ASYNWAIT" (declared at
          line 915 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_POLARITY(POLARITY) (((POLARITY) == FSMC_WaitSignalPolarity_Low) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",358  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_POLARITY" (declared
          at line 897 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WRAP_MODE(MODE) (((MODE) == FSMC_WrapMode_Disable) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",369  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WRAP_MODE" (declared at
          line 900 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_SIGNAL_ACTIVE(ACTIVE) (((ACTIVE) == FSMC_WaitSignalActive_BeforeWaitState) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",380  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_SIGNAL_ACTIVE"
          (declared at line 903 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WRITE_OPERATION(OPERATION) (((OPERATION) == FSMC_WriteOperation_Disable) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",391  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WRITE_OPERATION"
          (declared at line 906 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAITE_SIGNAL(SIGNAL) (((SIGNAL) == FSMC_WaitSignal_Disable) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",402  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAITE_SIGNAL" (declared
          at line 909 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_EXTENDED_MODE(MODE) (((MODE) == FSMC_ExtendedMode_Disable) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",414  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_EXTENDED_MODE" (declared
          at line 912 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WRITE_BURST(BURST) (((BURST) == FSMC_WriteBurst_Disable) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",426  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WRITE_BURST" (declared
          at line 920 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ADDRESS_SETUP_TIME(TIME) ((TIME) <= 0xF)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",435  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ADDRESS_SETUP_TIME"
          (declared at line 923 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ADDRESS_HOLD_TIME(TIME) ((TIME) <= 0xF)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",443  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ADDRESS_HOLD_TIME"
          (declared at line 925 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_DATASETUP_TIME(TIME) (((TIME) > 0) && ((TIME) <= 0xFF))
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",451  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_DATASETUP_TIME"
          (declared at line 927 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_TURNAROUND_TIME(TIME) ((TIME) <= 0xF)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",459  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_TURNAROUND_TIME"
          (declared at line 929 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_CLK_DIV(DIV) ((DIV) <= 0xF)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",467  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_CLK_DIV" (declared at
          line 934 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_DATA_LATENCY(LATENCY) ((LATENCY) <= 0xF)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",475  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_DATA_LATENCY" (declared
          at line 918 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ACCESS_MODE(MODE) (((MODE) == FSMC_AccessMode_A) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",487  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ACCESS_MODE" (declared
          at line 850 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_FEATURE(FEATURE) (((FEATURE) == FSMC_Waitfeature_Disable) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",508  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_FEATURE" (declared
          at line 858 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ECC_STATE(STATE) (((STATE) == FSMC_ECC_Disable) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",520  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ECC_STATE" (declared at
          line 864 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ECCPAGE_SIZE(SIZE) (((SIZE) == FSMC_ECCPageSize_256Bytes) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",535  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ECCPAGE_SIZE" (declared
          at line 867 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_TCLR_TIME(TIME) ((TIME) <= 0xFF)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",548  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_TCLR_TIME" (declared at
          line 874 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_TAR_TIME(TIME) ((TIME) <= 0xFF)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",556  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_TAR_TIME" (declared at
          line 876 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_SETUP_TIME(TIME) ((TIME) <= 0xFF)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",564  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_SETUP_TIME" (declared at
          line 878 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_TIME(TIME) ((TIME) <= 0xFF)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",572  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_TIME" (declared at
          line 880 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_HOLD_TIME(TIME) ((TIME) <= 0xFF)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",580  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_HOLD_TIME" (declared at
          line 882 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_HIZ_TIME(TIME) ((TIME) <= 0xFF)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",588  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_HIZ_TIME" (declared at
          line 884 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define FSMC_FLAG_FEMPT                          ((uint32_t)0x00000040)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",613  Warning[Pe047]: 
          incompatible redefinition of macro "FSMC_FLAG_FEMPT" (declared at
          line 530 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

    #define assert_param(expr) ((void)0)        
            ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\stm32f4xx_conf.h",149  Warning[Pe047]: 
          incompatible redefinition of macro "assert_param" (declared at line
          431 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Inc\stm32f4xx_hal_c
          onf.h")

   \                                 In section .text, align 4
   \   __interwork __softfp void serialprintPGM(char const *)
   \                     _Z14serialprintPGMPKc: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xE003             B.N      ??serialprintPGM_0
   \                     ??serialprintPGM_1: (+1)
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x4803             LDR.N    R0,??serialprintPGM_2
   \   0000000A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??serialprintPGM_0: (+1)
   \   0000000E   0xF914 0x1B01      LDRSB    R1,[R4], #+1
   \   00000012   0x0008             MOVS     R0,R1
   \   00000014   0xD1F7             BNE.N    ??serialprintPGM_1
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
   \                     ??serialprintPGM_2:
   \   00000018   0x........         DC32     Serial6

   \                                 In section .text, align 4
   \   __interwork __softfp bool IsRunning()
   \                     _Z9IsRunningv: (+1)
   \   00000000   0x4801             LDR.N    R0,??IsRunning_0
   \   00000002   0x7B80             LDRB     R0,[R0, #+14]
   \   00000004   0x4770             BX       LR               ;; return
   \   00000006   0xBF00             Nop      
   \                     ??IsRunning_0:
   \   00000008   0x........         DC32     axis_relative_modes

   \                                 In section .text, align 4
   \   __interwork __softfp bool IsStopped()
   \                     _Z9IsStoppedv: (+1)
   \   00000000   0x4802             LDR.N    R0,??IsStopped_0
   \   00000002   0x7B80             LDRB     R0,[R0, #+14]
   \   00000004   0xF080 0x0001      EOR      R0,R0,#0x1
   \   00000008   0x4770             BX       LR               ;; return
   \   0000000A   0xBF00             Nop      
   \                     ??IsStopped_0:
   \   0000000C   0x........         DC32     axis_relative_modes

   \                                 In section .text, align 4
   \   __interwork __softfp void refresh_cmd_timeout()
   \                     _Z19refresh_cmd_timeoutv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       HAL_GetTick
   \   00000006   0x4901             LDR.N    R1,??refresh_cmd_timeout_0
   \   00000008   0x6008             STR      R0,[R1, #+0]
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
   \                     ??refresh_cmd_timeout_0:
   \   0000000C   0x........         DC32     previous_cmd_ms

   \                                 In section .text, align 4
   \   __interwork __softfp void set_current_from_destination()
   \                     _Z28set_current_from_destinationv: (+1)
   \   00000000   0x4803             LDR.N    R0,??set_current_from_destination_0
   \   00000002   0x2210             MOVS     R2,#+16
   \   00000004   0xF100 0x0134      ADD      R1,R0,#+52
   \   00000008   0x3024             ADDS     R0,R0,#+36
   \   0000000A   0x.... 0x....      B.W      memcpy
   \   0000000E   0xBF00             Nop      
   \                     ??set_current_from_destination_0:
   \   00000010   0x........         DC32     axis_relative_modes

   \                                 In section .text, align 4
   \   __interwork __softfp void set_destination_from_current()
   \                     _Z28set_destination_from_currentv: (+1)
   \   00000000   0x4803             LDR.N    R0,??set_destination_from_current_0
   \   00000002   0x2210             MOVS     R2,#+16
   \   00000004   0xF100 0x0124      ADD      R1,R0,#+36
   \   00000008   0x3034             ADDS     R0,R0,#+52
   \   0000000A   0x.... 0x....      B.W      memcpy
   \   0000000E   0xBF00             Nop      
   \                     ??set_destination_from_current_0:
   \   00000010   0x........         DC32     axis_relative_modes
    249          
    250          #include "ultralcd.h"

   \                                 In section .text, align 2
   \   __interwork __softfp void lcd_init()
   \                     _Z8lcd_initv: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp bool lcd_hasstatus()
   \                     _Z13lcd_hasstatusv: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void lcd_setstatus(char const *, bool)
   \                     _Z13lcd_setstatusPKcb: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void lcd_setstatusPGM(char const *, int8_t)
   \                     _Z16lcd_setstatusPGMPKca: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void lcd_setalertstatusPGM(char const *)
   \                     _Z21lcd_setalertstatusPGMPKc: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void lcd_reset_alert_level()
   \                     _Z21lcd_reset_alert_levelv: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void lcd_refresh()
   \                     _Z11lcd_refreshv: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    251          #include "planner.h"

   \                                 In section .text, align 4
   \   __interwork __softfp void Planner::refresh_e_factor(uint8_t)
   \                     _ZN7Planner16refresh_e_factorEh: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4606             MOV      R6,R0
   \   00000004   0x480C             LDR.N    R0,??refresh_e_factor_0
   \   00000006   0xF930 0x0016      LDRSH    R0,[R0, R6, LSL #+1]
   \   0000000A   0x.... 0x....      BL       __aeabi_i2d
   \   0000000E   0x4A0B             LDR.N    R2,??refresh_e_factor_0+0x4  ;; 0x47ae147b
   \   00000010   0x4B0B             LDR.N    R3,??refresh_e_factor_0+0x8  ;; 0x3f847ae1
   \   00000012   0x.... 0x....      BL       __aeabi_dmul
   \   00000016   0x4604             MOV      R4,R0
   \   00000018   0x460D             MOV      R5,R1
   \   0000001A   0x480A             LDR.N    R0,??refresh_e_factor_0+0xC
   \   0000001C   0xF850 0x0026      LDR      R0,[R0, R6, LSL #+2]
   \   00000020   0x.... 0x....      BL       __aeabi_f2d
   \   00000024   0x4622             MOV      R2,R4
   \   00000026   0x462B             MOV      R3,R5
   \   00000028   0x.... 0x....      BL       __aeabi_dmul
   \   0000002C   0x.... 0x....      BL       __aeabi_d2f
   \   00000030   0x4905             LDR.N    R1,??refresh_e_factor_0+0x10
   \   00000032   0xF841 0x0026      STR      R0,[R1, R6, LSL #+2]
   \   00000036   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??refresh_e_factor_0:
   \   00000038   0x........         DC32     _ZN7Planner15flow_percentageE
   \   0000003C   0x47AE147B         DC32     0x47ae147b
   \   00000040   0x3F847AE1         DC32     0x3f847ae1
   \   00000044   0x........         DC32     _ZN7Planner21volumetric_multiplierE
   \   00000048   0x........         DC32     _ZN7Planner8e_factorE

   \                                 In section .text, align 4
   \   __interwork __softfp void Planner::set_filament_size(uint8_t, float const &)
   \                     _ZN7Planner17set_filament_sizeEhRKf: (+1)
   \   00000000   0x4A09             LDR.N    R2,??set_filament_size_0
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xE009             B.N      ??set_filament_size_1
   \                     ??set_filament_size_2: (+1)
   \   0000000C   0xED92 0x0A00      VLDR     S0,[R2, #0]
   \   00000010   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   00000014   0xEEF1 0xFA10      FMSTAT   
   \   00000018   0xD101             BNE.N    ??set_filament_size_3
   \   0000001A   0x4804             LDR.N    R0,??set_filament_size_0+0x4  ;; 0x40400000
   \   0000001C   0x6010             STR      R0,[R2, #+0]
   \                     ??set_filament_size_3: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \                     ??set_filament_size_1: (+1)
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD0F3             BEQ.N    ??set_filament_size_2
   \   00000024   0x4770             BX       LR               ;; return
   \   00000026   0xBF00             Nop      
   \                     ??set_filament_size_0:
   \   00000028   0x........         DC32     _ZN7Planner13filament_sizeE
   \   0000002C   0x40400000         DC32     0x40400000

   \                                 In section .text, align 2
   \   __interwork __vfp void Planner::buffer_line(float, float, float, float const &, float const &, uint8_t)
   \                     _ZN7Planner11buffer_lineEfffRKfS1_h: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xED2D 0x0A03      VPUSH    {S0-S2}
   \   00000006   0xB082             SUB      SP,SP,#+8
   \   00000008   0xB2D2             UXTB     R2,R2
   \   0000000A   0x9201             STR      R2,[SP, #+4]
   \   0000000C   0x9100             STR      R1,[SP, #+0]
   \   0000000E   0x4603             MOV      R3,R0
   \   00000010   0xAA04             ADD      R2,SP,#+16
   \   00000012   0xA903             ADD      R1,SP,#+12
   \   00000014   0xA802             ADD      R0,SP,#+8
   \   00000016   0x.... 0x....      BL       _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
   \   0000001A   0xB005             ADD      SP,SP,#+20
   \   0000001C   0xBD00             POP      {PC}             ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void Planner::buffer_line_kinematic(float const (&)[4], float const &, uint8_t)
   \                     _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x9201             STR      R2,[SP, #+4]
   \   00000006   0x9100             STR      R1,[SP, #+0]
   \   00000008   0xF100 0x030C      ADD      R3,R0,#+12
   \   0000000C   0xF100 0x0208      ADD      R2,R0,#+8
   \   00000010   0x1D01             ADDS     R1,R0,#+4
   \   00000012   0x.... 0x....      BL       _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
   \   00000016   0xBD07             POP      {R0-R2,PC}       ;; return

   \                                 In section .text, align 2
   \   __interwork __vfp void Planner::set_position_mm(float, float, float, float const &)
   \                     _ZN7Planner15set_position_mmEfffRKf: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xED2D 0x0A03      VPUSH    {S0-S2}
   \   00000006   0x4603             MOV      R3,R0
   \   00000008   0xAA02             ADD      R2,SP,#+8
   \   0000000A   0xA901             ADD      R1,SP,#+4
   \   0000000C   0xA800             ADD      R0,SP,#+0
   \   0000000E   0x.... 0x....      BL       _ZN7Planner16_set_position_mmERKfS1_S1_S1_
   \   00000012   0xBD07             POP      {R0-R2,PC}       ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void Planner::set_e_position_mm(float const &)
   \                     _ZN7Planner17set_e_position_mmERKf: (+1)
   \   00000000   0x4601             MOV      R1,R0
   \   00000002   0x2003             MOVS     R0,#+3
   \   00000004   0x.... 0x....      B.W      _ZN7Planner15set_position_mmE8AxisEnumRKf

   \                                 In section .text, align 4
   \   __interwork __softfp bool Planner::blocks_queued()
   \                     _ZN7Planner13blocks_queuedEv: (+1)
   \   00000000   0x4804             LDR.N    R0,??blocks_queued_0
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4904             LDR.N    R1,??blocks_queued_0+0x4
   \   00000006   0x7809             LDRB     R1,[R1, #+0]
   \   00000008   0x4288             CMP      R0,R1
   \   0000000A   0xD001             BEQ.N    ??blocks_queued_1
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x4770             BX       LR
   \                     ??blocks_queued_1: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4770             BX       LR               ;; return
   \                     ??blocks_queued_0:
   \   00000014   0x........         DC32     _ZN7Planner17block_buffer_headE
   \   00000018   0x........         DC32     _ZN7Planner17block_buffer_tailE

      static constexpr int8_t next_block_index(const int8_t block_index) { return BLOCK_MOD(block_index + 1); }
             ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\planner.h",582  Warning[Pe815]: 
          type qualifier on return type is meaningless

      static constexpr int8_t prev_block_index(const int8_t block_index) { return BLOCK_MOD(block_index - 1); }
             ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\planner.h",583  Warning[Pe815]: 
          type qualifier on return type is meaningless
    252          #include "stepper.h"
    253          #include "endstops.h"

   \                                 In section .text, align 4
   \   __interwork __softfp void Endstops::enable_globally(bool)
   \                     _ZN8Endstops15enable_globallyEb: (+1)
   \   00000000   0x4902             LDR.N    R1,??enable_globally_0
   \   00000002   0x7008             STRB     R0,[R1, #+0]
   \   00000004   0x4902             LDR.N    R1,??enable_globally_0+0x4
   \   00000006   0x7008             STRB     R0,[R1, #+0]
   \   00000008   0x4770             BX       LR               ;; return
   \   0000000A   0xBF00             Nop      
   \                     ??enable_globally_0:
   \   0000000C   0x........         DC32     _ZN8Endstops7enabledE
   \   00000010   0x........         DC32     _ZN8Endstops16enabled_globallyE

   \                                 In section .text, align 4
   \   __interwork __softfp void Endstops::enable(bool)
   \                     _ZN8Endstops6enableEb: (+1)
   \   00000000   0x4901             LDR.N    R1,??enable_0
   \   00000002   0x7008             STRB     R0,[R1, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   \   00000006   0xBF00             Nop      
   \                     ??enable_0:
   \   00000008   0x........         DC32     _ZN8Endstops7enabledE

   \                                 In section .text, align 4
   \   __interwork __softfp void Endstops::not_homing()
   \                     _ZN8Endstops10not_homingEv: (+1)
   \   00000000   0x4802             LDR.N    R0,??not_homing_0
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4902             LDR.N    R1,??not_homing_0+0x4
   \   00000006   0x7008             STRB     R0,[R1, #+0]
   \   00000008   0x4770             BX       LR               ;; return
   \   0000000A   0xBF00             Nop      
   \                     ??not_homing_0:
   \   0000000C   0x........         DC32     _ZN8Endstops16enabled_globallyE
   \   00000010   0x........         DC32     _ZN8Endstops7enabledE

   \                                 In section .text, align 4
   \   __interwork __softfp void Endstops::hit_on_purpose()
   \                     _ZN8Endstops14hit_on_purposeEv: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4901             LDR.N    R1,??hit_on_purpose_0
   \   00000004   0x7008             STRB     R0,[R1, #+0]
   \   00000006   0x4770             BX       LR               ;; return
   \                     ??hit_on_purpose_0:
   \   00000008   0x........         DC32     _ZN8Endstops16endstop_hit_bitsE
    254          #include "temperature.h"

   \                                 In section .text, align 4
   \   __interwork __vfp float Temperature::degHotend(uint8_t)
   \                     _ZN11Temperature9degHotendEh: (+1)
   \   00000000   0x4801             LDR.N    R0,??degHotend_0
   \   00000002   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000006   0x4770             BX       LR               ;; return
   \                     ??degHotend_0:
   \   00000008   0x........         DC32     _ZN11Temperature19current_temperatureE

   \                                 In section .text, align 4
   \   __interwork __vfp float Temperature::degTargetHotend(uint8_t)
   \                     _ZN11Temperature15degTargetHotendEh: (+1)
   \   00000000   0x4802             LDR.N    R0,??degTargetHotend_0
   \   00000002   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000006   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000000A   0x4770             BX       LR               ;; return
   \                     ??degTargetHotend_0:
   \   0000000C   0x........         DC32     _ZN11Temperature18target_temperatureE

   \                                 In section .text, align 4

        target_temperature[HOTEND_INDEX] = celsius;
                                         ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\temperature.h",397  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \   __interwork __vfp void Temperature::setTargetHotend(float, uint8_t)
   \                     _ZN11Temperature15setTargetHotendEfh: (+1)
   \   00000000   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   00000004   0x4802             LDR.N    R0,??setTargetHotend_0
   \   00000006   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x.... 0x....      B.W      _ZN11Temperature21start_watching_heaterEh
   \                     ??setTargetHotend_0:
   \   00000010   0x........         DC32     _ZN11Temperature18target_temperatureE

   \                                 In section .text, align 2
   \   __interwork __vfp void Temperature::setTargetBed(float)
   \                     _ZN11Temperature12setTargetBedEf: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4
   \   __interwork __softfp bool Temperature::isCoolingHotend(uint8_t)
   \                     _ZN11Temperature15isCoolingHotendEh: (+1)
   \   00000000   0x4808             LDR.N    R0,??isCoolingHotend_0
   \   00000002   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000006   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000000A   0x4807             LDR.N    R0,??isCoolingHotend_0+0x4
   \   0000000C   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   00000010   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000014   0xEEF1 0xFA10      FMSTAT   
   \   00000018   0xD501             BPL.N    ??isCoolingHotend_1
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x4770             BX       LR
   \                     ??isCoolingHotend_1: (+1)
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x4770             BX       LR               ;; return
   \   00000022   0xBF00             Nop      
   \                     ??isCoolingHotend_0:
   \   00000024   0x........         DC32     _ZN11Temperature18target_temperatureE
   \   00000028   0x........         DC32     _ZN11Temperature19current_temperatureE

   \                                 In section .text, align 2
   \   __interwork __softfp void Temperature::updatePID()
   \                     _ZN11Temperature9updatePIDEv: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    255          #include "cardreader.h"

  #define SD_DETECT_INVERTED false
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\cardreader.h",27  Warning[Pe047]: 
          incompatible redefinition of macro "SD_DETECT_INVERTED" (declared at
          line 512 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marl
          in\Configuration_adv.h")

  #define PSTR(s) s
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\cardreader.h",31  Warning[Pe047]: 
          incompatible redefinition of macro "PSTR" (declared at line 63 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marl
          in\Marlin.h")

  #define pgm_read_byte(x) (*(char*)x)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\cardreader.h",32  Warning[Pe047]: 
          incompatible redefinition of macro "pgm_read_byte" (declared at line
          64 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marl
          in\Marlin_export.h")

  #define LONG_FILENAME_LENGTH (13*MAX_VFAT_ENTRIES+1)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\cardreader.h",61  Warning[Pe047]: 
          incompatible redefinition of macro "LONG_FILENAME_LENGTH" (declared
          at line 119 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marl
          in\SdFatConfig.h")

  #define ALLOW_DEPRECATED_FUNCTIONS 0
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\SdFat.h",635  Warning[Pe047]: 
          incompatible redefinition of macro "ALLOW_DEPRECATED_FUNCTIONS"
          (declared at line 67 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marl
          in\SdFatConfig.h")

  #define SPI_SD_INIT_RATE 11
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\SdFat.h",647  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_SD_INIT_RATE" (declared at
          line 79 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marl
          in\SdFatConfig.h")

   \                                 In section .text, align 2
   \   __interwork __softfp bool CardReader::isFileOpen()
   \                     _ZN10CardReader10isFileOpenEv: (+1)
   \   00000000   0xF8D0 0x0200      LDR      R0,[R0, #+512]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD001             BEQ.N    ??isFileOpen_0
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x4770             BX       LR
   \                     ??isFileOpen_0: (+1)
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp bool CardReader::eof()
   \                     _ZN10CardReader3eofEv: (+1)
   \   00000000   0xF8D0 0x1460      LDR      R1,[R0, #+1120]
   \   00000004   0xF8D0 0x045C      LDR      R0,[R0, #+1116]
   \   00000008   0x4281             CMP      R1,R0
   \   0000000A   0x4180             SBCS     R0,R0,R0
   \   0000000C   0x43C0             MVNS     R0,R0
   \   0000000E   0x0FC0             LSRS     R0,R0,#+31
   \   00000010   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp UINT CardReader::gets(BYTE *, UINT)
   \                     _ZN10CardReader4getsEPhj: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0xAB00             ADD      R3,SP,#+0
   \   00000008   0x.... 0x....      BL       f_read
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD005             BEQ.N    ??gets_0
   \   00000010   0x20FF             MOVS     R0,#+255
   \   00000012   0x7028             STRB     R0,[R5, #+0]
   \   00000014   0xF04F 0x30FF      MOV      R0,#-1
   \   00000018   0x9000             STR      R0,[SP, #+0]
   \   0000001A   0xE005             B.N      ??gets_1
   \                     ??gets_0: (+1)
   \   0000001C   0xF8D4 0x0460      LDR      R0,[R4, #+1120]
   \   00000020   0x9900             LDR      R1,[SP, #+0]
   \   00000022   0x1808             ADDS     R0,R1,R0
   \   00000024   0xF8C4 0x0460      STR      R0,[R4, #+1120]
   \                     ??gets_1: (+1)
   \   00000028   0x9800             LDR      R0,[SP, #+0]
   \   0000002A   0xBD32             POP      {R1,R4,R5,PC}    ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void CardReader::setIndex(long)
   \                     _ZN10CardReader8setIndexEl: (+1)
   \   00000000   0xF8C0 0x1460      STR      R1,[R0, #+1120]
   \   00000004   0x.... 0x....      B.W      f_lseek
    256          #include "configuration_store.h"
    257          #include "language.h"
    258          //#include "pins_arduino.h"
    259          #include "math.h"
    260          #include "nozzle.h"
    261          #include "duration_t.h"

   \                                 In section .text, align 2
   \   __code __interwork __softfp duration_t::duration_t(uint32_t const &)
   \                     _ZN10duration_tC1ERKj: (+1)
   \   00000000   0x6809             LDR      R1,[R1, #+0]
   \   00000002   0x6001             STR      R1,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp uint8_t duration_t::year() const
   \                     _ZNK10duration_t4yearEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       _ZNK10duration_t3dayEv
   \   00000006   0xF240 0x116D      MOVW     R1,#+365
   \   0000000A   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000000E   0xB2C0             UXTB     R0,R0
   \   00000010   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp uint16_t duration_t::day() const
   \                     _ZNK10duration_t3dayEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       _ZNK10duration_t4hourEv
   \   00000006   0x2118             MOVS     R1,#+24
   \   00000008   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000000C   0xB280             UXTH     R0,R0
   \   0000000E   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp uint32_t duration_t::hour() const
   \                     _ZNK10duration_t4hourEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       _ZNK10duration_t6minuteEv
   \   00000006   0x213C             MOVS     R1,#+60
   \   00000008   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp uint32_t duration_t::minute() const
   \                     _ZNK10duration_t6minuteEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       _ZNK10duration_t6secondEv
   \   00000006   0x213C             MOVS     R1,#+60
   \   00000008   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp uint32_t duration_t::second() const
   \                     _ZNK10duration_t6secondEv: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4
   \   __interwork __softfp void duration_t::toString(char *) const
   \                     _ZNK10duration_t8toStringEPc: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x4607             MOV      R7,R0
   \   00000008   0x460C             MOV      R4,R1
   \   0000000A   0x.... 0x....      BL       _ZNK10duration_t4yearEv
   \   0000000E   0x4605             MOV      R5,R0
   \   00000010   0x4638             MOV      R0,R7
   \   00000012   0x.... 0x....      BL       _ZNK10duration_t3dayEv
   \   00000016   0xF240 0x116D      MOVW     R1,#+365
   \   0000001A   0xFB90 0xF1F1      SDIV     R1,R0,R1
   \   0000001E   0xF240 0x126D      MOVW     R2,#+365
   \   00000022   0xFB02 0x0611      MLS      R6,R2,R1,R0
   \   00000026   0x4638             MOV      R0,R7
   \   00000028   0x.... 0x....      BL       _ZNK10duration_t4hourEv
   \   0000002C   0x2118             MOVS     R1,#+24
   \   0000002E   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   00000032   0xEB01 0x0241      ADD      R2,R1,R1, LSL #+1
   \   00000036   0xEBA0 0x08C2      SUB      R8,R0,R2, LSL #+3
   \   0000003A   0x4638             MOV      R0,R7
   \   0000003C   0x.... 0x....      BL       _ZNK10duration_t6minuteEv
   \   00000040   0xF04F 0x093C      MOV      R9,#+60
   \   00000044   0x4649             MOV      R1,R9
   \   00000046   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   0000004A   0xFB09 0x0A11      MLS      R10,R9,R1,R0
   \   0000004E   0x4638             MOV      R0,R7
   \   00000050   0x.... 0x....      BL       _ZNK10duration_t6secondEv
   \   00000054   0x4649             MOV      R1,R9
   \   00000056   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   0000005A   0xFB09 0x0211      MLS      R2,R9,R1,R0
   \   0000005E   0x2D00             CMP      R5,#+0
   \   00000060   0xD00B             BEQ.N    ??toString_0
   \   00000062   0x9202             STR      R2,[SP, #+8]
   \   00000064   0xF8CD 0xA004      STR      R10,[SP, #+4]
   \   00000068   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   0000006C   0x4633             MOV      R3,R6
   \   0000006E   0x462A             MOV      R2,R5
   \   00000070   0x4918             LDR.N    R1,??toString_1
   \   00000072   0x4620             MOV      R0,R4
   \   00000074   0x.... 0x....      BL       sprintf
   \   00000078   0xE029             B.N      ??toString_2
   \                     ??toString_0: (+1)
   \   0000007A   0x2E00             CMP      R6,#+0
   \   0000007C   0xD009             BEQ.N    ??toString_3
   \   0000007E   0x9201             STR      R2,[SP, #+4]
   \   00000080   0xF8CD 0xA000      STR      R10,[SP, #+0]
   \   00000084   0x4643             MOV      R3,R8
   \   00000086   0x4632             MOV      R2,R6
   \   00000088   0x4913             LDR.N    R1,??toString_1+0x4
   \   0000008A   0x4620             MOV      R0,R4
   \   0000008C   0x.... 0x....      BL       sprintf
   \   00000090   0xE01D             B.N      ??toString_2
   \                     ??toString_3: (+1)
   \   00000092   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000096   0xD007             BEQ.N    ??toString_4
   \   00000098   0x9200             STR      R2,[SP, #+0]
   \   0000009A   0x4653             MOV      R3,R10
   \   0000009C   0x4642             MOV      R2,R8
   \   0000009E   0x490F             LDR.N    R1,??toString_1+0x8
   \   000000A0   0x4620             MOV      R0,R4
   \   000000A2   0x.... 0x....      BL       sprintf
   \   000000A6   0xE012             B.N      ??toString_2
   \                     ??toString_4: (+1)
   \   000000A8   0xF1BA 0x0F00      CMP      R10,#+0
   \   000000AC   0xD008             BEQ.N    ??toString_5
   \   000000AE   0x4613             MOV      R3,R2
   \   000000B0   0x4652             MOV      R2,R10
   \   000000B2   0x490B             LDR.N    R1,??toString_1+0xC
   \   000000B4   0x4620             MOV      R0,R4
   \   000000B6   0xB004             ADD      SP,SP,#+16
   \   000000B8   0xE8BD 0x47F0      POP      {R4-R10,LR}
   \   000000BC   0x.... 0x....      B.W      sprintf
   \                     ??toString_5: (+1)
   \   000000C0   0x4908             LDR.N    R1,??toString_1+0x10
   \   000000C2   0x4620             MOV      R0,R4
   \   000000C4   0xB004             ADD      SP,SP,#+16
   \   000000C6   0xE8BD 0x47F0      POP      {R4-R10,LR}
   \   000000CA   0x.... 0x....      B.W      sprintf
   \                     ??toString_2: (+1)
   \   000000CE   0xE8BD 0x87FF      POP      {R0-R10,PC}      ;; return
   \   000000D2   0xBF00             Nop      
   \                     ??toString_1:
   \   000000D4   0x........         DC32     _ZZNK10duration_t8toStringEPcEs
   \   000000D8   0x........         DC32     _ZZNK10duration_t8toStringEPcEs_0
   \   000000DC   0x........         DC32     _ZZNK10duration_t8toStringEPcEs_1
   \   000000E0   0x........         DC32     _ZZNK10duration_t8toStringEPcEs_2
   \   000000E4   0x........         DC32     _ZZNK10duration_t8toStringEPcEs_3
    262          //#include "types.h"
    263          #include "tim.h"
    264          #include "gcode.h"

   \                                 In section .text, align 4
   \   __interwork __softfp bool GCodeParser::seen(char)
   \                     _ZN11GCodeParser4seenEc: (+1)
   \   00000000   0xF1A0 0x0141      SUB      R1,R0,#+65
   \   00000004   0xB2C9             UXTB     R1,R1
   \   00000006   0x291A             CMP      R1,#+26
   \   00000008   0xD301             BCC.N    ??seen_0
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x4770             BX       LR
   \                     ??seen_0: (+1)
   \   0000000E   0x10C8             ASRS     R0,R1,#+3
   \   00000010   0x4A0A             LDR.N    R2,??seen_1
   \   00000012   0x5C80             LDRB     R0,[R0, R2]
   \   00000014   0xF001 0x0207      AND      R2,R1,#0x7
   \   00000018   0x40D0             LSRS     R0,R0,R2
   \   0000001A   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000001E   0xD00B             BEQ.N    ??seen_2
   \   00000020   0x4A07             LDR.N    R2,??seen_1+0x4
   \   00000022   0x5C89             LDRB     R1,[R1, R2]
   \   00000024   0x4A07             LDR.N    R2,??seen_1+0x8
   \   00000026   0x2900             CMP      R1,#+0
   \   00000028   0xD004             BEQ.N    ??seen_3
   \   0000002A   0x4B07             LDR.N    R3,??seen_1+0xC
   \   0000002C   0x681B             LDR      R3,[R3, #+0]
   \   0000002E   0x18C9             ADDS     R1,R1,R3
   \   00000030   0x6011             STR      R1,[R2, #+0]
   \   00000032   0x4770             BX       LR
   \                     ??seen_3: (+1)
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x6011             STR      R1,[R2, #+0]
   \                     ??seen_2: (+1)
   \   00000038   0x4770             BX       LR               ;; return
   \   0000003A   0xBF00             Nop      
   \                     ??seen_1:
   \   0000003C   0x........         DC32     _ZN11GCodeParser8codebitsE
   \   00000040   0x........         DC32     _ZN11GCodeParser5paramE
   \   00000044   0x........         DC32     _ZN11GCodeParser9value_ptrE
   \   00000048   0x........         DC32     _ZN11GCodeParser11command_ptrE

   \                                 In section .text, align 4
   \   __interwork __softfp bool GCodeParser::has_value()
   \                     _ZN11GCodeParser9has_valueEv: (+1)
   \   00000000   0x4803             LDR.N    R0,??has_value_0
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD001             BEQ.N    ??has_value_1
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x4770             BX       LR
   \                     ??has_value_1: (+1)
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
   \                     ??has_value_0:
   \   00000010   0x........         DC32     _ZN11GCodeParser9value_ptrE

   \                                 In section .text, align 2
   \   __interwork __softfp bool GCodeParser::seenval(char)
   \                     _ZN11GCodeParser7seenvalEc: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD003             BEQ.N    ??seenval_0
   \   0000000A   0xE8BD 0x4001      POP      {R0,LR}
   \   0000000E   0x.... 0x....      B.W      _ZN11GCodeParser9has_valueEv
   \                     ??seenval_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 4
   \   __interwork __vfp float GCodeParser::value_float()
   \                     _ZN11GCodeParser11value_floatEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4A17             LDR.N    R2,??value_float_0+0x4
   \   00000004   0x6810             LDR      R0,[R2, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD024             BEQ.N    ??value_float_1
   \   0000000A   0x4604             MOV      R4,R0
   \   0000000C   0xE000             B.N      ??value_float_2
   \                     ??value_float_3: (+1)
   \   0000000E   0x1C64             ADDS     R4,R4,#+1
   \                     ??value_float_2: (+1)
   \   00000010   0xF994 0x5000      LDRSB    R5,[R4, #+0]
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD001             BEQ.N    ??value_float_4
   \   00000018   0x2D20             CMP      R5,#+32
   \   0000001A   0xD109             BNE.N    ??value_float_5
   \                     ??value_float_4: (+1)
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x.... 0x....      BL       strtod
   \   00000022   0xEC51 0x0B10      VMOV     R0,R1,D0
   \   00000026   0x.... 0x....      BL       __aeabi_d2f
   \   0000002A   0xEE00 0x0A10      VMOV     S0,R0
   \   0000002E   0xBD31             POP      {R0,R4,R5,PC}
   \                     ??value_float_5: (+1)
   \   00000030   0x2D45             CMP      R5,#+69
   \   00000032   0xD001             BEQ.N    ??value_float_6
   \   00000034   0x2D65             CMP      R5,#+101
   \   00000036   0xD1EA             BNE.N    ??value_float_3
   \                     ??value_float_6: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x7020             STRB     R0,[R4, #+0]
   \   0000003C   0x4601             MOV      R1,R0
   \   0000003E   0x6810             LDR      R0,[R2, #+0]
   \   00000040   0x.... 0x....      BL       strtod
   \   00000044   0xEC51 0x0B10      VMOV     R0,R1,D0
   \   00000048   0x.... 0x....      BL       __aeabi_d2f
   \   0000004C   0xEE00 0x0A10      VMOV     S0,R0
   \   00000050   0x7025             STRB     R5,[R4, #+0]
   \   00000052   0xBD31             POP      {R0,R4,R5,PC}
   \                     ??value_float_1: (+1)
   \   00000054   0xED9F 0x0A01      VLDR.W   S0,??value_float_0  ;; 0x0
   \   00000058   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \   0000005A   0xBF00             Nop      
   \                     ??value_float_0:
   \   0000005C   0x00000000         DC32     0x0
   \   00000060   0x........         DC32     _ZN11GCodeParser9value_ptrE

   \                                 In section .text, align 4
   \   __interwork __softfp int32_t GCodeParser::value_long()
   \                     _ZN11GCodeParser10value_longEv: (+1)
   \   00000000   0x4804             LDR.N    R0,??value_long_0
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD003             BEQ.N    ??value_long_1
   \   00000008   0x220A             MOVS     R2,#+10
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x.... 0x....      B.W      strtol
   \                     ??value_long_1: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4770             BX       LR               ;; return
   \                     ??value_long_0:
   \   00000014   0x........         DC32     _ZN11GCodeParser9value_ptrE

   \                                 In section .text, align 4
   \   __interwork __softfp uint32_t GCodeParser::value_ulong()
   \                     _ZN11GCodeParser11value_ulongEv: (+1)
   \   00000000   0x4804             LDR.N    R0,??value_ulong_0
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD003             BEQ.N    ??value_ulong_1
   \   00000008   0x220A             MOVS     R2,#+10
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x.... 0x....      B.W      strtoul
   \                     ??value_ulong_1: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4770             BX       LR               ;; return
   \                     ??value_ulong_0:
   \   00000014   0x........         DC32     _ZN11GCodeParser9value_ptrE

   \                                 In section .text, align 2
   \   __interwork __softfp millis_t GCodeParser::value_millis()
   \                     _ZN11GCodeParser12value_millisEv: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN11GCodeParser11value_ulongEv

   \                                 In section .text, align 4

    FORCE_INLINE static millis_t value_millis_from_seconds() { return value_float() * 1000UL; }
                                                                      ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\gcode.h",207  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \   __interwork __softfp millis_t GCodeParser::value_millis_from_seconds()
   \                     _ZN11GCodeParser25value_millis_from_secondsEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       _ZN11GCodeParser11value_floatEv
   \   00000006   0xEDDF 0x0A04      VLDR.W   S1,??value_millis_from_seconds_0  ;; 0x447a0000
   \   0000000A   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   0000000E   0xEEBC 0x0AC0      VCVT.U32.F32 S0,S0
   \   00000012   0xEE10 0x0A10      VMOV     R0,S0
   \   00000016   0xBD02             POP      {R1,PC}          ;; return
   \                     ??value_millis_from_seconds_0:
   \   00000018   0x447A0000         DC32     0x447a0000

   \                                 In section .text, align 2
   \   __interwork __softfp int16_t GCodeParser::value_int()
   \                     _ZN11GCodeParser9value_intEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       _ZN11GCodeParser10value_longEv
   \   00000006   0xB200             SXTH     R0,R0
   \   00000008   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp uint16_t GCodeParser::value_ushort()
   \                     _ZN11GCodeParser12value_ushortEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       _ZN11GCodeParser10value_longEv
   \   00000006   0xB280             UXTH     R0,R0
   \   00000008   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp uint8_t GCodeParser::value_byte()
   \                     _ZN11GCodeParser10value_byteEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       _ZN11GCodeParser10value_longEv
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD501             BPL.N    ??value_byte_0
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xE007             B.N      ??value_byte_1
   \                     ??value_byte_0: (+1)
   \   0000000E   0x.... 0x....      BL       _ZN11GCodeParser10value_longEv
   \   00000012   0x28FF             CMP      R0,#+255
   \   00000014   0xDD01             BLE.N    ??value_byte_2
   \   00000016   0x20FF             MOVS     R0,#+255
   \   00000018   0xE001             B.N      ??value_byte_1
   \                     ??value_byte_2: (+1)
   \   0000001A   0x.... 0x....      BL       _ZN11GCodeParser10value_longEv
   \                     ??value_byte_1: (+1)
   \   0000001E   0xB2C0             UXTB     R0,R0
   \   00000020   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp bool GCodeParser::value_bool()
   \                     _ZN11GCodeParser10value_boolEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       _ZN11GCodeParser9has_valueEv
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD006             BEQ.N    ??value_bool_0
   \   0000000A   0x.... 0x....      BL       _ZN11GCodeParser10value_byteEv
   \   0000000E   0x1E40             SUBS     R0,R0,#+1
   \   00000010   0x4180             SBCS     R0,R0,R0
   \   00000012   0x43C0             MVNS     R0,R0
   \   00000014   0x0FC0             LSRS     R0,R0,#+31
   \   00000016   0xBD02             POP      {R1,PC}
   \                     ??value_bool_0: (+1)
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __vfp float GCodeParser::value_linear_units()
   \                     _ZN11GCodeParser18value_linear_unitsEv: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN11GCodeParser11value_floatEv

   \                                 In section .text, align 2
   \   __interwork __vfp float GCodeParser::value_axis_units(AxisEnum)
   \                     _ZN11GCodeParser16value_axis_unitsE8AxisEnum: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN11GCodeParser11value_floatEv

   \                                 In section .text, align 2
   \   __interwork __vfp float GCodeParser::value_per_axis_unit(AxisEnum)
   \                     _ZN11GCodeParser19value_per_axis_unitE8AxisEnum: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN11GCodeParser11value_floatEv

   \                                 In section .text, align 2
   \   __interwork __vfp float GCodeParser::value_celsius()
   \                     _ZN11GCodeParser13value_celsiusEv: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN11GCodeParser11value_floatEv

   \                                 In section .text, align 2
   \   __interwork __vfp float GCodeParser::value_feedrate()
   \                     _ZN11GCodeParser14value_feedrateEv: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN11GCodeParser18value_linear_unitsEv

   \                                 In section .text, align 2
   \   __interwork __softfp bool GCodeParser::boolval(char)
   \                     _ZN11GCodeParser7boolvalEc: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD003             BEQ.N    ??boolval_0
   \   0000000C   0xE8BD 0x4010      POP      {R4,LR}
   \   00000010   0x.... 0x....      B.W      _ZN11GCodeParser10value_boolEv
   \                     ??boolval_0: (+1)
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001A   0x.... 0x....      B.W      _ZN11GCodeParser4seenEc

   \                                 In section .text, align 2
   \   __interwork __softfp uint8_t GCodeParser::byteval(char, uint8_t)
   \                     _ZN11GCodeParser7bytevalEch: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD002             BEQ.N    ??byteval_0
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser10value_byteEv
   \   00000010   0x4604             MOV      R4,R0
   \                     ??byteval_0: (+1)
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp int16_t GCodeParser::intval(char, int16_t)
   \                     _ZN11GCodeParser6intvalEcs: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD002             BEQ.N    ??intval_0
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser9value_intEv
   \   00000010   0x4604             MOV      R4,R0
   \                     ??intval_0: (+1)
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp uint16_t GCodeParser::ushortval(char, uint16_t)
   \                     _ZN11GCodeParser9ushortvalEct: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD002             BEQ.N    ??ushortval_0
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser12value_ushortEv
   \   00000010   0x4604             MOV      R4,R0
   \                     ??ushortval_0: (+1)
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __vfp float GCodeParser::linearval(char, float)
   \                     _ZN11GCodeParser9linearvalEcf: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   0000000A   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD003             BEQ.N    ??linearval_0
   \   00000012   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000016   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \                     ??linearval_0: (+1)
   \   0000001A   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   0000001E   0xECBD 0x8B02      VPOP     {D8}
   \   00000022   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __vfp float GCodeParser::celsiusval(char, float)
   \                     _ZN11GCodeParser10celsiusvalEcf: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   0000000A   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD003             BEQ.N    ??celsiusval_0
   \   00000012   0x.... 0x....      BL       _ZN11GCodeParser13value_celsiusEv
   \   00000016   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \                     ??celsiusval_0: (+1)
   \   0000001A   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   0000001E   0xECBD 0x8B02      VPOP     {D8}
   \   00000022   0xBD01             POP      {R0,PC}          ;; return
    265          
    266          #include "least_squares_fit.h"
    267          //#include "ubl.h"
    268          
    269          #include "mks_cfg.h"
    270          #include "mks_reprint.h"
    271          #include "mks_dlp_main.h"

  #define IS_SPI_MODE(MODE) (((MODE) == SPI_Mode_Master) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",173  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_MODE" (declared at line
          511 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_DATASIZE(DATASIZE) (((DATASIZE) == SPI_DataSize_16b) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",185  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_DATASIZE" (declared at
          line 523 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_CPOL(CPOL) (((CPOL) == SPI_CPOL_Low) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",197  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_CPOL" (declared at line
          526 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_CPHA(CPHA) (((CPHA) == SPI_CPHA_1Edge) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",209  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_CPHA" (declared at line
          529 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_NSS(NSS) (((NSS) == SPI_NSS_Soft) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",221  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_NSS" (declared at line
          532 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_BAUDRATE_PRESCALER(PRESCALER) (((PRESCALER) == SPI_BaudRatePrescaler_2) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",239  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_BAUDRATE_PRESCALER"
          (declared at line 536 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_FIRST_BIT(BIT) (((BIT) == SPI_FirstBit_MSB) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",257  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_FIRST_BIT" (declared at
          line 545 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_DIRECTION(DIRECTION) (((DIRECTION) == SPI_Direction_Rx) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",400  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_DIRECTION" (declared at
          line 514 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define SPI_FLAG_CRCERR                 ((uint16_t)0x0010)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",442  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_FLAG_CRCERR" (declared at
          line 293 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define SPI_FLAG_MODF                   ((uint16_t)0x0020)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",443  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_FLAG_MODF" (declared at line
          294 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_CRC_POLYNOMIAL(POLYNOMIAL) ((POLYNOMIAL) >= 0x1)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",462  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_CRC_POLYNOMIAL" (declared
          at line 554 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define SPI_IT_TXE                   SPI_I2S_IT_TXE
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",473  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_IT_TXE" (declared at line
          280 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define SPI_IT_RXNE                  SPI_I2S_IT_RXNE
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",474  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_IT_RXNE" (declared at line
          281 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define SPI_IT_ERR                   SPI_I2S_IT_ERR
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",475  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_IT_ERR" (declared at line
          282 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define SPI_FLAG_RXNE                SPI_I2S_FLAG_RXNE
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",477  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_FLAG_RXNE" (declared at line
          290 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define SPI_FLAG_TXE                 SPI_I2S_FLAG_TXE
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",478  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_FLAG_TXE" (declared at line
          291 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define SPI_FLAG_OVR                 SPI_I2S_FLAG_OVR
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",479  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_FLAG_OVR" (declared at line
          295 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define SPI_FLAG_BSY                 SPI_I2S_FLAG_BSY
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",480  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_FLAG_BSY" (declared at line
          292 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")
    272          #if 1
    273          
    274          #include "wifi_module.h"
    275          
    276          #include "gui.h"
    277          
    278          #include "draw_ready_print.h"
    279          
    280          #include "draw_ui.h"

    #define FILAMENT_CHANGE_TEXT_EN				"Please click <Load> \nor <unload>,After \npinter pause."
            ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\User\ui\Multi_language\Language_en.h",175  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_EN"
          (declared at line 153)

  #define DIALOG_UNBIND_PRINTER_CN            "è§£é¤ç»å®?"
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\User\ui\Multi_language\Language_s_cn.h",258  Warning[Pe047]: 
          incompatible redefinition of macro "DIALOG_UNBIND_PRINTER_CN"
          (declared at line 253)

    #define FILAMENT_CHANGE_TEXT_T_CN				"å¾æå°æ©æ«åå,\nè«æ<é²æ>æ<éæ>"
            ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\User\ui\Multi_language\Language_t_cn.h",167  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_T_CN"
          (declared at line 153)

    #define FILAMENT_CHANGE_TEXT_RU				"Please click <Load> \nor <unload>,After \npinter pause."
            ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\User\ui\Multi_language\Language_ru.h",173  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_RU"
          (declared at line 153)

  #define DIALOG_UNBIND_PRINTER_RU            "Unbind the printer?"
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\User\ui\Multi_language\Language_ru.h",270  Warning[Pe047]: 
          incompatible redefinition of macro "DIALOG_UNBIND_PRINTER_RU"
          (declared at line 265)

    #define FILAMENT_CHANGE_TEXT_FR				"Please click <Load> \nor <unload>,After \npinter pause."
            ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\User\ui\Multi_language\Language_fr.h",173  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_FR"
          (declared at line 153)

  #define DIALOG_UNBIND_PRINTER_FR        "Unbind the printer?"
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\User\ui\Multi_language\Language_fr.h",273  Warning[Pe047]: 
          incompatible redefinition of macro "DIALOG_UNBIND_PRINTER_FR"
          (declared at line 269)

    #define FILAMENT_CHANGE_TEXT_SP				"Please click <Load> \nor <unload>,After \npinter pause."
            ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\User\ui\Multi_language\Language_sp.h",173  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_SP"
          (declared at line 154)

    #define FILAMENT_CHANGE_TEXT_IT				"Please click <Load> \nor <unload>,After \npinter pause."
            ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\User\ui\Multi_language\Language_it.h",173  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_IT"
          (declared at line 153)

  #define DIALOG_UNBIND_PRINTER_IT                "Unbind the printer?"
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\User\ui\Multi_language\Language_it.h",269  Warning[Pe047]: 
          incompatible redefinition of macro "DIALOG_UNBIND_PRINTER_IT"
          (declared at line 264)

  #define FILAMENT_CHANGE_TEXT_JP				"Please click <Load> \nor <unload>,After \npinter pause."
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\User\ui\Multi_language\Multi_language.h",705  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_JP"
          (declared at line 698)

  #define FILAMENT_CHANGE_TEXT_GN				"Please click <Load> \nor <unload>,After \npinter pause."
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\User\ui\Multi_language\Multi_language.h",913  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_GN"
          (declared at line 907)

  #define Simple_Dec"¼õÉÙ"
                    ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\User\ui\draw_ui.h",499  Warning[Pe1649]: 
          white space is required between the macro name "Simple_Dec" and its
          replacement text

  #define Simple_Speed "ËÙ¶È"
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\User\ui\draw_ui.h",554  Warning[Pe047]: 
          incompatible redefinition of macro "Simple_Speed" (declared at line
          551)

  #define Complex_Speed "ËÙ¶È"
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\User\ui\draw_ui.h",555  Warning[Pe047]: 
          incompatible redefinition of macro "Complex_Speed" (declared at line
          552)
    281          #include "wifi_module.h"
    282          #include "draw_printing.h"
    283          
    284          
    285          volatile uint8_t temper_error_flg = 0;
    286          
    287          volatile uint8_t mks_heating_busy = 0;
    288          
    289          extern void PowerOff_Filament_Check();
    290          extern void display_temper_error();
    291          extern void Close_machine_display();
    292          
    293          extern uint8_t IsChooseAutoShutdown;
    294          
    295          extern uint8_t temperature_change_frequency;
    296          extern uint8_t from_flash_pic;
    297          
    298          static uint32_t temperature_change_frequency_cnt = 0;
    299          static uint32_t After_finish_print_time = 0;
    300          
    301          #if 0
    302          uint8_t filament_loading_time_flg;
    303          uint32_t filament_loading_time_cnt;
    304          uint8_t filament_loading_completed;
    305          uint8_t filament_unloading_time_flg;
    306          uint32_t filament_unloading_time_cnt;
    307          uint8_t filament_unloading_completed;
    308          
    309          uint8_t filament_heat_completed_load;
    310          uint8_t filament_heat_completed_unload;
    311          
    312          extern uint32_t filament_rate;
    313          #endif
    314          
    315          volatile uint32_t TimeIncrease;
    316          uint8_t volatile printing_rate_update_flag;
    317          uint8_t preview_no_display;
    318          extern PRINT_TIME  print_time;
    319          #endif
    320          
    321          
    322          #if HAS_ABL
    323            #include "vector_3.h"
    324            #if ENABLED(AUTO_BED_LEVELING_LINEAR)
    325              #include "least_squares_fit.h"
    326            #endif
    327          #elif ENABLED(MESH_BED_LEVELING)
    328            #include "mesh_bed_leveling.h"
    329          #endif
    330          
    331          #if ENABLED(BEZIER_CURVE_SUPPORT)
    332            #include "planner_bezier.h"
    333          #endif
    334          
    335          #if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
    336            #include "buzzer.h"
    337          #endif
    338          
    339          #if ENABLED(USE_WATCHDOG)
    340            #include "watchdog.h"
    341          #endif
    342          
    343          #if ENABLED(MAX7219_DEBUG)
    344            #include "Max7219_Debug_LEDs.h"
    345          #endif
    346          
    347          #if HAS_COLOR_LEDS
    348            #include "leds.h"
    349          #endif
    350          
    351          #if HAS_SERVOS
    352            #include "servo.h"
    353          #endif
    354          
    355          #if HAS_DIGIPOTSS
    356            #include <SPI.h>
    357          #endif
    358          
    359          #if ENABLED(DAC_STEPPER_CURRENT)
    360            #include "stepper_dac.h"
    361          #endif
    362          
    363          #if ENABLED(EXPERIMENTAL_I2CBUS)
    364            #include "twibus.h"
    365          #endif
    366          
    367          #if ENABLED(I2C_POSITION_ENCODERS)
    368            #include "I2CPositionEncoder.h"
    369          #endif
    370          
    371          #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
    372            #include "endstop_interrupts.h"
    373          #endif
    374          
    375          #if ENABLED(M100_FREE_MEMORY_WATCHER)
    376            void gcode_M100();
    377            void M100_dump_routine(const char * const title, const char *start, const char *end);
    378          #endif
    379          
    380          #if ENABLED(G26_MESH_VALIDATION)
    381            bool g26_debug_flag; // =false
    382            void gcode_G26();
    383          #endif
    384          
    385          #if ENABLED(SDSUPPORT)

   \                                 In section .text, align 2, keep-with-next
   \   static __intrinsic __interwork __softfp void __sti__routine()
   \                     __sti__routine: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    386            CardReader card;
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable104_6
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0x.... 0x....      BL       _ZN10CardReaderC1Ev
   \   0000000C   0xF504 0x6060      ADD      R0,R4,#+3584
   \   00000010   0x.... 0x....      BL       _ZN9StopwatchC1Ev
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable104_7
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable104_8
   \   0000001C   0x684A             LDR      R2,[R1, #+4]
   \   0000001E   0x60C2             STR      R2,[R0, #+12]
   \   00000020   0x688A             LDR      R2,[R1, #+8]
   \   00000022   0x6182             STR      R2,[R0, #+24]
   \   00000024   0xF991 0x2001      LDRSB    R2,[R1, #+1]
   \   00000028   0x2A00             CMP      R2,#+0
   \   0000002A   0xD502             BPL.N    ??__sti__routine_0
   \   0000002C   0xED91 0x0A01      VLDR     S0,[R1, #+4]
   \   00000030   0xE001             B.N      ??__sti__routine_1
   \                     ??__sti__routine_0: (+1)
   \   00000032   0xED91 0x0A02      VLDR     S0,[R1, #+8]
   \                     ??__sti__routine_1: (+1)
   \   00000036   0xED80 0x0A09      VSTR     S0,[R0, #+36]
   \   0000003A   0xED91 0x0A02      VLDR     S0,[R1, #+8]
   \   0000003E   0xEDD1 0x0A01      VLDR     S1,[R1, #+4]
   \   00000042   0xEE30 0x0A60      VSUB.F32 S0,S0,S1
   \   00000046   0xED80 0x0A0C      VSTR     S0,[R0, #+48]
   \   0000004A   0x7849             LDRB     R1,[R1, #+1]
   \   0000004C   0x7081             STRB     R1,[R0, #+2]
   \   0000004E   0xF604 0x10C4      ADDW     R0,R4,#+2500
   \   00000052   0xE8BD 0x4010      POP      {R4,LR}
   \   00000056   0x.... 0x....      B.W      _ZN7MKS_DLPC1Ev
    387          #endif
    388          
    389          #if ENABLED(EXPERIMENTAL_I2CBUS)
    390            TWIBus i2c;
    391          #endif
    392          
    393          #if ENABLED(G38_PROBE_TARGET)
    394            bool G38_move = false,
    395                 G38_endstop_hit = false;
    396          #endif
    397          
    398          #if ENABLED(AUTO_BED_LEVELING_UBL)
    399            #include "ubl.h"
    400            extern bool defer_return_to_status;
    401            unified_bed_leveling ubl;
    402          #endif
    403          
    404          #if ENABLED(CNC_COORDINATE_SYSTEMS)
    405            int8_t active_coordinate_system = -1; // machine space
    406            float coordinate_system[MAX_COORDINATE_SYSTEMS][XYZ];
    407          #endif
    408          
    409          bool Running = true;
    410          
    411          uint8_t marlin_debug_flags = DEBUG_NONE;
    412          
    413          /**
    414           * Cartesian Current Position
    415           *   Used to track the native machine position as moves are queued.
    416           *   Used by 'buffer_line_to_current_position' to do a move after changing it.
    417           *   Used by 'SYNC_PLAN_POSITION_KINEMATIC' to update 'planner.position'.
    418           */
    419          float current_position[XYZE] = { 0.0 };
    420          
    421          /**
    422           * Cartesian Destination
    423           *   The destination for a move, filled in by G-code movement commands,
    424           *   and expected by functions like 'prepare_move_to_destination'.
    425           *   Set with 'gcode_get_destination' or 'set_destination_from_current'.
    426           */
    427          float destination[XYZE] = { 0.0 };
    428          
    429          /**
    430           * axis_homed
    431           *   Flags that each linear axis was homed.
    432           *   XYZ on cartesian, ABC on delta, ABZ on SCARA.
    433           *
    434           * axis_known_position
    435           *   Flags that the position is known in each linear axis. Set when homed.
    436           *   Cleared whenever a stepper powers off, potentially losing its position.
    437           */
    438          bool axis_homed[XYZ] = { false }, axis_known_position[XYZ] = { false };
    439          
    440          /**
    441           * GCode line number handling. Hosts may opt to include line numbers when
    442           * sending commands to Marlin, and lines will be checked for sequentiality.
    443           * M110 N<int> sets the current line number.
    444           */
    445          static long gcode_N, gcode_LastN, Stopped_gcode_LastN = 0;
    446          
    447          /**
    448           * GCode Command Queue
    449           * A simple ring buffer of BUFSIZE command strings.
    450           *
    451           * Commands are copied into this buffer by the command injectors
    452           * (immediate, serial, sd card) and they are processed sequentially by
    453           * the main loop. The process_next_command function parses the next
    454           * command and hands off execution to individual handler functions.
    455           */
    456          uint8_t commands_in_queue = 0; // Count of commands in the queue
    457          static uint8_t cmd_queue_index_r = 0, // Ring buffer read position
    458                         cmd_queue_index_w = 0; // Ring buffer write position
    459          #if ENABLED(M100_FREE_MEMORY_WATCHER)
    460            char command_queue[BUFSIZE][MAX_CMD_SIZE];  // Necessary so M100 Free Memory Dumper can show us the commands and any corruption
    461          #else                                         // This can be collapsed back to the way it was soon.
    462          static char command_queue[BUFSIZE][MAX_CMD_SIZE];
    463          #endif
    464          
    465          /**
    466           * Next Injected Command pointer. NULL if no commands are being injected.
    467           * Used by Marlin internally to ensure that commands initiated from within
    468           * are enqueued ahead of any pending serial or sd card commands.
    469           */
    470          static const char *injected_commands_P = NULL;
    471          
    472          #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
    473            TempUnit input_temp_units = TEMPUNIT_C;
    474          #endif
    475          
    476          /**
    477           * Feed rates are often configured with mm/m
    478           * but the planner and stepper like mm/s units.
    479           */
    480           /*
    481          static const float homing_feedrate_mm_s[] PROGMEM = {
    482            #if ENABLED(DELTA)
    483              MMM_TO_MMS(HOMING_FEEDRATE_Z), MMM_TO_MMS(HOMING_FEEDRATE_Z),
    484            #else
    485              MMM_TO_MMS(HOMING_FEEDRATE_XY), MMM_TO_MMS(HOMING_FEEDRATE_XY),
    486            #endif
    487            MMM_TO_MMS(HOMING_FEEDRATE_Z), 0
    488          };
    489          
    490          FORCE_INLINE float homing_feedrate(const AxisEnum a) { return pgm_read_float(&homing_feedrate_mm_s[a]); }
    491          */
    492          
    493          float  homing_feedrate_mm_s[4];
    494          
    495          float feedrate_mm_s = MMM_TO_MMS(1500.0);
    496          static float saved_feedrate_mm_s;
    497          int16_t feedrate_percentage = 100, saved_feedrate_percentage;
    498          
    499          // Initialized by settings.load()
    500          bool axis_relative_modes[] = AXIS_RELATIVE_MODES;
    501          
    502          #if HAS_WORKSPACE_OFFSET
    503            #if HAS_POSITION_SHIFT
    504              // The distance that XYZ has been offset by G92. Reset by G28.
    505              float position_shift[XYZ] = { 0 };
    506            #endif
    507            #if HAS_HOME_OFFSET
    508              // This offset is added to the configured home position.
    509              // Set by M206, M428, or menu item. Saved to EEPROM.
    510              float home_offset[XYZ] = { 0 };
    511            #endif
    512            #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
    513              // The above two are combined to save on computes
    514              float workspace_offset[XYZ] = { 0 };
    515            #endif
    516          #endif
    517          
    518          // Software Endstops are based on the configured limits.
    519          /*
    520          float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
    521                soft_endstop_max[XYZ] = { X_MAX_BED, Y_MAX_BED, Z_MAX_POS };
    522          */
    523          float soft_endstop_min[XYZ],soft_endstop_max[XYZ];

   \                                 In section .text, align 4, keep-with-next
    524          void soft_endstop_min_init()
    525          {
    526                  soft_endstop_min[0]= X_MIN_BED;
   \                     _Z21soft_endstop_min_initv: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable104_9
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6101             STR      R1,[R0, #+16]
    527                  soft_endstop_min[1]= X_MIN_BED;
   \   00000008   0x6141             STR      R1,[R0, #+20]
    528                  soft_endstop_min[2]= Z_MIN_POS;
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable104_8
   \   0000000E   0x684A             LDR      R2,[R1, #+4]
   \   00000010   0x6182             STR      R2,[R0, #+24]
    529          
    530                  soft_endstop_max[0] = X_MAX_BED;
   \   00000012   0xED9F 0x....      VLDR.W   S0,??DataTable88  ;; 0x43480000
   \   00000016   0xED80 0x0A07      VSTR     S0,[R0, #+28]
    531                  soft_endstop_max[1] = Y_MAX_BED;
   \   0000001A   0xED80 0x0A08      VSTR     S0,[R0, #+32]
    532                  soft_endstop_max[2] = Z_MAX_POS;
   \   0000001E   0x6889             LDR      R1,[R1, #+8]
   \   00000020   0x6241             STR      R1,[R0, #+36]
    533          }
   \   00000022   0x4770             BX       LR               ;; return
    534          
    535          #if HAS_SOFTWARE_ENDSTOPS
    536            bool soft_endstops_enabled = true;
    537            #if IS_KINEMATIC
    538              float soft_endstop_radius, soft_endstop_radius_2;
    539            #endif
    540          #endif
    541          
    542          #if FAN_COUNT > 0
    543            int fanSpeeds[FAN_COUNT] = { 0 };
    544            #if ENABLED(EXTRA_FAN_SPEED)
    545              int16_t old_fanSpeeds[FAN_COUNT],
    546                      new_fanSpeeds[FAN_COUNT];
    547            #endif
    548            #if ENABLED(PROBING_FANS_OFF)
    549              bool fans_paused = false;
    550              int16_t paused_fanSpeeds[FAN_COUNT] = { 0 };
    551            #endif
    552          #endif
    553          
    554          // The active extruder (tool). Set with T<extruder> command.
    555          uint8_t active_extruder = 0;
    556          
    557          // Relative Mode. Enable with G91, disable with G90.
    558          static bool relative_mode = false;
    559          
    560          // For M109 and M190, this flag may be cleared (by M108) to exit the wait loop
    561          volatile bool wait_for_heatup = true;
    562          
    563          // For M0/M1, this flag may be cleared (by M108) to exit the wait-for-user loop
    564          #if HAS_RESUME_CONTINUE
    565            volatile bool wait_for_user = false;
    566          #endif
    567          

   \                                 In section .text, align 4, keep-with-next
    568          const char axis_codes[XYZE] = { 'X', 'Y', 'Z', 'E' };
   \                     axis_codes:
   \   00000000   0x58 0x59          DC8 88, 89, 90, 69
   \              0x5A 0x45    
    569          
    570          // Number of characters read in the current line of serial input
    571          static int serial_count = 0;
    572          static int wifi_read_count = 0;
    573          
    574          // Inactivity shutdown
    575          millis_t previous_cmd_ms = 0;
    576          static millis_t max_inactive_time = 0;
    577          static millis_t stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000UL;
    578          
    579          // Print Job Timer
    580          #if ENABLED(PRINTCOUNTER)
    581            PrintCounter print_job_timer = PrintCounter();
    582          #else
    583            Stopwatch print_job_timer = Stopwatch();
    584          #endif
    585          
    586          // Buzzer - I2C on the LCD or a BEEPER_PIN
    587          #if ENABLED(LCD_USE_I2C_BUZZER)
    588            #define BUZZ(d,f) lcd_buzz(d, f)
    589          #elif PIN_EXISTS(BEEPER)
    590            Buzzer buzzer;
    591            #define BUZZ(d,f) buzzer.tone(d, f)
    592          #else
    593            #define BUZZ(d,f) NOOP
    594          #endif
    595          
    596          uint8_t target_extruder;
    597          
    598          #if HAS_BED_PROBE
    599            float zprobe_zoffset; // Initialized by settings.load()
    600          #endif
    601          
    602          #if HAS_ABL
    603            float xy_probe_feedrate_mm_s = MMM_TO_MMS(XY_PROBE_SPEED);
    604            #define XY_PROBE_FEEDRATE_MM_S xy_probe_feedrate_mm_s
    605          #elif defined(XY_PROBE_SPEED)
    606            #define XY_PROBE_FEEDRATE_MM_S MMM_TO_MMS(XY_PROBE_SPEED)
    607          #else
    608            #define XY_PROBE_FEEDRATE_MM_S PLANNER_XY_FEEDRATE()
    609          #endif
    610          
    611          #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
    612            #if ENABLED(DELTA)
    613              #define ADJUST_DELTA(V) \
    614                if (planner.leveling_active) { \
    615                  const float zadj = bilinear_z_offset(V); \
    616                  delta[A_AXIS] += zadj; \
    617                  delta[B_AXIS] += zadj; \
    618                  delta[C_AXIS] += zadj; \
    619                }
    620            #else
    621              #define ADJUST_DELTA(V) if (planner.leveling_active) { delta[Z_AXIS] += bilinear_z_offset(V); }
    622            #endif
    623          #elif IS_KINEMATIC
    624            #define ADJUST_DELTA(V) NOOP
    625          #endif
    626          
    627          #if ENABLED(X_DUAL_ENDSTOPS)
    628            float x_endstop_adj;                // Initialized by settings.load()
    629          #endif
    630          #if ENABLED(Y_DUAL_ENDSTOPS)
    631            float y_endstop_adj;                // Initialized by settings.load()
    632          #endif
    633          #if ENABLED(Z_DUAL_ENDSTOPS)
    634            float z_endstop_adj;                // Initialized by settings.load()
    635          #endif
    636          
    637          // Extruder offsets
    638          #if HOTENDS > 1
    639            float hotend_offset[XYZ][HOTENDS];  // Initialized by settings.load()
    640          #endif
    641          
    642          #if HAS_Z_SERVO_ENDSTOP
    643            const int z_servo_angle[2] = Z_SERVO_ANGLES;
    644          #endif
    645          
    646          #if ENABLED(BARICUDA)
    647            uint8_t baricuda_valve_pressure = 0,
    648                    baricuda_e_to_p_pressure = 0;
    649          #endif
    650          
    651          #if ENABLED(FWRETRACT)                      // Initialized by settings.load()...
    652            bool autoretract_enabled,                 // M209 S - Autoretract switch
    653                 retracted[EXTRUDERS] = { false };    // Which extruders are currently retracted
    654            float retract_length,                     // M207 S - G10 Retract length
    655                  retract_feedrate_mm_s,              // M207 F - G10 Retract feedrate
    656                  retract_zlift,                      // M207 Z - G10 Retract hop size
    657                  retract_recover_length,             // M208 S - G11 Recover length
    658                  retract_recover_feedrate_mm_s,      // M208 F - G11 Recover feedrate
    659                  swap_retract_length,                // M207 W - G10 Swap Retract length
    660                  swap_retract_recover_length,        // M208 W - G11 Swap Recover length
    661                  swap_retract_recover_feedrate_mm_s; // M208 R - G11 Swap Recover feedrate
    662            #if EXTRUDERS > 1
    663              bool retracted_swap[EXTRUDERS] = { false }; // Which extruders are swap-retracted
    664            #else
    665              constexpr bool retracted_swap[1] = { false };
    666            #endif
    667          #endif // FWRETRACT
    668          
    669          #if HAS_POWER_SWITCH
    670            bool powersupply_on =
    671              #if ENABLED(PS_DEFAULT_OFF)
    672                false
    673              #else
    674                true
    675              #endif
    676            ;
    677          #endif
    678          
    679          #if ENABLED(DELTA)
    680          
    681            float delta[ABC];
    682          
    683            // Initialized by settings.load()
    684            float delta_height,
    685                  delta_endstop_adj[ABC] = { 0 },
    686                  delta_radius,
    687                  delta_tower_angle_trim[ABC],
    688                  delta_tower[ABC][2],
    689                  delta_diagonal_rod,
    690                  delta_calibration_radius,
    691                  delta_diagonal_rod_2_tower[ABC],
    692                  delta_segments_per_second,
    693                  delta_clip_start_height = Z_MAX_POS;
    694          
    695            float delta_safe_distance_from_top();
    696          
    697          #endif
    698          
    699          #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
    700            int bilinear_grid_spacing[2], bilinear_start[2];
    701            float bilinear_grid_factor[2],
    702                  z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
    703          #endif
    704          
    705          #if IS_SCARA
    706            // Float constants for SCARA calculations
    707            const float L1 = SCARA_LINKAGE_1, L2 = SCARA_LINKAGE_2,
    708                        L1_2 = sq(float(L1)), L1_2_2 = 2.0 * L1_2,
    709                        L2_2 = sq(float(L2));
    710          
    711            float delta_segments_per_second = SCARA_SEGMENTS_PER_SECOND,
    712                  delta[ABC];
    713          #endif
    714          
    715          float cartes[XYZ] = { 0 };
    716          
    717          #if ENABLED(FILAMENT_WIDTH_SENSOR)
    718            bool filament_sensor = false;                                 // M405 turns on filament sensor control. M406 turns it off.
    719            float filament_width_nominal = DEFAULT_NOMINAL_FILAMENT_DIA,  // Nominal filament width. Change with M404.
    720                  filament_width_meas = DEFAULT_MEASURED_FILAMENT_DIA;    // Measured filament diameter
    721            uint8_t meas_delay_cm = MEASUREMENT_DELAY_CM;                 // Distance delay setting
    722            int8_t measurement_delay[MAX_MEASUREMENT_DELAY + 1],          // Ring buffer to delayed measurement. Store extruder factor after subtracting 100
    723                   filwidth_delay_index[2] = { 0, -1 };                   // Indexes into ring buffer
    724          #endif
    725          
    726          #if ENABLED(FILAMENT_RUNOUT_SENSOR)
    727            static bool filament_ran_out = false;
    728          #endif
    729          
    730          #if ENABLED(ADVANCED_PAUSE_FEATURE)
    731            AdvancedPauseMenuResponse advanced_pause_menu_response;
    732          #endif
    733          
    734          #if ENABLED(MIXING_EXTRUDER)
    735            float mixing_factor[MIXING_STEPPERS]; // Reciprocal of mix proportion. 0.0 = off, otherwise >= 1.0.
    736            #if MIXING_VIRTUAL_TOOLS > 1
    737              float mixing_virtual_tool_mix[MIXING_VIRTUAL_TOOLS][MIXING_STEPPERS];
    738            #endif
    739          #endif
    740          
    741          static bool send_ok[BUFSIZE];
    742          
    743          #if HAS_SERVOS
    744            Servo servo[NUM_SERVOS];
    745            #define MOVE_SERVO(I, P) servo[I].move(P)
    746            #if HAS_Z_SERVO_ENDSTOP
    747              #define DEPLOY_Z_SERVO() MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[0])
    748              #define STOW_Z_SERVO() MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[1])
    749            #endif
    750          #endif
    751          
    752          #ifdef CHDK
    753            millis_t chdkHigh = 0;
    754            bool chdkActive = false;
    755          #endif
    756          
    757          #if ENABLED(PID_EXTRUSION_SCALING)
    758            int lpq_len = 20;
    759          #endif
    760          
    761          #if ENABLED(HOST_KEEPALIVE_FEATURE)
    762            MarlinBusyState busy_state = NOT_BUSY;
    763            static millis_t next_busy_signal_ms = 0;
    764            uint8_t host_keepalive_interval = DEFAULT_KEEPALIVE_INTERVAL;
    765          #else
    766            #define host_keepalive() NOOP
    767          #endif
    768          
    769          #if ENABLED(I2C_POSITION_ENCODERS)
    770            I2CPositionEncodersMgr I2CPEM;
    771            uint8_t blockBufferIndexRef = 0;
    772            millis_t lastUpdateMillis;
    773          #endif
    774          
    775          #if ENABLED(CNC_WORKSPACE_PLANES)
    776            static WorkspacePlane workspace_plane = PLANE_XY;
    777          #endif
    778          
    779          //FORCE_INLINE float pgm_read_any(const float *p) { return pgm_read_float_near(p); }
    780          //FORCE_INLINE signed char pgm_read_any(const signed char *p) { return pgm_read_byte_near(p); }
    781          static inline float pgm_read_any(const float *p) { return (*(const float *)(p)); }
    782          static inline signed char pgm_read_any(const signed char *p) { return (*(const signed char *)(p)); }
    783          /*P
    784          #define XYZ_CONSTS_FROM_CONFIG(type, array, CONFIG) \
    785            static const PROGMEM type array##_P[XYZ] = { X_##CONFIG, Y_##CONFIG, Z_##CONFIG }; \
    786            static inline type array(const AxisEnum axis) { return pgm_read_any(&array##_P[axis]); } \
    787            typedef void __void_##CONFIG##__
    788          */
    789          #define XYZ_CONSTS_FROM_CONFIG(type, array, CONFIG) \
    790          	  type array##_P[XYZ] = { X_##CONFIG, Y_##CONFIG, Z_##CONFIG }; \
    791          	  static inline type array(AxisEnum axis) { return (array##_P[axis]); } 
    792          

   \                                 In section .text, align 2, keep-with-next
    793          XYZ_CONSTS_FROM_CONFIG(float, base_min_pos,   MIN_POS);
   \                     _Z12base_min_pos8AxisEnum: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable104_7
   \   00000004   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   00000008   0xED90 0x0A01      VLDR     S0,[R0, #+4]
   \   0000000C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    794          XYZ_CONSTS_FROM_CONFIG(float, base_max_pos,   MAX_POS);
   \                     _Z12base_max_pos8AxisEnum: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable104_7
   \   00000004   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   00000008   0xED90 0x0A04      VLDR     S0,[R0, #+16]
   \   0000000C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    795          XYZ_CONSTS_FROM_CONFIG(float, base_home_pos,  HOME_POS);
   \                     _Z13base_home_pos8AxisEnum: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable104_7
   \   00000004   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   00000008   0xED90 0x0A07      VLDR     S0,[R0, #+28]
   \   0000000C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    796          XYZ_CONSTS_FROM_CONFIG(float, max_length,     MAX_LENGTH);
   \                     _Z10max_length8AxisEnum: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable104_7
   \   00000004   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   00000008   0xED90 0x0A0A      VLDR     S0,[R0, #+40]
   \   0000000C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    797          XYZ_CONSTS_FROM_CONFIG(float, home_bump_mm,   HOME_BUMP_MM);
   \                     _Z12home_bump_mm8AxisEnum: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable107
   \   00000004   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   00000008   0xED90 0x0A18      VLDR     S0,[R0, #+96]
   \   0000000C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    798          XYZ_CONSTS_FROM_CONFIG(signed char, home_dir, HOME_DIR);
   \                     _Z8home_dir8AxisEnum: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable104_7
   \   00000004   0x5640             LDRSB    R0,[R0, R1]
   \   00000006   0x4770             BX       LR               ;; return
    799          
    800          /**
    801           * ***************************************************************************
    802           * ******************************** FUNCTIONS ********************************
    803           * ***************************************************************************
    804           */
    805          
    806          void stop();
    807          
    808          void get_available_commands();
    809          void process_next_command();
    810          void process_parsed_command();
    811          
    812          void get_cartesian_from_steppers();
    813          void set_current_from_steppers_for_axis(const AxisEnum axis);
    814          
    815          #if ENABLED(ARC_SUPPORT)
    816            void plan_arc(const float (&cart)[XYZE], const float (&offset)[2], const bool clockwise);
    817          #endif
    818          
    819          #if ENABLED(BEZIER_CURVE_SUPPORT)
    820            void plan_cubic_move(const float (&offset)[4]);
    821          #endif
    822          
    823          void tool_change(const uint8_t tmp_extruder, const float fr_mm_s=0.0, bool no_move=false);
    824          void report_current_position();
    825          void report_current_position_detail();
    826          
    827          #if ENABLED(DEBUG_LEVELING_FEATURE)
    828            void print_xyz(const char* prefix, const char* suffix, const float x, const float y, const float z) {
    829              serialprintPGM(prefix);
    830              SERIAL_CHAR('(');
    831              SERIAL_ECHO(x);
    832              SERIAL_ECHOPAIR(", ", y);
    833              SERIAL_ECHOPAIR(", ", z);
    834              SERIAL_CHAR(')');
    835              if (suffix) serialprintPGM(suffix); else SERIAL_EOL();
    836            }
    837          
    838            void print_xyz(const char* prefix, const char* suffix, const float xyz[]) {
    839              print_xyz(prefix, suffix, xyz[X_AXIS], xyz[Y_AXIS], xyz[Z_AXIS]);
    840            }
    841          
    842            #if HAS_ABL
    843              void print_xyz(const char* prefix, const char* suffix, const vector_3 &xyz) {
    844                print_xyz(prefix, suffix, xyz.x, xyz.y, xyz.z);
    845              }
    846            #endif
    847          
    848            #define DEBUG_POS(SUFFIX,VAR) do { \
    849              print_xyz(PSTR("  " STRINGIFY(VAR) "="), PSTR(" : " SUFFIX "\n"), VAR); }while(0)
    850          #endif
    851          
    852          /**
    853           * sync_plan_position
    854           *
    855           * Set the planner/stepper positions directly from current_position with
    856           * no kinematic translation. Used for homing axes and cartesian/core syncing.
    857           */

   \                                 In section .text, align 2, keep-with-next
    858          void sync_plan_position() {
    859            #if ENABLED(DEBUG_LEVELING_FEATURE)
    860              if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position", current_position);
    861            #endif
    862            planner.set_position_mm(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
   \                     _Z18sync_plan_positionv: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable107
   \   00000004   0xF101 0x0030      ADD      R0,R1,#+48
   \   00000008   0xED91 0x1A0B      VLDR     S2,[R1, #+44]
   \   0000000C   0xEDD1 0x0A0A      VLDR     S1,[R1, #+40]
   \   00000010   0xED91 0x0A09      VLDR     S0,[R1, #+36]
   \   00000014   0x.... 0x....      B.W      _ZN7Planner15set_position_mmEfffRKf
    863          }

   \                                 In section .text, align 4
    864          inline void sync_plan_position_e() { planner.set_e_position_mm(current_position[E_AXIS]); }
   \                     _Z20sync_plan_position_ev: (+1)
   \   00000000   0x4801             LDR.N    R0,??sync_plan_position_e_0
   \   00000002   0x.... 0x....      B.W      _ZN7Planner17set_e_position_mmERKf
   \   00000006   0xBF00             Nop      
   \                     ??sync_plan_position_e_0:
   \   00000008   0x........         DC32     axis_relative_modes+0x30
    865          
    866          #if IS_KINEMATIC
    867          
    868            inline void sync_plan_position_kinematic() {
    869              #if ENABLED(DEBUG_LEVELING_FEATURE)
    870                if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position_kinematic", current_position);
    871              #endif
    872              planner.set_position_mm_kinematic(current_position);
    873            }
    874            #define SYNC_PLAN_POSITION_KINEMATIC() sync_plan_position_kinematic()
    875          
    876          #else
    877          
    878            #define SYNC_PLAN_POSITION_KINEMATIC() sync_plan_position()
    879          
    880          #endif
    881          
    882          #if 0//ENABLED(SDSUPPORT)
    883            #include "SdFatUtil.h"
    884            int freeMemory() { return SdFatUtil::FreeRam(); }
    885          #else
    886          /*
    887          extern "C" {
    888            extern char __bss_end;
    889            extern char __heap_start;
    890            extern void* __brkval;
    891          
    892            int freeMemory() {
    893              int free_memory;
    894              if ((int)__brkval == 0)
    895                free_memory = ((int)&free_memory) - ((int)&__bss_end);
    896              else
    897                free_memory = ((int)&free_memory) - ((int)__brkval);
    898              return free_memory;
    899            }
    900          }
    901          */

   \                                 In section .text, align 2, keep-with-next
    902          	int freeMemory() { return 4396; }	//No free ram management
   \                     _Z10freeMemoryv: (+1)
   \   00000000   0xF241 0x102C      MOVW     R0,#+4396
   \   00000004   0x4770             BX       LR               ;; return
    903          
    904          #endif // !SDSUPPORT
    905          
    906          #if ENABLED(DIGIPOT_I2C)
    907            extern void digipot_i2c_set_current(uint8_t channel, float current);
    908            extern void digipot_i2c_init();
    909          #endif
    910          
    911          /**
    912           * Inject the next "immediate" command, when possible, onto the front of the queue.
    913           * Return true if any immediate commands remain to inject.
    914           */

   \                                 In section .text, align 2, keep-with-next
    915          static bool drain_injected_commands_P() {
   \                     _Z25drain_injected_commands_Pv: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
    916            if (injected_commands_P != NULL) {
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable107_1
   \   00000008   0x6821             LDR      R1,[R4, #+0]
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD01C             BEQ.N    ??drain_injected_commands_P_0
    917              size_t i = 0;
   \   0000000E   0x2500             MOVS     R5,#+0
    918              char c, cmd[30];
    919              //strncpy_P(cmd, injected_commands_P, sizeof(cmd) - 1);
    920              strncpy(cmd, injected_commands_P, sizeof(cmd) - 1);	/*--mks--*/
   \   00000010   0x221D             MOVS     R2,#+29
   \   00000012   0xA800             ADD      R0,SP,#+0
   \   00000014   0x.... 0x....      BL       strncpy
    921              cmd[sizeof(cmd) - 1] = '\0';
   \   00000018   0xA800             ADD      R0,SP,#+0
   \   0000001A   0x4629             MOV      R1,R5
   \   0000001C   0x7741             STRB     R1,[R0, #+29]
   \   0000001E   0xE000             B.N      ??drain_injected_commands_P_1
    922              while ((c = cmd[i]) && c != '\n') i++; // find the end of this gcode command
   \                     ??drain_injected_commands_P_2: (+1)
   \   00000020   0x1C6D             ADDS     R5,R5,#+1
   \                     ??drain_injected_commands_P_1: (+1)
   \   00000022   0x562E             LDRSB    R6,[R5, R0]
   \   00000024   0x2E00             CMP      R6,#+0
   \   00000026   0xD001             BEQ.N    ??drain_injected_commands_P_3
   \   00000028   0x2E0A             CMP      R6,#+10
   \   0000002A   0xD1F9             BNE.N    ??drain_injected_commands_P_2
    923              cmd[i] = '\0';
   \                     ??drain_injected_commands_P_3: (+1)
   \   0000002C   0x5429             STRB     R1,[R5, R0]
    924              if (enqueue_and_echo_command(cmd))     // success?
   \   0000002E   0x.... 0x....      BL       _Z24enqueue_and_echo_commandPKcb
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD008             BEQ.N    ??drain_injected_commands_P_0
    925                injected_commands_P = c ? injected_commands_P + i + 1 : NULL; // next command or done
   \   00000036   0x2E00             CMP      R6,#+0
   \   00000038   0xD004             BEQ.N    ??drain_injected_commands_P_4
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x1828             ADDS     R0,R5,R0
   \   0000003E   0x1C40             ADDS     R0,R0,#+1
   \   00000040   0x6020             STR      R0,[R4, #+0]
   \   00000042   0xE001             B.N      ??drain_injected_commands_P_0
   \                     ??drain_injected_commands_P_4: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x6020             STR      R0,[R4, #+0]
    926            }
    927            return (injected_commands_P != NULL);    // return whether any more remain
   \                     ??drain_injected_commands_P_0: (+1)
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD001             BEQ.N    ??drain_injected_commands_P_5
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0xE000             B.N      ??drain_injected_commands_P_6
   \                     ??drain_injected_commands_P_5: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \                     ??drain_injected_commands_P_6: (+1)
   \   00000054   0xB008             ADD      SP,SP,#+32
   \   00000056   0xBD70             POP      {R4-R6,PC}       ;; return
    928          }
    929          
    930          /**
    931           * Record one or many commands to run from program memory.
    932           * Aborts the current queue, if any.
    933           * Note: drain_injected_commands_P() must be called repeatedly to drain the commands afterwards
    934           */

   \                                 In section .text, align 2, keep-with-next
    935          void enqueue_and_echo_commands_P(const char * const pgcode) {
    936            injected_commands_P = pgcode;
   \                     _Z27enqueue_and_echo_commands_PPKc: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable107_1
   \   00000004   0x6008             STR      R0,[R1, #+0]
    937            drain_injected_commands_P(); // first command executed asap (when possible)
   \   00000006   0x....             B.N      _Z25drain_injected_commands_Pv
    938          }
    939          
    940          /**
    941           * Clear the Marlin command queue
    942           */

   \                                 In section .text, align 2, keep-with-next
    943          void clear_command_queue() {
    944            cmd_queue_index_r = cmd_queue_index_w;
   \                     _Z19clear_command_queuev: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable107
   \   00000004   0x7C81             LDRB     R1,[R0, #+18]
   \   00000006   0x7441             STRB     R1,[R0, #+17]
    945            commands_in_queue = 0;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x7401             STRB     R1,[R0, #+16]
    946          }
   \   0000000C   0x4770             BX       LR               ;; return
    947          
    948          /**
    949           * Once a new command is in the ring buffer, call this to commit it
    950           */

   \                                 In section .text, align 4
    951          inline void _commit_command(bool say_ok) {
    952            send_ok[cmd_queue_index_w] = say_ok;
   \                     _Z15_commit_commandb: (+1)
   \   00000000   0x4907             LDR.N    R1,??_commit_command_0
   \   00000002   0x7C8A             LDRB     R2,[R1, #+18]
   \   00000004   0x1853             ADDS     R3,R2,R1
   \   00000006   0x7718             STRB     R0,[R3, #+28]
    953            if (++cmd_queue_index_w >= BUFSIZE) cmd_queue_index_w = 0;
   \   00000008   0x1C50             ADDS     R0,R2,#+1
   \   0000000A   0x7488             STRB     R0,[R1, #+18]
   \   0000000C   0xB2C0             UXTB     R0,R0
   \   0000000E   0x2804             CMP      R0,#+4
   \   00000010   0xDB01             BLT.N    ??_commit_command_1
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x7488             STRB     R0,[R1, #+18]
    954            commands_in_queue++;
   \                     ??_commit_command_1: (+1)
   \   00000016   0x7C08             LDRB     R0,[R1, #+16]
   \   00000018   0x1C40             ADDS     R0,R0,#+1
   \   0000001A   0x7408             STRB     R0,[R1, #+16]
    955          }
   \   0000001C   0x4770             BX       LR               ;; return
   \   0000001E   0xBF00             Nop      
   \                     ??_commit_command_0:
   \   00000020   0x........         DC32     axis_relative_modes
    956          
    957          /**
    958           * Copy a command from RAM into the main command buffer.
    959           * Return true if the command was successfully added.
    960           * Return false for a full buffer, or if the 'command' is a comment.
    961           */

   \                                 In section .text, align 4
    962          inline bool _enqueuecommand(const char* cmd, bool say_ok=false) {
   \                     _Z15_enqueuecommandPKcb: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
    963            if (*cmd == ';' || commands_in_queue >= BUFSIZE) return false;
   \   00000004   0xF990 0x1000      LDRSB    R1,[R0, #+0]
   \   00000008   0x293B             CMP      R1,#+59
   \   0000000A   0xD003             BEQ.N    ??_enqueuecommand_0
   \   0000000C   0x4A09             LDR.N    R2,??_enqueuecommand_1
   \   0000000E   0x7C11             LDRB     R1,[R2, #+16]
   \   00000010   0x2904             CMP      R1,#+4
   \   00000012   0xDB01             BLT.N    ??_enqueuecommand_2
   \                     ??_enqueuecommand_0: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xBD10             POP      {R4,PC}
    964            strcpy(command_queue[cmd_queue_index_w], cmd);
   \                     ??_enqueuecommand_2: (+1)
   \   00000018   0x4601             MOV      R1,R0
   \   0000001A   0x7C90             LDRB     R0,[R2, #+18]
   \   0000001C   0xEB00 0x0340      ADD      R3,R0,R0, LSL #+1
   \   00000020   0xEB02 0x1043      ADD      R0,R2,R3, LSL #+5
   \   00000024   0x308C             ADDS     R0,R0,#+140
   \   00000026   0x.... 0x....      BL       strcpy
    965            _commit_command(say_ok);
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       _Z15_commit_commandb
    966            return true;
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0xBD10             POP      {R4,PC}          ;; return
   \                     ??_enqueuecommand_1:
   \   00000034   0x........         DC32     axis_relative_modes
    967          }
    968          
    969          /**
    970           * Enqueue with Serial Echo
    971           */

   \                                 In section .text, align 2, keep-with-next
    972          bool enqueue_and_echo_command(const char* cmd, bool say_ok/*=false*/) {
   \                     _Z24enqueue_and_echo_commandPKcb: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    973            if (_enqueuecommand(cmd, say_ok)) {
   \   00000004   0x.... 0x....      BL       _Z15_enqueuecommandPKcb
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD014             BEQ.N    ??enqueue_and_echo_command_0
    974              SERIAL_ECHO_START();
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable107_2
   \   00000010   0x.... 0x....      BL       _Z14serialprintPGMPKc
    975              SERIAL_ECHOPAIR(MSG_ENQUEUEING, cmd);
   \   00000014   0x4621             MOV      R1,R4
   \   00000016   0x.... 0x....      ADR.W    R0,`?<Constant "enqueueing \\"">`
   \   0000001A   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
    976              SERIAL_CHAR('"');
   \   0000001E   0x.... 0x....      LDR.W    R4,??DataTable109
   \   00000022   0x2122             MOVS     R1,#+34
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    977              SERIAL_EOL();
   \   0000002A   0x210A             MOVS     R1,#+10
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    978              return true;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xBD10             POP      {R4,PC}
    979            }
    980            return false;
   \                     ??enqueue_and_echo_command_0: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
    981          }
    982          

   \                                 In section .text, align 2, keep-with-next
    983          void setup_killpin() {
    984            #if HAS_KILL
    985              SET_INPUT_PULLUP(KILL_PIN);
    986            #endif
    987          }
   \                     _Z13setup_killpinv: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    988          
    989          #if ENABLED(FILAMENT_RUNOUT_SENSOR)
    990          
    991            void setup_filrunoutpin() {
    992              #if ENABLED(ENDSTOPPULLUP_FIL_RUNOUT)
    993                SET_INPUT_PULLUP(FIL_RUNOUT_PIN);
    994              #else
    995                SET_INPUT(FIL_RUNOUT_PIN);
    996              #endif
    997            }
    998          
    999          #endif
   1000          

   \                                 In section .text, align 2, keep-with-next
   1001          void setup_powerhold() {
   1002            #if HAS_SUICIDE
   1003              OUT_WRITE(SUICIDE_PIN, HIGH);
   1004            #endif
   1005            #if HAS_POWER_SWITCH
   1006              #if ENABLED(PS_DEFAULT_OFF)
   1007                OUT_WRITE(PS_ON_PIN, PS_ON_ASLEEP);
   1008              #else
   1009                OUT_WRITE(PS_ON_PIN, PS_ON_AWAKE);
   1010              #endif
   1011            #endif
   1012          }
   \                     _Z15setup_powerholdv: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1013          

   \                                 In section .text, align 2, keep-with-next
   1014          void suicide() {
   1015            #if HAS_SUICIDE
   1016              OUT_WRITE(SUICIDE_PIN, LOW);
   1017            #endif
   1018          }
   \                     _Z7suicidev: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1019          

   \                                 In section .text, align 2, keep-with-next
   1020          void servo_init() {
   1021            #if NUM_SERVOS >= 1 && HAS_SERVO_0
   1022              servo[0].attach(SERVO0_PIN);
   1023              servo[0].detach(); // Just set up the pin. We don't have a position yet. Don't move to a random position.
   1024            #endif
   1025            #if NUM_SERVOS >= 2 && HAS_SERVO_1
   1026              servo[1].attach(SERVO1_PIN);
   1027              servo[1].detach();
   1028            #endif
   1029            #if NUM_SERVOS >= 3 && HAS_SERVO_2
   1030              servo[2].attach(SERVO2_PIN);
   1031              servo[2].detach();
   1032            #endif
   1033            #if NUM_SERVOS >= 4 && HAS_SERVO_3
   1034              servo[3].attach(SERVO3_PIN);
   1035              servo[3].detach();
   1036            #endif
   1037          
   1038            #if HAS_Z_SERVO_ENDSTOP
   1039              /**
   1040               * Set position of Z Servo Endstop
   1041               *
   1042               * The servo might be deployed and positioned too low to stow
   1043               * when starting up the machine or rebooting the board.
   1044               * There's no way to know where the nozzle is positioned until
   1045               * homing has been done - no homing with z-probe without init!
   1046               *
   1047               */
   1048              STOW_Z_SERVO();
   1049            #endif
   1050          }
   \                     _Z10servo_initv: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1051          
   1052          /**
   1053           * Stepper Reset (RigidBoard, et.al.)
   1054           */
   1055          #if HAS_STEPPER_RESET
   1056            void disableStepperDrivers() {
   1057              OUT_WRITE(STEPPER_RESET_PIN, LOW);  // drive it down to hold in reset motor driver chips
   1058            }
   1059            void enableStepperDrivers() { SET_INPUT(STEPPER_RESET_PIN); }  // set to input, which allows it to be pulled high by pullups
   1060          #endif
   1061          
   1062          #if ENABLED(EXPERIMENTAL_I2CBUS) && I2C_SLAVE_ADDRESS > 0
   1063          
   1064            void i2c_on_receive(int bytes) { // just echo all bytes received to serial
   1065              i2c.receive(bytes);
   1066            }
   1067          
   1068            void i2c_on_request() {          // just send dummy data for now
   1069              i2c.reply("Hello World!\n");
   1070            }
   1071          
   1072          #endif
   1073          

   \                                 In section .text, align 2, keep-with-next
   1074          void gcode_line_error(const char* err, bool doFlush = true) {
   \                     _Z16gcode_line_errorPKcb: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1075            SERIAL_ERROR_START();
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable107_3
   \   0000000A   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1076            serialprintPGM(err);
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1077            SERIAL_ERRORLN(gcode_LastN);
   \   00000014   0x.... 0x....      LDR.W    R4,??DataTable109
   \   00000018   0x220A             MOVS     R2,#+10
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable107
   \   0000001E   0x6F01             LDR      R1,[R0, #+112]
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       _ZN5Print5printEli
   \   00000026   0x210A             MOVS     R1,#+10
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   1078            //Serial.println(gcode_N);
   1079            if (doFlush) FlushSerialRequestResend();
   \   0000002E   0x2D00             CMP      R5,#+0
   \   00000030   0xD001             BEQ.N    ??gcode_line_error_0
   \   00000032   0x.... 0x....      BL       _Z24FlushSerialRequestResendv
   1080            serial_count = 0;
   \                     ??gcode_line_error_0: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable111
   \   0000003C   0x6008             STR      R0,[R1, #+0]
   1081          }
   \   0000003E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1082          
   1083          uint8_t serial_wait_tick = 0; //use to calculate the serial wait ticks
   1084          
   1085          uint8_t from_wifi_flag = 0; // whether data comes from wifi model
   1086          
   1087          /**
   1088           * Get all commands waiting on the serial port and queue them.
   1089           * Exit when the buffer is full or when no more characters are
   1090           * left on the serial port.
   1091           */

   \                                 In section .text, align 4
   1092          inline void get_serial_commands() {
   \                     _Z19get_serial_commandsv: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   1093            static char serial_line_buffer[MAX_CMD_SIZE];
   1094            static bool serial_comment_mode = false;
   1095            static millis_t last_wait_time = 0;
   1096            const millis_t wait_ms = millis();
   \   00000004   0x.... 0x....      BL       HAL_GetTick
   \   00000008   0x4605             MOV      R5,R0
   1097          
   1098            // If the command buffer is empty for too long,
   1099            // send "wait" to indicate Marlin is still waiting.
   1100            #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
   1101              static millis_t last_command_time = 0;
   1102              const millis_t ms = millis();
   1103              if (commands_in_queue == 0 && !MYSERIAL.available() && ELAPSED(ms, last_command_time + NO_TIMEOUTS)) {
   1104                SERIAL_ECHOLNPGM(MSG_WAIT);
   1105                last_command_time = ms;
   1106              }
   1107            #endif
   1108          #if 1
   1109            
   1110          	  /*5s?¡§?2a2?|¨¬?????¡§2¡§oy?Y?¡§¡ã¡§¡§??a??¡§?D¡§¡éa?¡§2?????¨º??¡§|¡§o1¡§??wifi*/
   1111          	 if (commands_in_queue == 0 && !MYSERIAL.available() && ELAPSED(wait_ms, last_wait_time + 1000)) {
   \   0000000A   0x4C74             LDR.N    R4,??get_serial_commands_0
   \   0000000C   0x7C20             LDRB     R0,[R4, #+16]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xF040 0x809C      BNE.W    ??get_serial_commands_1
   \   00000014   0x4872             LDR.N    R0,??get_serial_commands_0+0x4
   \   00000016   0x.... 0x....      BL       _ZN10USARTClass9availableEv
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xF040 0x8096      BNE.W    ??get_serial_commands_1
   \   00000020   0x4870             LDR.N    R0,??get_serial_commands_0+0x8
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0x1A69             SUBS     R1,R5,R1
   \   00000026   0xF5B1 0x717A      SUBS     R1,R1,#+1000
   \   0000002A   0xF100 0x808F      BMI.W    ??get_serial_commands_1
   1112          		if(serial_wait_tick <= 5)
   \   0000002E   0x7DE1             LDRB     R1,[R4, #+23]
   \   00000030   0x2906             CMP      R1,#+6
   \   00000032   0xDA01             BGE.N    ??get_serial_commands_2
   1113          	  {
   1114          		  serial_wait_tick ++;
   \   00000034   0x1C49             ADDS     R1,R1,#+1
   \   00000036   0x75E1             STRB     R1,[R4, #+23]
   1115          	  }
   1116          		last_wait_time = wait_ms;
   \                     ??get_serial_commands_2: (+1)
   \   00000038   0x6005             STR      R5,[R0, #+0]
   \   0000003A   0xE087             B.N      ??get_serial_commands_1
   1117          	  }
   1118          #endif
   1119          
   1120            /**
   1121             * Loop while serial characters are incoming and the queue is not full
   1122             */
   1123            int c;
   1124            while (commands_in_queue < BUFSIZE && (c = MYSERIAL.read()) >= 0) {
   1125          
   1126              char serial_char = c;
   1127          	
   1128          	serial_wait_tick = 0;
   1129          	from_wifi_flag = 0;
   1130          
   1131              /**
   1132               * If the character ends the line
   1133               */
   1134              if (serial_char == '\n' || serial_char == '\r') {
   1135          
   1136                serial_comment_mode = false;                      // end of line == end of comment
   1137          
   1138                if (!serial_count) continue;                      // Skip empty lines
   1139          
   1140                serial_line_buffer[serial_count] = 0;             // Terminate string
   1141                serial_count = 0;                                 // Reset buffer
   1142          
   1143                char* command = serial_line_buffer;
   1144          
   1145                while (*command == ' ') command++;                // Skip leading spaces
   \                     ??get_serial_commands_3: (+1)
   \   0000003C   0x1C76             ADDS     R6,R6,#+1
   \                     ??get_serial_commands_4: (+1)
   \   0000003E   0xF996 0x0000      LDRSB    R0,[R6, #+0]
   \   00000042   0x2820             CMP      R0,#+32
   \   00000044   0xD0FA             BEQ.N    ??get_serial_commands_3
   1146                char *npos = (*command == 'N') ? command : NULL;  // Require the N parameter to start the line
   \   00000046   0x284E             CMP      R0,#+78
   \   00000048   0xD101             BNE.N    ??get_serial_commands_5
   \   0000004A   0x46B0             MOV      R8,R6
   \   0000004C   0xE001             B.N      ??get_serial_commands_6
   \                     ??get_serial_commands_5: (+1)
   \   0000004E   0xF04F 0x0800      MOV      R8,#+0
   1147          
   1148                if (npos) {
   \                     ??get_serial_commands_6: (+1)
   \   00000052   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000056   0xD044             BEQ.N    ??get_serial_commands_7
   1149          
   1150                  bool M110 = strstr_P(command, PSTR("M110")) != NULL;
   \   00000058   0x4963             LDR.N    R1,??get_serial_commands_0+0xC
   \   0000005A   0x4630             MOV      R0,R6
   \   0000005C   0x.... 0x....      BL       _Z6strstrPcPKc
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD001             BEQ.N    ??get_serial_commands_8
   \   00000064   0x2701             MOVS     R7,#+1
   \   00000066   0xE000             B.N      ??get_serial_commands_9
   \                     ??get_serial_commands_8: (+1)
   \   00000068   0x2700             MOVS     R7,#+0
   1151          
   1152                  if (M110) {
   \                     ??get_serial_commands_9: (+1)
   \   0000006A   0x2F00             CMP      R7,#+0
   \   0000006C   0xD006             BEQ.N    ??get_serial_commands_10
   1153                    char* n2pos = strchr(command + 4, 'N');
   \   0000006E   0x214E             MOVS     R1,#+78
   \   00000070   0x1D30             ADDS     R0,R6,#+4
   \   00000072   0x.... 0x....      BL       _Z6strchrPci
   1154                    if (n2pos) npos = n2pos;
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD000             BEQ.N    ??get_serial_commands_10
   \   0000007A   0x4680             MOV      R8,R0
   1155                  }
   1156          
   1157                  gcode_N = strtol(npos + 1, NULL, 10);
   \                     ??get_serial_commands_10: (+1)
   \   0000007C   0x220A             MOVS     R2,#+10
   \   0000007E   0x2100             MOVS     R1,#+0
   \   00000080   0xF108 0x0001      ADD      R0,R8,#+1
   \   00000084   0x.... 0x....      BL       strtol
   \   00000088   0x66E0             STR      R0,[R4, #+108]
   1158          
   1159                  if (gcode_N != gcode_LastN + 1 && !M110) {
   \   0000008A   0x6F21             LDR      R1,[R4, #+112]
   \   0000008C   0x1C49             ADDS     R1,R1,#+1
   \   0000008E   0x4288             CMP      R0,R1
   \   00000090   0xD007             BEQ.N    ??get_serial_commands_11
   \   00000092   0x2F00             CMP      R7,#+0
   \   00000094   0xD105             BNE.N    ??get_serial_commands_11
   1160                    gcode_line_error(PSTR(MSG_ERR_LINE_NO));
   \   00000096   0x2101             MOVS     R1,#+1
   \   00000098   0x4854             LDR.N    R0,??get_serial_commands_0+0x10
   \   0000009A   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   0000009E   0x.... 0x....      B.W      _Z16gcode_line_errorPKcb
   1161                    return;
   1162                  }
   1163          
   1164                  char *apos = strrchr(command, '*');
   \                     ??get_serial_commands_11: (+1)
   \   000000A2   0x212A             MOVS     R1,#+42
   \   000000A4   0x4630             MOV      R0,R6
   \   000000A6   0x.... 0x....      BL       _Z7strrchrPci
   1165                  if (apos) {
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xD06B             BEQ.N    ??get_serial_commands_12
   1166                    uint8_t checksum = 0, count = uint8_t(apos - command);
   \   000000AE   0x2700             MOVS     R7,#+0
   \   000000B0   0x1B81             SUBS     R1,R0,R6
   \   000000B2   0xE003             B.N      ??get_serial_commands_13
   1167                    while (count) checksum ^= command[--count];
   \                     ??get_serial_commands_14: (+1)
   \   000000B4   0x1E49             SUBS     R1,R1,#+1
   \   000000B6   0xB2C9             UXTB     R1,R1
   \   000000B8   0x578A             LDRSB    R2,[R1, R6]
   \   000000BA   0x4057             EORS     R7,R2,R7
   \                     ??get_serial_commands_13: (+1)
   \   000000BC   0xB2C9             UXTB     R1,R1
   \   000000BE   0x2900             CMP      R1,#+0
   \   000000C0   0xD1F8             BNE.N    ??get_serial_commands_14
   1168                    if (strtol(apos + 1, NULL, 10) != checksum) {
   \   000000C2   0x220A             MOVS     R2,#+10
   \   000000C4   0x2100             MOVS     R1,#+0
   \   000000C6   0x1C40             ADDS     R0,R0,#+1
   \   000000C8   0x.... 0x....      BL       strtol
   \   000000CC   0xB2FF             UXTB     R7,R7
   \   000000CE   0x42B8             CMP      R0,R7
   \   000000D0   0xD005             BEQ.N    ??get_serial_commands_15
   1169                      gcode_line_error(PSTR(MSG_ERR_CHECKSUM_MISMATCH));
   \   000000D2   0x2101             MOVS     R1,#+1
   \   000000D4   0x4846             LDR.N    R0,??get_serial_commands_0+0x14
   \   000000D6   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   000000DA   0x.... 0x....      B.W      _Z16gcode_line_errorPKcb
   1170                      return;
   1171                    }
   1172                  }
   1173                  else {
   1174                    gcode_line_error(PSTR(MSG_ERR_NO_CHECKSUM));
   1175                    return;
   1176                  }
   1177          
   1178                  gcode_LastN = gcode_N;
   \                     ??get_serial_commands_15: (+1)
   \   000000DE   0x6EE0             LDR      R0,[R4, #+108]
   \   000000E0   0x6720             STR      R0,[R4, #+112]
   1179                }
   1180          
   1181                // Movement commands alert when stopped
   1182                if (IsStopped()) {
   \                     ??get_serial_commands_7: (+1)
   \   000000E2   0x.... 0x....      BL       _Z9IsStoppedv
   \   000000E6   0x2800             CMP      R0,#+0
   \   000000E8   0xD013             BEQ.N    ??get_serial_commands_16
   1183                  char* gpos = strchr(command, 'G');
   \   000000EA   0x2147             MOVS     R1,#+71
   \   000000EC   0x4630             MOV      R0,R6
   \   000000EE   0x.... 0x....      BL       _Z6strchrPci
   1184                  if (gpos) {
   \   000000F2   0x2800             CMP      R0,#+0
   \   000000F4   0xD00D             BEQ.N    ??get_serial_commands_16
   1185                    const int codenum = strtol(gpos + 1, NULL, 10);
   1186                    switch (codenum) {
   \   000000F6   0x220A             MOVS     R2,#+10
   \   000000F8   0x2100             MOVS     R1,#+0
   \   000000FA   0x1C40             ADDS     R0,R0,#+1
   \   000000FC   0x.... 0x....      BL       strtol
   \   00000100   0x2803             CMP      R0,#+3
   \   00000102   0xD806             BHI.N    ??get_serial_commands_16
   1187                      case 0:
   1188                      case 1:
   1189                      case 2:
   1190                      case 3:
   1191                        SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
   \   00000104   0x483B             LDR.N    R0,??get_serial_commands_0+0x18
   \   00000106   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1192                        LCD_MESSAGEPGM(MSG_STOPPED);
   \   0000010A   0x2100             MOVS     R1,#+0
   \   0000010C   0x483A             LDR.N    R0,??get_serial_commands_0+0x1C
   \   0000010E   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   1193                        break;
   1194                    }
   1195                  }
   1196                }
   1197          
   1198                #if DISABLED(EMERGENCY_PARSER)
   1199                  // If command was e-stop process now
   1200                  if (strcmp(command, "M108") == 0) {
   \                     ??get_serial_commands_16: (+1)
   \   00000112   0x493A             LDR.N    R1,??get_serial_commands_0+0x20
   \   00000114   0x4630             MOV      R0,R6
   \   00000116   0x.... 0x....      BL       strcmp
   \   0000011A   0x2800             CMP      R0,#+0
   \   0000011C   0xD101             BNE.N    ??get_serial_commands_17
   1201                    wait_for_heatup = false;
   \   0000011E   0x2000             MOVS     R0,#+0
   \   00000120   0x7560             STRB     R0,[R4, #+21]
   1202                    #if ENABLED(ULTIPANEL)
   1203                      wait_for_user = false;
   1204                    #endif
   1205                  }
   1206                  if (strcmp(command, "M112") == 0) kill(PSTR(MSG_KILLED));
   \                     ??get_serial_commands_17: (+1)
   \   00000122   0x4937             LDR.N    R1,??get_serial_commands_0+0x24
   \   00000124   0x4630             MOV      R0,R6
   \   00000126   0x.... 0x....      BL       strcmp
   \   0000012A   0x2800             CMP      R0,#+0
   \   0000012C   0xD102             BNE.N    ??get_serial_commands_18
   \   0000012E   0x4835             LDR.N    R0,??get_serial_commands_0+0x28
   \   00000130   0x.... 0x....      BL       _Z4killPKc
   1207                  if (strcmp(command, "M410") == 0) { quickstop_stepper(); }
   \                     ??get_serial_commands_18: (+1)
   \   00000134   0x4934             LDR.N    R1,??get_serial_commands_0+0x2C
   \   00000136   0x4630             MOV      R0,R6
   \   00000138   0x.... 0x....      BL       strcmp
   \   0000013C   0x2800             CMP      R0,#+0
   \   0000013E   0xD101             BNE.N    ??get_serial_commands_19
   \   00000140   0x.... 0x....      BL       _Z17quickstop_stepperv
   1208                #endif
   1209          
   1210                #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
   1211                  last_command_time = ms;
   1212                #endif
   1213          
   1214                // Add the command to the queue
   1215                _enqueuecommand(serial_line_buffer, true);
   \                     ??get_serial_commands_19: (+1)
   \   00000144   0x2101             MOVS     R1,#+1
   \   00000146   0x4628             MOV      R0,R5
   \   00000148   0x.... 0x....      BL       _Z15_enqueuecommandPKcb
   \                     ??get_serial_commands_1: (+1)
   \   0000014C   0x7C20             LDRB     R0,[R4, #+16]
   \   0000014E   0x2804             CMP      R0,#+4
   \   00000150   0xDA41             BGE.N    ??get_serial_commands_20
   \   00000152   0x4D23             LDR.N    R5,??get_serial_commands_0+0x4
   \   00000154   0x4628             MOV      R0,R5
   \   00000156   0x.... 0x....      BL       _ZN10USARTClass4readEv
   \   0000015A   0x2800             CMP      R0,#+0
   \   0000015C   0xD43B             BMI.N    ??get_serial_commands_20
   \   0000015E   0xB240             SXTB     R0,R0
   \   00000160   0x2100             MOVS     R1,#+0
   \   00000162   0x75E1             STRB     R1,[R4, #+23]
   \   00000164   0x7621             STRB     R1,[R4, #+24]
   \   00000166   0x280A             CMP      R0,#+10
   \   00000168   0xD001             BEQ.N    ??get_serial_commands_21
   \   0000016A   0x280D             CMP      R0,#+13
   \   0000016C   0xD111             BNE.N    ??get_serial_commands_22
   \                     ??get_serial_commands_21: (+1)
   \   0000016E   0x4608             MOV      R0,R1
   \   00000170   0x4926             LDR.N    R1,??get_serial_commands_0+0x30
   \   00000172   0x7008             STRB     R0,[R1, #+0]
   \   00000174   0x4E26             LDR.N    R6,??get_serial_commands_0+0x34
   \   00000176   0x6831             LDR      R1,[R6, #+0]
   \   00000178   0x2900             CMP      R1,#+0
   \   0000017A   0xD0E7             BEQ.N    ??get_serial_commands_1
   \   0000017C   0x4D25             LDR.N    R5,??get_serial_commands_0+0x38
   \   0000017E   0x5548             STRB     R0,[R1, R5]
   \   00000180   0x6030             STR      R0,[R6, #+0]
   \   00000182   0x462E             MOV      R6,R5
   \   00000184   0xE75B             B.N      ??get_serial_commands_4
   \                     ??get_serial_commands_12: (+1)
   \   00000186   0x2101             MOVS     R1,#+1
   \   00000188   0x4823             LDR.N    R0,??get_serial_commands_0+0x3C
   \   0000018A   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   0000018E   0x.... 0x....      B.W      _Z16gcode_line_errorPKcb
   1216              }
   1217              else if (serial_count >= MAX_CMD_SIZE - 1) {
   \                     ??get_serial_commands_22: (+1)
   \   00000192   0x4E1F             LDR.N    R6,??get_serial_commands_0+0x34
   \   00000194   0x6831             LDR      R1,[R6, #+0]
   \   00000196   0x295F             CMP      R1,#+95
   \   00000198   0xDAD8             BGE.N    ??get_serial_commands_1
   1218                // Keep fetching, but ignore normal characters beyond the max length
   1219                // The command will be injected when EOL is reached
   1220              }
   1221              else if (serial_char == '\\') {  // Handle escapes
   \   0000019A   0x285C             CMP      R0,#+92
   \   0000019C   0xD10E             BNE.N    ??get_serial_commands_23
   1222                if ((c = MYSERIAL.read()) >= 0) {
   \   0000019E   0x4628             MOV      R0,R5
   \   000001A0   0x.... 0x....      BL       _ZN10USARTClass4readEv
   \   000001A4   0x2800             CMP      R0,#+0
   \   000001A6   0xD4D1             BMI.N    ??get_serial_commands_1
   1223                  // if we have one more character, copy it over
   1224                  serial_char = c;
   1225                  if (!serial_comment_mode) serial_line_buffer[serial_count++] = serial_char;
   \   000001A8   0x4918             LDR.N    R1,??get_serial_commands_0+0x30
   \   000001AA   0x7809             LDRB     R1,[R1, #+0]
   \   000001AC   0x2900             CMP      R1,#+0
   \   000001AE   0xD1CD             BNE.N    ??get_serial_commands_1
   \   000001B0   0x6831             LDR      R1,[R6, #+0]
   \   000001B2   0x4A18             LDR.N    R2,??get_serial_commands_0+0x38
   \   000001B4   0x5488             STRB     R0,[R1, R2]
   \   000001B6   0x1C48             ADDS     R0,R1,#+1
   \   000001B8   0x6030             STR      R0,[R6, #+0]
   \   000001BA   0xE7C7             B.N      ??get_serial_commands_1
   1226                }
   1227                // otherwise do nothing
   1228              }
   1229              else { // it's not a newline, carriage return or escape char
   1230                if (serial_char == ';') serial_comment_mode = true;
   \                     ??get_serial_commands_23: (+1)
   \   000001BC   0x4A13             LDR.N    R2,??get_serial_commands_0+0x30
   \   000001BE   0x283B             CMP      R0,#+59
   \   000001C0   0xD101             BNE.N    ??get_serial_commands_24
   \   000001C2   0x2301             MOVS     R3,#+1
   \   000001C4   0x7013             STRB     R3,[R2, #+0]
   1231                if (!serial_comment_mode) serial_line_buffer[serial_count++] = serial_char;
   \                     ??get_serial_commands_24: (+1)
   \   000001C6   0x7812             LDRB     R2,[R2, #+0]
   \   000001C8   0x2A00             CMP      R2,#+0
   \   000001CA   0xD1BF             BNE.N    ??get_serial_commands_1
   \   000001CC   0x4A11             LDR.N    R2,??get_serial_commands_0+0x38
   \   000001CE   0x5488             STRB     R0,[R1, R2]
   \   000001D0   0x1C48             ADDS     R0,R1,#+1
   \   000001D2   0x6030             STR      R0,[R6, #+0]
   \   000001D4   0xE7BA             B.N      ??get_serial_commands_1
   1232              }
   1233          
   1234            } // queue has space, serial has data
   1235          }
   \                     ??get_serial_commands_20: (+1)
   \   000001D6   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   \   000001DA   0xBF00             Nop      
   \                     ??get_serial_commands_0:
   \   000001DC   0x........         DC32     axis_relative_modes
   \   000001E0   0x........         DC32     Serial6
   \   000001E4   0x........         DC32     _ZZ19get_serial_commandsvE14last_wait_time
   \   000001E8   0x........         DC32     _ZZ19get_serial_commandsvEs
   \   000001EC   0x........         DC32     _ZZ19get_serial_commandsvEs_0
   \   000001F0   0x........         DC32     _ZZ19get_serial_commandsvEs_1
   \   000001F4   0x........         DC32     _ZZ19get_serial_commandsvEs_3
   \   000001F8   0x........         DC32     _ZZ19get_serial_commandsvEs_4
   \   000001FC   0x........         DC32     _ZZ19get_serial_commandsvEs_5
   \   00000200   0x........         DC32     _ZZ19get_serial_commandsvEs_6
   \   00000204   0x........         DC32     _ZZ19get_serial_commandsvEs_7
   \   00000208   0x........         DC32     _ZZ19get_serial_commandsvEs_8
   \   0000020C   0x........         DC32     _ZZ19get_serial_commandsvE19serial_comment_mode
   \   00000210   0x........         DC32     serial_count
   \   00000214   0x........         DC32     _ZZ19get_serial_commandsvE18serial_line_buffer
   \   00000218   0x........         DC32     _ZZ19get_serial_commandsvEs_2
   1236          
   1237          #if ENABLED(SDSUPPORT)
   1238          
   1239            /**
   1240             * Get commands from the SD Card until the command buffer is full
   1241             * or until the end of the file is reached. The special character '#'
   1242             * can also interrupt buffering.
   1243             */
   1244            inline void get_sdcard_commands() {
   1245              static bool stop_buffering = false,
   1246                          sd_comment_mode = false;
   1247          
   1248              if (!card.sdprinting) return;
   1249          
   1250              /**
   1251               * '#' stops reading from SD to the buffer prematurely, so procedural
   1252               * macro calls are possible. If it occurs, stop_buffering is triggered
   1253               * and the buffer is run dry; this character _can_ occur in serial com
   1254               * due to checksums, however, no checksums are used in SD printing.
   1255               */
   1256          
   1257              if (commands_in_queue == 0) stop_buffering = false;
   1258          
   1259              uint16_t sd_count = 0;
   1260              bool card_eof = card.eof();
   1261              while (commands_in_queue < BUFSIZE && !card_eof && !stop_buffering) {
   1262                const int16_t n = card.get();
   1263                char sd_char = (char)n;
   1264                card_eof = card.eof();
   1265                if (card_eof || n == -1
   1266                    || sd_char == '\n' || sd_char == '\r'
   1267                    || ((sd_char == '#' || sd_char == ':') && !sd_comment_mode)
   1268                ) {
   1269                  if (card_eof) {
   1270                    gCfgItems.breakpoint_reprint_flg = 0;
   1271                    gCfgItems.breakpoint_z_pos = 0;
   1272          
   1273                    card.printingHasFinished();
   1274          
   1275                    if (card.sdprinting)
   1276                      sd_count = 0; // If a sub-file was printing, continue from call point
   1277                    else {
   1278                      SERIAL_PROTOCOLLNPGM(MSG_FILE_PRINTED);
   1279                      #if ENABLED(PRINTER_EVENT_LEDS)
   1280                        LCD_MESSAGEPGM(MSG_INFO_COMPLETED_PRINTS);
   1281                        leds.set_green();
   1282                        #if HAS_RESUME_CONTINUE
   1283                          enqueue_and_echo_commands_P(PSTR("M0")); // end of the queue!
   1284                        #else
   1285                          safe_delay(1000);
   1286                        #endif
   1287                        leds.set_off();
   1288                      #endif
   1289                      card.checkautostart(true);
   1290          			
   1291          			#if 1
   1292          			
   1293          			
   1294          			//¡ä¨°¨ª¨º1??¨²?¡ê
   1295          			if((gCfgItems.print_finish_close_machine_flg == 1)&&(IsChooseAutoShutdown==1))
   1296          			    Close_machine_display();
   1297          
   1298                      #endif 				
   1299                    }
   1300                  }
   1301                  else if (n == -1) {
   1302                    SERIAL_ERROR_START();
   1303                    SERIAL_ECHOLNPGM(MSG_SD_ERR_READ);
   1304                  }
   1305                  if (sd_char == '#') stop_buffering = true;
   1306          
   1307                  sd_comment_mode = false; // for new command
   1308          
   1309                  if (!sd_count) continue; // skip empty lines (and comment lines)
   1310          
   1311                  command_queue[cmd_queue_index_w][sd_count] = '\0'; // terminate string
   1312                  sd_count = 0; // clear sd line buffer
   1313          
   1314                  _commit_command(false);
   1315                }
   1316                else if (sd_count >= MAX_CMD_SIZE - 1) {
   1317                  /**
   1318                   * Keep fetching, but ignore normal characters beyond the max length
   1319                   * The command will be injected when EOL is reached
   1320                   */
   1321                }
   1322                else {
   1323                  if (sd_char == ';') sd_comment_mode = true;
   1324                  //if (!sd_comment_mode) command_queue[cmd_queue_index_w][sd_count++] = sd_char;
   1325                  if (!sd_comment_mode) 
   1326                  {
   1327          			command_queue[cmd_queue_index_w][sd_count++] = sd_char;
   1328          #if 0	//mks dlp			
   1329          			if(sd_char == 0x5a ) //"Z"
   1330          			{
   1331          				mksReprint.sdpos = card.getsdpos()-3;	//"¡¤?2?????"
   1332          				#if 1
   1333          				mksReprint.sdpos_bak = mksReprint.sdpos;//sdpos_bak¦Ì?¨¨Y??¦Ì?¡ê????¡ä¨º1¨®?
   1334          				if(gCfgItems.pwroff_save_mode != 1)//sd?¡§¡À¡ê¡ä???¦Ì?¨ºy?Y
   1335                          #endif
   1336          					mksReprint.refresh = true;
   1337          			}
   1338          #endif			
   1339                  }        
   1340                }
   1341              }
   1342            }
   1343          
   1344          #endif // SDSUPPORT
   1345          #if 1

   \                                 In section .text, align 4
   1346          inline void get_wifi_commands() {
   \                     _Z17get_wifi_commandsv: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1347            static char wifi_line_buffer[MAX_CMD_SIZE];
   1348            static bool wifi_comment_mode = false;
   1349          
   1350            if(serial_wait_tick > 5)
   \   00000002   0x4C3B             LDR.N    R4,??get_wifi_commands_0
   \   00000004   0x7DE0             LDRB     R0,[R4, #+23]
   \   00000006   0x2806             CMP      R0,#+6
   \   00000008   0xDB6F             BLT.N    ??get_wifi_commands_1
   1351            {
   1352            	from_wifi_flag = 1;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x7620             STRB     R0,[R4, #+24]
   \   0000000E   0xE039             B.N      ??get_wifi_commands_2
   1353          
   1354          /**
   1355          	   * Loop while serial characters are incoming and the queue is not full
   1356          	   */
   1357          	  while ((commands_in_queue < BUFSIZE) && (espGcodeFifo.r != espGcodeFifo.w)) {
   1358          
   1359          	    char wifi_char = espGcodeFifo.Buffer[espGcodeFifo.r];
   1360          
   1361          	    espGcodeFifo.r = (espGcodeFifo.r + 1) % WIFI_GCODE_BUFFER_SIZE;
   1362          
   1363          	    /**
   1364          	     * If the character ends the line
   1365          	     */
   1366          	    if (wifi_char == '\n' || wifi_char == '\r') {
   1367          
   1368          	      wifi_comment_mode = false; // end of line == end of comment
   1369          
   1370          	      if (!wifi_read_count) continue; // skip empty lines
   1371          
   1372          	      wifi_line_buffer[wifi_read_count] = 0; // terminate string
   1373          	      wifi_read_count = 0; //reset buffer
   1374          
   1375          	      char* command = wifi_line_buffer;
   1376          
   1377          	      while (*command == ' ') command++; // skip any leading spaces	    
   \                     ??get_wifi_commands_3: (+1)
   \   00000010   0x1C76             ADDS     R6,R6,#+1
   \                     ??get_wifi_commands_4: (+1)
   \   00000012   0xF996 0x0000      LDRSB    R0,[R6, #+0]
   \   00000016   0x2820             CMP      R0,#+32
   \   00000018   0xD0FA             BEQ.N    ??get_wifi_commands_3
   1378          
   1379          	      // Movement commands alert when stopped
   1380          	      if (IsStopped()) {
   \   0000001A   0x.... 0x....      BL       _Z9IsStoppedv
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD013             BEQ.N    ??get_wifi_commands_5
   1381          	        char* gpos = strchr(command, 'G');
   \   00000022   0x2147             MOVS     R1,#+71
   \   00000024   0x4630             MOV      R0,R6
   \   00000026   0x.... 0x....      BL       _Z6strchrPci
   1382          	        if (gpos) {
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD00D             BEQ.N    ??get_wifi_commands_5
   1383          	          const int codenum = strtol(gpos + 1, NULL, 10);
   1384          	          switch (codenum) {
   \   0000002E   0x220A             MOVS     R2,#+10
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x1C40             ADDS     R0,R0,#+1
   \   00000034   0x.... 0x....      BL       strtol
   \   00000038   0x2803             CMP      R0,#+3
   \   0000003A   0xD806             BHI.N    ??get_wifi_commands_5
   1385          	            case 0:
   1386          	            case 1:
   1387          	            case 2:
   1388          	            case 3:
   1389          	              SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
   \   0000003C   0x482D             LDR.N    R0,??get_wifi_commands_0+0x4
   \   0000003E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1390          	              LCD_MESSAGEPGM(MSG_STOPPED);
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0x482C             LDR.N    R0,??get_wifi_commands_0+0x8
   \   00000046   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   1391          	              break;
   1392          	          }
   1393          	        }
   1394          	      }
   1395          
   1396          	      #if DISABLED(EMERGENCY_PARSER)
   1397          	        // If command was e-stop process now
   1398          	        if (strcmp(command, "M108") == 0) {
   \                     ??get_wifi_commands_5: (+1)
   \   0000004A   0x492C             LDR.N    R1,??get_wifi_commands_0+0xC
   \   0000004C   0x4630             MOV      R0,R6
   \   0000004E   0x.... 0x....      BL       strcmp
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD101             BNE.N    ??get_wifi_commands_6
   1399          	          wait_for_heatup = false;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x7560             STRB     R0,[R4, #+21]
   1400          	          #if ENABLED(ULTIPANEL)
   1401          	            wait_for_user = false;
   1402          	          #endif
   1403          	        }
   1404          	        if (strcmp(command, "M112") == 0) kill(PSTR(MSG_KILLED));
   \                     ??get_wifi_commands_6: (+1)
   \   0000005A   0x4929             LDR.N    R1,??get_wifi_commands_0+0x10
   \   0000005C   0x4630             MOV      R0,R6
   \   0000005E   0x.... 0x....      BL       strcmp
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD102             BNE.N    ??get_wifi_commands_7
   \   00000066   0x4827             LDR.N    R0,??get_wifi_commands_0+0x14
   \   00000068   0x.... 0x....      BL       _Z4killPKc
   1405          	        if (strcmp(command, "M410") == 0) { quickstop_stepper(); }
   \                     ??get_wifi_commands_7: (+1)
   \   0000006C   0x4926             LDR.N    R1,??get_wifi_commands_0+0x18
   \   0000006E   0x4630             MOV      R0,R6
   \   00000070   0x.... 0x....      BL       strcmp
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD101             BNE.N    ??get_wifi_commands_8
   \   00000078   0x.... 0x....      BL       _Z17quickstop_stepperv
   1406          	      #endif
   1407          
   1408          	      #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
   1409          	        last_command_time = ms;
   1410          	      #endif
   1411          
   1412          	      // Add the command to the queue
   1413          	      _enqueuecommand(wifi_line_buffer, true);
   \                     ??get_wifi_commands_8: (+1)
   \   0000007C   0x2101             MOVS     R1,#+1
   \   0000007E   0x4628             MOV      R0,R5
   \   00000080   0x.... 0x....      BL       _Z15_enqueuecommandPKcb
   \                     ??get_wifi_commands_2: (+1)
   \   00000084   0x7C20             LDRB     R0,[R4, #+16]
   \   00000086   0x2804             CMP      R0,#+4
   \   00000088   0xDA31             BGE.N    ??get_wifi_commands_9
   \   0000008A   0x4920             LDR.N    R1,??get_wifi_commands_0+0x1C
   \   0000008C   0x6E0A             LDR      R2,[R1, #+96]
   \   0000008E   0x6E48             LDR      R0,[R1, #+100]
   \   00000090   0x4282             CMP      R2,R0
   \   00000092   0xD02C             BEQ.N    ??get_wifi_commands_9
   \   00000094   0x5650             LDRSB    R0,[R2, R1]
   \   00000096   0x1C52             ADDS     R2,R2,#+1
   \   00000098   0x2360             MOVS     R3,#+96
   \   0000009A   0xFBB2 0xF3F3      UDIV     R3,R2,R3
   \   0000009E   0xEB03 0x0543      ADD      R5,R3,R3, LSL #+1
   \   000000A2   0xEBA2 0x1245      SUB      R2,R2,R5, LSL #+5
   \   000000A6   0x660A             STR      R2,[R1, #+96]
   \   000000A8   0x280A             CMP      R0,#+10
   \   000000AA   0xD001             BEQ.N    ??get_wifi_commands_10
   \   000000AC   0x280D             CMP      R0,#+13
   \   000000AE   0xD10B             BNE.N    ??get_wifi_commands_11
   \                     ??get_wifi_commands_10: (+1)
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0x4917             LDR.N    R1,??get_wifi_commands_0+0x20
   \   000000B4   0x7008             STRB     R0,[R1, #+0]
   \   000000B6   0x4917             LDR.N    R1,??get_wifi_commands_0+0x24
   \   000000B8   0x680A             LDR      R2,[R1, #+0]
   \   000000BA   0x2A00             CMP      R2,#+0
   \   000000BC   0xD0E2             BEQ.N    ??get_wifi_commands_2
   \   000000BE   0x4D16             LDR.N    R5,??get_wifi_commands_0+0x28
   \   000000C0   0x5550             STRB     R0,[R2, R5]
   \   000000C2   0x6008             STR      R0,[R1, #+0]
   \   000000C4   0x462E             MOV      R6,R5
   \   000000C6   0xE7A4             B.N      ??get_wifi_commands_4
   1414          	    }
   1415          	    else if (wifi_read_count >= MAX_CMD_SIZE - 1) {
   \                     ??get_wifi_commands_11: (+1)
   \   000000C8   0x4912             LDR.N    R1,??get_wifi_commands_0+0x24
   \   000000CA   0x680A             LDR      R2,[R1, #+0]
   \   000000CC   0x2A5F             CMP      R2,#+95
   \   000000CE   0xDAD9             BGE.N    ??get_wifi_commands_2
   1416          	      // Keep fetching, but ignore normal characters beyond the max length
   1417          	      // The command will be injected when EOL is reached
   1418          	    }
   1419          		/*
   1420          	    else if (wifi_char == '\\') {  // Handle escapes
   1421          	      if (MYSERIAL.available() > 0) {
   1422          	        // if we have one more character, copy it over
   1423          	        wifi_char = MYSERIAL.read();
   1424          	        if (!serial_comment_mode) serial_line_buffer[serial_count++] = serial_char;
   1425          	      }
   1426          	      // otherwise do nothing
   1427          	    }*/
   1428          	    else { // it's not a newline, carriage return or escape char
   1429          	      if (wifi_char == ';') wifi_comment_mode = true;
   \   000000D0   0x4B0F             LDR.N    R3,??get_wifi_commands_0+0x20
   \   000000D2   0x283B             CMP      R0,#+59
   \   000000D4   0xD101             BNE.N    ??get_wifi_commands_12
   \   000000D6   0x2501             MOVS     R5,#+1
   \   000000D8   0x701D             STRB     R5,[R3, #+0]
   1430          	      if (!wifi_comment_mode) wifi_line_buffer[wifi_read_count++] = wifi_char;
   \                     ??get_wifi_commands_12: (+1)
   \   000000DA   0x781B             LDRB     R3,[R3, #+0]
   \   000000DC   0x2B00             CMP      R3,#+0
   \   000000DE   0xD1D1             BNE.N    ??get_wifi_commands_2
   \   000000E0   0x4B0D             LDR.N    R3,??get_wifi_commands_0+0x28
   \   000000E2   0x54D0             STRB     R0,[R2, R3]
   \   000000E4   0x1C50             ADDS     R0,R2,#+1
   \   000000E6   0x6008             STR      R0,[R1, #+0]
   \   000000E8   0xE7CC             B.N      ??get_wifi_commands_2
   1431          	    }
   1432          
   1433          	  }
   1434              }// queue has space, serial has data
   1435              else
   1436              {
   1437              	from_wifi_flag = 0;
   \                     ??get_wifi_commands_1: (+1)
   \   000000EA   0x2000             MOVS     R0,#+0
   \   000000EC   0x7620             STRB     R0,[R4, #+24]
   1438              }
   1439          }
   \                     ??get_wifi_commands_9: (+1)
   \   000000EE   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??get_wifi_commands_0:
   \   000000F0   0x........         DC32     axis_relative_modes
   \   000000F4   0x........         DC32     _ZZ17get_wifi_commandsvEs
   \   000000F8   0x........         DC32     _ZZ17get_wifi_commandsvEs_0
   \   000000FC   0x........         DC32     _ZZ17get_wifi_commandsvEs_1
   \   00000100   0x........         DC32     _ZZ17get_wifi_commandsvEs_2
   \   00000104   0x........         DC32     _ZZ17get_wifi_commandsvEs_3
   \   00000108   0x........         DC32     _ZZ17get_wifi_commandsvEs_4
   \   0000010C   0x........         DC32     espGcodeFifo
   \   00000110   0x........         DC32     _ZZ17get_wifi_commandsvE17wifi_comment_mode
   \   00000114   0x........         DC32     wifi_read_count
   \   00000118   0x........         DC32     _ZZ17get_wifi_commandsvE16wifi_line_buffer
   1440          #endif
   1441          
   1442          /**
   1443           * Add to the circular command queue the next command from:
   1444           *  - The command-injection queue (injected_commands_P)
   1445           *  - The active serial input (usually USB)
   1446           *  - The SD card file being actively printed
   1447           */

   \                                 In section .text, align 2, keep-with-next
   1448          void get_available_commands() {
   \                     _Z22get_available_commandsv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1449          
   1450            // if any immediate commands remain, don't get other commands yet
   1451            if (drain_injected_commands_P()) return;
   \   00000002   0x.... 0x....      BL       _Z25drain_injected_commands_Pv
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD105             BNE.N    ??get_available_commands_0
   1452          
   1453            get_serial_commands();
   \   0000000A   0x.... 0x....      BL       _Z19get_serial_commandsv
   1454            
   1455          #if 1
   1456          	get_wifi_commands();
   \   0000000E   0xE8BD 0x4001      POP      {R0,LR}
   \   00000012   0x.... 0x....      B.W      _Z17get_wifi_commandsv
   \                     ??get_available_commands_0: (+1)
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
   1457          #endif
   1458          
   1459            #if ENABLED(SDSUPPORT) && DISABLED(MKS_DLP_BOARD)
   1460              get_sdcard_commands();
   1461            #endif
   1462          }
   1463          
   1464          /**
   1465           * Set target_extruder from the T parameter or the active_extruder
   1466           *
   1467           * Returns TRUE if the target is invalid
   1468           */

   \                                 In section .text, align 2, keep-with-next
   1469          bool get_target_extruder_from_command(const uint16_t code) {
   \                     _Z32get_target_extruder_from_commandt: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   1470            if (parser.seenval('T')) {
   \   00000004   0x2054             MOVS     R0,#+84
   \   00000006   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD023             BEQ.N    ??get_target_extruder_from_command_0
   1471              const int8_t e = parser.value_byte();
   \   0000000E   0x.... 0x....      BL       _ZN11GCodeParser10value_byteEv
   \   00000012   0x4605             MOV      R5,R0
   \   00000014   0xB26D             SXTB     R5,R5
   1472              if (e >= EXTRUDERS) {
   \   00000016   0x2D01             CMP      R5,#+1
   \   00000018   0xDB19             BLT.N    ??get_target_extruder_from_command_1
   1473                SERIAL_ECHO_START();
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable107_2
   \   0000001E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1474                SERIAL_CHAR('M');
   \   00000022   0x.... 0x....      LDR.W    R6,??DataTable109
   \   00000026   0x214D             MOVS     R1,#+77
   \   00000028   0x4630             MOV      R0,R6
   \   0000002A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   1475                SERIAL_ECHO(code);
   \   0000002E   0x220A             MOVS     R2,#+10
   \   00000030   0x4621             MOV      R1,R4
   \   00000032   0x4630             MOV      R0,R6
   \   00000034   0x.... 0x....      BL       _ZN5Print5printEii
   1476                SERIAL_ECHOLNPAIR(" " MSG_INVALID_EXTRUDER " ", e);
   \   00000038   0x4629             MOV      R1,R5
   \   0000003A   0x.... 0x....      ADR.W    R0,`?<Constant " Invalid extruder ">`
   \   0000003E   0x.... 0x....      BL       _Z17serial_echopair_PPKci
   \   00000042   0x210A             MOVS     R1,#+10
   \   00000044   0x4630             MOV      R0,R6
   \   00000046   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   1477                return true;
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0xBD70             POP      {R4-R6,PC}
   1478              }
   1479              target_extruder = e;
   \                     ??get_target_extruder_from_command_1: (+1)
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable111_1
   \   00000052   0x7585             STRB     R5,[R0, #+22]
   \   00000054   0xE003             B.N      ??get_target_extruder_from_command_2
   1480            }
   1481            else
   1482              target_extruder = active_extruder;
   \                     ??get_target_extruder_from_command_0: (+1)
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable111_1
   \   0000005A   0x7CC1             LDRB     R1,[R0, #+19]
   \   0000005C   0x7581             STRB     R1,[R0, #+22]
   1483          
   1484            return false;
   \                     ??get_target_extruder_from_command_2: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xBD70             POP      {R4-R6,PC}       ;; return
   1485          }
   1486          
   1487          #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
   1488            bool extruder_duplication_enabled = false; // Used in Dual X mode 2
   1489          #endif
   1490          
   1491          #if ENABLED(DUAL_X_CARRIAGE)
   1492          
   1493            static DualXMode dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
   1494          
   1495            static float x_home_pos(const int extruder) {
   1496              if (extruder == 0)
   1497                return base_home_pos(X_AXIS);
   1498              else
   1499                /**
   1500                 * In dual carriage mode the extruder offset provides an override of the
   1501                 * second X-carriage position when homed - otherwise X2_HOME_POS is used.
   1502                 * This allows soft recalibration of the second extruder home position
   1503                 * without firmware reflash (through the M218 command).
   1504                 */
   1505                return hotend_offset[X_AXIS][1] > 0 ? hotend_offset[X_AXIS][1] : X2_HOME_POS;
   1506            }
   1507          
   1508            static int x_home_dir(const int extruder) { return extruder ? X2_HOME_DIR : X_HOME_DIR; }
   1509          
   1510            static float inactive_extruder_x_pos = X2_MAX_POS; // used in mode 0 & 1
   1511            static bool active_extruder_parked = false;        // used in mode 1 & 2
   1512            static float raised_parked_position[XYZE];         // used in mode 1
   1513            static millis_t delayed_move_time = 0;             // used in mode 1
   1514            static float duplicate_extruder_x_offset = DEFAULT_DUPLICATION_X_OFFSET; // used in mode 2
   1515            static int16_t duplicate_extruder_temp_offset = 0; // used in mode 2
   1516          
   1517          #endif // DUAL_X_CARRIAGE
   1518          
   1519          #if HAS_WORKSPACE_OFFSET || ENABLED(DUAL_X_CARRIAGE)
   1520          
   1521            /**
   1522             * Software endstops can be used to monitor the open end of
   1523             * an axis that has a hardware endstop on the other end. Or
   1524             * they can prevent axes from moving past endstops and grinding.
   1525             *
   1526             * To keep doing their job as the coordinate system changes,
   1527             * the software endstop positions must be refreshed to remain
   1528             * at the same positions relative to the machine.
   1529             */

   \                                 In section .text, align 2, keep-with-next
   1530            void update_software_endstops(const AxisEnum axis) {
   \                     _Z24update_software_endstops8AxisEnum: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1531              #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
   1532                workspace_offset[axis] = home_offset[axis] + position_shift[axis];
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable104_9
   \   00000008   0xEB00 0x0584      ADD      R5,R0,R4, LSL #+2
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable111_1
   \   00000010   0xEB00 0x0084      ADD      R0,R0,R4, LSL #+2
   \   00000014   0xED90 0x0A15      VLDR     S0,[R0, #+84]
   \   00000018   0xEDD0 0x0A20      VLDR     S1,[R0, #+128]
   \   0000001C   0xEE30 0x0A20      VADD.F32 S0,S0,S1
   \   00000020   0xED85 0x0A01      VSTR     S0,[R5, #+4]
   1533              #endif
   1534          
   1535              #if ENABLED(DUAL_X_CARRIAGE)
   1536                if (axis == X_AXIS) {
   1537          
   1538                  // In Dual X mode hotend_offset[X] is T1's home position
   1539                  float dual_max_x = max(hotend_offset[X_AXIS][1], X2_MAX_POS);
   1540          
   1541                  if (active_extruder != 0) {
   1542                    // T1 can move from X2_MIN_POS to X2_MAX_POS or X2 home position (whichever is larger)
   1543                    soft_endstop_min[X_AXIS] = X2_MIN_POS;
   1544                    soft_endstop_max[X_AXIS] = dual_max_x;
   1545                  }
   1546                  else if (dual_x_carriage_mode == DXC_DUPLICATION_MODE) {
   1547                    // In Duplication Mode, T0 can move as far left as X_MIN_POS
   1548                    // but not so far to the right that T1 would move past the end
   1549                    soft_endstop_min[X_AXIS] = base_min_pos(X_AXIS);
   1550                    soft_endstop_max[X_AXIS] = min(base_max_pos(X_AXIS), dual_max_x - duplicate_extruder_x_offset);
   1551                  }
   1552                  else {
   1553                    // In other modes, T0 can move from X_MIN_POS to X_MAX_POS
   1554                    soft_endstop_min[axis] = base_min_pos(axis);
   1555                    soft_endstop_max[axis] = base_max_pos(axis);
   1556                  }
   1557                }
   1558              #elif ENABLED(DELTA)
   1559                soft_endstop_min[axis] = base_min_pos(axis);
   1560                soft_endstop_max[axis] = axis == Z_AXIS ? delta_height : base_max_pos(axis);
   1561              #else
   1562                soft_endstop_min[axis] = base_min_pos(axis);
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       _Z12base_min_pos8AxisEnum
   \   0000002A   0xED85 0x0A04      VSTR     S0,[R5, #+16]
   1563                soft_endstop_max[axis] = base_max_pos(axis);
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       _Z12base_max_pos8AxisEnum
   \   00000034   0xED85 0x0A07      VSTR     S0,[R5, #+28]
   1564              #endif
   1565          
   1566              #if ENABLED(DEBUG_LEVELING_FEATURE)
   1567                if (DEBUGGING(LEVELING)) {
   1568                  SERIAL_ECHOPAIR("For ", axis_codes[axis]);
   1569                  #if HAS_HOME_OFFSET
   1570                    SERIAL_ECHOPAIR(" axis:\n home_offset = ", home_offset[axis]);
   1571                  #endif
   1572                  #if HAS_POSITION_SHIFT
   1573                    SERIAL_ECHOPAIR("\n position_shift = ", position_shift[axis]);
   1574                  #endif
   1575                  SERIAL_ECHOPAIR("\n soft_endstop_min = ", soft_endstop_min[axis]);
   1576                  SERIAL_ECHOLNPAIR("\n soft_endstop_max = ", soft_endstop_max[axis]);
   1577                }
   1578              #endif
   1579          
   1580              #if ENABLED(DELTA)
   1581                switch(axis) {
   1582                  case X_AXIS:
   1583                  case Y_AXIS:
   1584                    // Get a minimum radius for clamping
   1585                    soft_endstop_radius = MIN3(FABS(max(soft_endstop_min[X_AXIS], soft_endstop_min[Y_AXIS])), soft_endstop_max[X_AXIS], soft_endstop_max[Y_AXIS]);
   1586                    soft_endstop_radius_2 = sq(soft_endstop_radius);
   1587                    break;
   1588                  case Z_AXIS:
   1589                    delta_clip_start_height = soft_endstop_max[axis] - delta_safe_distance_from_top();
   1590                  default: break;
   1591                }
   1592              #endif
   1593            }
   \   00000038   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1594          
   1595          #endif // HAS_WORKSPACE_OFFSET || DUAL_X_CARRIAGE
   1596          
   1597          #if HAS_M206_COMMAND
   1598            /**
   1599             * Change the home offset for an axis, update the current
   1600             * position and the software endstops to retain the same
   1601             * relative distance to the new home.
   1602             *
   1603             * Since this changes the current_position, code should
   1604             * call sync_plan_position soon after this.
   1605             */

   \                                 In section .text, align 2, keep-with-next
   1606            static void set_home_offset(const AxisEnum axis, const float v) {
   1607              home_offset[axis] = v;
   \                     _Z15set_home_offset8AxisEnumf: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable111_1
   \   00000004   0xEB01 0x0180      ADD      R1,R1,R0, LSL #+2
   \   00000008   0xED81 0x0A15      VSTR     S0,[R1, #+84]
   1608              update_software_endstops(axis);
   \   0000000C   0x....             B.N      _Z24update_software_endstops8AxisEnum
   1609            }
   1610          #endif // HAS_M206_COMMAND
   1611          
   1612          /**
   1613           * Set an axis' current position to its home position (after homing).
   1614           *
   1615           * For Core and Cartesian robots this applies one-to-one when an
   1616           * individual axis has been homed.
   1617           *
   1618           * DELTA should wait until all homing is done before setting the XYZ
   1619           * current_position to home, because homing is a single operation.
   1620           * In the case where the axis positions are already known and previously
   1621           * homed, DELTA could home to X or Y individually by moving either one
   1622           * to the center. However, homing Z always homes XY and Z.
   1623           *
   1624           * SCARA should wait until all XY homing is done before setting the XY
   1625           * current_position to home, because neither X nor Y is at home until
   1626           * both are at home. Z can however be homed individually.
   1627           *
   1628           * Callers must sync the planner position after calling this!
   1629           */

   \                                 In section .text, align 2, keep-with-next
   1630          static void set_axis_is_at_home(const AxisEnum axis) {
   \                     _Z19set_axis_is_at_home8AxisEnum: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   1631            #if ENABLED(DEBUG_LEVELING_FEATURE)
   1632              if (DEBUGGING(LEVELING)) {
   1633                SERIAL_ECHOPAIR(">>> set_axis_is_at_home(", axis_codes[axis]);
   1634                SERIAL_CHAR(')');
   1635                SERIAL_EOL();
   1636              }
   1637            #endif
   1638          
   1639            axis_known_position[axis] = axis_homed[axis] = true;
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable107
   \   00000008   0x1960             ADDS     R0,R4,R5
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x7101             STRB     R1,[R0, #+4]
   \   0000000E   0x7201             STRB     R1,[R0, #+8]
   1640          
   1641            #if HAS_POSITION_SHIFT
   1642              position_shift[axis] = 0;
   \   00000010   0xEB05 0x0684      ADD      R6,R5,R4, LSL #+2
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF8C6 0x0080      STR      R0,[R6, #+128]
   1643              update_software_endstops(axis);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       _Z24update_software_endstops8AxisEnum
   1644            #endif
   1645          
   1646            #if ENABLED(DUAL_X_CARRIAGE)
   1647              if (axis == X_AXIS && (active_extruder == 1 || dual_x_carriage_mode == DXC_DUPLICATION_MODE)) {
   1648                current_position[X_AXIS] = x_home_pos(active_extruder);
   1649                return;
   1650              }
   1651            #endif
   1652          
   1653            #if ENABLED(MORGAN_SCARA)
   1654          
   1655              /**
   1656               * Morgan SCARA homes XY at the same time
   1657               */
   1658              if (axis == X_AXIS || axis == Y_AXIS) {
   1659          
   1660                float homeposition[XYZ] = {
   1661                  base_home_pos(X_AXIS),
   1662                  base_home_pos(Y_AXIS),
   1663                  base_home_pos(Z_AXIS)
   1664                };
   1665          
   1666                // SERIAL_ECHOPAIR("homeposition X:", homeposition[X_AXIS]);
   1667                // SERIAL_ECHOLNPAIR(" Y:", homeposition[Y_AXIS]);
   1668          
   1669                /**
   1670                 * Get Home position SCARA arm angles using inverse kinematics,
   1671                 * and calculate homing offset using forward kinematics
   1672                 */
   1673                inverse_kinematics(homeposition);
   1674                forward_kinematics_SCARA(delta[A_AXIS], delta[B_AXIS]);
   1675          
   1676                // SERIAL_ECHOPAIR("Cartesian X:", cartes[X_AXIS]);
   1677                // SERIAL_ECHOLNPAIR(" Y:", cartes[Y_AXIS]);
   1678          
   1679                current_position[axis] = cartes[axis];
   1680          
   1681                /**
   1682                 * SCARA home positions are based on configuration since the actual
   1683                 * limits are determined by the inverse kinematic transform.
   1684                 */
   1685                soft_endstop_min[axis] = base_min_pos(axis); // + (cartes[axis] - base_home_pos(axis));
   1686                soft_endstop_max[axis] = base_max_pos(axis); // + (cartes[axis] - base_home_pos(axis));
   1687              }
   1688              else
   1689            #elif ENABLED(DELTA)
   1690              if (axis == Z_AXIS)
   1691                current_position[axis] = delta_height;
   1692              else
   1693            #endif
   1694            {
   1695              current_position[axis] = base_home_pos(axis);
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       _Z13base_home_pos8AxisEnum
   \   00000026   0xED86 0x0A09      VSTR     S0,[R6, #+36]
   1696              current_position[C_AXIS] = home_offset[C_AXIS];   //mks_dlp 
   \   0000002A   0x6DE8             LDR      R0,[R5, #+92]
   \   0000002C   0x62E8             STR      R0,[R5, #+44]
   1697            }
   1698          
   1699            /**
   1700             * Z Probe Z Homing? Account for the probe's Z offset.
   1701             */
   1702            //#if HAS_BED_PROBE && Z_HOME_DIR < 0
   1703          #if 0
   1704              if (axis == Z_AXIS) {
   1705                #if HOMING_Z_WITH_PROBE
   1706          
   1707                  current_position[Z_AXIS] -= zprobe_zoffset;
   1708          
   1709                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   1710                    if (DEBUGGING(LEVELING)) {
   1711                      SERIAL_ECHOLNPGM("*** Z HOMED WITH PROBE (Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) ***");
   1712                      SERIAL_ECHOLNPAIR("> zprobe_zoffset = ", zprobe_zoffset);
   1713                    }
   1714                  #endif
   1715          
   1716                #elif ENABLED(DEBUG_LEVELING_FEATURE)
   1717          
   1718                  if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("*** Z HOMED TO ENDSTOP (Z_MIN_PROBE_ENDSTOP) ***");
   1719          
   1720                #endif
   1721              }
   1722            #endif
   1723          
   1724            #if ENABLED(DEBUG_LEVELING_FEATURE)
   1725              if (DEBUGGING(LEVELING)) {
   1726                #if HAS_HOME_OFFSET
   1727                  SERIAL_ECHOPAIR("> home_offset[", axis_codes[axis]);
   1728                  SERIAL_ECHOLNPAIR("] = ", home_offset[axis]);
   1729                #endif
   1730                DEBUG_POS("", current_position);
   1731                SERIAL_ECHOPAIR("<<< set_axis_is_at_home(", axis_codes[axis]);
   1732                SERIAL_CHAR(')');
   1733                SERIAL_EOL();
   1734              }
   1735            #endif
   1736          
   1737            #if ENABLED(I2C_POSITION_ENCODERS)
   1738              I2CPEM.homed(axis);
   1739            #endif
   1740          }
   \   0000002E   0xBD70             POP      {R4-R6,PC}       ;; return
   1741          
   1742          /**
   1743           * Some planner shorthand inline functions
   1744           */

   \                                 In section .text, align 4
   1745          inline float get_homing_bump_feedrate(const AxisEnum axis) {
   \                     _Z24get_homing_bump_feedrate8AxisEnum: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x4604             MOV      R4,R0
   1746            //static const uint8_t homing_bump_divisor[] PROGMEM = HOMING_BUMP_DIVISOR;
   1747          	int  homing_bump_divisor[4];
   1748          		homing_bump_divisor[0] = 2;
   \   00000006   0x2002             MOVS     R0,#+2
   \   00000008   0x9000             STR      R0,[SP, #+0]
   1749          		homing_bump_divisor[1] = 2;
   \   0000000A   0xA800             ADD      R0,SP,#+0
   \   0000000C   0x2102             MOVS     R1,#+2
   \   0000000E   0x6041             STR      R1,[R0, #+4]
   1750          		homing_bump_divisor[2] = 4;
   \   00000010   0x2104             MOVS     R1,#+4
   \   00000012   0x9102             STR      R1,[SP, #+8]
   1751            uint8_t hbd = pgm_read_byte(&homing_bump_divisor[axis]);
   \   00000014   0xF810 0x5024      LDRB     R5,[R0, R4, LSL #+2]
   1752            if (hbd < 1) {
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD106             BNE.N    ??get_homing_bump_feedrate_0
   1753              hbd = 10;
   \   0000001C   0x250A             MOVS     R5,#+10
   1754              SERIAL_ECHO_START();
   \   0000001E   0x4809             LDR.N    R0,??get_homing_bump_feedrate_1
   \   00000020   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1755              SERIAL_ECHOLNPGM("Warning: Homing Bump Divisor < 1");
   \   00000024   0x4808             LDR.N    R0,??get_homing_bump_feedrate_1+0x4
   \   00000026   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1756            }
   1757            //return homing_feedrate(axis) / hbd;
   1758            return homing_feedrate_mm_s[axis] / hbd;
   \                     ??get_homing_bump_feedrate_0: (+1)
   \   0000002A   0xEE00 0x5A10      VMOV     S0,R5
   \   0000002E   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   00000032   0x4806             LDR.N    R0,??get_homing_bump_feedrate_1+0x8
   \   00000034   0xEB00 0x0084      ADD      R0,R0,R4, LSL #+2
   \   00000038   0xEDD0 0x0A11      VLDR     S1,[R0, #+68]
   \   0000003C   0xEE80 0x0A80      VDIV.F32 S0,S1,S0
   \   00000040   0xB005             ADD      SP,SP,#+20
   \   00000042   0xBD30             POP      {R4,R5,PC}       ;; return
   \                     ??get_homing_bump_feedrate_1:
   \   00000044   0x........         DC32     echomagic
   \   00000048   0x........         DC32     _ZZ24get_homing_bump_feedrate8AxisEnumEs
   \   0000004C   0x........         DC32     axis_relative_modes
   1759          }
   1760          
   1761          /**
   1762           * Move the planner to the current position from wherever it last moved
   1763           * (or from wherever it has been told it is located).
   1764           */

   \                                 In section .text, align 4
   1765          inline void buffer_line_to_current_position() {
   1766            planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], feedrate_mm_s, active_extruder);
   \                     _Z31buffer_line_to_current_positionv: (+1)
   \   00000000   0x4B06             LDR.N    R3,??buffer_line_to_current_position_0
   \   00000002   0x7CDA             LDRB     R2,[R3, #+19]
   \   00000004   0xF103 0x0178      ADD      R1,R3,#+120
   \   00000008   0xF103 0x0030      ADD      R0,R3,#+48
   \   0000000C   0xED93 0x1A0B      VLDR     S2,[R3, #+44]
   \   00000010   0xEDD3 0x0A0A      VLDR     S1,[R3, #+40]
   \   00000014   0xED93 0x0A09      VLDR     S0,[R3, #+36]
   \   00000018   0x.... 0x....      B.W      _ZN7Planner11buffer_lineEfffRKfS1_h
   \                     ??buffer_line_to_current_position_0:
   \   0000001C   0x........         DC32     axis_relative_modes
   1767          }
   1768          
   1769          /**
   1770           * Move the planner to the position stored in the destination array, which is
   1771           * used by G0/G1/G2/G3/G5 and many other functions to set a destination.
   1772           */

   \                                 In section .text, align 4
   1773          inline void buffer_line_to_destination(const float fr_mm_s) {
   \                     _Z26buffer_line_to_destinationf: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xED2D 0x0A01      VPUSH    {S0}
   1774            planner.buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], fr_mm_s, active_extruder);
   \   00000006   0x4B07             LDR.N    R3,??buffer_line_to_destination_0
   \   00000008   0x7CDA             LDRB     R2,[R3, #+19]
   \   0000000A   0xA900             ADD      R1,SP,#+0
   \   0000000C   0xF103 0x0040      ADD      R0,R3,#+64
   \   00000010   0xED93 0x1A0F      VLDR     S2,[R3, #+60]
   \   00000014   0xEDD3 0x0A0E      VLDR     S1,[R3, #+56]
   \   00000018   0xED93 0x0A0D      VLDR     S0,[R3, #+52]
   \   0000001C   0x.... 0x....      BL       _ZN7Planner11buffer_lineEfffRKfS1_h
   1775          }
   \   00000020   0xBD01             POP      {R0,PC}          ;; return
   \   00000022   0xBF00             Nop      
   \                     ??buffer_line_to_destination_0:
   \   00000024   0x........         DC32     axis_relative_modes
   1776          
   1777          #if IS_KINEMATIC
   1778            /**
   1779             * Calculate delta, start a line, and set current_position to destination
   1780             */
   1781            void prepare_uninterpolated_move_to_destination(const float fr_mm_s=0.0) {
   1782              #if ENABLED(DEBUG_LEVELING_FEATURE)
   1783                if (DEBUGGING(LEVELING)) DEBUG_POS("prepare_uninterpolated_move_to_destination", destination);
   1784              #endif
   1785          
   1786              refresh_cmd_timeout();
   1787          
   1788              #if UBL_SEGMENTED
   1789                // ubl segmented line will do z-only moves in single segment
   1790                ubl.prepare_segmented_line_to(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s));
   1791              #else
   1792                if ( current_position[X_AXIS] == destination[X_AXIS]
   1793                  && current_position[Y_AXIS] == destination[Y_AXIS]
   1794                  && current_position[Z_AXIS] == destination[Z_AXIS]
   1795                  && current_position[E_AXIS] == destination[E_AXIS]
   1796                ) return;
   1797          
   1798                planner.buffer_line_kinematic(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s), active_extruder);
   1799              #endif
   1800          
   1801              set_current_from_destination();
   1802            }
   1803          #endif // IS_KINEMATIC
   1804          
   1805          /**
   1806           *  Plan a move to (X, Y, Z) and set the current_position
   1807           *  The final current_position may not be the one that was requested
   1808           */

   \                                 In section .text, align 2, keep-with-next
   1809          void do_blocking_move_to(const float &rx, const float &ry, const float &rz, const float &fr_mm_s/*=0.0*/) {
   \                     _Z19do_blocking_move_toRKfS0_S0_S0_: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xED2D 0x8B02      VPUSH    {D8}
   \   00000008   0x4606             MOV      R6,R0
   \   0000000A   0x460F             MOV      R7,R1
   \   0000000C   0x4614             MOV      R4,R2
   \   0000000E   0x4698             MOV      R8,R3
   1810            const float old_feedrate_mm_s = feedrate_mm_s;
   \   00000010   0x.... 0x....      LDR.W    R5,??DataTable107
   \   00000014   0xED95 0x8A1E      VLDR     S16,[R5, #+120]
   1811          
   1812            #if ENABLED(DEBUG_LEVELING_FEATURE)
   1813              if (DEBUGGING(LEVELING)) print_xyz(PSTR(">>> do_blocking_move_to"), NULL, LOGICAL_X_POSITION(rx), LOGICAL_Y_POSITION(ry), LOGICAL_Z_POSITION(rz));
   1814            #endif
   1815          
   1816            const float z_feedrate = fr_mm_s ? fr_mm_s : homing_feedrate_mm_s[Z_AXIS];
   \   00000018   0xEDD8 0x8A00      VLDR     S17,[R8, #0]
   \   0000001C   0xEEF5 0x8A40      VCMP.F32 S17,#0.0
   \   00000020   0xEEF1 0xFA10      FMSTAT   
   \   00000024   0xD101             BNE.N    ??do_blocking_move_to_0
   \   00000026   0xEDD5 0x8A13      VLDR     S17,[R5, #+76]
   1817          
   1818            #if ENABLED(DELTA)
   1819              if (!position_is_reachable(rx, ry)) return;
   1820          
   1821              feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
   1822          
   1823              set_destination_from_current();          // sync destination at the start
   1824          
   1825              #if ENABLED(DEBUG_LEVELING_FEATURE)
   1826                if (DEBUGGING(LEVELING)) DEBUG_POS("set_destination_from_current", destination);
   1827              #endif
   1828          
   1829              // when in the danger zone
   1830              if (current_position[Z_AXIS] > delta_clip_start_height) {
   1831                if (rz > delta_clip_start_height) {   // staying in the danger zone
   1832                  destination[X_AXIS] = rx;           // move directly (uninterpolated)
   1833                  destination[Y_AXIS] = ry;
   1834                  destination[Z_AXIS] = rz;
   1835                  prepare_uninterpolated_move_to_destination(); // set_current_from_destination
   1836                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   1837                    if (DEBUGGING(LEVELING)) DEBUG_POS("danger zone move", current_position);
   1838                  #endif
   1839                  return;
   1840                }
   1841                destination[Z_AXIS] = delta_clip_start_height;
   1842                prepare_uninterpolated_move_to_destination(); // set_current_from_destination
   1843                #if ENABLED(DEBUG_LEVELING_FEATURE)
   1844                  if (DEBUGGING(LEVELING)) DEBUG_POS("zone border move", current_position);
   1845                #endif
   1846              }
   1847          
   1848              if (rz > current_position[Z_AXIS]) {    // raising?
   1849                destination[Z_AXIS] = rz;
   1850                prepare_uninterpolated_move_to_destination(z_feedrate);   // set_current_from_destination
   1851                #if ENABLED(DEBUG_LEVELING_FEATURE)
   1852                  if (DEBUGGING(LEVELING)) DEBUG_POS("z raise move", current_position);
   1853                #endif
   1854              }
   1855          
   1856              destination[X_AXIS] = rx;
   1857              destination[Y_AXIS] = ry;
   1858              prepare_move_to_destination();         // set_current_from_destination
   1859              #if ENABLED(DEBUG_LEVELING_FEATURE)
   1860                if (DEBUGGING(LEVELING)) DEBUG_POS("xy move", current_position);
   1861              #endif
   1862          
   1863              if (rz < current_position[Z_AXIS]) {    // lowering?
   1864                destination[Z_AXIS] = rz;
   1865                prepare_uninterpolated_move_to_destination(z_feedrate);   // set_current_from_destination
   1866                #if ENABLED(DEBUG_LEVELING_FEATURE)
   1867                  if (DEBUGGING(LEVELING)) DEBUG_POS("z lower move", current_position);
   1868                #endif
   1869              }
   1870          
   1871            #elif IS_SCARA
   1872          
   1873              if (!position_is_reachable(rx, ry)) return;
   1874          
   1875              set_destination_from_current();
   1876          
   1877              // If Z needs to raise, do it before moving XY
   1878              if (destination[Z_AXIS] < rz) {
   1879                destination[Z_AXIS] = rz;
   1880                prepare_uninterpolated_move_to_destination(z_feedrate);
   1881              }
   1882          
   1883              destination[X_AXIS] = rx;
   1884              destination[Y_AXIS] = ry;
   1885              prepare_uninterpolated_move_to_destination(fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S);
   1886          
   1887              // If Z needs to lower, do it after moving XY
   1888              if (destination[Z_AXIS] > rz) {
   1889                destination[Z_AXIS] = rz;
   1890                prepare_uninterpolated_move_to_destination(z_feedrate);
   1891              }
   1892          
   1893            #else
   1894          
   1895              // If Z needs to raise, do it before moving XY
   1896              if (current_position[Z_AXIS] < rz) {
   \                     ??do_blocking_move_to_0: (+1)
   \   0000002A   0xED95 0x0A0B      VLDR     S0,[R5, #+44]
   \   0000002E   0xEDD4 0x0A00      VLDR     S1,[R4, #0]
   \   00000032   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000036   0xEEF1 0xFA10      FMSTAT   
   \   0000003A   0xD505             BPL.N    ??do_blocking_move_to_1
   1897                feedrate_mm_s = z_feedrate;
   \   0000003C   0xEDC5 0x8A1E      VSTR     S17,[R5, #+120]
   1898                current_position[Z_AXIS] = rz;
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0x62E8             STR      R0,[R5, #+44]
   1899                buffer_line_to_current_position();
   \   00000044   0x.... 0x....      BL       _Z31buffer_line_to_current_positionv
   1900              }
   1901          
   1902              feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
   \                     ??do_blocking_move_to_1: (+1)
   \   00000048   0xED98 0x0A00      VLDR     S0,[R8, #0]
   \   0000004C   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   00000050   0xEEF1 0xFA10      FMSTAT   
   \   00000054   0xD002             BEQ.N    ??do_blocking_move_to_2
   \   00000056   0xED85 0x0A1E      VSTR     S0,[R5, #+120]
   \   0000005A   0xE002             B.N      ??do_blocking_move_to_3
   \                     ??do_blocking_move_to_2: (+1)
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable111_2  ;; 0x43055555
   \   00000060   0x67A8             STR      R0,[R5, #+120]
   1903              current_position[X_AXIS] = rx;
   \                     ??do_blocking_move_to_3: (+1)
   \   00000062   0x6830             LDR      R0,[R6, #+0]
   \   00000064   0x6268             STR      R0,[R5, #+36]
   1904              current_position[Y_AXIS] = ry;
   \   00000066   0x6838             LDR      R0,[R7, #+0]
   \   00000068   0x62A8             STR      R0,[R5, #+40]
   1905              buffer_line_to_current_position();
   \   0000006A   0x.... 0x....      BL       _Z31buffer_line_to_current_positionv
   1906          
   1907              // If Z needs to lower, do it after moving XY
   1908              if (current_position[Z_AXIS] > rz) {
   \   0000006E   0xED94 0x0A00      VLDR     S0,[R4, #0]
   \   00000072   0xEDD5 0x0A0B      VLDR     S1,[R5, #+44]
   \   00000076   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   0000007A   0xEEF1 0xFA10      FMSTAT   
   \   0000007E   0xD505             BPL.N    ??do_blocking_move_to_4
   1909                feedrate_mm_s = z_feedrate;
   \   00000080   0xEDC5 0x8A1E      VSTR     S17,[R5, #+120]
   1910                current_position[Z_AXIS] = rz;
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x62E8             STR      R0,[R5, #+44]
   1911                buffer_line_to_current_position();
   \   00000088   0x.... 0x....      BL       _Z31buffer_line_to_current_positionv
   1912              }
   1913          
   1914            #endif
   1915          
   1916            stepper.synchronize();
   \                     ??do_blocking_move_to_4: (+1)
   \   0000008C   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   1917          
   1918            feedrate_mm_s = old_feedrate_mm_s;
   \   00000090   0xED85 0x8A1E      VSTR     S16,[R5, #+120]
   1919          
   1920            #if ENABLED(DEBUG_LEVELING_FEATURE)
   1921              if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< do_blocking_move_to");
   1922            #endif
   1923          }
   \   00000094   0xECBD 0x8B02      VPOP     {D8}
   \   00000098   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1924          

   \                                 In section .text, align 2, keep-with-next
   1925          void do_blocking_move_to_nowait(const float &rx, const float &ry, const float &rz, const float &fr_mm_s/*=0.0*/) {
   \                     _Z26do_blocking_move_to_nowaitRKfS0_S0_S0_: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xED2D 0x8B02      VPUSH    {D8}
   \   00000008   0x4606             MOV      R6,R0
   \   0000000A   0x460F             MOV      R7,R1
   \   0000000C   0x4614             MOV      R4,R2
   \   0000000E   0x4698             MOV      R8,R3
   1926            const float old_feedrate_mm_s = feedrate_mm_s;
   \   00000010   0x.... 0x....      LDR.W    R5,??DataTable107
   \   00000014   0xED95 0x8A1E      VLDR     S16,[R5, #+120]
   1927          
   1928            #if ENABLED(DEBUG_LEVELING_FEATURE)
   1929              if (DEBUGGING(LEVELING)) print_xyz(PSTR(">>> do_blocking_move_to"), NULL, LOGICAL_X_POSITION(rx), LOGICAL_Y_POSITION(ry), LOGICAL_Z_POSITION(rz));
   1930            #endif
   1931          
   1932            const float z_feedrate = fr_mm_s ? fr_mm_s : homing_feedrate_mm_s[Z_AXIS];
   \   00000018   0xEDD8 0x8A00      VLDR     S17,[R8, #0]
   \   0000001C   0xEEF5 0x8A40      VCMP.F32 S17,#0.0
   \   00000020   0xEEF1 0xFA10      FMSTAT   
   \   00000024   0xD101             BNE.N    ??do_blocking_move_to_nowait_0
   \   00000026   0xEDD5 0x8A13      VLDR     S17,[R5, #+76]
   1933          
   1934            #if ENABLED(DELTA)
   1935              if (!position_is_reachable(rx, ry)) return;
   1936          
   1937              feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
   1938          
   1939              set_destination_from_current();          // sync destination at the start
   1940          
   1941              #if ENABLED(DEBUG_LEVELING_FEATURE)
   1942                if (DEBUGGING(LEVELING)) DEBUG_POS("set_destination_from_current", destination);
   1943              #endif
   1944          
   1945              // when in the danger zone
   1946              if (current_position[Z_AXIS] > delta_clip_start_height) {
   1947                if (rz > delta_clip_start_height) {   // staying in the danger zone
   1948                  destination[X_AXIS] = rx;           // move directly (uninterpolated)
   1949                  destination[Y_AXIS] = ry;
   1950                  destination[Z_AXIS] = rz;
   1951                  prepare_uninterpolated_move_to_destination(); // set_current_from_destination
   1952                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   1953                    if (DEBUGGING(LEVELING)) DEBUG_POS("danger zone move", current_position);
   1954                  #endif
   1955                  return;
   1956                }
   1957                destination[Z_AXIS] = delta_clip_start_height;
   1958                prepare_uninterpolated_move_to_destination(); // set_current_from_destination
   1959                #if ENABLED(DEBUG_LEVELING_FEATURE)
   1960                  if (DEBUGGING(LEVELING)) DEBUG_POS("zone border move", current_position);
   1961                #endif
   1962              }
   1963          
   1964              if (rz > current_position[Z_AXIS]) {    // raising?
   1965                destination[Z_AXIS] = rz;
   1966                prepare_uninterpolated_move_to_destination(z_feedrate);   // set_current_from_destination
   1967                #if ENABLED(DEBUG_LEVELING_FEATURE)
   1968                  if (DEBUGGING(LEVELING)) DEBUG_POS("z raise move", current_position);
   1969                #endif
   1970              }
   1971          
   1972              destination[X_AXIS] = rx;
   1973              destination[Y_AXIS] = ry;
   1974              prepare_move_to_destination();         // set_current_from_destination
   1975              #if ENABLED(DEBUG_LEVELING_FEATURE)
   1976                if (DEBUGGING(LEVELING)) DEBUG_POS("xy move", current_position);
   1977              #endif
   1978          
   1979              if (rz < current_position[Z_AXIS]) {    // lowering?
   1980                destination[Z_AXIS] = rz;
   1981                prepare_uninterpolated_move_to_destination(z_feedrate);   // set_current_from_destination
   1982                #if ENABLED(DEBUG_LEVELING_FEATURE)
   1983                  if (DEBUGGING(LEVELING)) DEBUG_POS("z lower move", current_position);
   1984                #endif
   1985              }
   1986          
   1987            #elif IS_SCARA
   1988          
   1989              if (!position_is_reachable(rx, ry)) return;
   1990          
   1991              set_destination_from_current();
   1992          
   1993              // If Z needs to raise, do it before moving XY
   1994              if (destination[Z_AXIS] < rz) {
   1995                destination[Z_AXIS] = rz;
   1996                prepare_uninterpolated_move_to_destination(z_feedrate);
   1997              }
   1998          
   1999              destination[X_AXIS] = rx;
   2000              destination[Y_AXIS] = ry;
   2001              prepare_uninterpolated_move_to_destination(fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S);
   2002          
   2003              // If Z needs to lower, do it after moving XY
   2004              if (destination[Z_AXIS] > rz) {
   2005                destination[Z_AXIS] = rz;
   2006                prepare_uninterpolated_move_to_destination(z_feedrate);
   2007              }
   2008          
   2009            #else
   2010          
   2011              // If Z needs to raise, do it before moving XY
   2012              if (current_position[Z_AXIS] < rz) {
   \                     ??do_blocking_move_to_nowait_0: (+1)
   \   0000002A   0xED95 0x0A0B      VLDR     S0,[R5, #+44]
   \   0000002E   0xEDD4 0x0A00      VLDR     S1,[R4, #0]
   \   00000032   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000036   0xEEF1 0xFA10      FMSTAT   
   \   0000003A   0xD505             BPL.N    ??do_blocking_move_to_nowait_1
   2013                feedrate_mm_s = z_feedrate;
   \   0000003C   0xEDC5 0x8A1E      VSTR     S17,[R5, #+120]
   2014                current_position[Z_AXIS] = rz;
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0x62E8             STR      R0,[R5, #+44]
   2015                buffer_line_to_current_position();
   \   00000044   0x.... 0x....      BL       _Z31buffer_line_to_current_positionv
   2016              }
   2017          
   2018              feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
   \                     ??do_blocking_move_to_nowait_1: (+1)
   \   00000048   0xED98 0x0A00      VLDR     S0,[R8, #0]
   \   0000004C   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   00000050   0xEEF1 0xFA10      FMSTAT   
   \   00000054   0xD002             BEQ.N    ??do_blocking_move_to_nowait_2
   \   00000056   0xED85 0x0A1E      VSTR     S0,[R5, #+120]
   \   0000005A   0xE002             B.N      ??do_blocking_move_to_nowait_3
   \                     ??do_blocking_move_to_nowait_2: (+1)
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable111_2  ;; 0x43055555
   \   00000060   0x67A8             STR      R0,[R5, #+120]
   2019              current_position[X_AXIS] = rx;
   \                     ??do_blocking_move_to_nowait_3: (+1)
   \   00000062   0x6830             LDR      R0,[R6, #+0]
   \   00000064   0x6268             STR      R0,[R5, #+36]
   2020              current_position[Y_AXIS] = ry;
   \   00000066   0x6838             LDR      R0,[R7, #+0]
   \   00000068   0x62A8             STR      R0,[R5, #+40]
   2021              buffer_line_to_current_position();
   \   0000006A   0x.... 0x....      BL       _Z31buffer_line_to_current_positionv
   2022          
   2023              // If Z needs to lower, do it after moving XY
   2024              if (current_position[Z_AXIS] > rz) {
   \   0000006E   0xED94 0x0A00      VLDR     S0,[R4, #0]
   \   00000072   0xEDD5 0x0A0B      VLDR     S1,[R5, #+44]
   \   00000076   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   0000007A   0xEEF1 0xFA10      FMSTAT   
   \   0000007E   0xD505             BPL.N    ??do_blocking_move_to_nowait_4
   2025                feedrate_mm_s = z_feedrate;
   \   00000080   0xEDC5 0x8A1E      VSTR     S17,[R5, #+120]
   2026                current_position[Z_AXIS] = rz;
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x62E8             STR      R0,[R5, #+44]
   2027                buffer_line_to_current_position();
   \   00000088   0x.... 0x....      BL       _Z31buffer_line_to_current_positionv
   2028              }
   2029          
   2030            #endif
   2031          
   2032          //  stepper.synchronize();
   2033          
   2034            feedrate_mm_s = old_feedrate_mm_s;
   \                     ??do_blocking_move_to_nowait_4: (+1)
   \   0000008C   0xED85 0x8A1E      VSTR     S16,[R5, #+120]
   2035          
   2036            #if ENABLED(DEBUG_LEVELING_FEATURE)
   2037              if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< do_blocking_move_to");
   2038            #endif
   2039          }
   \   00000090   0xECBD 0x8B02      VPOP     {D8}
   \   00000094   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2040          
   2041          

   \                                 In section .text, align 2, keep-with-next
   2042          void do_blocking_move_to_x(const float &rx, const float &fr_mm_s/*=0.0*/) {
   \                     _Z21do_blocking_move_to_xRKfS0_: (+1)
   \   00000000   0xB418             PUSH     {R3,R4}
   2043            do_blocking_move_to(rx, current_position[Y_AXIS], current_position[Z_AXIS], fr_mm_s);
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable111_1
   \   00000006   0x460B             MOV      R3,R1
   \   00000008   0xF104 0x022C      ADD      R2,R4,#+44
   \   0000000C   0xF104 0x0128      ADD      R1,R4,#+40
   \   00000010   0xB001             ADD      SP,SP,#+4
   \   00000012   0xBC10             POP      {R4}
   \   00000014   0x....             B.N      _Z19do_blocking_move_toRKfS0_S0_S0_
   2044          }

   \                                 In section .text, align 2, keep-with-next
   2045          void do_blocking_move_to_z(const float &rz, const float &fr_mm_s/*=0.0*/) {
   \                     _Z21do_blocking_move_to_zRKfS0_: (+1)
   \   00000000   0xB418             PUSH     {R3,R4}
   2046            do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], rz, fr_mm_s);
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable111_1
   \   00000006   0x460B             MOV      R3,R1
   \   00000008   0x4602             MOV      R2,R0
   \   0000000A   0xF104 0x0128      ADD      R1,R4,#+40
   \   0000000E   0xF104 0x0024      ADD      R0,R4,#+36
   \   00000012   0xB001             ADD      SP,SP,#+4
   \   00000014   0xBC10             POP      {R4}
   \   00000016   0x....             B.N      _Z19do_blocking_move_toRKfS0_S0_S0_
   2047          }

   \                                 In section .text, align 2, keep-with-next
   2048          void do_blocking_move_to_z_nowait(const float &rz, const float &fr_mm_s/*=0.0*/) {
   \                     _Z28do_blocking_move_to_z_nowaitRKfS0_: (+1)
   \   00000000   0xB418             PUSH     {R3,R4}
   2049            do_blocking_move_to_nowait(current_position[X_AXIS], current_position[Y_AXIS], rz, fr_mm_s);
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable111_1
   \   00000006   0x460B             MOV      R3,R1
   \   00000008   0x4602             MOV      R2,R0
   \   0000000A   0xF104 0x0128      ADD      R1,R4,#+40
   \   0000000E   0xF104 0x0024      ADD      R0,R4,#+36
   \   00000012   0xB001             ADD      SP,SP,#+4
   \   00000014   0xBC10             POP      {R4}
   \   00000016   0x....             B.N      _Z26do_blocking_move_to_nowaitRKfS0_S0_S0_
   2050          }
   2051          

   \                                 In section .text, align 2, keep-with-next
   2052          void do_blocking_move_to_xy(const float &rx, const float &ry, const float &fr_mm_s/*=0.0*/) {
   2053            do_blocking_move_to(rx, ry, current_position[Z_AXIS], fr_mm_s);
   \                     _Z22do_blocking_move_to_xyRKfS0_S0_: (+1)
   \   00000000   0x4613             MOV      R3,R2
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable111_4
   \   00000006   0x....             B.N      _Z19do_blocking_move_toRKfS0_S0_S0_
   2054          }
   2055          
   2056          //
   2057          // Prepare to do endstop or probe moves
   2058          // with custom feedrates.
   2059          //
   2060          //  - Save current feedrates
   2061          //  - Reset the rate multiplier
   2062          //  - Reset the command timeout
   2063          //  - Enable the endstops (for endstop moves)
   2064          //

   \                                 In section .text, align 2, keep-with-next
   2065          static void setup_for_endstop_or_probe_move() {
   2066            #if ENABLED(DEBUG_LEVELING_FEATURE)
   2067              if (DEBUGGING(LEVELING)) DEBUG_POS("setup_for_endstop_or_probe_move", current_position);
   2068            #endif
   2069            saved_feedrate_mm_s = feedrate_mm_s;
   \                     _Z31setup_for_endstop_or_probe_movev: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable107
   \   00000004   0x6F81             LDR      R1,[R0, #+120]
   \   00000006   0x67C1             STR      R1,[R0, #+124]
   2070            saved_feedrate_percentage = feedrate_percentage;
   \   00000008   0x8C01             LDRH     R1,[R0, #+32]
   \   0000000A   0x8441             STRH     R1,[R0, #+34]
   2071            feedrate_percentage = 100;
   \   0000000C   0x2164             MOVS     R1,#+100
   \   0000000E   0x8401             STRH     R1,[R0, #+32]
   2072            refresh_cmd_timeout();
   \   00000010   0x.... 0x....      B.W      _Z19refresh_cmd_timeoutv
   2073          }
   2074          

   \                                 In section .text, align 2, keep-with-next
   2075          static void clean_up_after_endstop_or_probe_move() {
   2076            #if ENABLED(DEBUG_LEVELING_FEATURE)
   2077              if (DEBUGGING(LEVELING)) DEBUG_POS("clean_up_after_endstop_or_probe_move", current_position);
   2078            #endif
   2079            feedrate_mm_s = saved_feedrate_mm_s;
   \                     _Z36clean_up_after_endstop_or_probe_movev: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable107
   \   00000004   0x6FC1             LDR      R1,[R0, #+124]
   \   00000006   0x6781             STR      R1,[R0, #+120]
   2080            feedrate_percentage = saved_feedrate_percentage;
   \   00000008   0x8C41             LDRH     R1,[R0, #+34]
   \   0000000A   0x8401             STRH     R1,[R0, #+32]
   2081            refresh_cmd_timeout();
   \   0000000C   0x.... 0x....      B.W      _Z19refresh_cmd_timeoutv
   2082          }
   2083          
   2084          #if HAS_BED_PROBE
   2085            /**
   2086             * Raise Z to a minimum height to make room for a probe to move
   2087             */
   2088            inline void do_probe_raise(const float z_raise) {
   2089              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2090                if (DEBUGGING(LEVELING)) {
   2091                  SERIAL_ECHOPAIR("do_probe_raise(", z_raise);
   2092                  SERIAL_CHAR(')');
   2093                  SERIAL_EOL();
   2094                }
   2095              #endif
   2096          
   2097              float z_dest = z_raise;
   2098              if (zprobe_zoffset < 0) z_dest -= zprobe_zoffset;
   2099          
   2100              if (z_dest > current_position[Z_AXIS])
   2101                do_blocking_move_to_z(z_dest);
   2102            }
   2103          
   2104          #endif // HAS_BED_PROBE
   2105          
   2106          #if HAS_AXIS_UNHOMED_ERR
   2107          #if defined(MKS_DLP_BOARD)

   \                                 In section .text, align 2, keep-with-next
   2108            bool axis_unhomed_error(const bool z/*=true*/) {
   \                     _Z18axis_unhomed_errorb: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   2109              #if ENABLED(HOME_AFTER_DEACTIVATE)
   2110                const bool zz = z && !axis_known_position[Z_AXIS];
   2111              #else
   2112                const bool zz = z && !axis_homed[Z_AXIS];
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD005             BEQ.N    ??axis_unhomed_error_0
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable107
   \   0000000A   0x7980             LDRB     R0,[R0, #+6]
   \   0000000C   0xF080 0x0401      EOR      R4,R0,#0x1
   \   00000010   0xE000             B.N      ??axis_unhomed_error_1
   \                     ??axis_unhomed_error_0: (+1)
   \   00000012   0x2400             MOVS     R4,#+0
   2113              #endif
   2114              if (zz) {
   \                     ??axis_unhomed_error_1: (+1)
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD012             BEQ.N    ??axis_unhomed_error_2
   2115                SERIAL_ECHO_START();
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable107_2
   \   0000001C   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2116                SERIAL_ECHOPGM(MSG_HOME " ");
   \   00000020   0x.... 0x....      ADR.W    R0,`?<Constant "Home ">`
   \   00000024   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2117                if (zz) SERIAL_ECHOPGM(MSG_Z);
   \   00000028   0x2C00             CMP      R4,#+0
   \   0000002A   0xD002             BEQ.N    ??axis_unhomed_error_3
   \   0000002C   0x....             ADR.N    R0,??DataTable103  ;; "Z"
   \   0000002E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2118                SERIAL_ECHOLNPGM(" " MSG_FIRST);
   \                     ??axis_unhomed_error_3: (+1)
   \   00000032   0x.... 0x....      ADR.W    R0,`?<Constant " first\\n">`
   \   00000036   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2119          
   2120                #if ENABLED(ULTRA_LCD)
   2121                  lcd_status_printf_P(0, PSTR(MSG_HOME " %s%s%s " MSG_FIRST), xx ? MSG_X : "", yy ? MSG_Y : "", zz ? MSG_Z : "");
   2122                #endif
   2123                return true;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xBD10             POP      {R4,PC}
   2124              }
   2125              return false;
   \                     ??axis_unhomed_error_2: (+1)
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xBD10             POP      {R4,PC}          ;; return
   2126            }
   2127          #else
   2128          bool axis_unhomed_error(const bool x/*=true*/, const bool y/*=true*/, const bool z/*=true*/) {
   2129            #if ENABLED(HOME_AFTER_DEACTIVATE)
   2130          	const bool xx = x && !axis_known_position[X_AXIS],
   2131          			   yy = y && !axis_known_position[Y_AXIS],
   2132          			   zz = z && !axis_known_position[Z_AXIS];
   2133            #else
   2134          	const bool xx = x && !axis_homed[X_AXIS],
   2135          			   yy = y && !axis_homed[Y_AXIS],
   2136          			   zz = z && !axis_homed[Z_AXIS];
   2137            #endif
   2138            if (xx || yy || zz) {
   2139          	SERIAL_ECHO_START();
   2140          	SERIAL_ECHOPGM(MSG_HOME " ");
   2141          	if (xx) SERIAL_ECHOPGM(MSG_X);
   2142          	if (yy) SERIAL_ECHOPGM(MSG_Y);
   2143          	if (zz) SERIAL_ECHOPGM(MSG_Z);
   2144          	SERIAL_ECHOLNPGM(" " MSG_FIRST);
   2145          
   2146          	#if ENABLED(ULTRA_LCD)
   2147          	  lcd_status_printf_P(0, PSTR(MSG_HOME " %s%s%s " MSG_FIRST), xx ? MSG_X : "", yy ? MSG_Y : "", zz ? MSG_Z : "");
   2148          	#endif
   2149          	return true;
   2150            }
   2151            return false;
   2152          }
   2153          
   2154          #endif
   2155          #endif // HAS_AXIS_UNHOMED_ERR
   2156          
   2157          #if ENABLED(Z_PROBE_SLED)
   2158          
   2159            #ifndef SLED_DOCKING_OFFSET
   2160              #define SLED_DOCKING_OFFSET 0
   2161            #endif
   2162          
   2163            /**
   2164             * Method to dock/undock a sled designed by Charles Bell.
   2165             *
   2166             * stow[in]     If false, move to MAX_X and engage the solenoid
   2167             *              If true, move to MAX_X and release the solenoid
   2168             */
   2169            static void dock_sled(bool stow) {
   2170              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2171                if (DEBUGGING(LEVELING)) {
   2172                  SERIAL_ECHOPAIR("dock_sled(", stow);
   2173                  SERIAL_CHAR(')');
   2174                  SERIAL_EOL();
   2175                }
   2176              #endif
   2177          
   2178              // Dock sled a bit closer to ensure proper capturing
   2179              do_blocking_move_to_x(X_MAX_POS + SLED_DOCKING_OFFSET - ((stow) ? 1 : 0));
   2180          
   2181              #if HAS_SOLENOID_1 && DISABLED(EXT_SOLENOID)
   2182                WRITE(SOL1_PIN, !stow); // switch solenoid
   2183              #endif
   2184            }
   2185          
   2186          #elif ENABLED(Z_PROBE_ALLEN_KEY)
   2187          
   2188            FORCE_INLINE void do_blocking_move_to(const float (&raw)[XYZ], const float &fr_mm_s) {
   2189              do_blocking_move_to(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], fr_mm_s);
   2190            }
   2191          
   2192            void run_deploy_moves_script() {
   2193              #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_Z)
   2194                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_X
   2195                  #define Z_PROBE_ALLEN_KEY_DEPLOY_1_X current_position[X_AXIS]
   2196                #endif
   2197                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_Y
   2198                  #define Z_PROBE_ALLEN_KEY_DEPLOY_1_Y current_position[Y_AXIS]
   2199                #endif
   2200                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_Z
   2201                  #define Z_PROBE_ALLEN_KEY_DEPLOY_1_Z current_position[Z_AXIS]
   2202                #endif
   2203                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE
   2204                  #define Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE 0.0
   2205                #endif
   2206                const float deploy_1[] = { Z_PROBE_ALLEN_KEY_DEPLOY_1_X, Z_PROBE_ALLEN_KEY_DEPLOY_1_Y, Z_PROBE_ALLEN_KEY_DEPLOY_1_Z };
   2207                do_blocking_move_to(deploy_1, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE));
   2208              #endif
   2209              #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_Z)
   2210                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_X
   2211                  #define Z_PROBE_ALLEN_KEY_DEPLOY_2_X current_position[X_AXIS]
   2212                #endif
   2213                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_Y
   2214                  #define Z_PROBE_ALLEN_KEY_DEPLOY_2_Y current_position[Y_AXIS]
   2215                #endif
   2216                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_Z
   2217                  #define Z_PROBE_ALLEN_KEY_DEPLOY_2_Z current_position[Z_AXIS]
   2218                #endif
   2219                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE
   2220                  #define Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE 0.0
   2221                #endif
   2222                const float deploy_2[] = { Z_PROBE_ALLEN_KEY_DEPLOY_2_X, Z_PROBE_ALLEN_KEY_DEPLOY_2_Y, Z_PROBE_ALLEN_KEY_DEPLOY_2_Z };
   2223                do_blocking_move_to(deploy_2, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE));
   2224              #endif
   2225              #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_Z)
   2226                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_X
   2227                  #define Z_PROBE_ALLEN_KEY_DEPLOY_3_X current_position[X_AXIS]
   2228                #endif
   2229                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_Y
   2230                  #define Z_PROBE_ALLEN_KEY_DEPLOY_3_Y current_position[Y_AXIS]
   2231                #endif
   2232                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_Z
   2233                  #define Z_PROBE_ALLEN_KEY_DEPLOY_3_Z current_position[Z_AXIS]
   2234                #endif
   2235                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE
   2236                  #define Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE 0.0
   2237                #endif
   2238                const float deploy_3[] = { Z_PROBE_ALLEN_KEY_DEPLOY_3_X, Z_PROBE_ALLEN_KEY_DEPLOY_3_Y, Z_PROBE_ALLEN_KEY_DEPLOY_3_Z };
   2239                do_blocking_move_to(deploy_3, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE));
   2240              #endif
   2241              #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_Z)
   2242                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_X
   2243                  #define Z_PROBE_ALLEN_KEY_DEPLOY_4_X current_position[X_AXIS]
   2244                #endif
   2245                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_Y
   2246                  #define Z_PROBE_ALLEN_KEY_DEPLOY_4_Y current_position[Y_AXIS]
   2247                #endif
   2248                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_Z
   2249                  #define Z_PROBE_ALLEN_KEY_DEPLOY_4_Z current_position[Z_AXIS]
   2250                #endif
   2251                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE
   2252                  #define Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE 0.0
   2253                #endif
   2254                const float deploy_4[] = { Z_PROBE_ALLEN_KEY_DEPLOY_4_X, Z_PROBE_ALLEN_KEY_DEPLOY_4_Y, Z_PROBE_ALLEN_KEY_DEPLOY_4_Z };
   2255                do_blocking_move_to(deploy_4, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE));
   2256              #endif
   2257              #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_Z)
   2258                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_X
   2259                  #define Z_PROBE_ALLEN_KEY_DEPLOY_5_X current_position[X_AXIS]
   2260                #endif
   2261                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_Y
   2262                  #define Z_PROBE_ALLEN_KEY_DEPLOY_5_Y current_position[Y_AXIS]
   2263                #endif
   2264                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_Z
   2265                  #define Z_PROBE_ALLEN_KEY_DEPLOY_5_Z current_position[Z_AXIS]
   2266                #endif
   2267                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE
   2268                  #define Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE 0.0
   2269                #endif
   2270                const float deploy_5[] = { Z_PROBE_ALLEN_KEY_DEPLOY_5_X, Z_PROBE_ALLEN_KEY_DEPLOY_5_Y, Z_PROBE_ALLEN_KEY_DEPLOY_5_Z };
   2271                do_blocking_move_to(deploy_5, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE));
   2272              #endif
   2273            }
   2274          
   2275            void run_stow_moves_script() {
   2276              #if defined(Z_PROBE_ALLEN_KEY_STOW_1_X) || defined(Z_PROBE_ALLEN_KEY_STOW_1_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_1_Z)
   2277                #ifndef Z_PROBE_ALLEN_KEY_STOW_1_X
   2278                  #define Z_PROBE_ALLEN_KEY_STOW_1_X current_position[X_AXIS]
   2279                #endif
   2280                #ifndef Z_PROBE_ALLEN_KEY_STOW_1_Y
   2281                  #define Z_PROBE_ALLEN_KEY_STOW_1_Y current_position[Y_AXIS]
   2282                #endif
   2283                #ifndef Z_PROBE_ALLEN_KEY_STOW_1_Z
   2284                  #define Z_PROBE_ALLEN_KEY_STOW_1_Z current_position[Z_AXIS]
   2285                #endif
   2286                #ifndef Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE
   2287                  #define Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE 0.0
   2288                #endif
   2289                const float stow_1[] = { Z_PROBE_ALLEN_KEY_STOW_1_X, Z_PROBE_ALLEN_KEY_STOW_1_Y, Z_PROBE_ALLEN_KEY_STOW_1_Z };
   2290                do_blocking_move_to(stow_1, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE));
   2291              #endif
   2292              #if defined(Z_PROBE_ALLEN_KEY_STOW_2_X) || defined(Z_PROBE_ALLEN_KEY_STOW_2_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_2_Z)
   2293                #ifndef Z_PROBE_ALLEN_KEY_STOW_2_X
   2294                  #define Z_PROBE_ALLEN_KEY_STOW_2_X current_position[X_AXIS]
   2295                #endif
   2296                #ifndef Z_PROBE_ALLEN_KEY_STOW_2_Y
   2297                  #define Z_PROBE_ALLEN_KEY_STOW_2_Y current_position[Y_AXIS]
   2298                #endif
   2299                #ifndef Z_PROBE_ALLEN_KEY_STOW_2_Z
   2300                  #define Z_PROBE_ALLEN_KEY_STOW_2_Z current_position[Z_AXIS]
   2301                #endif
   2302                #ifndef Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE
   2303                  #define Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE 0.0
   2304                #endif
   2305                const float stow_2[] = { Z_PROBE_ALLEN_KEY_STOW_2_X, Z_PROBE_ALLEN_KEY_STOW_2_Y, Z_PROBE_ALLEN_KEY_STOW_2_Z };
   2306                do_blocking_move_to(stow_2, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE));
   2307              #endif
   2308              #if defined(Z_PROBE_ALLEN_KEY_STOW_3_X) || defined(Z_PROBE_ALLEN_KEY_STOW_3_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_3_Z)
   2309                #ifndef Z_PROBE_ALLEN_KEY_STOW_3_X
   2310                  #define Z_PROBE_ALLEN_KEY_STOW_3_X current_position[X_AXIS]
   2311                #endif
   2312                #ifndef Z_PROBE_ALLEN_KEY_STOW_3_Y
   2313                  #define Z_PROBE_ALLEN_KEY_STOW_3_Y current_position[Y_AXIS]
   2314                #endif
   2315                #ifndef Z_PROBE_ALLEN_KEY_STOW_3_Z
   2316                  #define Z_PROBE_ALLEN_KEY_STOW_3_Z current_position[Z_AXIS]
   2317                #endif
   2318                #ifndef Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE
   2319                  #define Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE 0.0
   2320                #endif
   2321                const float stow_3[] = { Z_PROBE_ALLEN_KEY_STOW_3_X, Z_PROBE_ALLEN_KEY_STOW_3_Y, Z_PROBE_ALLEN_KEY_STOW_3_Z };
   2322                do_blocking_move_to(stow_3, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE));
   2323              #endif
   2324              #if defined(Z_PROBE_ALLEN_KEY_STOW_4_X) || defined(Z_PROBE_ALLEN_KEY_STOW_4_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_4_Z)
   2325                #ifndef Z_PROBE_ALLEN_KEY_STOW_4_X
   2326                  #define Z_PROBE_ALLEN_KEY_STOW_4_X current_position[X_AXIS]
   2327                #endif
   2328                #ifndef Z_PROBE_ALLEN_KEY_STOW_4_Y
   2329                  #define Z_PROBE_ALLEN_KEY_STOW_4_Y current_position[Y_AXIS]
   2330                #endif
   2331                #ifndef Z_PROBE_ALLEN_KEY_STOW_4_Z
   2332                  #define Z_PROBE_ALLEN_KEY_STOW_4_Z current_position[Z_AXIS]
   2333                #endif
   2334                #ifndef Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE
   2335                  #define Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE 0.0
   2336                #endif
   2337                const float stow_4[] = { Z_PROBE_ALLEN_KEY_STOW_4_X, Z_PROBE_ALLEN_KEY_STOW_4_Y, Z_PROBE_ALLEN_KEY_STOW_4_Z };
   2338                do_blocking_move_to(stow_4, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE));
   2339              #endif
   2340              #if defined(Z_PROBE_ALLEN_KEY_STOW_5_X) || defined(Z_PROBE_ALLEN_KEY_STOW_5_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_5_Z)
   2341                #ifndef Z_PROBE_ALLEN_KEY_STOW_5_X
   2342                  #define Z_PROBE_ALLEN_KEY_STOW_5_X current_position[X_AXIS]
   2343                #endif
   2344                #ifndef Z_PROBE_ALLEN_KEY_STOW_5_Y
   2345                  #define Z_PROBE_ALLEN_KEY_STOW_5_Y current_position[Y_AXIS]
   2346                #endif
   2347                #ifndef Z_PROBE_ALLEN_KEY_STOW_5_Z
   2348                  #define Z_PROBE_ALLEN_KEY_STOW_5_Z current_position[Z_AXIS]
   2349                #endif
   2350                #ifndef Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE
   2351                  #define Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE 0.0
   2352                #endif
   2353                const float stow_5[] = { Z_PROBE_ALLEN_KEY_STOW_5_X, Z_PROBE_ALLEN_KEY_STOW_5_Y, Z_PROBE_ALLEN_KEY_STOW_5_Z };
   2354                do_blocking_move_to(stow_5, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE));
   2355              #endif
   2356            }
   2357          
   2358          #endif // Z_PROBE_ALLEN_KEY
   2359          
   2360          #if ENABLED(PROBING_FANS_OFF)
   2361          
   2362            void fans_pause(const bool p) {
   2363              if (p != fans_paused) {
   2364                fans_paused = p;
   2365                if (p)
   2366                  for (uint8_t x = 0; x < FAN_COUNT; x++) {
   2367                    paused_fanSpeeds[x] = fanSpeeds[x];
   2368                    fanSpeeds[x] = 0;
   2369                  }
   2370                else
   2371                  for (uint8_t x = 0; x < FAN_COUNT; x++)
   2372                    fanSpeeds[x] = paused_fanSpeeds[x];
   2373              }
   2374            }
   2375          
   2376          #endif // PROBING_FANS_OFF
   2377          
   2378          #if HAS_BED_PROBE
   2379          
   2380            // TRIGGERED_WHEN_STOWED_TEST can easily be extended to servo probes, ... if needed.
   2381            #if ENABLED(PROBE_IS_TRIGGERED_WHEN_STOWED_TEST)
   2382              #if ENABLED(Z_MIN_PROBE_ENDSTOP)
   2383                #define _TRIGGERED_WHEN_STOWED_TEST (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)
   2384              #else
   2385                #define _TRIGGERED_WHEN_STOWED_TEST (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)
   2386              #endif
   2387            #endif
   2388          
   2389            #if QUIET_PROBING
   2390              void probing_pause(const bool p) {
   2391                #if ENABLED(PROBING_HEATERS_OFF)
   2392                  thermalManager.pause(p);
   2393                #endif
   2394                #if ENABLED(PROBING_FANS_OFF)
   2395                  fans_pause(p);
   2396                #endif
   2397                if (p) safe_delay(
   2398                  #if DELAY_BEFORE_PROBING > 25
   2399                    DELAY_BEFORE_PROBING
   2400                  #else
   2401                    25
   2402                  #endif
   2403                );
   2404              }
   2405            #endif // QUIET_PROBING
   2406          
   2407            #if ENABLED(BLTOUCH)
   2408          
   2409              void bltouch_command(int angle) {
   2410                MOVE_SERVO(Z_ENDSTOP_SERVO_NR, angle);  // Give the BL-Touch the command and wait
   2411                safe_delay(BLTOUCH_DELAY);
   2412              }
   2413          
   2414              bool set_bltouch_deployed(const bool deploy) {
   2415                if (deploy && TEST_BLTOUCH()) {      // If BL-Touch says it's triggered
   2416                  bltouch_command(BLTOUCH_RESET);    //  try to reset it.
   2417                  bltouch_command(BLTOUCH_DEPLOY);   // Also needs to deploy and stow to
   2418                  bltouch_command(BLTOUCH_STOW);     //  clear the triggered condition.
   2419                  safe_delay(1500);                  // Wait for internal self-test to complete.
   2420                                                     //  (Measured completion time was 0.65 seconds
   2421                                                     //   after reset, deploy, and stow sequence)
   2422                  if (TEST_BLTOUCH()) {              // If it still claims to be triggered...
   2423                    SERIAL_ERROR_START();
   2424                    SERIAL_ERRORLNPGM(MSG_STOP_BLTOUCH);
   2425                    stop();                          // punt!
   2426                    return true;
   2427                  }
   2428                }
   2429          
   2430                bltouch_command(deploy ? BLTOUCH_DEPLOY : BLTOUCH_STOW);
   2431          
   2432                #if ENABLED(DEBUG_LEVELING_FEATURE)
   2433                  if (DEBUGGING(LEVELING)) {
   2434                    SERIAL_ECHOPAIR("set_bltouch_deployed(", deploy);
   2435                    SERIAL_CHAR(')');
   2436                    SERIAL_EOL();
   2437                  }
   2438                #endif
   2439          
   2440                return false;
   2441              }
   2442          
   2443            #endif // BLTOUCH
   2444          
   2445            // returns false for ok and true for failure
   2446            bool set_probe_deployed(bool deploy) {
   2447          
   2448              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2449                if (DEBUGGING(LEVELING)) {
   2450                  DEBUG_POS("set_probe_deployed", current_position);
   2451                  SERIAL_ECHOLNPAIR("deploy: ", deploy);
   2452                }
   2453              #endif
   2454          
   2455              if (endstops.z_probe_enabled == deploy) return false;
   2456          
   2457              // Make room for probe
   2458              //do_probe_raise(_Z_CLEARANCE_DEPLOY_PROBE);
   2459              do_probe_raise(Z_CLEARANCE_DEPLOY_PROBE>Z_CLEARANCE_BETWEEN_PROBES ? Z_CLEARANCE_DEPLOY_PROBE : Z_CLEARANCE_BETWEEN_PROBES);
   2460          
   2461              #if ENABLED(Z_PROBE_SLED) || ENABLED(Z_PROBE_ALLEN_KEY)
   2462                #if ENABLED(Z_PROBE_SLED)
   2463                  #define _AUE_ARGS true, false, false
   2464                #else
   2465                  #define _AUE_ARGS
   2466                #endif
   2467                if (axis_unhomed_error(_AUE_ARGS)) {
   2468                  SERIAL_ERROR_START();
   2469                  SERIAL_ERRORLNPGM(MSG_STOP_UNHOMED);
   2470                  stop();
   2471                  return true;
   2472                }
   2473              #endif
   2474          
   2475              const float oldXpos = current_position[X_AXIS],
   2476                          oldYpos = current_position[Y_AXIS];
   2477          
   2478              #ifdef _TRIGGERED_WHEN_STOWED_TEST
   2479          
   2480                // If endstop is already false, the Z probe is deployed
   2481                if (_TRIGGERED_WHEN_STOWED_TEST == deploy) {     // closed after the probe specific actions.
   2482                                                                 // Would a goto be less ugly?
   2483                  //while (!_TRIGGERED_WHEN_STOWED_TEST) idle(); // would offer the opportunity
   2484                                                                 // for a triggered when stowed manual probe.
   2485          
   2486                  if (!deploy) endstops.enable_z_probe(false); // Switch off triggered when stowed probes early
   2487                                                               // otherwise an Allen-Key probe can't be stowed.
   2488              #endif
   2489          
   2490                  #if ENABLED(SOLENOID_PROBE)
   2491          
   2492                    #if HAS_SOLENOID_1
   2493                      WRITE(SOL1_PIN, deploy);
   2494                    #endif
   2495          
   2496                  #elif ENABLED(Z_PROBE_SLED)
   2497          
   2498                    dock_sled(!deploy);
   2499          
   2500                  #elif HAS_Z_SERVO_ENDSTOP && DISABLED(BLTOUCH)
   2501          
   2502                    MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[deploy ? 0 : 1]);
   2503          
   2504                  #elif ENABLED(Z_PROBE_ALLEN_KEY)
   2505          
   2506                    deploy ? run_deploy_moves_script() : run_stow_moves_script();
   2507          
   2508                  #endif
   2509          
   2510              #ifdef _TRIGGERED_WHEN_STOWED_TEST
   2511                } // _TRIGGERED_WHEN_STOWED_TEST == deploy
   2512          
   2513                if (_TRIGGERED_WHEN_STOWED_TEST == deploy) { // State hasn't changed?
   2514          
   2515                  if (IsRunning()) {
   2516                    SERIAL_ERROR_START();
   2517                    SERIAL_ERRORLNPGM("Z-Probe failed");
   2518                    LCD_ALERTMESSAGEPGM("Err: ZPROBE");
   2519                  }
   2520                  stop();
   2521                  return true;
   2522          
   2523                } // _TRIGGERED_WHEN_STOWED_TEST == deploy
   2524          
   2525              #endif
   2526          
   2527              do_blocking_move_to(oldXpos, oldYpos, current_position[Z_AXIS]); // return to position before deploy
   2528              endstops.enable_z_probe(deploy);
   2529              return false;
   2530            }
   2531          
   2532            /**
   2533             * @brief Used by run_z_probe to do a single Z probe move.
   2534             *
   2535             * @param  z        Z destination
   2536             * @param  fr_mm_s  Feedrate in mm/s
   2537             * @return true to indicate an error
   2538             */
   2539            static bool do_probe_move(const float z, const float fr_mm_m) {
   2540              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2541                if (DEBUGGING(LEVELING)) DEBUG_POS(">>> do_probe_move", current_position);
   2542              #endif
   2543          
   2544              // Deploy BLTouch at the start of any probe
   2545              #if ENABLED(BLTOUCH)
   2546                if (set_bltouch_deployed(true)) return true;
   2547              #endif
   2548          
   2549              #if QUIET_PROBING
   2550                probing_pause(true);
   2551              #endif
   2552          
   2553              // Move down until probe triggered
   2554              do_blocking_move_to_z(z, MMM_TO_MMS(fr_mm_m));
   2555          
   2556              // Check to see if the probe was triggered
   2557              const bool probe_triggered = TEST(Endstops::endstop_hit_bits,
   2558                #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
   2559                  Z_MIN
   2560                #else
   2561                  Z_MIN_PROBE
   2562                #endif
   2563              );
   2564          
   2565              #if QUIET_PROBING
   2566                probing_pause(false);
   2567              #endif
   2568          
   2569              // Retract BLTouch immediately after a probe if it was triggered
   2570              #if ENABLED(BLTOUCH)
   2571                if (probe_triggered && set_bltouch_deployed(false)) return true;
   2572              #endif
   2573          
   2574              // Clear endstop flags
   2575              endstops.hit_on_purpose();
   2576          
   2577              // Get Z where the steppers were interrupted
   2578              set_current_from_steppers_for_axis(Z_AXIS);
   2579          
   2580              // Tell the planner where we actually are
   2581              SYNC_PLAN_POSITION_KINEMATIC();
   2582          
   2583              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2584                if (DEBUGGING(LEVELING)) DEBUG_POS("<<< do_probe_move", current_position);
   2585              #endif
   2586          
   2587              return !probe_triggered;
   2588            }
   2589          
   2590            /**
   2591             * @details Used by probe_pt to do a single Z probe at the current position.
   2592             *          Leaves current_position[Z_AXIS] at the height where the probe triggered.
   2593             *
   2594             * @return The raw Z position where the probe was triggered
   2595             */
   2596            static float run_z_probe() {
   2597          
   2598              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2599                if (DEBUGGING(LEVELING)) DEBUG_POS(">>> run_z_probe", current_position);
   2600              #endif
   2601          
   2602              // Prevent stepper_inactive_time from running out and EXTRUDER_RUNOUT_PREVENT from extruding
   2603              refresh_cmd_timeout();
   2604          
   2605              // Double-probing does a fast probe followed by a slow probe
   2606              #if MULTIPLE_PROBING == 2
   2607          
   2608                // Do a first probe at the fast speed
   2609                if (do_probe_move(-10, Z_PROBE_SPEED_FAST)) return NAN;
   2610          
   2611                float first_probe_z = current_position[Z_AXIS];
   2612          
   2613                #if ENABLED(DEBUG_LEVELING_FEATURE)
   2614                  if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("1st Probe Z:", first_probe_z);
   2615                #endif
   2616          
   2617                // move up to make clearance for the probe
   2618                do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
   2619          
   2620              #else
   2621          
   2622                // If the nozzle is above the travel height then
   2623                // move down quickly before doing the slow probe
   2624                float z = Z_CLEARANCE_DEPLOY_PROBE;
   2625                if (zprobe_zoffset < 0) z -= zprobe_zoffset;
   2626          
   2627                if (z < current_position[Z_AXIS]) {
   2628          
   2629                  // If we don't make it to the z position (i.e. the probe triggered), move up to make clearance for the probe
   2630                  if (!do_probe_move(z, Z_PROBE_SPEED_FAST))
   2631                    do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
   2632                }
   2633              #endif
   2634          
   2635              #if MULTIPLE_PROBING > 2
   2636                float probes_total = 0;
   2637                for (uint8_t p = MULTIPLE_PROBING + 1; --p;) {
   2638              #endif
   2639          
   2640                  // move down slowly to find bed
   2641                  if (do_probe_move(-10, Z_PROBE_SPEED_SLOW)) return NAN;
   2642          
   2643              #if MULTIPLE_PROBING > 2
   2644                  probes_total += current_position[Z_AXIS];
   2645                  if (p > 1) do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
   2646                }
   2647              #endif
   2648          
   2649              #if MULTIPLE_PROBING > 2
   2650          
   2651                // Return the average value of all probes
   2652                return probes_total * (1.0 / (MULTIPLE_PROBING));
   2653          
   2654              #elif MULTIPLE_PROBING == 2
   2655          
   2656                const float z2 = current_position[Z_AXIS];
   2657          
   2658                #if ENABLED(DEBUG_LEVELING_FEATURE)
   2659                  if (DEBUGGING(LEVELING)) {
   2660                    SERIAL_ECHOPAIR("2nd Probe Z:", z2);
   2661                    SERIAL_ECHOLNPAIR(" Discrepancy:", first_probe_z - z2);
   2662                  }
   2663                #endif
   2664          
   2665                // Return a weighted average of the fast and slow probes
   2666                return (z2 * 3.0 + first_probe_z * 2.0) * 0.2;
   2667          
   2668              #else
   2669          
   2670                // Return the single probe result
   2671                return current_position[Z_AXIS];
   2672          
   2673              #endif
   2674          
   2675              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2676                if (DEBUGGING(LEVELING)) DEBUG_POS("<<< run_z_probe", current_position);
   2677              #endif
   2678            }
   2679          
   2680            /**
   2681             * - Move to the given XY
   2682             * - Deploy the probe, if not already deployed
   2683             * - Probe the bed, get the Z position
   2684             * - Depending on the 'stow' flag
   2685             *   - Stow the probe, or
   2686             *   - Raise to the BETWEEN height
   2687             * - Return the probed Z position
   2688             */
   2689            float probe_pt(const float &rx, const float &ry, const bool stow, const uint8_t verbose_level, const bool probe_relative=true) {
   2690              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2691                if (DEBUGGING(LEVELING)) {
   2692                  SERIAL_ECHOPAIR(">>> probe_pt(", LOGICAL_X_POSITION(rx));
   2693                  SERIAL_ECHOPAIR(", ", LOGICAL_Y_POSITION(ry));
   2694                  SERIAL_ECHOPAIR(", ", stow ? "" : "no ");
   2695                  SERIAL_ECHOLNPGM("stow)");
   2696                  DEBUG_POS("", current_position);
   2697                }
   2698              #endif
   2699          
   2700              // TODO: Adapt for SCARA, where the offset rotates
   2701              float nx = rx, ny = ry;
   2702              if (probe_relative) {
   2703                if (!position_is_reachable_by_probe(rx, ry)) return NAN;  // The given position is in terms of the probe
   2704                nx -= (X_PROBE_OFFSET_FROM_EXTRUDER);                     // Get the nozzle position
   2705                ny -= (Y_PROBE_OFFSET_FROM_EXTRUDER);
   2706              }
   2707              else if (!position_is_reachable(nx, ny)) return NAN;        // The given position is in terms of the nozzle
   2708          
   2709              const float nz =
   2710                #if ENABLED(DELTA)
   2711                  // Move below clip height or xy move will be aborted by do_blocking_move_to
   2712                  min(current_position[Z_AXIS], delta_clip_start_height)
   2713                #else
   2714                  current_position[Z_AXIS]
   2715                #endif
   2716              ;
   2717          
   2718              const float old_feedrate_mm_s = feedrate_mm_s;
   2719              feedrate_mm_s = XY_PROBE_FEEDRATE_MM_S;
   2720          
   2721              // Move the probe to the starting XYZ
   2722              do_blocking_move_to(nx, ny, nz);
   2723          
   2724              float measured_z = NAN;
   2725              if (!DEPLOY_PROBE()) {
   2726                measured_z = run_z_probe() + zprobe_zoffset;
   2727          
   2728                if (!stow)
   2729                  do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
   2730                else
   2731                  if (STOW_PROBE()) measured_z = NAN;
   2732              }
   2733          
   2734              if (verbose_level > 2) {
   2735                SERIAL_PROTOCOLPGM("Bed X: ");
   2736                SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(rx), 3);
   2737                SERIAL_PROTOCOLPGM(" Y: ");
   2738                SERIAL_PROTOCOL_F(LOGICAL_Y_POSITION(ry), 3);
   2739                SERIAL_PROTOCOLPGM(" Z: ");
   2740                SERIAL_PROTOCOL_F(measured_z, 3);
   2741                SERIAL_EOL();
   2742              }
   2743          
   2744              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2745                if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< probe_pt");
   2746              #endif
   2747          
   2748              feedrate_mm_s = old_feedrate_mm_s;
   2749          
   2750              if (isnan(measured_z)) {
   2751                LCD_MESSAGEPGM(MSG_ERR_PROBING_FAILED);
   2752                SERIAL_ERROR_START();
   2753                SERIAL_ERRORLNPGM(MSG_ERR_PROBING_FAILED);
   2754              }
   2755          
   2756              return measured_z;
   2757            }
   2758          
   2759          #endif // HAS_BED_PROBE
   2760          
   2761          #if HAS_LEVELING
   2762          
   2763            bool leveling_is_valid() {
   2764              return
   2765                #if ENABLED(MESH_BED_LEVELING)
   2766                  mbl.has_mesh
   2767                #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
   2768                  !!bilinear_grid_spacing[X_AXIS]
   2769                #elif ENABLED(AUTO_BED_LEVELING_UBL)
   2770                  true
   2771                #else // 3POINT, LINEAR
   2772                  true
   2773                #endif
   2774              ;
   2775            }
   2776          
   2777            /**
   2778             * Turn bed leveling on or off, fixing the current
   2779             * position as-needed.
   2780             *
   2781             * Disable: Current position = physical position
   2782             *  Enable: Current position = "unleveled" physical position
   2783             */
   2784            void set_bed_leveling_enabled(const bool enable/*=true*/) {
   2785          
   2786              #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
   2787                const bool can_change = (!enable || leveling_is_valid());
   2788              #else
   2789                constexpr bool can_change = true;
   2790              #endif
   2791          
   2792              if (can_change && enable != planner.leveling_active) {
   2793          
   2794                #if ENABLED(MESH_BED_LEVELING)
   2795          
   2796                  if (!enable)
   2797                    planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS]);
   2798          
   2799                  const bool enabling = enable && leveling_is_valid();
   2800                  planner.leveling_active = enabling;
   2801                  if (enabling) planner.unapply_leveling(current_position);
   2802          
   2803                #elif ENABLED(AUTO_BED_LEVELING_UBL)
   2804                  #if PLANNER_LEVELING
   2805                    if (planner.leveling_active) {                       // leveling from on to off
   2806                      // change unleveled current_position to physical current_position without moving steppers.
   2807                      planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS]);
   2808                      planner.leveling_active = false;                   // disable only AFTER calling apply_leveling
   2809                    }
   2810                    else {                                        // leveling from off to on
   2811                      planner.leveling_active = true;                    // enable BEFORE calling unapply_leveling, otherwise ignored
   2812                      // change physical current_position to unleveled current_position without moving steppers.
   2813                      planner.unapply_leveling(current_position);
   2814                    }
   2815                  #else
   2816                    planner.leveling_active = enable;                    // just flip the bit, current_position will be wrong until next move.
   2817                  #endif
   2818          
   2819                #else // ABL
   2820          
   2821                  #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
   2822                    // Force bilinear_z_offset to re-calculate next time
   2823                    const float reset[XYZ] = { -9999.999, -9999.999, 0 };
   2824                    (void)bilinear_z_offset(reset);
   2825                  #endif
   2826          
   2827                  // Enable or disable leveling compensation in the planner
   2828                  planner.leveling_active = enable;
   2829          
   2830                  if (!enable)
   2831                    // When disabling just get the current position from the steppers.
   2832                    // This will yield the smallest error when first converted back to steps.
   2833                    set_current_from_steppers_for_axis(
   2834                      #if ABL_PLANAR
   2835                        ALL_AXES
   2836                      #else
   2837                        Z_AXIS
   2838                      #endif
   2839                    );
   2840                  else
   2841                    // When enabling, remove compensation from the current position,
   2842                    // so compensation will give the right stepper counts.
   2843                    planner.unapply_leveling(current_position);
   2844          
   2845                  SYNC_PLAN_POSITION_KINEMATIC();
   2846          
   2847                #endif // ABL
   2848              }
   2849            }
   2850          
   2851            #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
   2852          
   2853              void set_z_fade_height(const float zfh, const bool do_report/*=true*/) {
   2854          
   2855                if (planner.z_fade_height == zfh) return; // do nothing if no change
   2856          
   2857                const bool level_active = planner.leveling_active;
   2858          
   2859                #if ENABLED(AUTO_BED_LEVELING_UBL)
   2860                  if (level_active) set_bed_leveling_enabled(false);  // turn off before changing fade height for proper apply/unapply leveling to maintain current_position
   2861                #endif
   2862          
   2863                planner.set_z_fade_height(zfh);
   2864          
   2865                if (level_active) {
   2866                  const float oldpos[] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] };
   2867                  #if ENABLED(AUTO_BED_LEVELING_UBL)
   2868                    set_bed_leveling_enabled(true);  // turn back on after changing fade height
   2869                  #else
   2870                    set_current_from_steppers_for_axis(
   2871                      #if ABL_PLANAR
   2872                        ALL_AXES
   2873                      #else
   2874                        Z_AXIS
   2875                      #endif
   2876                    );
   2877                    SYNC_PLAN_POSITION_KINEMATIC();
   2878                  #endif
   2879                  if (do_report && memcmp(oldpos, current_position, sizeof(oldpos)))
   2880                    report_current_position();
   2881                }
   2882              }
   2883          
   2884            #endif // LEVELING_FADE_HEIGHT
   2885          
   2886            /**
   2887             * Reset calibration results to zero.
   2888             */
   2889            void reset_bed_level() {
   2890              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2891                if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("reset_bed_level");
   2892              #endif
   2893              set_bed_leveling_enabled(false);
   2894              #if ENABLED(MESH_BED_LEVELING)
   2895                if (leveling_is_valid()) {
   2896                  mbl.reset();
   2897                  mbl.has_mesh = false;
   2898                }
   2899              #elif ENABLED(AUTO_BED_LEVELING_UBL)
   2900                ubl.reset();
   2901              #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
   2902                bilinear_start[X_AXIS] = bilinear_start[Y_AXIS] =
   2903                bilinear_grid_spacing[X_AXIS] = bilinear_grid_spacing[Y_AXIS] = 0;
   2904                for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
   2905                  for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
   2906                    z_values[x][y] = NAN;
   2907              #elif ABL_PLANAR
   2908                planner.bed_level_matrix.set_to_identity();
   2909              #endif
   2910            }
   2911          
   2912          #endif // HAS_LEVELING
   2913          
   2914          #if ENABLED(AUTO_BED_LEVELING_BILINEAR) || ENABLED(MESH_BED_LEVELING)
   2915          
   2916            /**
   2917             * Enable to produce output in JSON format suitable
   2918             * for SCAD or JavaScript mesh visualizers.
   2919             *
   2920             * Visualize meshes in OpenSCAD using the included script.
   2921             *
   2922             *   buildroot/shared/scripts/MarlinMesh.scad
   2923             */
   2924            //#define SCAD_MESH_OUTPUT
   2925          
   2926            /**
   2927             * Print calibration results for plotting or manual frame adjustment.
   2928             */
   2929            static void print_2d_array(const uint8_t sx, const uint8_t sy, const uint8_t precision, float (*fn)(const uint8_t, const uint8_t)) {
   2930              #ifndef SCAD_MESH_OUTPUT
   2931                for (uint8_t x = 0; x < sx; x++) {
   2932                  for (uint8_t i = 0; i < precision + 2 + (x < 10 ? 1 : 0); i++)
   2933                    SERIAL_PROTOCOLCHAR(' ');
   2934                  SERIAL_PROTOCOL((int)x);
   2935                }
   2936                SERIAL_EOL();
   2937              #endif
   2938              #ifdef SCAD_MESH_OUTPUT
   2939                SERIAL_PROTOCOLLNPGM("measured_z = ["); // open 2D array
   2940              #endif
   2941              for (uint8_t y = 0; y < sy; y++) {
   2942                #ifdef SCAD_MESH_OUTPUT
   2943                  SERIAL_PROTOCOLPGM(" [");           // open sub-array
   2944                #else
   2945                  if (y < 10) SERIAL_PROTOCOLCHAR(' ');
   2946                  SERIAL_PROTOCOL((int)y);
   2947                #endif
   2948                for (uint8_t x = 0; x < sx; x++) {
   2949                  SERIAL_PROTOCOLCHAR(' ');
   2950                  const float offset = fn(x, y);
   2951                  if (!isnan(offset)) {
   2952                    if (offset >= 0) SERIAL_PROTOCOLCHAR('+');
   2953                    SERIAL_PROTOCOL_F(offset, precision);
   2954                  }
   2955                  else {
   2956                    #ifdef SCAD_MESH_OUTPUT
   2957                      for (uint8_t i = 3; i < precision + 3; i++)
   2958                        SERIAL_PROTOCOLCHAR(' ');
   2959                      SERIAL_PROTOCOLPGM("NAN");
   2960                    #else
   2961                      for (uint8_t i = 0; i < precision + 3; i++)
   2962                        SERIAL_PROTOCOLCHAR(i ? '=' : ' ');
   2963                    #endif
   2964                  }
   2965                  #ifdef SCAD_MESH_OUTPUT
   2966                    if (x < sx - 1) SERIAL_PROTOCOLCHAR(',');
   2967                  #endif
   2968                }
   2969                #ifdef SCAD_MESH_OUTPUT
   2970                  SERIAL_PROTOCOLCHAR(' ');
   2971                  SERIAL_PROTOCOLCHAR(']');                     // close sub-array
   2972                  if (y < sy - 1) SERIAL_PROTOCOLCHAR(',');
   2973                #endif
   2974                SERIAL_EOL();
   2975              }
   2976              #ifdef SCAD_MESH_OUTPUT
   2977                SERIAL_PROTOCOLPGM("];");                       // close 2D array
   2978              #endif
   2979              SERIAL_EOL();
   2980            }
   2981          
   2982          #endif
   2983          
   2984          #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
   2985          
   2986            /**
   2987             * Extrapolate a single point from its neighbors
   2988             */
   2989            static void extrapolate_one_point(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir) {
   2990              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2991                if (DEBUGGING(LEVELING)) {
   2992                  SERIAL_ECHOPGM("Extrapolate [");
   2993                  if (x < 10) SERIAL_CHAR(' ');
   2994                  SERIAL_ECHO((int)x);
   2995                  SERIAL_CHAR(xdir ? (xdir > 0 ? '+' : '-') : ' ');
   2996                  SERIAL_CHAR(' ');
   2997                  if (y < 10) SERIAL_CHAR(' ');
   2998                  SERIAL_ECHO((int)y);
   2999                  SERIAL_CHAR(ydir ? (ydir > 0 ? '+' : '-') : ' ');
   3000                  SERIAL_CHAR(']');
   3001                }
   3002              #endif
   3003              if (!isnan(z_values[x][y])) {
   3004                #if ENABLED(DEBUG_LEVELING_FEATURE)
   3005                  if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM(" (done)");
   3006                #endif
   3007                return;  // Don't overwrite good values.
   3008              }
   3009              SERIAL_EOL();
   3010          
   3011              // Get X neighbors, Y neighbors, and XY neighbors
   3012              const uint8_t x1 = x + xdir, y1 = y + ydir, x2 = x1 + xdir, y2 = y1 + ydir;
   3013              float a1 = z_values[x1][y ], a2 = z_values[x2][y ],
   3014                    b1 = z_values[x ][y1], b2 = z_values[x ][y2],
   3015                    c1 = z_values[x1][y1], c2 = z_values[x2][y2];
   3016          
   3017              // Treat far unprobed points as zero, near as equal to far
   3018              if (isnan(a2)) a2 = 0.0; if (isnan(a1)) a1 = a2;
   3019              if (isnan(b2)) b2 = 0.0; if (isnan(b1)) b1 = b2;
   3020              if (isnan(c2)) c2 = 0.0; if (isnan(c1)) c1 = c2;
   3021          
   3022              const float a = 2 * a1 - a2, b = 2 * b1 - b2, c = 2 * c1 - c2;
   3023          
   3024              // Take the average instead of the median
   3025              z_values[x][y] = (a + b + c) / 3.0;
   3026          
   3027              // Median is robust (ignores outliers).
   3028              // z_values[x][y] = (a < b) ? ((b < c) ? b : (c < a) ? a : c)
   3029              //                                : ((c < b) ? b : (a < c) ? a : c);
   3030            }
   3031          
   3032            //Enable this if your SCARA uses 180° of total area
   3033            //#define EXTRAPOLATE_FROM_EDGE
   3034          
   3035            #if ENABLED(EXTRAPOLATE_FROM_EDGE)
   3036              #if GRID_MAX_POINTS_X < GRID_MAX_POINTS_Y
   3037                #define HALF_IN_X
   3038              #elif GRID_MAX_POINTS_Y < GRID_MAX_POINTS_X
   3039                #define HALF_IN_Y
   3040              #endif
   3041            #endif
   3042          
   3043            /**
   3044             * Fill in the unprobed points (corners of circular print surface)
   3045             * using linear extrapolation, away from the center.
   3046             */
   3047            static void extrapolate_unprobed_bed_level() {
   3048              #ifdef HALF_IN_X
   3049                constexpr uint8_t ctrx2 = 0, xlen = GRID_MAX_POINTS_X - 1;
   3050              #else
   3051                constexpr uint8_t ctrx1 = (GRID_MAX_POINTS_X - 1) / 2, // left-of-center
   3052                                  ctrx2 = (GRID_MAX_POINTS_X) / 2,     // right-of-center
   3053                                  xlen = ctrx1;
   3054              #endif
   3055          
   3056              #ifdef HALF_IN_Y
   3057                constexpr uint8_t ctry2 = 0, ylen = GRID_MAX_POINTS_Y - 1;
   3058              #else
   3059                constexpr uint8_t ctry1 = (GRID_MAX_POINTS_Y - 1) / 2, // top-of-center
   3060                                  ctry2 = (GRID_MAX_POINTS_Y) / 2,     // bottom-of-center
   3061                                  ylen = ctry1;
   3062              #endif
   3063          
   3064              for (uint8_t xo = 0; xo <= xlen; xo++)
   3065                for (uint8_t yo = 0; yo <= ylen; yo++) {
   3066                  uint8_t x2 = ctrx2 + xo, y2 = ctry2 + yo;
   3067                  #ifndef HALF_IN_X
   3068                    const uint8_t x1 = ctrx1 - xo;
   3069                  #endif
   3070                  #ifndef HALF_IN_Y
   3071                    const uint8_t y1 = ctry1 - yo;
   3072                    #ifndef HALF_IN_X
   3073                      extrapolate_one_point(x1, y1, +1, +1);   //  left-below + +
   3074                    #endif
   3075                    extrapolate_one_point(x2, y1, -1, +1);     // right-below - +
   3076                  #endif
   3077                  #ifndef HALF_IN_X
   3078                    extrapolate_one_point(x1, y2, +1, -1);     //  left-above + -
   3079                  #endif
   3080                  extrapolate_one_point(x2, y2, -1, -1);       // right-above - -
   3081                }
   3082          
   3083            }
   3084          
   3085            static void print_bilinear_leveling_grid() {
   3086              SERIAL_ECHOLNPGM("Bilinear Leveling Grid:");
   3087              print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 3,
   3088                [](const uint8_t ix, const uint8_t iy) { return z_values[ix][iy]; }
   3089              );
   3090            }
   3091          
   3092            #if ENABLED(ABL_BILINEAR_SUBDIVISION)
   3093          
   3094              #define ABL_GRID_POINTS_VIRT_X (GRID_MAX_POINTS_X - 1) * (BILINEAR_SUBDIVISIONS) + 1
   3095              #define ABL_GRID_POINTS_VIRT_Y (GRID_MAX_POINTS_Y - 1) * (BILINEAR_SUBDIVISIONS) + 1
   3096              #define ABL_TEMP_POINTS_X (GRID_MAX_POINTS_X + 2)
   3097              #define ABL_TEMP_POINTS_Y (GRID_MAX_POINTS_Y + 2)
   3098              float z_values_virt[ABL_GRID_POINTS_VIRT_X][ABL_GRID_POINTS_VIRT_Y];
   3099              int bilinear_grid_spacing_virt[2] = { 0 };
   3100              float bilinear_grid_factor_virt[2] = { 0 };
   3101          
   3102              static void print_bilinear_leveling_grid_virt() {
   3103                SERIAL_ECHOLNPGM("Subdivided with CATMULL ROM Leveling Grid:");
   3104                print_2d_array(ABL_GRID_POINTS_VIRT_X, ABL_GRID_POINTS_VIRT_Y, 5,
   3105                  [](const uint8_t ix, const uint8_t iy) { return z_values_virt[ix][iy]; }
   3106                );
   3107              }
   3108          
   3109              #define LINEAR_EXTRAPOLATION(E, I) ((E) * 2 - (I))
   3110              float bed_level_virt_coord(const uint8_t x, const uint8_t y) {
   3111                uint8_t ep = 0, ip = 1;
   3112                if (!x || x == ABL_TEMP_POINTS_X - 1) {
   3113                  if (x) {
   3114                    ep = GRID_MAX_POINTS_X - 1;
   3115                    ip = GRID_MAX_POINTS_X - 2;
   3116                  }
   3117                  if (WITHIN(y, 1, ABL_TEMP_POINTS_Y - 2))
   3118                    return LINEAR_EXTRAPOLATION(
   3119                      z_values[ep][y - 1],
   3120                      z_values[ip][y - 1]
   3121                    );
   3122                  else
   3123                    return LINEAR_EXTRAPOLATION(
   3124                      bed_level_virt_coord(ep + 1, y),
   3125                      bed_level_virt_coord(ip + 1, y)
   3126                    );
   3127                }
   3128                if (!y || y == ABL_TEMP_POINTS_Y - 1) {
   3129                  if (y) {
   3130                    ep = GRID_MAX_POINTS_Y - 1;
   3131                    ip = GRID_MAX_POINTS_Y - 2;
   3132                  }
   3133                  if (WITHIN(x, 1, ABL_TEMP_POINTS_X - 2))
   3134                    return LINEAR_EXTRAPOLATION(
   3135                      z_values[x - 1][ep],
   3136                      z_values[x - 1][ip]
   3137                    );
   3138                  else
   3139                    return LINEAR_EXTRAPOLATION(
   3140                      bed_level_virt_coord(x, ep + 1),
   3141                      bed_level_virt_coord(x, ip + 1)
   3142                    );
   3143                }
   3144                return z_values[x - 1][y - 1];
   3145              }
   3146          
   3147              static float bed_level_virt_cmr(const float p[4], const uint8_t i, const float t) {
   3148                return (
   3149                    p[i-1] * -t * sq(1 - t)
   3150                  + p[i]   * (2 - 5 * sq(t) + 3 * t * sq(t))
   3151                  + p[i+1] * t * (1 + 4 * t - 3 * sq(t))
   3152                  - p[i+2] * sq(t) * (1 - t)
   3153                ) * 0.5;
   3154              }
   3155          
   3156              static float bed_level_virt_2cmr(const uint8_t x, const uint8_t y, const float &tx, const float &ty) {
   3157                float row[4], column[4];
   3158                for (uint8_t i = 0; i < 4; i++) {
   3159                  for (uint8_t j = 0; j < 4; j++) {
   3160                    column[j] = bed_level_virt_coord(i + x - 1, j + y - 1);
   3161                  }
   3162                  row[i] = bed_level_virt_cmr(column, 1, ty);
   3163                }
   3164                return bed_level_virt_cmr(row, 1, tx);
   3165              }
   3166          
   3167              void bed_level_virt_interpolate() {
   3168                bilinear_grid_spacing_virt[X_AXIS] = bilinear_grid_spacing[X_AXIS] / (BILINEAR_SUBDIVISIONS);
   3169                bilinear_grid_spacing_virt[Y_AXIS] = bilinear_grid_spacing[Y_AXIS] / (BILINEAR_SUBDIVISIONS);
   3170                bilinear_grid_factor_virt[X_AXIS] = RECIPROCAL(bilinear_grid_spacing_virt[X_AXIS]);
   3171                bilinear_grid_factor_virt[Y_AXIS] = RECIPROCAL(bilinear_grid_spacing_virt[Y_AXIS]);
   3172                for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
   3173                  for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
   3174                    for (uint8_t ty = 0; ty < BILINEAR_SUBDIVISIONS; ty++)
   3175                      for (uint8_t tx = 0; tx < BILINEAR_SUBDIVISIONS; tx++) {
   3176                        if ((ty && y == GRID_MAX_POINTS_Y - 1) || (tx && x == GRID_MAX_POINTS_X - 1))
   3177                          continue;
   3178                        z_values_virt[x * (BILINEAR_SUBDIVISIONS) + tx][y * (BILINEAR_SUBDIVISIONS) + ty] =
   3179                          bed_level_virt_2cmr(
   3180                            x + 1,
   3181                            y + 1,
   3182                            (float)tx / (BILINEAR_SUBDIVISIONS),
   3183                            (float)ty / (BILINEAR_SUBDIVISIONS)
   3184                          );
   3185                      }
   3186              }
   3187            #endif // ABL_BILINEAR_SUBDIVISION
   3188          
   3189            // Refresh after other values have been updated
   3190            void refresh_bed_level() {
   3191              bilinear_grid_factor[X_AXIS] = RECIPROCAL(bilinear_grid_spacing[X_AXIS]);
   3192              bilinear_grid_factor[Y_AXIS] = RECIPROCAL(bilinear_grid_spacing[Y_AXIS]);
   3193              #if ENABLED(ABL_BILINEAR_SUBDIVISION)
   3194                bed_level_virt_interpolate();
   3195              #endif
   3196            }
   3197          
   3198          #endif // AUTO_BED_LEVELING_BILINEAR
   3199          
   3200          /**
   3201           * Home an individual linear axis
   3202           */

   \                                 In section .text, align 2, keep-with-next
   3203          static void do_homing_move(const AxisEnum axis, const float distance, const float fr_mm_s=0.0) {
   \                     _Z14do_homing_move8AxisEnumff: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0xB082             SUB      SP,SP,#+8
   \   00000008   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   0000000C   0xEEF0 0x8A60      VMOV.F32 S17,S1
   \   00000010   0x.... 0x....      LDR.W    R4,??DataTable107
   \   00000014   0xEB04 0x0580      ADD      R5,R4,R0, LSL #+2
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x6268             STR      R0,[R5, #+36]
   3204          
   3205            #if ENABLED(DEBUG_LEVELING_FEATURE)
   3206              if (DEBUGGING(LEVELING)) {
   3207                SERIAL_ECHOPAIR(">>> do_homing_move(", axis_codes[axis]);
   3208                SERIAL_ECHOPAIR(", ", distance);
   3209                SERIAL_ECHOPAIR(", ", fr_mm_s);
   3210                SERIAL_CHAR(')');
   3211                SERIAL_EOL();
   3212              }
   3213            #endif
   3214          
   3215          //  #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
   3216          #if 0    
   3217              const bool deploy_bltouch = (axis == Z_AXIS && distance < 0);
   3218              if (deploy_bltouch) set_bltouch_deployed(true);
   3219            #endif
   3220          
   3221            #if QUIET_PROBING
   3222              if (axis == Z_AXIS) probing_pause(true);
   3223            #endif
   3224          
   3225            // Tell the planner the axis is at 0
   3226            current_position[axis] = 0;
   3227          
   3228            #if IS_SCARA
   3229              SYNC_PLAN_POSITION_KINEMATIC();
   3230              current_position[axis] = distance;
   3231              inverse_kinematics(current_position);
   3232              planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate(axis), active_extruder);
   3233            #else
   3234              sync_plan_position();
   \   0000001C   0x.... 0x....      BL       _Z18sync_plan_positionv
   3235              current_position[axis] = distance;
   \   00000020   0xED85 0x8A09      VSTR     S16,[R5, #+36]
   3236              //planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate(axis), active_extruder);
   3237              planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate_mm_s[axis], active_extruder);
   \   00000024   0xEEF5 0x8A40      VCMP.F32 S17,#0.0
   \   00000028   0xEEF1 0xFA10      FMSTAT   
   \   0000002C   0xD002             BEQ.N    ??do_homing_move_0
   \   0000002E   0xEDCD 0x8A00      VSTR     S17,[SP, #+0]
   \   00000032   0xE001             B.N      ??do_homing_move_1
   \                     ??do_homing_move_0: (+1)
   \   00000034   0x6C68             LDR      R0,[R5, #+68]
   \   00000036   0x9000             STR      R0,[SP, #+0]
   \                     ??do_homing_move_1: (+1)
   \   00000038   0x7CE2             LDRB     R2,[R4, #+19]
   \   0000003A   0xA900             ADD      R1,SP,#+0
   \   0000003C   0xF104 0x0030      ADD      R0,R4,#+48
   \   00000040   0xED94 0x1A0B      VLDR     S2,[R4, #+44]
   \   00000044   0xEDD4 0x0A0A      VLDR     S1,[R4, #+40]
   \   00000048   0xED94 0x0A09      VLDR     S0,[R4, #+36]
   \   0000004C   0x.... 0x....      BL       _ZN7Planner11buffer_lineEfffRKfS1_h
   3238          
   3239            #endif
   3240          
   3241            stepper.synchronize();
   \   00000050   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   3242          
   3243            #if QUIET_PROBING
   3244              if (axis == Z_AXIS) probing_pause(false);
   3245            #endif
   3246          
   3247          //  #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
   3248          #if 0    
   3249              if (deploy_bltouch) set_bltouch_deployed(false);
   3250            #endif
   3251          
   3252            endstops.hit_on_purpose();
   \   00000054   0x.... 0x....      BL       _ZN8Endstops14hit_on_purposeEv
   3253          
   3254            #if ENABLED(DEBUG_LEVELING_FEATURE)
   3255              if (DEBUGGING(LEVELING)) {
   3256                SERIAL_ECHOPAIR("<<< do_homing_move(", axis_codes[axis]);
   3257                SERIAL_CHAR(')');
   3258                SERIAL_EOL();
   3259              }
   3260            #endif
   3261          }
   \   00000058   0xB002             ADD      SP,SP,#+8
   \   0000005A   0xECBD 0x8B02      VPOP     {D8}
   \   0000005E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   3262          
   3263          /**
   3264           * TMC2130 specific sensorless homing using stallGuard2.
   3265           * stallGuard2 only works when in spreadCycle mode.
   3266           * spreadCycle and stealthChop are mutually exclusive.
   3267           */
   3268          #if ENABLED(SENSORLESS_HOMING)
   3269            template<typename TMC>
   3270            void tmc_sensorless_homing(TMC &st, bool enable=true) {
   3271              #if ENABLED(STEALTHCHOP)
   3272                if (enable) {
   3273                  st.coolstep_min_speed(1024UL * 1024UL - 1UL);
   3274                  st.stealthChop(0);
   3275                }
   3276                else {
   3277                  st.coolstep_min_speed(0);
   3278                  st.stealthChop(1);
   3279                }
   3280              #endif
   3281          
   3282              st.diag1_stall(enable ? 1 : 0);
   3283            }
   3284          #endif
   3285          
   3286          /**
   3287           * Home an individual "raw axis" to its endstop.
   3288           * This applies to XYZ on Cartesian and Core robots, and
   3289           * to the individual ABC steppers on DELTA and SCARA.
   3290           *
   3291           * At the end of the procedure the axis is marked as
   3292           * homed and the current position of that axis is updated.
   3293           * Kinematic robots should wait till all axes are homed
   3294           * before updating the current position.
   3295           */
   3296          
   3297          #define HOMEAXIS(LETTER) homeaxis(LETTER##_AXIS)
   3298          

   \                                 In section .text, align 4, keep-with-next
   3299          static void homeaxis(const AxisEnum axis) {
   \                     _Z8homeaxis8AxisEnum: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0xED2D 0x8B02      VPUSH    {D8}
   \   00000008   0x4604             MOV      R4,R0
   3300          
   3301            #if IS_SCARA
   3302              // Only Z homing (with probe) is permitted
   3303              if (axis != Z_AXIS) { BUZZ(100, 880); return; }
   3304            #else
   3305              #define CAN_HOME(A) \
   3306                (axis == A##_AXIS && ((A##_MIN_PIN > -1 && A##_HOME_DIR < 0) || (A##_MAX_PIN > -1 && A##_HOME_DIR > 0)))
   3307              if (!CAN_HOME(X) && !CAN_HOME(Y) && !CAN_HOME(Z)) return;
   \   0000000A   0x4625             MOV      R5,R4
   \   0000000C   0x2D02             CMP      R5,#+2
   \   0000000E   0xD178             BNE.N    ??homeaxis_0
   \   00000010   0x....             LDR.N    R0,??DataTable104_8
   \   00000012   0xF990 0x0001      LDRSB    R0,[R0, #+1]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD073             BEQ.N    ??homeaxis_0
   3308            #endif
   3309          
   3310            #if ENABLED(DEBUG_LEVELING_FEATURE)
   3311              if (DEBUGGING(LEVELING)) {
   3312                SERIAL_ECHOPAIR(">>> homeaxis(", axis_codes[axis]);
   3313                SERIAL_CHAR(')');
   3314                SERIAL_EOL();
   3315              }
   3316            #endif
   3317          
   3318            const int axis_home_dir =
   3319              #if ENABLED(DUAL_X_CARRIAGE)
   3320                (axis == X_AXIS) ? x_home_dir(active_extruder) :
   3321              #endif
   3322              home_dir(axis);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       _Z8home_dir8AxisEnum
   \   00000020   0xEE08 0x0A90      VMOV     S17,R0
   3323          
   3324            // Homing Z towards the bed? Deploy the Z probe or endstop.
   3325            #if HOMING_Z_WITH_PROBE
   3326              if (axis == Z_AXIS && DEPLOY_PROBE()) return;
   3327            #endif
   3328          
   3329            // Set flags for X, Y, Z motor locking
   3330            #if ENABLED(X_DUAL_ENDSTOPS)
   3331              if (axis == X_AXIS) stepper.set_homing_flag_x(true);
   3332            #endif
   3333            #if ENABLED(Y_DUAL_ENDSTOPS)
   3334              if (axis == Y_AXIS) stepper.set_homing_flag_y(true);
   3335            #endif
   3336            #if ENABLED(Z_DUAL_ENDSTOPS)
   3337              if (axis == Z_AXIS) stepper.set_homing_flag_z(true);
   3338            #endif
   3339          
   3340            // Disable stealthChop if used. Enable diag1 pin on driver.
   3341            #if ENABLED(SENSORLESS_HOMING)
   3342              #if ENABLED(X_IS_TMC2130)
   3343                if (axis == X_AXIS) tmc_sensorless_homing(stepperX);
   3344              #endif
   3345              #if ENABLED(Y_IS_TMC2130)
   3346                if (axis == Y_AXIS) tmc_sensorless_homing(stepperY);
   3347              #endif
   3348            #endif
   3349          
   3350            // Fast move towards endstop until triggered
   3351            #if ENABLED(DEBUG_LEVELING_FEATURE)
   3352              if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 1 Fast:");
   3353            #endif
   3354            mksdlp.quick_stop_ena = false;
   \   00000024   0x....             LDR.N    R6,??DataTable104_6
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xF886 0x0CB5      STRB     R0,[R6, #+3253]
   3355            do_homing_move(axis, 1.5 * max_length(axis) * axis_home_dir);
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       _Z10max_length8AxisEnum
   \   00000032   0xEDDF 0x....      VLDR.W   S1,??DataTable103_1  ;; 0x0
   \   00000036   0xEEB0 0x8A60      VMOV.F32 S16,S1
   \   0000003A   0xEE10 0x0A10      VMOV     R0,S0
   \   0000003E   0x.... 0x....      BL       __aeabi_f2d
   \   00000042   0x2200             MOVS     R2,#+0
   \   00000044   0x.... 0x....      LDR.W    R3,??DataTable111_6  ;; 0x3ff80000
   \   00000048   0x.... 0x....      BL       __aeabi_dmul
   \   0000004C   0x4680             MOV      R8,R0
   \   0000004E   0x4689             MOV      R9,R1
   \   00000050   0xEE18 0x0A90      VMOV     R0,S17
   \   00000054   0x.... 0x....      BL       __aeabi_i2d
   \   00000058   0x4642             MOV      R2,R8
   \   0000005A   0x464B             MOV      R3,R9
   \   0000005C   0x.... 0x....      BL       __aeabi_dmul
   \   00000060   0x.... 0x....      BL       __aeabi_d2f
   \   00000064   0xEE00 0x0A10      VMOV     S0,R0
   \   00000068   0xEEF0 0x0A48      VMOV.F32 S1,S16
   \   0000006C   0x4620             MOV      R0,R4
   \   0000006E   0x.... 0x....      BL       _Z14do_homing_move8AxisEnumff
   3356            
   3357            mksdlp.buzzer_tone(500,100,2);
   \   00000072   0xF606 0x17C4      ADDW     R7,R6,#+2500
   \   00000076   0x2302             MOVS     R3,#+2
   \   00000078   0x2264             MOVS     R2,#+100
   \   0000007A   0xF44F 0x71FA      MOV      R1,#+500
   \   0000007E   0x4638             MOV      R0,R7
   \   00000080   0x.... 0x....      BL       _ZN7MKS_DLP11buzzer_toneEtth
   3358            // When homing Z with probe respect probe clearance
   3359            const float bump = axis_home_dir * (
   3360              //#if HOMING_Z_WITH_PROBE
   3361          #if 0                                 
   3362                (axis == Z_AXIS) ? max(Z_CLEARANCE_BETWEEN_PROBES, home_bump_mm(Z_AXIS)) :
   3363              #endif
   3364              home_bump_mm(axis)
   3365            );
   \   00000084   0xEEB8 0x8AE8      VCVT.F32.S32 S16,S17
   \   00000088   0x4620             MOV      R0,R4
   \   0000008A   0x.... 0x....      BL       _Z12home_bump_mm8AxisEnum
   \   0000008E   0xEE28 0x8A00      VMUL.F32 S16,S16,S0
   3366          
   3367            // If a second homing move is configured...
   3368            if (bump) {
   \   00000092   0xEEB5 0x8A40      VCMP.F32 S16,#0.0
   \   00000096   0xEEF1 0xFA10      FMSTAT   
   \   0000009A   0xD021             BEQ.N    ??homeaxis_1
   3369              // Move away from the endstop by the axis HOME_BUMP_MM
   3370              #if ENABLED(DEBUG_LEVELING_FEATURE)
   3371                if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Move Away:");
   3372              #endif
   3373          	if(!mksdlp.quick_stop_ena)
   \   0000009C   0xF896 0x0CB5      LDRB     R0,[R6, #+3253]
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD106             BNE.N    ??homeaxis_2
   3374          		{
   3375          	    do_homing_move(axis, -bump);
   \   000000A4   0xEDDF 0x....      VLDR.W   S1,??DataTable103_1  ;; 0x0
   \   000000A8   0xEEB1 0x0A48      VNEG.F32 S0,S16
   \   000000AC   0x4620             MOV      R0,R4
   \   000000AE   0x.... 0x....      BL       _Z14do_homing_move8AxisEnumff
   3376          		}
   3377              // Slow move towards endstop until triggered
   3378              #if ENABLED(DEBUG_LEVELING_FEATURE)
   3379                if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 2 Slow:");
   3380              #endif
   3381          	if(!mksdlp.quick_stop_ena)
   \                     ??homeaxis_2: (+1)
   \   000000B2   0xF896 0x0CB5      LDRB     R0,[R6, #+3253]
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD112             BNE.N    ??homeaxis_1
   3382          		{
   3383            	  	do_homing_move(axis, 2 * bump, get_homing_bump_feedrate(axis));
   \   000000BA   0x4620             MOV      R0,R4
   \   000000BC   0x.... 0x....      BL       _Z24get_homing_bump_feedrate8AxisEnum
   \   000000C0   0xEEF0 0x0A40      VMOV.F32 S1,S0
   \   000000C4   0xEEB0 0x0A00      VMOV.F32 S0,#2.0
   \   000000C8   0xEE28 0x0A00      VMUL.F32 S0,S16,S0
   \   000000CC   0x4620             MOV      R0,R4
   \   000000CE   0x.... 0x....      BL       _Z14do_homing_move8AxisEnumff
   3384          		mksdlp.buzzer_tone(500,100,2);
   \   000000D2   0x2302             MOVS     R3,#+2
   \   000000D4   0x2264             MOVS     R2,#+100
   \   000000D6   0xF44F 0x71FA      MOV      R1,#+500
   \   000000DA   0x4638             MOV      R0,R7
   \   000000DC   0x.... 0x....      BL       _ZN7MKS_DLP11buzzer_toneEtth
   3385          		}
   3386            }
   3387          
   3388            /**
   3389             * Home axes that have dual endstops... differently
   3390             */
   3391            #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
   3392              const bool pos_dir = axis_home_dir > 0;
   3393              #if ENABLED(X_DUAL_ENDSTOPS)
   3394                if (axis == X_AXIS) {
   3395                  const bool lock_x1 = pos_dir ? (x_endstop_adj > 0) : (x_endstop_adj < 0);
   3396                  const float adj = FABS(x_endstop_adj);
   3397                  if (lock_x1) stepper.set_x_lock(true); else stepper.set_x2_lock(true);
   3398                  do_homing_move(axis, pos_dir ? -adj : adj);
   3399                  if (lock_x1) stepper.set_x_lock(false); else stepper.set_x2_lock(false);
   3400                  stepper.set_homing_flag_x(false);
   3401                }
   3402              #endif
   3403              #if ENABLED(Y_DUAL_ENDSTOPS)
   3404                if (axis == Y_AXIS) {
   3405                  const bool lock_y1 = pos_dir ? (y_endstop_adj > 0) : (y_endstop_adj < 0);
   3406                  const float adj = FABS(y_endstop_adj);
   3407                  if (lock_y1) stepper.set_y_lock(true); else stepper.set_y2_lock(true);
   3408                  do_homing_move(axis, pos_dir ? -adj : adj);
   3409                  if (lock_y1) stepper.set_y_lock(false); else stepper.set_y2_lock(false);
   3410                  stepper.set_homing_flag_y(false);
   3411                }
   3412              #endif
   3413              #if ENABLED(Z_DUAL_ENDSTOPS)
   3414                if (axis == Z_AXIS) {
   3415                  const bool lock_z1 = pos_dir ? (z_endstop_adj > 0) : (z_endstop_adj < 0);
   3416                  const float adj = FABS(z_endstop_adj);
   3417                  if (lock_z1) stepper.set_z_lock(true); else stepper.set_z2_lock(true);
   3418                  do_homing_move(axis, pos_dir ? -adj : adj);
   3419                  if (lock_z1) stepper.set_z_lock(false); else stepper.set_z2_lock(false);
   3420                  stepper.set_homing_flag_z(false);
   3421                }
   3422              #endif
   3423            #endif
   3424          
   3425            #if IS_SCARA
   3426          
   3427              set_axis_is_at_home(axis);
   3428              SYNC_PLAN_POSITION_KINEMATIC();
   3429          
   3430            #elif ENABLED(DELTA)
   3431          
   3432              // Delta has already moved all three towers up in G28
   3433              // so here it re-homes each tower in turn.
   3434              // Delta homing treats the axes as normal linear axes.
   3435          
   3436              // retrace by the amount specified in delta_endstop_adj + additional 0.1mm in order to have minimum steps
   3437              if (delta_endstop_adj[axis] * Z_HOME_DIR <= 0) {
   3438                #if ENABLED(DEBUG_LEVELING_FEATURE)
   3439                  if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("delta_endstop_adj:");
   3440                #endif
   3441                do_homing_move(axis, delta_endstop_adj[axis] - 0.1 * Z_HOME_DIR);
   3442              }
   3443          
   3444            #else
   3445          
   3446              // For cartesian/core machines,
   3447              // set the axis to its home position
   3448              axis_homed[Z_AXIS]=false;
   \                     ??homeaxis_1: (+1)
   \   000000E0   0x.... 0x....      LDR.W    R7,??DataTable107
   \   000000E4   0x2000             MOVS     R0,#+0
   \   000000E6   0x71B8             STRB     R0,[R7, #+6]
   3449            if(!mksdlp.quick_stop_ena)
   \   000000E8   0xF896 0x0CB5      LDRB     R0,[R6, #+3253]
   \   000000EC   0x2800             CMP      R0,#+0
   \   000000EE   0xD108             BNE.N    ??homeaxis_0
   3450            	{
   3451              set_axis_is_at_home(axis);
   \   000000F0   0x4620             MOV      R0,R4
   \   000000F2   0x.... 0x....      BL       _Z19set_axis_is_at_home8AxisEnum
   3452              sync_plan_position();
   \   000000F6   0x.... 0x....      BL       _Z18sync_plan_positionv
   3453              destination[axis] = current_position[axis];
   \   000000FA   0xEB07 0x0085      ADD      R0,R7,R5, LSL #+2
   \   000000FE   0x6A41             LDR      R1,[R0, #+36]
   \   00000100   0x6341             STR      R1,[R0, #+52]
   3454            	}
   3455              #if ENABLED(DEBUG_LEVELING_FEATURE)
   3456                if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
   3457              #endif
   3458          
   3459            #endif
   3460          
   3461            // Re-enable stealthChop if used. Disable diag1 pin on driver.
   3462            #if ENABLED(SENSORLESS_HOMING)
   3463              #if ENABLED(X_IS_TMC2130)
   3464                if (axis == X_AXIS) tmc_sensorless_homing(stepperX, false);
   3465              #endif
   3466              #if ENABLED(Y_IS_TMC2130)
   3467                if (axis == Y_AXIS) tmc_sensorless_homing(stepperY, false);
   3468              #endif
   3469            #endif
   3470          
   3471            // Put away the Z probe
   3472            //#if HOMING_Z_WITH_PROBE
   3473          #if 0      
   3474              if (axis == Z_AXIS && STOW_PROBE()) return;
   3475            #endif
   3476          
   3477            #if ENABLED(DEBUG_LEVELING_FEATURE)
   3478              if (DEBUGGING(LEVELING)) {
   3479                SERIAL_ECHOPAIR("<<< homeaxis(", axis_codes[axis]);
   3480                SERIAL_CHAR(')');
   3481                SERIAL_EOL();
   3482              }
   3483            #endif
   3484          } // homeaxis()
   \                     ??homeaxis_0: (+1)
   \   00000102   0xECBD 0x8B02      VPOP     {D8}
   \   00000106   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
   3485          
   3486          #if ENABLED(FWRETRACT)
   3487          
   3488            /**
   3489             * Retract or recover according to firmware settings
   3490             *
   3491             * This function handles retract/recover moves for G10 and G11,
   3492             * plus auto-retract moves sent from G0/G1 when E-only moves are done.
   3493             *
   3494             * To simplify the logic, doubled retract/recover moves are ignored.
   3495             *
   3496             * Note: Z lift is done transparently to the planner. Aborting
   3497             *       a print between G10 and G11 may corrupt the Z position.
   3498             *
   3499             * Note: Auto-retract will apply the set Z hop in addition to any Z hop
   3500             *       included in the G-code. Use M207 Z0 to to prevent double hop.
   3501             */
   3502            void retract(const bool retracting
   3503              #if EXTRUDERS > 1
   3504                , bool swapping = false
   3505              #endif
   3506            ) {
   3507          
   3508              static float hop_amount = 0.0;  // Total amount lifted, for use in recover
   3509          
   3510              // Prevent two retracts or recovers in a row
   3511              if (retracted[active_extruder] == retracting) return;
   3512          
   3513              // Prevent two swap-retract or recovers in a row
   3514              #if EXTRUDERS > 1
   3515                // Allow G10 S1 only after G10
   3516                if (swapping && retracted_swap[active_extruder] == retracting) return;
   3517                // G11 priority to recover the long retract if activated
   3518                if (!retracting) swapping = retracted_swap[active_extruder];
   3519              #else
   3520                const bool swapping = false;
   3521              #endif
   3522          
   3523              /* // debugging
   3524                SERIAL_ECHOLNPAIR("retracting ", retracting);
   3525                SERIAL_ECHOLNPAIR("swapping ", swapping);
   3526                SERIAL_ECHOLNPAIR("active extruder ", active_extruder);
   3527                for (uint8_t i = 0; i < EXTRUDERS; ++i) {
   3528                  SERIAL_ECHOPAIR("retracted[", i);
   3529                  SERIAL_ECHOLNPAIR("] ", retracted[i]);
   3530                  SERIAL_ECHOPAIR("retracted_swap[", i);
   3531                  SERIAL_ECHOLNPAIR("] ", retracted_swap[i]);
   3532                }
   3533                SERIAL_ECHOLNPAIR("current_position[z] ", current_position[Z_AXIS]);
   3534                SERIAL_ECHOLNPAIR("hop_amount ", hop_amount);
   3535              //*/
                      ^
Warning[Pe009]: nested comment is not allowed
   3536          
   3537              const bool has_zhop = retract_zlift > 0.01;     // Is there a hop set?
   3538              const float old_feedrate_mm_s = feedrate_mm_s;
   3539          
   3540              // The current position will be the destination for E and Z moves
   3541              set_destination_from_current();
   3542              stepper.synchronize();  // Wait for buffered moves to complete
   3543          
   3544              const float renormalize = 1.0 / planner.e_factor[active_extruder];
   3545          
   3546              if (retracting) {
   3547                // Retract by moving from a faux E position back to the current E position
   3548                feedrate_mm_s = retract_feedrate_mm_s;
   3549                current_position[E_AXIS] += (swapping ? swap_retract_length : retract_length) * renormalize;
   3550                sync_plan_position_e();
   3551                prepare_move_to_destination();
   3552          
   3553                // Is a Z hop set, and has the hop not yet been done?
   3554                if (has_zhop && !hop_amount) {
   3555                  hop_amount += retract_zlift;                        // Carriage is raised for retraction hop
   3556                  feedrate_mm_s = planner.max_feedrate_mm_s[Z_AXIS];  // Z feedrate to max
   3557                  current_position[Z_AXIS] -= retract_zlift;          // Pretend current pos is lower. Next move raises Z.
   3558                  SYNC_PLAN_POSITION_KINEMATIC();                     // Set the planner to the new position
   3559                  prepare_move_to_destination();                      // Raise up to the old current pos
   3560                  feedrate_mm_s = retract_feedrate_mm_s;              // Restore feedrate
   3561                }
   3562              }
   3563              else {
   3564                // If a hop was done and Z hasn't changed, undo the Z hop
   3565                if (hop_amount) {
   3566                  current_position[Z_AXIS] += retract_zlift;          // Pretend current pos is lower. Next move raises Z.
   3567                  SYNC_PLAN_POSITION_KINEMATIC();                     // Set the planner to the new position
   3568                  feedrate_mm_s = planner.max_feedrate_mm_s[Z_AXIS];  // Z feedrate to max
   3569                  prepare_move_to_destination();                      // Raise up to the old current pos
   3570                  hop_amount = 0.0;                                   // Clear hop
   3571                }
   3572          
   3573                // A retract multiplier has been added here to get faster swap recovery
   3574                feedrate_mm_s = swapping ? swap_retract_recover_feedrate_mm_s : retract_recover_feedrate_mm_s;
   3575          
   3576                const float move_e = swapping ? swap_retract_length + swap_retract_recover_length : retract_length + retract_recover_length;
   3577                current_position[E_AXIS] -= move_e * renormalize;
   3578                sync_plan_position_e();
   3579                prepare_move_to_destination();                        // Recover E
   3580              }
   3581          
   3582              feedrate_mm_s = old_feedrate_mm_s;                      // Restore original feedrate
   3583          
   3584              retracted[active_extruder] = retracting;                // Active extruder now retracted / recovered
   3585          
   3586              // If swap retract/recover update the retracted_swap flag too
   3587              #if EXTRUDERS > 1
   3588                if (swapping) retracted_swap[active_extruder] = retracting;
   3589              #endif
   3590          
   3591              /* // debugging
   3592                SERIAL_ECHOLNPAIR("retracting ", retracting);
   3593                SERIAL_ECHOLNPAIR("swapping ", swapping);
   3594                SERIAL_ECHOLNPAIR("active_extruder ", active_extruder);
   3595                for (uint8_t i = 0; i < EXTRUDERS; ++i) {
   3596                  SERIAL_ECHOPAIR("retracted[", i);
   3597                  SERIAL_ECHOLNPAIR("] ", retracted[i]);
   3598                  SERIAL_ECHOPAIR("retracted_swap[", i);
   3599                  SERIAL_ECHOLNPAIR("] ", retracted_swap[i]);
   3600                }
   3601                SERIAL_ECHOLNPAIR("current_position[z] ", current_position[Z_AXIS]);
   3602                SERIAL_ECHOLNPAIR("hop_amount ", hop_amount);
   3603              //*/
                      ^
Warning[Pe009]: nested comment is not allowed
   3604          
   3605            }
   3606          
   3607          #endif // FWRETRACT
   3608          
   3609          #if ENABLED(MIXING_EXTRUDER)
   3610          
   3611            void normalize_mix() {
   3612              float mix_total = 0.0;
   3613              for (uint8_t i = 0; i < MIXING_STEPPERS; i++) mix_total += RECIPROCAL(mixing_factor[i]);
   3614              // Scale all values if they don't add up to ~1.0
   3615              if (!NEAR(mix_total, 1.0)) {
   3616                SERIAL_PROTOCOLLNPGM("Warning: Mix factors must add up to 1.0. Scaling.");
   3617                for (uint8_t i = 0; i < MIXING_STEPPERS; i++) mixing_factor[i] *= mix_total;
   3618              }
   3619            }
   3620          
   3621            #if ENABLED(DIRECT_MIXING_IN_G1)
   3622              // Get mixing parameters from the GCode
   3623              // The total "must" be 1.0 (but it will be normalized)
   3624              // If no mix factors are given, the old mix is preserved
   3625              void gcode_get_mix() {
   3626                const char* mixing_codes = "ABCDHI";
   3627                byte mix_bits = 0;
   3628                for (uint8_t i = 0; i < MIXING_STEPPERS; i++) {
   3629                  if (parser.seenval(mixing_codes[i])) {
   3630                    SBI(mix_bits, i);
   3631                    float v = parser.value_float();
   3632                    NOLESS(v, 0.0);
   3633                    mixing_factor[i] = RECIPROCAL(v);
   3634                  }
   3635                }
   3636                // If any mixing factors were included, clear the rest
   3637                // If none were included, preserve the last mix
   3638                if (mix_bits) {
   3639                  for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
   3640                    if (!TEST(mix_bits, i)) mixing_factor[i] = 0.0;
   3641                  normalize_mix();
   3642                }
   3643              }
   3644            #endif
   3645          
   3646          #endif
   3647          
   3648          /**
   3649           * ***************************************************************************
   3650           * ***************************** G-CODE HANDLING *****************************
   3651           * ***************************************************************************
   3652           */
   3653          
   3654          /**
   3655           * Set XYZE destination and feedrate from the current GCode command
   3656           *
   3657           *  - Set destination from included axis codes
   3658           *  - Set to current for missing axis codes
   3659           *  - Set the feedrate, if included
   3660           */

   \                                 In section .text, align 4, keep-with-next
   3661          void gcode_get_destination() {
   \                     _Z21gcode_get_destinationv: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   3662            LOOP_XYZE(i) {
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0x.... 0x....      LDR.W    R6,??DataTable107
   \   00000008   0xE002             B.N      ??gcode_get_destination_0
   3663              if (parser.seen(axis_codes[i])) {
   3664                const float v = parser.value_axis_units((AxisEnum)i) + (axis_relative_modes[i] || relative_mode ? current_position[i] : 0);
   3665                //destination[i] = i == E_AXIS ? v : LOGICAL_TO_NATIVE(v, i);
   3666                destination[i] = v;
   3667              }
   3668              else
   3669                destination[i] = current_position[i];
   \                     ??gcode_get_destination_1: (+1)
   \   0000000A   0x6A68             LDR      R0,[R5, #+36]
   \   0000000C   0x6368             STR      R0,[R5, #+52]
   \                     ??gcode_get_destination_2: (+1)
   \   0000000E   0x1C64             ADDS     R4,R4,#+1
   \                     ??gcode_get_destination_0: (+1)
   \   00000010   0x2C04             CMP      R4,#+4
   \   00000012   0xDA1A             BGE.N    ??gcode_get_destination_3
   \   00000014   0xEB06 0x0584      ADD      R5,R6,R4, LSL #+2
   \   00000018   0x.... 0x....      ADR.W    R0,axis_codes
   \   0000001C   0x5620             LDRSB    R0,[R4, R0]
   \   0000001E   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD0F1             BEQ.N    ??gcode_get_destination_1
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0xB240             SXTB     R0,R0
   \   0000002A   0x.... 0x....      BL       _ZN11GCodeParser16value_axis_unitsE8AxisEnum
   \   0000002E   0x5DA0             LDRB     R0,[R4, R6]
   \   00000030   0x7D31             LDRB     R1,[R6, #+20]
   \   00000032   0x4308             ORRS     R0,R1,R0
   \   00000034   0xD002             BEQ.N    ??gcode_get_destination_4
   \   00000036   0xEDD5 0x0A09      VLDR     S1,[R5, #+36]
   \   0000003A   0xE001             B.N      ??gcode_get_destination_5
   \                     ??gcode_get_destination_4: (+1)
   \   0000003C   0xEDDF 0x....      VLDR.W   S1,??DataTable103_1  ;; 0x0
   \                     ??gcode_get_destination_5: (+1)
   \   00000040   0xEE30 0x0A20      VADD.F32 S0,S0,S1
   \   00000044   0xED85 0x0A0D      VSTR     S0,[R5, #+52]
   \   00000048   0xE7E1             B.N      ??gcode_get_destination_2
   3670            }
   3671          
   3672            if (parser.linearval('F') > 0.0)
   \                     ??gcode_get_destination_3: (+1)
   \   0000004A   0xED9F 0x....      VLDR.W   S0,??DataTable103_1  ;; 0x0
   \   0000004E   0x2046             MOVS     R0,#+70
   \   00000050   0x.... 0x....      BL       _ZN11GCodeParser9linearvalEcf
   \   00000054   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   00000058   0xEEF1 0xFA10      FMSTAT   
   \   0000005C   0xDD08             BLE.N    ??gcode_get_destination_6
   3673              feedrate_mm_s = MMM_TO_MMS(parser.value_feedrate());
   \   0000005E   0x.... 0x....      BL       _ZN11GCodeParser14value_feedrateEv
   \   00000062   0xEDDF 0x....      VLDR.W   S1,??DataTable104  ;; 0x42700000
   \   00000066   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   0000006A   0x4630             MOV      R0,R6
   \   0000006C   0xED80 0x0A1E      VSTR     S0,[R0, #+120]
   3674          
   3675            #if ENABLED(PRINTCOUNTER)
   3676              if (!DEBUGGING(DRYRUN))
   3677                print_job_timer.incFilamentUsed(destination[E_AXIS] - current_position[E_AXIS]);
   3678            #endif
   3679          
   3680            // Get ABCDHI mixing factors
   3681            #if ENABLED(MIXING_EXTRUDER) && ENABLED(DIRECT_MIXING_IN_G1)
   3682              gcode_get_mix();
   3683            #endif
   3684          }
   \                     ??gcode_get_destination_6: (+1)
   \   00000070   0xBD70             POP      {R4-R6,PC}       ;; return
   3685          
   3686          #if ENABLED(HOST_KEEPALIVE_FEATURE)
   3687          
   3688            /**
   3689             * Output a "busy" message at regular intervals
   3690             * while the machine is not accepting commands.
   3691             */
   3692            void host_keepalive() {
   3693              const millis_t ms = millis();
   3694              if (host_keepalive_interval && busy_state != NOT_BUSY) {
   3695                if (PENDING(ms, next_busy_signal_ms)) return;
   3696                switch (busy_state) {
   3697                  case IN_HANDLER:
   3698                  case IN_PROCESS:
   3699                    SERIAL_ECHO_START();
   3700                    SERIAL_ECHOLNPGM(MSG_BUSY_PROCESSING);
   3701                    break;
   3702                  case PAUSED_FOR_USER:
   3703                    SERIAL_ECHO_START();
   3704                    SERIAL_ECHOLNPGM(MSG_BUSY_PAUSED_FOR_USER);
   3705                    break;
   3706                  case PAUSED_FOR_INPUT:
   3707                    SERIAL_ECHO_START();
   3708                    SERIAL_ECHOLNPGM(MSG_BUSY_PAUSED_FOR_INPUT);
   3709                    break;
   3710                  default:
   3711                    break;
   3712                }
   3713              }
   3714              next_busy_signal_ms = ms + host_keepalive_interval * 1000UL;
   3715            }
   3716          
   3717          #endif // HOST_KEEPALIVE_FEATURE
   3718          
   3719          
   3720          /**************************************************
   3721           ***************** GCode Handlers *****************
   3722           **************************************************/
   3723          
   3724          #if ENABLED(NO_MOTION_BEFORE_HOMING)
   3725            #define G0_G1_CONDITION !axis_unhomed_error(parser.seen('X'), parser.seen('Y'), parser.seen('Z'))
   3726          #else
   3727            #define G0_G1_CONDITION true
   3728          #endif
   3729          
   3730          /**
   3731           * G0, G1: Coordinated movement of X Y Z E axes
   3732           */

   \                                 In section .text, align 2
   3733          inline void gcode_G0_G1(
   3734            #if IS_SCARA
   3735              bool fast_move=false
   3736            #endif
   3737          ) {
   \                     _Z11gcode_G0_G1v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   3738            if (IsRunning() && G0_G1_CONDITION) {
   \   00000002   0x.... 0x....      BL       _Z9IsRunningv
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD005             BEQ.N    ??gcode_G0_G1_0
   3739              gcode_get_destination(); // For X Y Z E F
   \   0000000A   0x.... 0x....      BL       _Z21gcode_get_destinationv
   3740          
   3741              #if ENABLED(FWRETRACT)
   3742                if (MIN_AUTORETRACT <= MAX_AUTORETRACT) {
   3743                  // When M209 Autoretract is enabled, convert E-only moves to firmware retract/recover moves
   3744                  if (autoretract_enabled && parser.seen('E') && !(parser.seen('X') || parser.seen('Y') || parser.seen('Z'))) {
   3745                    const float echange = destination[E_AXIS] - current_position[E_AXIS];
   3746                    // Is this a retract or recover move?
   3747                    if (WITHIN(FABS(echange), MIN_AUTORETRACT, MAX_AUTORETRACT) && retracted[active_extruder] == (echange > 0.0)) {
   3748                      current_position[E_AXIS] = destination[E_AXIS]; // Hide a G1-based retract/recover from calculations
   3749                      sync_plan_position_e();                         // AND from the planner
   3750                      return retract(echange < 0.0);                  // Firmware-based retract/recover (double-retract ignored)
   3751                    }
   3752                  }
   3753                }
   3754              #endif // FWRETRACT
   3755          
   3756              #if IS_SCARA
   3757                fast_move ? prepare_uninterpolated_move_to_destination() : prepare_move_to_destination();
   3758              #else
   3759                prepare_move_to_destination();
   \   0000000E   0xE8BD 0x4001      POP      {R0,LR}
   \   00000012   0x.... 0x....      B.W      _Z27prepare_move_to_destinationv
   3760              #endif
   3761          
   3762              #if ENABLED(NANODLP_Z_SYNC)
   3763                #if ENABLED(NANODLP_ALL_AXIS)
   3764                  #define _MOVE_SYNC true                 // For any move wait and output sync message
   3765                #else
   3766                  #define _MOVE_SYNC parser.seenval('Z')  // Only for Z move
   3767                #endif
   3768                if (_MOVE_SYNC) {
   3769                  stepper.synchronize();
   3770                  SERIAL_ECHOLNPGM(MSG_Z_MOVE_COMP);
   3771                }
   3772              #endif
   3773            }
   3774          }
   \                     ??gcode_G0_G1_0: (+1)
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
   3775          
   3776          /**
   3777           * G2: Clockwise Arc
   3778           * G3: Counterclockwise Arc
   3779           *
   3780           * This command has two forms: IJ-form and R-form.
   3781           *
   3782           *  - I specifies an X offset. J specifies a Y offset.
   3783           *    At least one of the IJ parameters is required.
   3784           *    X and Y can be omitted to do a complete circle.
   3785           *    The given XY is not error-checked. The arc ends
   3786           *     based on the angle of the destination.
   3787           *    Mixing I or J with R will throw an error.
   3788           *
   3789           *  - R specifies the radius. X or Y is required.
   3790           *    Omitting both X and Y will throw an error.
   3791           *    X or Y must differ from the current XY.
   3792           *    Mixing R with I or J will throw an error.
   3793           *
   3794           *  - P specifies the number of full circles to do
   3795           *    before the specified arc move.
   3796           *
   3797           *  Examples:
   3798           *
   3799           *    G2 I10           ; CW circle centered at X+10
   3800           *    G3 X20 Y12 R14   ; CCW circle with r=14 ending at X20 Y12
   3801           */
   3802          #if ENABLED(ARC_SUPPORT)
   3803          

   \                                 In section .text, align 4
   3804            inline void gcode_G2_G3(const bool clockwise) {
   \                     _Z11gcode_G2_G3b: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0xED2D 0x8B0E      VPUSH    {D8-D14}
   \   00000006   0xB082             SUB      SP,SP,#+8
   \   00000008   0x4604             MOV      R4,R0
   3805              #if ENABLED(NO_MOTION_BEFORE_HOMING)
   3806                if (axis_unhomed_error()) return;
   3807              #endif
   3808          
   3809              if (IsRunning()) {
   \   0000000A   0x.... 0x....      BL       _Z9IsRunningv
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xF000 0x80EB      BEQ.W    ??gcode_G2_G3_0
   3810          
   3811                #if ENABLED(SF_ARC_FIX)
   3812                  const bool relative_mode_backup = relative_mode;
   3813                  relative_mode = true;
   3814                #endif
   3815          
   3816                gcode_get_destination();
   \   00000014   0x.... 0x....      BL       _Z21gcode_get_destinationv
   3817          
   3818                #if ENABLED(SF_ARC_FIX)
   3819                  relative_mode = relative_mode_backup;
   3820                #endif
   3821          
   3822                float arc_offset[2] = { 0.0, 0.0 };
   \   00000018   0xA800             ADD      R0,SP,#+0
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x460A             MOV      R2,R1
   \   0000001E   0xC006             STM      R0!,{R1,R2}
   3823                if (parser.seenval('R')) {
   \   00000020   0x2052             MOVS     R0,#+82
   \   00000022   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xF000 0x80B1      BEQ.W    ??gcode_G2_G3_1
   3824                  const float r = parser.value_linear_units(),
   \   0000002C   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000030   0xEEB0 0x8A40      VMOV.F32 S16,S0
   3825                              p1 = current_position[X_AXIS], q1 = current_position[Y_AXIS],
   \   00000034   0x4870             LDR.N    R0,??gcode_G2_G3_2+0x4
   \   00000036   0xED90 0xAA09      VLDR     S20,[R0, #+36]
   \   0000003A   0xEDD0 0xAA0A      VLDR     S21,[R0, #+40]
   3826                              p2 = destination[X_AXIS], q2 = destination[Y_AXIS];
   \   0000003E   0xED90 0xBA0D      VLDR     S22,[R0, #+52]
   \   00000042   0xEDD0 0xBA0E      VLDR     S23,[R0, #+56]
   3827                  if (r && (p2 != p1 || q2 != q1)) {
   \   00000046   0xEEB5 0x8A40      VCMP.F32 S16,#0.0
   \   0000004A   0xEEF1 0xFA10      FMSTAT   
   \   0000004E   0xF000 0x80B0      BEQ.W    ??gcode_G2_G3_3
   \   00000052   0xEEB4 0xBA4A      VCMP.F32 S22,S20
   \   00000056   0xEEF1 0xFA10      FMSTAT   
   \   0000005A   0xD105             BNE.N    ??gcode_G2_G3_4
   \   0000005C   0xEEF4 0xBA6A      VCMP.F32 S23,S21
   \   00000060   0xEEF1 0xFA10      FMSTAT   
   \   00000064   0xF000 0x80A5      BEQ.W    ??gcode_G2_G3_3
   3828                    const float e = clockwise ^ (r < 0) ? -1 : 1,           // clockwise -1/1, counterclockwise 1/-1
   \                     ??gcode_G2_G3_4: (+1)
   \   00000068   0xEEB5 0x8A40      VCMP.F32 S16,#0.0
   \   0000006C   0xEEF1 0xFA10      FMSTAT   
   \   00000070   0xD501             BPL.N    ??gcode_G2_G3_5
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0xE000             B.N      ??gcode_G2_G3_6
   \                     ??gcode_G2_G3_5: (+1)
   \   00000076   0x2000             MOVS     R0,#+0
   \                     ??gcode_G2_G3_6: (+1)
   \   00000078   0xEEF7 0xDA00      VMOV.F32 S27,#1.0
   \   0000007C   0xEA90 0x0F04      TEQ      R0,R4
   \   00000080   0xD002             BEQ.N    ??gcode_G2_G3_7
   \   00000082   0xEEBF 0xCA00      VMOV.F32 S24,#-1.0
   \   00000086   0xE001             B.N      ??gcode_G2_G3_8
   \                     ??gcode_G2_G3_7: (+1)
   \   00000088   0xEEB0 0xCA6D      VMOV.F32 S24,S27
   3829                                dx = p2 - p1, dy = q2 - q1,                 // X and Y differences
   \                     ??gcode_G2_G3_8: (+1)
   \   0000008C   0xEE7B 0xCA4A      VSUB.F32 S25,S22,S20
   \   00000090   0xEE3B 0xDAEA      VSUB.F32 S26,S23,S21
   3830                                d = HYPOT(dx, dy),                          // Linear distance between the points
   \   00000094   0xEEB0 0x0A6C      VMOV.F32 S0,S25
   \   00000098   0x2002             MOVS     R0,#+2
   \   0000009A   0xEEF0 0x0A6D      VMOV.F32 S1,S27
   \   0000009E   0xE001             B.N      ??gcode_G2_G3_9
   \                     ??gcode_G2_G3_10: (+1)
   \   000000A0   0xEE20 0x0A00      VMUL.F32 S0,S0,S0
   \                     ??gcode_G2_G3_9: (+1)
   \   000000A4   0x07C1             LSLS     R1,R0,#+31
   \   000000A6   0xD501             BPL.N    ??gcode_G2_G3_11
   \   000000A8   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \                     ??gcode_G2_G3_11: (+1)
   \   000000AC   0x0840             LSRS     R0,R0,#+1
   \   000000AE   0xD1F7             BNE.N    ??gcode_G2_G3_10
   \   000000B0   0xEEB0 0x0A4D      VMOV.F32 S0,S26
   \   000000B4   0x2002             MOVS     R0,#+2
   \   000000B6   0xEEB0 0x1A6D      VMOV.F32 S2,S27
   \   000000BA   0xE001             B.N      ??gcode_G2_G3_12
   \                     ??gcode_G2_G3_13: (+1)
   \   000000BC   0xEE20 0x0A00      VMUL.F32 S0,S0,S0
   \                     ??gcode_G2_G3_12: (+1)
   \   000000C0   0x07C1             LSLS     R1,R0,#+31
   \   000000C2   0xD501             BPL.N    ??gcode_G2_G3_14
   \   000000C4   0xEE21 0x1A00      VMUL.F32 S2,S2,S0
   \                     ??gcode_G2_G3_14: (+1)
   \   000000C8   0x0840             LSRS     R0,R0,#+1
   \   000000CA   0xD1F7             BNE.N    ??gcode_G2_G3_13
   \   000000CC   0xEE30 0x0A81      VADD.F32 S0,S1,S2
   \   000000D0   0x.... 0x....      BL       sqrtf
   \   000000D4   0xEEB0 0xEA40      VMOV.F32 S28,S0
   3831                                h = SQRT(sq(r) - sq(d * 0.5)),              // Distance to the arc pivot-point
   \   000000D8   0x2002             MOVS     R0,#+2
   \   000000DA   0xE001             B.N      ??gcode_G2_G3_15
   \                     ??gcode_G2_G3_16: (+1)
   \   000000DC   0xEE28 0x8A08      VMUL.F32 S16,S16,S16
   \                     ??gcode_G2_G3_15: (+1)
   \   000000E0   0x07C1             LSLS     R1,R0,#+31
   \   000000E2   0xD501             BPL.N    ??gcode_G2_G3_17
   \   000000E4   0xEE6D 0xDA88      VMUL.F32 S27,S27,S16
   \                     ??gcode_G2_G3_17: (+1)
   \   000000E8   0x0840             LSRS     R0,R0,#+1
   \   000000EA   0xD1F7             BNE.N    ??gcode_G2_G3_16
   \   000000EC   0xEE1E 0x0A10      VMOV     R0,S28
   \   000000F0   0x.... 0x....      BL       __aeabi_f2d
   \   000000F4   0x2200             MOVS     R2,#+0
   \   000000F6   0x4B41             LDR.N    R3,??gcode_G2_G3_2+0x8  ;; 0x3fe00000
   \   000000F8   0x.... 0x....      BL       __aeabi_dmul
   \   000000FC   0xEC41 0x0B18      VMOV     D8,R0,R1
   \   00000100   0x2502             MOVS     R5,#+2
   \   00000102   0xED9F 0x9B3F      VLDR.W   D9,??gcode_G2_G3_2+0xC
   \   00000106   0xE007             B.N      ??gcode_G2_G3_18
   \                     ??gcode_G2_G3_19: (+1)
   \   00000108   0xEC51 0x0B18      VMOV     R0,R1,D8
   \   0000010C   0xEC53 0x2B18      VMOV     R2,R3,D8
   \   00000110   0x.... 0x....      BL       __aeabi_dmul
   \   00000114   0xEC41 0x0B18      VMOV     D8,R0,R1
   \                     ??gcode_G2_G3_18: (+1)
   \   00000118   0x07E8             LSLS     R0,R5,#+31
   \   0000011A   0xD507             BPL.N    ??gcode_G2_G3_20
   \   0000011C   0xEC51 0x0B19      VMOV     R0,R1,D9
   \   00000120   0xEC53 0x2B18      VMOV     R2,R3,D8
   \   00000124   0x.... 0x....      BL       __aeabi_dmul
   \   00000128   0xEC41 0x0B19      VMOV     D9,R0,R1
   \                     ??gcode_G2_G3_20: (+1)
   \   0000012C   0x086D             LSRS     R5,R5,#+1
   \   0000012E   0xD1EB             BNE.N    ??gcode_G2_G3_19
   \   00000130   0xEE1D 0x0A90      VMOV     R0,S27
   \   00000134   0x.... 0x....      BL       __aeabi_f2d
   \   00000138   0xEC53 0x2B19      VMOV     R2,R3,D9
   \   0000013C   0x.... 0x....      BL       __aeabi_dsub
   \   00000140   0xEC41 0x0B10      VMOV     D0,R0,R1
   \   00000144   0x.... 0x....      BL       sqrt
   \   00000148   0xEC51 0x0B10      VMOV     R0,R1,D0
   \   0000014C   0x.... 0x....      BL       __aeabi_d2f
   \   00000150   0xEE00 0x0A10      VMOV     S0,R0
   3832                                mx = (p1 + p2) * 0.5, my = (q1 + q2) * 0.5, // Point between the two points
   3833                                sx = -dy / d, sy = dx / d,                  // Slope of the perpendicular bisector
   3834                                cx = mx + e * h * sx, cy = my + e * h * sy; // Pivot-point of the arc
   3835                    arc_offset[0] = cx - p1;
   \   00000154   0xEE2C 0x0A00      VMUL.F32 S0,S24,S0
   \   00000158   0xEEF6 0x0A00      VMOV.F32 S1,#0.5
   \   0000015C   0xEE3A 0x1A0B      VADD.F32 S2,S20,S22
   \   00000160   0xEE21 0x1A20      VMUL.F32 S2,S2,S1
   \   00000164   0xEECD 0x1A0E      VDIV.F32 S3,S26,S28
   \   00000168   0xEE00 0x1A61      VMLS.F32 S2,S0,S3
   \   0000016C   0xEE31 0x1A4A      VSUB.F32 S2,S2,S20
   \   00000170   0xED8D 0x1A00      VSTR     S2,[SP, #+0]
   3836                    arc_offset[1] = cy - q1;
   \   00000174   0xEE3A 0x1AAB      VADD.F32 S2,S21,S23
   \   00000178   0xEE61 0x0A20      VMUL.F32 S1,S2,S1
   \   0000017C   0xEE8C 0x1A8E      VDIV.F32 S2,S25,S28
   \   00000180   0xEE40 0x0A01      VMLA.F32 S1,S0,S2
   \   00000184   0xEE30 0x0AEA      VSUB.F32 S0,S1,S21
   \   00000188   0xED8D 0x0A01      VSTR     S0,[SP, #+4]
   \   0000018C   0xE011             B.N      ??gcode_G2_G3_3
   3837                  }
   3838                }
   3839                else {
   3840                  if (parser.seenval('I')) arc_offset[0] = parser.value_linear_units();
   \                     ??gcode_G2_G3_1: (+1)
   \   0000018E   0x2049             MOVS     R0,#+73
   \   00000190   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000194   0x2800             CMP      R0,#+0
   \   00000196   0xD003             BEQ.N    ??gcode_G2_G3_21
   \   00000198   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   0000019C   0xED8D 0x0A00      VSTR     S0,[SP, #+0]
   3841                  if (parser.seenval('J')) arc_offset[1] = parser.value_linear_units();
   \                     ??gcode_G2_G3_21: (+1)
   \   000001A0   0x204A             MOVS     R0,#+74
   \   000001A2   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   000001A6   0x2800             CMP      R0,#+0
   \   000001A8   0xD003             BEQ.N    ??gcode_G2_G3_3
   \   000001AA   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   000001AE   0xED8D 0x0A01      VSTR     S0,[SP, #+4]
   3842                }
   3843          
   3844                if (arc_offset[0] || arc_offset[1]) {
   \                     ??gcode_G2_G3_3: (+1)
   \   000001B2   0xED9D 0x0A00      VLDR     S0,[SP, #+0]
   \   000001B6   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   000001BA   0xEEF1 0xFA10      FMSTAT   
   \   000001BE   0xD106             BNE.N    ??gcode_G2_G3_22
   \   000001C0   0xED9D 0x0A01      VLDR     S0,[SP, #+4]
   \   000001C4   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   000001C8   0xEEF1 0xFA10      FMSTAT   
   \   000001CC   0xD007             BEQ.N    ??gcode_G2_G3_23
   3845          
   3846                  #if ENABLED(ARC_P_CIRCLES)
   3847                    // P indicates number of circles to do
   3848                    int8_t circles_to_do = parser.byteval('P');
   3849                    if (!WITHIN(circles_to_do, 0, 100)) {
   3850                      SERIAL_ERROR_START();
   3851                      SERIAL_ERRORLNPGM(MSG_ERR_ARC_ARGS);
   3852                    }
   3853                    while (circles_to_do--)
   3854                      plan_arc(current_position, arc_offset, clockwise);
   3855                  #endif
   3856          
   3857                  // Send the arc to the planner
   3858                  plan_arc(destination, arc_offset, clockwise);
   \                     ??gcode_G2_G3_22: (+1)
   \   000001CE   0x4622             MOV      R2,R4
   \   000001D0   0xA900             ADD      R1,SP,#+0
   \   000001D2   0x480D             LDR.N    R0,??gcode_G2_G3_2+0x14
   \   000001D4   0x.... 0x....      BL       _Z8plan_arcRA4_KfRA2_S_b
   3859                  refresh_cmd_timeout();
   \   000001D8   0x.... 0x....      BL       _Z19refresh_cmd_timeoutv
   \   000001DC   0xE005             B.N      ??gcode_G2_G3_0
   3860                }
   3861                else {
   3862                  // Bad arguments
   3863                  SERIAL_ERROR_START();
   \                     ??gcode_G2_G3_23: (+1)
   \   000001DE   0x480B             LDR.N    R0,??gcode_G2_G3_2+0x18
   \   000001E0   0x.... 0x....      BL       _Z14serialprintPGMPKc
   3864                  SERIAL_ERRORLNPGM(MSG_ERR_ARC_ARGS);
   \   000001E4   0x4803             LDR.N    R0,??gcode_G2_G3_2
   \   000001E6   0x.... 0x....      BL       _Z14serialprintPGMPKc
   3865                }
   3866              }
   3867            }
   \                     ??gcode_G2_G3_0: (+1)
   \   000001EA   0xB002             ADD      SP,SP,#+8
   \   000001EC   0xECBD 0x8B0E      VPOP     {D8-D14}
   \   000001F0   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \   000001F2   0xBF00             Nop      
   \                     ??gcode_G2_G3_2:
   \   000001F4   0x........         DC32     _ZZ11gcode_G2_G3bEs
   \   000001F8   0x........         DC32     axis_relative_modes
   \   000001FC   0x3FE00000         DC32     0x3fe00000
   \   00000200   0x00000000         DC32     0x0,0x3FF00000
   \              0x3FF00000   
   \   00000208   0x........         DC32     axis_relative_modes+0x34
   \   0000020C   0x........         DC32     errormagic
   3868          
   3869          #endif // ARC_SUPPORT
   3870          

   \                                 In section .text, align 2, keep-with-next
   3871          void dwell(millis_t time) {
   \                     _Z5dwellm: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   3872            refresh_cmd_timeout();
   \   00000004   0x.... 0x....      BL       _Z19refresh_cmd_timeoutv
   3873            time += previous_cmd_ms;
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable118
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x1904             ADDS     R4,R0,R4
   \   00000010   0xE001             B.N      ??dwell_0
   3874            while (PENDING(millis(), time)) idle();
   \                     ??dwell_1: (+1)
   \   00000012   0x.... 0x....      BL       _Z4idlev
   \                     ??dwell_0: (+1)
   \   00000016   0x.... 0x....      BL       HAL_GetTick
   \   0000001A   0x1B00             SUBS     R0,R0,R4
   \   0000001C   0xD4F9             BMI.N    ??dwell_1
   3875          }
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
   3876          
   3877          /**
   3878           * G4: Dwell S<seconds> or P<milliseconds>
   3879           */

   \                                 In section .text, align 4
   3880          inline void gcode_G4() {
   \                     _Z8gcode_G4v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   3881            millis_t dwell_ms = 0;
   \   00000002   0x2400             MOVS     R4,#+0
   3882          
   3883            if (parser.seenval('P')) dwell_ms = parser.value_millis(); // milliseconds to wait
   \   00000004   0x2050             MOVS     R0,#+80
   \   00000006   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD002             BEQ.N    ??gcode_G4_0
   \   0000000E   0x.... 0x....      BL       _ZN11GCodeParser12value_millisEv
   \   00000012   0x4604             MOV      R4,R0
   3884            if (parser.seenval('S')) dwell_ms = parser.value_millis_from_seconds(); // seconds to wait
   \                     ??gcode_G4_0: (+1)
   \   00000014   0x2053             MOVS     R0,#+83
   \   00000016   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD002             BEQ.N    ??gcode_G4_1
   \   0000001E   0x.... 0x....      BL       _ZN11GCodeParser25value_millis_from_secondsEv
   \   00000022   0x4604             MOV      R4,R0
   3885          
   3886            stepper.synchronize();
   \                     ??gcode_G4_1: (+1)
   \   00000024   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   3887            #if ENABLED(NANODLP_Z_SYNC)
   3888              SERIAL_ECHOLNPGM(MSG_Z_MOVE_COMP);
   3889            #endif
   3890          
   3891            if (!lcd_hasstatus()) LCD_MESSAGEPGM(MSG_DWELL);
   \   00000028   0x.... 0x....      BL       _Z13lcd_hasstatusv
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD103             BNE.N    ??gcode_G4_2
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x4804             LDR.N    R0,??gcode_G4_3
   \   00000034   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   3892          
   3893            dwell(dwell_ms);
   \                     ??gcode_G4_2: (+1)
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000003E   0x.... 0x....      B.W      _Z5dwellm
   \   00000042   0xBF00             Nop      
   \                     ??gcode_G4_3:
   \   00000044   0x........         DC32     _ZZ8gcode_G4vEs
   3894          }
   3895          
   3896          #if ENABLED(BEZIER_CURVE_SUPPORT)
   3897          
   3898            /**
   3899             * Parameters interpreted according to:
   3900             * http://linuxcnc.org/docs/2.6/html/gcode/gcode.html#sec:G5-Cubic-Spline
   3901             * However I, J omission is not supported at this point; all
   3902             * parameters can be omitted and default to zero.
   3903             */
   3904          
   3905            /**
   3906             * G5: Cubic B-spline
   3907             */
   3908            inline void gcode_G5() {
   3909              #if ENABLED(NO_MOTION_BEFORE_HOMING)
   3910                if (axis_unhomed_error()) return;
   3911              #endif
   3912          
   3913              if (IsRunning()) {
   3914          
   3915                #if ENABLED(CNC_WORKSPACE_PLANES)
   3916                  if (workspace_plane != PLANE_XY) {
   3917                    SERIAL_ERROR_START();
   3918                    SERIAL_ERRORLNPGM(MSG_ERR_BAD_PLANE_MODE);
   3919                    return;
   3920                  }
   3921                #endif
   3922          
   3923                gcode_get_destination();
   3924          
   3925                const float offset[] = {
   3926                  parser.linearval('I'),
   3927                  parser.linearval('J'),
   3928                  parser.linearval('P'),
   3929                  parser.linearval('Q')
   3930                };
   3931          
   3932                plan_cubic_move(offset);
   3933              }
   3934            }
   3935          
   3936          #endif // BEZIER_CURVE_SUPPORT
   3937          
   3938          #if ENABLED(FWRETRACT)
   3939          
   3940            /**
   3941             * G10 - Retract filament according to settings of M207
   3942             */
   3943            inline void gcode_G10() {
   3944              #if EXTRUDERS > 1
   3945                const bool rs = parser.boolval('S');
   3946                retracted_swap[active_extruder] = rs; // Use 'S' for swap, default to false
   3947              #endif
   3948              retract(true
   3949                #if EXTRUDERS > 1
   3950                  , rs
   3951                #endif
   3952              );
   3953            }
   3954          
   3955            /**
   3956             * G11 - Recover filament according to settings of M208
   3957             */
   3958            inline void gcode_G11() { retract(false); }
   3959          
   3960          #endif // FWRETRACT
   3961          
   3962          #if ENABLED(NOZZLE_CLEAN_FEATURE)
   3963            /**
   3964             * G12: Clean the nozzle
   3965             */
   3966            inline void gcode_G12() {
   3967              // Don't allow nozzle cleaning without homing first
   3968              if (axis_unhomed_error()) return;
   3969          
   3970              const uint8_t pattern = parser.ushortval('P', 0),
   3971                            strokes = parser.ushortval('S', NOZZLE_CLEAN_STROKES),
   3972                            objects = parser.ushortval('T', NOZZLE_CLEAN_TRIANGLES);
   3973              const float radius = parser.floatval('R', NOZZLE_CLEAN_CIRCLE_RADIUS);
   3974          
   3975              Nozzle::clean(pattern, strokes, radius, objects);
   3976            }
   3977          #endif
   3978          
   3979          #if ENABLED(CNC_WORKSPACE_PLANES)
   3980          
   3981            inline void report_workspace_plane() {
   3982              SERIAL_ECHO_START();
   3983              SERIAL_ECHOPGM("Workspace Plane ");
   3984              serialprintPGM(
   3985                workspace_plane == PLANE_YZ ? PSTR("YZ\n") :
   3986                workspace_plane == PLANE_ZX ? PSTR("ZX\n") :
   3987                                              PSTR("XY\n")
   3988              );
   3989            }
   3990          
   3991            inline void set_workspace_plane(const WorkspacePlane plane) {
   3992              workspace_plane = plane;
   3993              if (DEBUGGING(INFO)) report_workspace_plane();
   3994            }
   3995          
   3996            /**
   3997             * G17: Select Plane XY
   3998             * G18: Select Plane ZX
   3999             * G19: Select Plane YZ
   4000             */
   4001            inline void gcode_G17() { set_workspace_plane(PLANE_XY); }
   4002            inline void gcode_G18() { set_workspace_plane(PLANE_ZX); }
   4003            inline void gcode_G19() { set_workspace_plane(PLANE_YZ); }
   4004          
   4005          #endif // CNC_WORKSPACE_PLANES
   4006          
   4007          #if ENABLED(CNC_COORDINATE_SYSTEMS)
   4008          
   4009            /**
   4010             * Select a coordinate system and update the workspace offset.
   4011             * System index -1 is used to specify machine-native.
   4012             */
   4013            bool select_coordinate_system(const int8_t _new) {
   4014              if (active_coordinate_system == _new) return false;
   4015              float old_offset[XYZ] = { 0 }, new_offset[XYZ] = { 0 };
   4016              if (WITHIN(active_coordinate_system, 0, MAX_COORDINATE_SYSTEMS - 1))
   4017                COPY(old_offset, coordinate_system[active_coordinate_system]);
   4018              if (WITHIN(_new, 0, MAX_COORDINATE_SYSTEMS - 1))
   4019                COPY(new_offset, coordinate_system[_new]);
   4020              active_coordinate_system = _new;
   4021              LOOP_XYZ(i) {
   4022                const float diff = new_offset[i] - old_offset[i];
   4023                if (diff) {
   4024                  position_shift[i] += diff;
   4025                  update_software_endstops((AxisEnum)i);
   4026                }
   4027              }
   4028              return true;
   4029            }
   4030          
   4031            /**
   4032             * In CNC G-code G53 is like a modifier
   4033             * It precedes a movement command (or other modifiers) on the same line.
   4034             * This is the first command to use parser.chain() to make this possible.
   4035             */
   4036            inline void gcode_G53() {
   4037              // If this command has more following...
   4038              if (parser.chain()) {
   4039                const int8_t _system = active_coordinate_system;
   4040                active_coordinate_system = -1;
   4041                process_parsed_command();
   4042                active_coordinate_system = _system;
   4043              }
   4044            }
   4045          
   4046            /**
   4047             * G54-G59.3: Select a new workspace
   4048             *
   4049             * A workspace is an XYZ offset to the machine native space.
   4050             * All workspaces default to 0,0,0 at start, or with EEPROM
   4051             * support they may be restored from a previous session.
   4052             *
   4053             * G92 is used to set the current workspace's offset.
   4054             */
   4055            inline void gcode_G54_59(uint8_t subcode=0) {
   4056              const int8_t _space = parser.codenum - 54 + subcode;
   4057              if (select_coordinate_system(_space)) {
   4058                SERIAL_PROTOCOLLNPAIR("Select workspace ", _space);
   4059                report_current_position();
   4060              }
   4061            }
   4062            FORCE_INLINE void gcode_G54() { gcode_G54_59(); }
   4063            FORCE_INLINE void gcode_G55() { gcode_G54_59(); }
   4064            FORCE_INLINE void gcode_G56() { gcode_G54_59(); }
   4065            FORCE_INLINE void gcode_G57() { gcode_G54_59(); }
   4066            FORCE_INLINE void gcode_G58() { gcode_G54_59(); }
   4067            FORCE_INLINE void gcode_G59() { gcode_G54_59(parser.subcode); }
   4068          
   4069          #endif
   4070          
   4071          #if ENABLED(INCH_MODE_SUPPORT)
   4072            /**
   4073             * G20: Set input mode to inches
   4074             */
   4075            inline void gcode_G20() { parser.set_input_linear_units(LINEARUNIT_INCH); }
   4076          
   4077            /**
   4078             * G21: Set input mode to millimeters
   4079             */
   4080            inline void gcode_G21() { parser.set_input_linear_units(LINEARUNIT_MM); }
   4081          #endif
   4082          
   4083          #if ENABLED(NOZZLE_PARK_FEATURE)
   4084            /**
   4085             * G27: Park the nozzle
   4086             */
   4087            inline void gcode_G27() {
   4088              // Don't allow nozzle parking without homing first
   4089              if (axis_unhomed_error()) return;
   4090              Nozzle::park(parser.ushortval('P'));
   4091            }
   4092          #endif // NOZZLE_PARK_FEATURE
   4093          
   4094          #if ENABLED(QUICK_HOME)
   4095          
   4096            static void quick_home_xy() {
   4097          
   4098              // Pretend the current position is 0,0
   4099              current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
   4100              sync_plan_position();
   4101          
   4102              const int x_axis_home_dir =
   4103                #if ENABLED(DUAL_X_CARRIAGE)
   4104                  x_home_dir(active_extruder)
   4105                #else
   4106                  home_dir(X_AXIS)
   4107                #endif
   4108              ;
   4109          
   4110              const float mlx = max_length(X_AXIS),
   4111                          mly = max_length(Y_AXIS),
   4112                          mlratio = mlx > mly ? mly / mlx : mlx / mly,
   4113                          fr_mm_s = min(homing_feedrate_mm_s[X_AXIS], homing_feedrate_mm_s[Y_AXIS]) * SQRT(sq(mlratio) + 1.0);
   4114          
   4115              do_blocking_move_to_xy(1.5 * mlx * x_axis_home_dir, 1.5 * mly * home_dir(Y_AXIS), fr_mm_s);
   4116              endstops.hit_on_purpose(); // clear endstop hit flags
   4117              current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
   4118            }
   4119          
   4120          #endif // QUICK_HOME
   4121          
   4122          #if ENABLED(DEBUG_LEVELING_FEATURE)
   4123          
   4124            void log_machine_info() {
   4125              SERIAL_ECHOPGM("Machine Type: ");
   4126              #if ENABLED(DELTA)
   4127                SERIAL_ECHOLNPGM("Delta");
   4128              #elif IS_SCARA
   4129                SERIAL_ECHOLNPGM("SCARA");
   4130              #elif IS_CORE
   4131                SERIAL_ECHOLNPGM("Core");
   4132              #else
   4133                SERIAL_ECHOLNPGM("Cartesian");
   4134              #endif
   4135          
   4136              SERIAL_ECHOPGM("Probe: ");
   4137              #if ENABLED(PROBE_MANUALLY)
   4138                SERIAL_ECHOLNPGM("PROBE_MANUALLY");
   4139              #elif ENABLED(FIX_MOUNTED_PROBE)
   4140                SERIAL_ECHOLNPGM("FIX_MOUNTED_PROBE");
   4141              #elif ENABLED(BLTOUCH)
   4142                SERIAL_ECHOLNPGM("BLTOUCH");
   4143              #elif HAS_Z_SERVO_ENDSTOP
   4144                SERIAL_ECHOLNPGM("SERVO PROBE");
   4145              #elif ENABLED(Z_PROBE_SLED)
   4146                SERIAL_ECHOLNPGM("Z_PROBE_SLED");
   4147              #elif ENABLED(Z_PROBE_ALLEN_KEY)
   4148                SERIAL_ECHOLNPGM("Z_PROBE_ALLEN_KEY");
   4149              #else
   4150                SERIAL_ECHOLNPGM("NONE");
   4151              #endif
   4152          
   4153              #if HAS_BED_PROBE
   4154                SERIAL_ECHOPAIR("Probe Offset X:", X_PROBE_OFFSET_FROM_EXTRUDER);
   4155                SERIAL_ECHOPAIR(" Y:", Y_PROBE_OFFSET_FROM_EXTRUDER);
   4156                SERIAL_ECHOPAIR(" Z:", zprobe_zoffset);
   4157                #if X_PROBE_OFFSET_FROM_EXTRUDER > 0
   4158                  SERIAL_ECHOPGM(" (Right");
   4159                #elif X_PROBE_OFFSET_FROM_EXTRUDER < 0
   4160                  SERIAL_ECHOPGM(" (Left");
   4161                #elif Y_PROBE_OFFSET_FROM_EXTRUDER != 0
   4162                  SERIAL_ECHOPGM(" (Middle");
   4163                #else
   4164                  SERIAL_ECHOPGM(" (Aligned With");
   4165                #endif
   4166                #if Y_PROBE_OFFSET_FROM_EXTRUDER > 0
   4167                  SERIAL_ECHOPGM("-Back");
   4168                #elif Y_PROBE_OFFSET_FROM_EXTRUDER < 0
   4169                  SERIAL_ECHOPGM("-Front");
   4170                #elif X_PROBE_OFFSET_FROM_EXTRUDER != 0
   4171                  SERIAL_ECHOPGM("-Center");
   4172                #endif
   4173                if (zprobe_zoffset < 0)
   4174                  SERIAL_ECHOPGM(" & Below");
   4175                else if (zprobe_zoffset > 0)
   4176                  SERIAL_ECHOPGM(" & Above");
   4177                else
   4178                  SERIAL_ECHOPGM(" & Same Z as");
   4179                SERIAL_ECHOLNPGM(" Nozzle)");
   4180              #endif
   4181          
   4182              #if HAS_ABL
   4183                SERIAL_ECHOPGM("Auto Bed Leveling: ");
   4184                #if ENABLED(AUTO_BED_LEVELING_LINEAR)
   4185                  SERIAL_ECHOPGM("LINEAR");
   4186                #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
   4187                  SERIAL_ECHOPGM("BILINEAR");
   4188                #elif ENABLED(AUTO_BED_LEVELING_3POINT)
   4189                  SERIAL_ECHOPGM("3POINT");
   4190                #elif ENABLED(AUTO_BED_LEVELING_UBL)
   4191                  SERIAL_ECHOPGM("UBL");
   4192                #endif
   4193                if (planner.leveling_active) {
   4194                  SERIAL_ECHOLNPGM(" (enabled)");
   4195                  #if ABL_PLANAR
   4196                    const float diff[XYZ] = {
   4197                      stepper.get_axis_position_mm(X_AXIS) - current_position[X_AXIS],
   4198                      stepper.get_axis_position_mm(Y_AXIS) - current_position[Y_AXIS],
   4199                      stepper.get_axis_position_mm(Z_AXIS) - current_position[Z_AXIS]
   4200                    };
   4201                    SERIAL_ECHOPGM("ABL Adjustment X");
   4202                    if (diff[X_AXIS] > 0) SERIAL_CHAR('+');
   4203                    SERIAL_ECHO(diff[X_AXIS]);
   4204                    SERIAL_ECHOPGM(" Y");
   4205                    if (diff[Y_AXIS] > 0) SERIAL_CHAR('+');
   4206                    SERIAL_ECHO(diff[Y_AXIS]);
   4207                    SERIAL_ECHOPGM(" Z");
   4208                    if (diff[Z_AXIS] > 0) SERIAL_CHAR('+');
   4209                    SERIAL_ECHO(diff[Z_AXIS]);
   4210                  #elif ENABLED(AUTO_BED_LEVELING_UBL)
   4211                    SERIAL_ECHOPAIR("UBL Adjustment Z", stepper.get_axis_position_mm(Z_AXIS) - current_position[Z_AXIS]);
   4212                  #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
   4213                    SERIAL_ECHOPAIR("ABL Adjustment Z", bilinear_z_offset(current_position));
   4214                  #endif
   4215                }
   4216                else
   4217                  SERIAL_ECHOLNPGM(" (disabled)");
   4218          
   4219                SERIAL_EOL();
   4220          
   4221              #elif ENABLED(MESH_BED_LEVELING)
   4222          
   4223                SERIAL_ECHOPGM("Mesh Bed Leveling");
   4224                if (planner.leveling_active) {
   4225                  float rz = current_position[Z_AXIS];
   4226                  planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], rz);
   4227                  SERIAL_ECHOLNPGM(" (enabled)");
   4228                  SERIAL_ECHOPAIR("MBL Adjustment Z", rz);
   4229                }
   4230                else
   4231                  SERIAL_ECHOPGM(" (disabled)");
   4232          
   4233                SERIAL_EOL();
   4234          
   4235              #endif // MESH_BED_LEVELING
   4236            }
   4237          
   4238          #endif // DEBUG_LEVELING_FEATURE
   4239          
   4240          #if ENABLED(DELTA)
   4241          
   4242            /**
   4243             * A delta can only safely home all axes at the same time
   4244             * This is like quick_home_xy() but for 3 towers.
   4245             */
   4246            inline bool home_delta() {
   4247              #if ENABLED(DEBUG_LEVELING_FEATURE)
   4248                if (DEBUGGING(LEVELING)) DEBUG_POS(">>> home_delta", current_position);
   4249              #endif
   4250              // Init the current position of all carriages to 0,0,0
   4251              ZERO(current_position);
   4252              sync_plan_position();
   4253          
   4254              // Move all carriages together linearly until an endstop is hit.
   4255              current_position[X_AXIS] = current_position[Y_AXIS] = current_position[Z_AXIS] = (delta_height + 10);
   4256              feedrate_mm_s = homing_feedrate_mm_s[X_AXIS];
   4257              buffer_line_to_current_position();
   4258              stepper.synchronize();
   4259          
   4260              // If an endstop was not hit, then damage can occur if homing is continued.
   4261              // This can occur if the delta height not set correctly.
   4262              if (!(Endstops::endstop_hit_bits & (_BV(X_MAX) | _BV(Y_MAX) | _BV(Z_MAX)))) {
   4263                LCD_MESSAGEPGM(MSG_ERR_HOMING_FAILED);
   4264                SERIAL_ERROR_START();
   4265                SERIAL_ERRORLNPGM(MSG_ERR_HOMING_FAILED);
   4266                return false;
   4267              }
   4268          
   4269              endstops.hit_on_purpose(); // clear endstop hit flags
   4270          
   4271              // At least one carriage has reached the top.
   4272              // Now re-home each carriage separately.
   4273              HOMEAXIS(A);
   4274              HOMEAXIS(B);
   4275              HOMEAXIS(C);
   4276          
   4277              // Set all carriages to their home positions
   4278              // Do this here all at once for Delta, because
   4279              // XYZ isn't ABC. Applying this per-tower would
   4280              // give the impression that they are the same.
   4281              LOOP_XYZ(i) set_axis_is_at_home((AxisEnum)i);
   4282          
   4283              SYNC_PLAN_POSITION_KINEMATIC();
   4284          
   4285              #if ENABLED(DEBUG_LEVELING_FEATURE)
   4286                if (DEBUGGING(LEVELING)) DEBUG_POS("<<< home_delta", current_position);
   4287              #endif
   4288          
   4289              return true;
   4290            }
   4291          
   4292          #endif // DELTA
   4293          
   4294          #if ENABLED(Z_SAFE_HOMING)
   4295          
   4296            inline void home_z_safely() {
   4297          
   4298              // Disallow Z homing if X or Y are unknown
   4299              if (!axis_known_position[X_AXIS] || !axis_known_position[Y_AXIS]) {
   4300                LCD_MESSAGEPGM(MSG_ERR_Z_HOMING);
   4301                SERIAL_ECHO_START();
   4302                SERIAL_ECHOLNPGM(MSG_ERR_Z_HOMING);
   4303                return;
   4304              }
   4305          
   4306              #if ENABLED(DEBUG_LEVELING_FEATURE)
   4307                if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Z_SAFE_HOMING >>>");
   4308              #endif
   4309          
   4310              SYNC_PLAN_POSITION_KINEMATIC();
   4311          
   4312              /**
   4313               * Move the Z probe (or just the nozzle) to the safe homing point
   4314               */
   4315              destination[X_AXIS] = Z_SAFE_HOMING_X_POINT;
   4316              destination[Y_AXIS] = Z_SAFE_HOMING_Y_POINT;
   4317              destination[Z_AXIS] = current_position[Z_AXIS]; // Z is already at the right height
   4318          
   4319              #if HOMING_Z_WITH_PROBE
   4320                destination[X_AXIS] -= X_PROBE_OFFSET_FROM_EXTRUDER;
   4321                destination[Y_AXIS] -= Y_PROBE_OFFSET_FROM_EXTRUDER;
   4322              #endif
   4323          
   4324              if (position_is_reachable(destination[X_AXIS], destination[Y_AXIS])) {
   4325          
   4326                #if ENABLED(DEBUG_LEVELING_FEATURE)
   4327                  if (DEBUGGING(LEVELING)) DEBUG_POS("Z_SAFE_HOMING", destination);
   4328                #endif
   4329          
   4330                // This causes the carriage on Dual X to unpark
   4331                #if ENABLED(DUAL_X_CARRIAGE)
   4332                  active_extruder_parked = false;
   4333                #endif
   4334          
   4335                do_blocking_move_to_xy(destination[X_AXIS], destination[Y_AXIS]);
   4336                HOMEAXIS(Z);
   4337              }
   4338              else {
   4339                LCD_MESSAGEPGM(MSG_ZPROBE_OUT);
   4340                SERIAL_ECHO_START();
   4341                SERIAL_ECHOLNPGM(MSG_ZPROBE_OUT);
   4342              }
   4343          
   4344              #if ENABLED(DEBUG_LEVELING_FEATURE)
   4345                if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< Z_SAFE_HOMING");
   4346              #endif
   4347            }
   4348          
   4349          #endif // Z_SAFE_HOMING
   4350          
   4351          #if ENABLED(PROBE_MANUALLY)
   4352            bool g29_in_progress = false;
   4353          #else
   4354            constexpr bool g29_in_progress = false;
   4355          #endif
   4356          
   4357          /**
   4358           * G28: Home all axes according to settings
   4359           *
   4360           * Parameters
   4361           *
   4362           *  None  Home to all axes with no parameters.
   4363           *        With QUICK_HOME enabled XY will home together, then Z.
   4364           *
   4365           * Cartesian parameters
   4366           *
   4367           *  X   Home to the X endstop
   4368           *  Y   Home to the Y endstop
   4369           *  Z   Home to the Z endstop
   4370           *
   4371           */

   \                                 In section .text, align 4
   4372          inline void gcode_G28(const bool always_home_all) {
   \                     _Z9gcode_G28b: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4605             MOV      R5,R0
   4373          
   4374            #if ENABLED(DEBUG_LEVELING_FEATURE)
   4375              if (DEBUGGING(LEVELING)) {
   4376                SERIAL_ECHOLNPGM(">>> gcode_G28");
   4377                log_machine_info();
   4378              }
   4379            #endif
   4380          
   4381            // Wait for planner moves to finish!
   4382            stepper.synchronize();
   \   00000008   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   4383          
   4384            // Cancel the active G29 session
   4385            #if ENABLED(PROBE_MANUALLY)
   4386              g29_in_progress = false;
   4387            #endif
   4388          
   4389            // Disable the leveling matrix before homing
   4390            #if HAS_LEVELING
   4391              #if ENABLED(AUTO_BED_LEVELING_UBL)
   4392                const bool ubl_state_at_entry = planner.leveling_active;
   4393              #endif
   4394              set_bed_leveling_enabled(false);
   4395            #endif
   4396          
   4397            #if ENABLED(CNC_WORKSPACE_PLANES)
   4398              workspace_plane = PLANE_XY;
   4399            #endif
   4400          
   4401            // Always home with tool 0 active
   4402            #if HOTENDS > 1
   4403              const uint8_t old_tool_index = active_extruder;
   4404              tool_change(0, 0, true);
   4405            #endif
   4406          
   4407            #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
   4408              extruder_duplication_enabled = false;
   4409            #endif
   4410          
   4411            setup_for_endstop_or_probe_move();
   \   0000000C   0x.... 0x....      BL       _Z31setup_for_endstop_or_probe_movev
   4412            #if ENABLED(DEBUG_LEVELING_FEATURE)
   4413              if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> endstops.enable(true)");
   4414            #endif
   4415            endstops.enable(true); // Enable endstops for next homing move
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x.... 0x....      BL       _ZN8Endstops6enableEb
   4416          
   4417            #if ENABLED(DELTA)
   4418          
   4419              home_delta();
   4420              UNUSED(always_home_all);
   4421          
   4422            #else // NOT DELTA
   4423          
   4424              const bool homeX = always_home_all || parser.seen('X'),
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD104             BNE.N    ??gcode_G28_0
   \   0000001A   0x2058             MOVS     R0,#+88
   \   0000001C   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000020   0x4606             MOV      R6,R0
   \   00000022   0xE000             B.N      ??gcode_G28_1
   \                     ??gcode_G28_0: (+1)
   \   00000024   0x2601             MOVS     R6,#+1
   4425                         homeY = always_home_all || parser.seen('Y'),
   \                     ??gcode_G28_1: (+1)
   \   00000026   0x2D00             CMP      R5,#+0
   \   00000028   0xD104             BNE.N    ??gcode_G28_2
   \   0000002A   0x2059             MOVS     R0,#+89
   \   0000002C   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000030   0x4604             MOV      R4,R0
   \   00000032   0xE000             B.N      ??gcode_G28_3
   \                     ??gcode_G28_2: (+1)
   \   00000034   0x2401             MOVS     R4,#+1
   4426                         homeZ = always_home_all || parser.seen('Z'),
   \                     ??gcode_G28_3: (+1)
   \   00000036   0x2D00             CMP      R5,#+0
   \   00000038   0xD104             BNE.N    ??gcode_G28_4
   \   0000003A   0x205A             MOVS     R0,#+90
   \   0000003C   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000040   0x4605             MOV      R5,R0
   \   00000042   0xE000             B.N      ??gcode_G28_5
   \                     ??gcode_G28_4: (+1)
   \   00000044   0x2501             MOVS     R5,#+1
   4427                         home_all = (!homeX && !homeY && !homeZ) || (homeX && homeY && homeZ);
   \                     ??gcode_G28_5: (+1)
   \   00000046   0xEA44 0x0006      ORR      R0,R4,R6
   \   0000004A   0x4328             ORRS     R0,R5,R0
   \   0000004C   0xF080 0x0001      EOR      R0,R0,#0x1
   \   00000050   0xEA04 0x0106      AND      R1,R4,R6
   \   00000054   0x4029             ANDS     R1,R5,R1
   \   00000056   0xEA41 0x0700      ORR      R7,R1,R0
   4428          
   4429              set_destination_from_current();
   \   0000005A   0x.... 0x....      BL       _Z28set_destination_from_currentv
   4430          
   4431              //#if Z_HOME_DIR > 0  // If homing away from BED do Z first
   4432          if(Z_HOME_DIR > 0)
   \   0000005E   0xF8DF 0x8080      LDR.W    R8,??gcode_G28_6
   \   00000062   0xF998 0x0001      LDRSB    R0,[R8, #+1]
   \   00000066   0x2801             CMP      R0,#+1
   \   00000068   0xDB05             BLT.N    ??gcode_G28_7
   4433          {
   4434                if (home_all || homeZ) {
   \   0000006A   0xEA55 0x0007      ORRS     R0,R5,R7
   \   0000006E   0xD002             BEQ.N    ??gcode_G28_7
   4435                  HOMEAXIS(Z);
   \   00000070   0x2002             MOVS     R0,#+2
   \   00000072   0x.... 0x....      BL       _Z8homeaxis8AxisEnum
   4436                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   4437                    if (DEBUGGING(LEVELING)) DEBUG_POS("> HOMEAXIS(Z)", current_position);
   4438                  #endif
   4439                }
   4440          }
   4441              //#endif
   4442          
   4443              if (home_all || homeX || homeY) {
   \                     ??gcode_G28_7: (+1)
   \   00000076   0x433E             ORRS     R6,R6,R7
   \   00000078   0xEA54 0x0006      ORRS     R0,R4,R6
   \   0000007C   0xD00E             BEQ.N    ??gcode_G28_8
   4444                // Raise Z before homing any other axes and z is not already high enough (never lower z)
   4445                destination[Z_AXIS] = Z_HOMING_HEIGHT;
   \   0000007E   0x4819             LDR.N    R0,??gcode_G28_6+0x4
   \   00000080   0x2100             MOVS     R1,#+0
   \   00000082   0x63C1             STR      R1,[R0, #+60]
   4446                if (destination[Z_AXIS] > current_position[Z_AXIS]) {
   \   00000084   0xED90 0x0A0B      VLDR     S0,[R0, #+44]
   \   00000088   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   0000008C   0xEEF1 0xFA10      FMSTAT   
   \   00000090   0xD504             BPL.N    ??gcode_G28_8
   4447          
   4448                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   4449                    if (DEBUGGING(LEVELING))
   4450                      SERIAL_ECHOLNPAIR("Raise Z (before homing) to ", destination[Z_AXIS]);
   4451                  #endif
   4452          
   4453                  do_blocking_move_to_z(destination[Z_AXIS]);
   \   00000092   0x9100             STR      R1,[SP, #+0]
   \   00000094   0xA900             ADD      R1,SP,#+0
   \   00000096   0x303C             ADDS     R0,R0,#+60
   \   00000098   0x.... 0x....      BL       _Z21do_blocking_move_to_zRKfS0_
   4454                }
   4455              }
   4456          
   4457              #if ENABLED(QUICK_HOME)
   4458          
   4459                if (home_all || (homeX && homeY)) quick_home_xy();
   4460          
   4461              #endif
   4462          
   4463              #if ENABLED(HOME_Y_BEFORE_X)
   4464          
   4465                // Home Y
   4466                if (home_all || homeY) {
   4467                  HOMEAXIS(Y);
   4468                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   4469                    if (DEBUGGING(LEVELING)) DEBUG_POS("> homeY", current_position);
   4470                  #endif
   4471                }
   4472          
   4473              #endif
   4474          
   4475              // Home X
   4476              if (home_all || homeX) {
   \                     ??gcode_G28_8: (+1)
   \   0000009C   0x2E00             CMP      R6,#+0
   \   0000009E   0xD002             BEQ.N    ??gcode_G28_9
   4477          
   4478                #if ENABLED(DUAL_X_CARRIAGE)
   4479          
   4480                  // Always home the 2nd (right) extruder first
   4481                  active_extruder = 1;
   4482                  HOMEAXIS(X);
   4483          
   4484                  // Remember this extruder's position for later tool change
   4485                  inactive_extruder_x_pos = current_position[X_AXIS];
   4486          
   4487                  // Home the 1st (left) extruder
   4488                  active_extruder = 0;
   4489                  HOMEAXIS(X);
   4490          
   4491                  // Consider the active extruder to be parked
   4492                  COPY(raised_parked_position, current_position);
   4493                  delayed_move_time = 0;
   4494                  active_extruder_parked = true;
   4495          
   4496                #else
   4497          
   4498                  HOMEAXIS(X);
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0x.... 0x....      BL       _Z8homeaxis8AxisEnum
   4499          
   4500                #endif
   4501          
   4502                #if ENABLED(DEBUG_LEVELING_FEATURE)
   4503                  if (DEBUGGING(LEVELING)) DEBUG_POS("> homeX", current_position);
   4504                #endif
   4505              }
   4506          
   4507              #if DISABLED(HOME_Y_BEFORE_X)
   4508                // Home Y
   4509                if (home_all || homeY) {
   \                     ??gcode_G28_9: (+1)
   \   000000A6   0xEA54 0x0007      ORRS     R0,R4,R7
   \   000000AA   0xD002             BEQ.N    ??gcode_G28_10
   4510                  HOMEAXIS(Y);
   \   000000AC   0x2001             MOVS     R0,#+1
   \   000000AE   0x.... 0x....      BL       _Z8homeaxis8AxisEnum
   4511                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   4512                    if (DEBUGGING(LEVELING)) DEBUG_POS("> homeY", current_position);
   4513                  #endif
   4514                }
   4515              #endif
   4516          
   4517              // Home Z last if homing towards the bed
   4518              //#if Z_HOME_DIR < 0
   4519              if(Z_HOME_DIR < 0)
   \                     ??gcode_G28_10: (+1)
   \   000000B2   0xF998 0x0001      LDRSB    R0,[R8, #+1]
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD505             BPL.N    ??gcode_G28_11
   4520              {
   4521                if (home_all || homeZ) {
   \   000000BA   0xEA55 0x0007      ORRS     R0,R5,R7
   \   000000BE   0xD002             BEQ.N    ??gcode_G28_11
   4522                  #if ENABLED(Z_SAFE_HOMING)
   4523                    home_z_safely();
   4524                  #else
   4525                    HOMEAXIS(Z);
   \   000000C0   0x2002             MOVS     R0,#+2
   \   000000C2   0x.... 0x....      BL       _Z8homeaxis8AxisEnum
   4526                  #endif
   4527                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   4528                    if (DEBUGGING(LEVELING)) DEBUG_POS("> (home_all || homeZ) > final", current_position);
   4529                  #endif
   4530                } // home_all || homeZ
   4531              }
   4532              //#endif // Z_HOME_DIR < 0
   4533          
   4534              SYNC_PLAN_POSITION_KINEMATIC();
   \                     ??gcode_G28_11: (+1)
   \   000000C6   0x.... 0x....      BL       _Z18sync_plan_positionv
   4535          
   4536            #endif // !DELTA (gcode_G28)
   4537          
   4538            endstops.not_homing();
   \   000000CA   0x.... 0x....      BL       _ZN8Endstops10not_homingEv
   4539          
   4540            #if ENABLED(DELTA) && ENABLED(DELTA_HOME_TO_SAFE_ZONE)
   4541              // move to a height where we can use the full xy-area
   4542              do_blocking_move_to_z(delta_clip_start_height);
   4543            #endif
   4544          
   4545            #if ENABLED(AUTO_BED_LEVELING_UBL)
   4546              set_bed_leveling_enabled(ubl_state_at_entry);
   4547            #endif
   4548          
   4549            clean_up_after_endstop_or_probe_move();
   \   000000CE   0x.... 0x....      BL       _Z36clean_up_after_endstop_or_probe_movev
   4550          
   4551            // Restore the active tool after homing
   4552            #if HOTENDS > 1
   4553              #if ENABLED(PARKING_EXTRUDER)
   4554                #define NO_FETCH false // fetch the previous toolhead
   4555              #else
   4556                #define NO_FETCH true
   4557              #endif
   4558              tool_change(old_tool_index, 0, NO_FETCH);
   4559            #endif
   4560          
   4561            lcd_refresh();
   \   000000D2   0x.... 0x....      BL       _Z11lcd_refreshv
   4562          
   4563            report_current_position();
   \   000000D6   0x.... 0x....      BL       _Z23report_current_positionv
   4564          
   4565            #if ENABLED(NANODLP_Z_SYNC)
   4566              #if ENABLED(NANODLP_ALL_AXIS)
   4567                #define _HOME_SYNC true                 // For any axis, output sync text.
   4568              #else
   4569                #define _HOME_SYNC (home_all || homeZ)  // Only for Z-axis
   4570              #endif
   4571              if (_HOME_SYNC)
   4572                SERIAL_ECHOLNPGM(MSG_Z_MOVE_COMP);
   4573            #endif
   4574          
   4575            #if ENABLED(DEBUG_LEVELING_FEATURE)
   4576              if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< gcode_G28");
   4577            #endif
   4578          } // G28
   \   000000DA   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}  ;; return
   \   000000DE   0xBF00             Nop      
   \                     ??gcode_G28_6:
   \   000000E0   0x........         DC32     mksCfg
   \   000000E4   0x........         DC32     axis_relative_modes
   4579          

   \                                 In section .text, align 2, keep-with-next
   4580          void home_all_axes() { gcode_G28(true); }
   \                     _Z13home_all_axesv: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x.... 0x....      B.W      _Z9gcode_G28b
   4581          
   4582          #if HAS_PROBING_PROCEDURE
   4583          
   4584            void out_of_range_error(const char* p_edge) {
   4585              SERIAL_PROTOCOLPGM("?Probe ");
   4586              serialprintPGM(p_edge);
   4587              SERIAL_PROTOCOLLNPGM(" position out of range.");
   4588            }
   4589          
   4590          #endif
   4591          
   4592          #if ENABLED(MESH_BED_LEVELING) || ENABLED(PROBE_MANUALLY)
   4593          
   4594            #if ENABLED(LCD_BED_LEVELING)
   4595              //extern 
   4596              bool lcd_wait_for_move;
   4597            #else
   4598              constexpr bool lcd_wait_for_move = false;
   4599            #endif
   4600          
   4601            inline void _manual_goto_xy(const float &rx, const float &ry) {
   4602          
   4603              #if MANUAL_PROBE_HEIGHT > 0
   4604                const float prev_z = current_position[Z_AXIS];
   4605                do_blocking_move_to(rx, ry, MANUAL_PROBE_HEIGHT);
   4606                do_blocking_move_to_z(prev_z);
   4607              #else
   4608                do_blocking_move_to_xy(rx, ry);
   4609              #endif
   4610          
   4611              current_position[X_AXIS] = rx;
   4612              current_position[Y_AXIS] = ry;
   4613          
   4614              #if ENABLED(LCD_BED_LEVELING)
   4615                lcd_wait_for_move = false;
   4616              #endif
   4617            }
   4618          
   4619          #endif
   4620          
   4621          #if ENABLED(MESH_BED_LEVELING)
   4622          
   4623            // Save 130 bytes with non-duplication of PSTR
   4624            void echo_not_entered() { SERIAL_PROTOCOLLNPGM(" not entered."); }
   4625          
   4626            void mbl_mesh_report() {
   4627              SERIAL_PROTOCOLLNPGM("Num X,Y: " STRINGIFY(GRID_MAX_POINTS_X) "," STRINGIFY(GRID_MAX_POINTS_Y));
   4628              SERIAL_PROTOCOLPGM("Z offset: "); SERIAL_PROTOCOL_F(mbl.z_offset, 5);
   4629              SERIAL_PROTOCOLLNPGM("\nMeasured points:");
   4630              print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 5,
   4631                [](const uint8_t ix, const uint8_t iy) { return mbl.z_values[ix][iy]; }
   4632              );
   4633            }
   4634          
   4635            /**
   4636             * G29: Mesh-based Z probe, probes a grid and produces a
   4637             *      mesh to compensate for variable bed height
   4638             *
   4639             * Parameters With MESH_BED_LEVELING:
   4640             *
   4641             *  S0              Produce a mesh report
   4642             *  S1              Start probing mesh points
   4643             *  S2              Probe the next mesh point
   4644             *  S3 Xn Yn Zn.nn  Manually modify a single point
   4645             *  S4 Zn.nn        Set z offset. Positive away from bed, negative closer to bed.
   4646             *  S5              Reset and disable mesh
   4647             *
   4648             * The S0 report the points as below
   4649             *
   4650             *  +----> X-axis  1-n
   4651             *  |
   4652             *  |
   4653             *  v Y-axis  1-n
   4654             *
   4655             */
   4656            inline void gcode_G29() {
   4657          
   4658              static int mbl_probe_index = -1;
   4659              #if HAS_SOFTWARE_ENDSTOPS
   4660                static bool enable_soft_endstops;
   4661              #endif
   4662          
   4663              const MeshLevelingState state = (MeshLevelingState)parser.byteval('S', (int8_t)MeshReport);
   4664              if (!WITHIN(state, 0, 5)) {
   4665                SERIAL_PROTOCOLLNPGM("S out of range (0-5).");
   4666                return;
   4667              }
   4668          
   4669              int8_t px, py;
   4670          
   4671              switch (state) {
   4672                case MeshReport:
   4673                  if (leveling_is_valid()) {
   4674                    SERIAL_PROTOCOLLNPAIR("State: ", planner.leveling_active ? MSG_ON : MSG_OFF);
   4675                    mbl_mesh_report();
   4676                  }
   4677                  else
   4678                    SERIAL_PROTOCOLLNPGM("Mesh bed leveling has no data.");
   4679                  break;
   4680          
   4681                case MeshStart:
   4682                  mbl.reset();
   4683                  mbl_probe_index = 0;
   4684                  enqueue_and_echo_commands_P(lcd_wait_for_move ? PSTR("G29 S2") : PSTR("G28\nG29 S2"));
   4685                  break;
   4686          
   4687                case MeshNext:
   4688                  if (mbl_probe_index < 0) {
   4689                    SERIAL_PROTOCOLLNPGM("Start mesh probing with \"G29 S1\" first.");
   4690                    return;
   4691                  }
   4692                  // For each G29 S2...
   4693                  if (mbl_probe_index == 0) {
   4694                    #if HAS_SOFTWARE_ENDSTOPS
   4695                      // For the initial G29 S2 save software endstop state
   4696                      enable_soft_endstops = soft_endstops_enabled;
   4697                    #endif
   4698                  }
   4699                  else {
   4700                    // For G29 S2 after adjusting Z.
   4701                    mbl.set_zigzag_z(mbl_probe_index - 1, current_position[Z_AXIS]);
   4702                    #if HAS_SOFTWARE_ENDSTOPS
   4703                      soft_endstops_enabled = enable_soft_endstops;
   4704                    #endif
   4705                  }
   4706                  // If there's another point to sample, move there with optional lift.
   4707                  if (mbl_probe_index < GRID_MAX_POINTS) {
   4708                    mbl.zigzag(mbl_probe_index, px, py);
   4709                    _manual_goto_xy(mbl.index_to_xpos[px], mbl.index_to_ypos[py]);
   4710          
   4711                    #if HAS_SOFTWARE_ENDSTOPS
   4712                      // Disable software endstops to allow manual adjustment
   4713                      // If G29 is not completed, they will not be re-enabled
   4714                      soft_endstops_enabled = false;
   4715                    #endif
   4716          
   4717                    mbl_probe_index++;
   4718                  }
   4719                  else {
   4720                    // One last "return to the bed" (as originally coded) at completion
   4721                    current_position[Z_AXIS] = Z_MIN_POS + MANUAL_PROBE_HEIGHT;
   4722                    buffer_line_to_current_position();
   4723                    stepper.synchronize();
   4724          
   4725                    // After recording the last point, activate home and activate
   4726                    mbl_probe_index = -1;
   4727                    SERIAL_PROTOCOLLNPGM("Mesh probing done.");
   4728                    BUZZ(100, 659);
   4729                    BUZZ(100, 698);
   4730                    mbl.has_mesh = true;
   4731          
   4732                    home_all_axes();
   4733                    set_bed_leveling_enabled(true);
   4734          
   4735                    #if ENABLED(MESH_G28_REST_ORIGIN)
   4736                      current_position[Z_AXIS] = Z_MIN_POS;
   4737                      set_destination_from_current();
   4738                      buffer_line_to_destination(homing_feedrate_mm_s[Z_AXIS]);
   4739                      stepper.synchronize();
   4740                    #endif
   4741          
   4742                    #if ENABLED(LCD_BED_LEVELING)
   4743                      lcd_wait_for_move = false;
   4744                    #endif
   4745                  }
   4746                  break;
   4747          
   4748                case MeshSet:
   4749                  if (parser.seenval('X')) {
   4750                    px = parser.value_int() - 1;
   4751                    if (!WITHIN(px, 0, GRID_MAX_POINTS_X - 1)) {
   4752                      SERIAL_PROTOCOLLNPGM("X out of range (1-" STRINGIFY(GRID_MAX_POINTS_X) ").");
   4753                      return;
   4754                    }
   4755                  }
   4756                  else {
   4757                    SERIAL_CHAR('X'); echo_not_entered();
   4758                    return;
   4759                  }
   4760          
   4761                  if (parser.seenval('Y')) {
   4762                    py = parser.value_int() - 1;
   4763                    if (!WITHIN(py, 0, GRID_MAX_POINTS_Y - 1)) {
   4764                      SERIAL_PROTOCOLLNPGM("Y out of range (1-" STRINGIFY(GRID_MAX_POINTS_Y) ").");
   4765                      return;
   4766                    }
   4767                  }
   4768                  else {
   4769                    SERIAL_CHAR('Y'); echo_not_entered();
   4770                    return;
   4771                  }
   4772          
   4773                  if (parser.seenval('Z'))
   4774                    mbl.z_values[px][py] = parser.value_linear_units();
   4775                  else {
   4776                    SERIAL_CHAR('Z'); echo_not_entered();
   4777                    return;
   4778                  }
   4779                  break;
   4780          
   4781                case MeshSetZOffset:
   4782                  if (parser.seenval('Z'))
   4783                    mbl.z_offset = parser.value_linear_units();
   4784                  else {
   4785                    SERIAL_CHAR('Z'); echo_not_entered();
   4786                    return;
   4787                  }
   4788                  break;
   4789          
   4790                case MeshReset:
   4791                  reset_bed_level();
   4792                  break;
   4793          
   4794              } // switch(state)
   4795          
   4796              if (state == MeshStart || state == MeshNext) {
   4797                SERIAL_PROTOCOLPAIR("MBL G29 point ", min(mbl_probe_index, GRID_MAX_POINTS));
   4798                SERIAL_PROTOCOLLNPAIR(" of ", int(GRID_MAX_POINTS));
   4799              }
   4800          
   4801              report_current_position();
   4802            }
   4803          
   4804          #elif OLDSCHOOL_ABL
   4805          
   4806            #if ABL_GRID
   4807              #if ENABLED(PROBE_Y_FIRST)
   4808                #define PR_OUTER_VAR xCount
   4809                #define PR_OUTER_END abl_grid_points_x
   4810                #define PR_INNER_VAR yCount
   4811                #define PR_INNER_END abl_grid_points_y
   4812              #else
   4813                #define PR_OUTER_VAR yCount
   4814                #define PR_OUTER_END abl_grid_points_y
   4815                #define PR_INNER_VAR xCount
   4816                #define PR_INNER_END abl_grid_points_x
   4817              #endif
   4818            #endif
   4819          
   4820            /**
   4821             * G29: Detailed Z probe, probes the bed at 3 or more points.
   4822             *      Will fail if the printer has not been homed with G28.
   4823             *
   4824             * Enhanced G29 Auto Bed Leveling Probe Routine
   4825             *
   4826             *  D  Dry-Run mode. Just evaluate the bed Topology - Don't apply
   4827             *     or alter the bed level data. Useful to check the topology
   4828             *     after a first run of G29.
   4829             *
   4830             *  J  Jettison current bed leveling data
   4831             *
   4832             *  V  Set the verbose level (0-4). Example: "G29 V3"
   4833             *
   4834             * Parameters With LINEAR leveling only:
   4835             *
   4836             *  P  Set the size of the grid that will be probed (P x P points).
   4837             *     Example: "G29 P4"
   4838             *
   4839             *  X  Set the X size of the grid that will be probed (X x Y points).
   4840             *     Example: "G29 X7 Y5"
   4841             *
   4842             *  Y  Set the Y size of the grid that will be probed (X x Y points).
   4843             *
   4844             *  T  Generate a Bed Topology Report. Example: "G29 P5 T" for a detailed report.
   4845             *     This is useful for manual bed leveling and finding flaws in the bed (to
   4846             *     assist with part placement).
   4847             *     Not supported by non-linear delta printer bed leveling.
   4848             *
   4849             * Parameters With LINEAR and BILINEAR leveling only:
   4850             *
   4851             *  S  Set the XY travel speed between probe points (in units/min)
   4852             *
   4853             *  F  Set the Front limit of the probing grid
   4854             *  B  Set the Back limit of the probing grid
   4855             *  L  Set the Left limit of the probing grid
   4856             *  R  Set the Right limit of the probing grid
   4857             *
   4858             * Parameters with DEBUG_LEVELING_FEATURE only:
   4859             *
   4860             *  C  Make a totally fake grid with no actual probing.
   4861             *     For use in testing when no probing is possible.
   4862             *
   4863             * Parameters with BILINEAR leveling only:
   4864             *
   4865             *  Z  Supply an additional Z probe offset
   4866             *
   4867             * Extra parameters with PROBE_MANUALLY:
   4868             *
   4869             *  To do manual probing simply repeat G29 until the procedure is complete.
   4870             *  The first G29 accepts parameters. 'G29 Q' for status, 'G29 A' to abort.
   4871             *
   4872             *  Q  Query leveling and G29 state
   4873             *
   4874             *  A  Abort current leveling procedure
   4875             *
   4876             * Extra parameters with BILINEAR only:
   4877             *
   4878             *  W  Write a mesh point. (If G29 is idle.)
   4879             *  I  X index for mesh point
   4880             *  J  Y index for mesh point
   4881             *  X  X for mesh point, overrides I
   4882             *  Y  Y for mesh point, overrides J
   4883             *  Z  Z for mesh point. Otherwise, raw current Z.
   4884             *
   4885             * Without PROBE_MANUALLY:
   4886             *
   4887             *  E  By default G29 will engage the Z probe, test the bed, then disengage.
   4888             *     Include "E" to engage/disengage the Z probe for each sample.
   4889             *     There's no extra effect if you have a fixed Z probe.
   4890             *
   4891             */
   4892            inline void gcode_G29() {
   4893          
   4894              // G29 Q is also available if debugging
   4895              #if ENABLED(DEBUG_LEVELING_FEATURE)
   4896                const bool query = parser.seen('Q');
   4897                const uint8_t old_debug_flags = marlin_debug_flags;
   4898                if (query) marlin_debug_flags |= DEBUG_LEVELING;
   4899                if (DEBUGGING(LEVELING)) {
   4900                  DEBUG_POS(">>> G29", current_position);
   4901                  log_machine_info();
   4902                }
   4903                marlin_debug_flags = old_debug_flags;
   4904                #if DISABLED(PROBE_MANUALLY)
   4905                  if (query) return;
   4906                #endif
   4907              #endif
   4908          
   4909              #if ENABLED(PROBE_MANUALLY)
   4910                const bool seenA = parser.seen('A'), seenQ = parser.seen('Q'), no_action = seenA || seenQ;
   4911              #endif
   4912          
   4913              #if ENABLED(DEBUG_LEVELING_FEATURE) && DISABLED(PROBE_MANUALLY)
   4914                const bool faux = parser.boolval('C');
   4915              #elif ENABLED(PROBE_MANUALLY)
   4916                const bool faux = no_action;
   4917              #else
   4918                bool constexpr faux = false;
   4919              #endif
   4920          
   4921              // Don't allow auto-leveling without homing first
   4922              if (axis_unhomed_error()) return;
   4923          
   4924              // Define local vars 'static' for manual probing, 'auto' otherwise
   4925              #if ENABLED(PROBE_MANUALLY)
   4926                #define ABL_VAR static
   4927              #else
   4928                #define ABL_VAR
   4929              #endif
   4930          
   4931              ABL_VAR int verbose_level;
   4932              ABL_VAR float xProbe, yProbe, measured_z;
   4933              ABL_VAR bool dryrun, abl_should_enable;
   4934          
   4935              #if ENABLED(PROBE_MANUALLY) || ENABLED(AUTO_BED_LEVELING_LINEAR)
   4936                ABL_VAR int abl_probe_index;
   4937              #endif
   4938          
   4939              #if HAS_SOFTWARE_ENDSTOPS && ENABLED(PROBE_MANUALLY)
   4940                ABL_VAR bool enable_soft_endstops = true;
   4941              #endif
   4942          
   4943              #if ABL_GRID
   4944          
   4945                #if ENABLED(PROBE_MANUALLY)
   4946                  ABL_VAR uint8_t PR_OUTER_VAR;
   4947                  ABL_VAR  int8_t PR_INNER_VAR;
   4948                #endif
   4949          
   4950                ABL_VAR int left_probe_bed_position, right_probe_bed_position, front_probe_bed_position, back_probe_bed_position;
   4951                ABL_VAR float xGridSpacing = 0, yGridSpacing = 0;
   4952          
   4953                #if ENABLED(AUTO_BED_LEVELING_LINEAR)
   4954                  ABL_VAR uint8_t abl_grid_points_x = GRID_MAX_POINTS_X,
   4955                                  abl_grid_points_y = GRID_MAX_POINTS_Y;
   4956                  ABL_VAR bool do_topography_map;
   4957                #else // Bilinear
   4958                  uint8_t constexpr abl_grid_points_x = GRID_MAX_POINTS_X,
   4959                                    abl_grid_points_y = GRID_MAX_POINTS_Y;
   4960                #endif
   4961          
   4962                #if ENABLED(AUTO_BED_LEVELING_LINEAR)
   4963                  ABL_VAR int abl2;
   4964                #elif ENABLED(PROBE_MANUALLY) // Bilinear
   4965                  int constexpr abl2 = GRID_MAX_POINTS;
   4966                #endif
   4967          
   4968                #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
   4969          
   4970                  ABL_VAR float zoffset;
   4971          
   4972                #elif ENABLED(AUTO_BED_LEVELING_LINEAR)
   4973          
   4974                  ABL_VAR int indexIntoAB[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
   4975          
   4976                  ABL_VAR float eqnAMatrix[GRID_MAX_POINTS * 3], // "A" matrix of the linear system of equations
   4977                                eqnBVector[GRID_MAX_POINTS],     // "B" vector of Z points
   4978                                mean;
   4979                #endif
   4980          
   4981              #elif ENABLED(AUTO_BED_LEVELING_3POINT)
   4982          
   4983                #if ENABLED(PROBE_MANUALLY)
   4984                  int constexpr abl2 = 3; // used to show total points
   4985                #endif
   4986          
   4987                // Probe at 3 arbitrary points
   4988                ABL_VAR vector_3 points[3] = {
   4989                  vector_3(ABL_PROBE_PT_1_X, ABL_PROBE_PT_1_Y, 0),
   4990                  vector_3(ABL_PROBE_PT_2_X, ABL_PROBE_PT_2_Y, 0),
   4991                  vector_3(ABL_PROBE_PT_3_X, ABL_PROBE_PT_3_Y, 0)
   4992                };
   4993          
   4994              #endif // AUTO_BED_LEVELING_3POINT
   4995          
   4996              #if ENABLED(AUTO_BED_LEVELING_LINEAR)
   4997                struct linear_fit_data lsf_results;
   4998                incremental_LSF_reset(&lsf_results);
   4999              #endif
   5000          
   5001              /**
   5002               * On the initial G29 fetch command parameters.
   5003               */
   5004              if (!g29_in_progress) {
   5005          
   5006                #if ENABLED(PROBE_MANUALLY) || ENABLED(AUTO_BED_LEVELING_LINEAR)
   5007                  abl_probe_index = -1;
   5008                #endif
   5009          
   5010                abl_should_enable = planner.leveling_active;
   5011          
   5012                #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
   5013          
   5014                  if (parser.seen('W')) {
   5015                    if (!leveling_is_valid()) {
   5016                      SERIAL_ERROR_START();
   5017                      SERIAL_ERRORLNPGM("No bilinear grid");
   5018                      return;
   5019                    }
   5020          
   5021                    const float rz = parser.seenval('Z') ? RAW_Z_POSITION(parser.value_linear_units()) : current_position[Z_AXIS];
   5022                    if (!WITHIN(rz, -10, 10)) {
   5023                      SERIAL_ERROR_START();
   5024                      SERIAL_ERRORLNPGM("Bad Z value");
   5025                      return;
   5026                    }
   5027          
   5028                    const float rx = RAW_X_POSITION(parser.linearval('X', NAN)),
   5029                                ry = RAW_Y_POSITION(parser.linearval('Y', NAN));
   5030                    int8_t i = parser.byteval('I', -1),
   5031                           j = parser.byteval('J', -1);
   5032          
   5033                    if (!isnan(rx) && !isnan(ry)) {
   5034                      // Get nearest i / j from rx / ry
   5035                      i = (rx - bilinear_start[X_AXIS] + 0.5 * xGridSpacing) / xGridSpacing;
   5036                      j = (ry - bilinear_start[Y_AXIS] + 0.5 * yGridSpacing) / yGridSpacing;
   5037                      i = constrain(i, 0, GRID_MAX_POINTS_X - 1);
   5038                      j = constrain(j, 0, GRID_MAX_POINTS_Y - 1);
   5039                    }
   5040                    if (WITHIN(i, 0, GRID_MAX_POINTS_X - 1) && WITHIN(j, 0, GRID_MAX_POINTS_Y)) {
   5041                      set_bed_leveling_enabled(false);
   5042                      z_values[i][j] = rz;
   5043                      #if ENABLED(ABL_BILINEAR_SUBDIVISION)
   5044                        bed_level_virt_interpolate();
   5045                      #endif
   5046                      set_bed_leveling_enabled(abl_should_enable);
   5047                      if (abl_should_enable) report_current_position();
   5048                    }
   5049                    return;
   5050                  } // parser.seen('W')
   5051          
   5052                #endif
   5053          
   5054                // Jettison bed leveling data
   5055                if (parser.seen('J')) {
   5056                  reset_bed_level();
   5057                  return;
   5058                }
   5059          
   5060                verbose_level = parser.intval('V');
   5061                if (!WITHIN(verbose_level, 0, 4)) {
   5062                  SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-4).");
   5063                  return;
   5064                }
   5065          
   5066                dryrun = parser.boolval('D')
   5067                  #if ENABLED(PROBE_MANUALLY)
   5068                    || no_action
   5069                  #endif
   5070                ;
   5071          
   5072                #if ENABLED(AUTO_BED_LEVELING_LINEAR)
   5073          
   5074                  do_topography_map = verbose_level > 2 || parser.boolval('T');
   5075          
   5076                  // X and Y specify points in each direction, overriding the default
   5077                  // These values may be saved with the completed mesh
   5078                  abl_grid_points_x = parser.intval('X', GRID_MAX_POINTS_X);
   5079                  abl_grid_points_y = parser.intval('Y', GRID_MAX_POINTS_Y);
   5080                  if (parser.seenval('P')) abl_grid_points_x = abl_grid_points_y = parser.value_int();
   5081          
   5082                  if (abl_grid_points_x < 2 || abl_grid_points_y < 2) {
   5083                    SERIAL_PROTOCOLLNPGM("?Number of probe points is implausible (2 minimum).");
   5084                    return;
   5085                  }
   5086          
   5087                  abl2 = abl_grid_points_x * abl_grid_points_y;
   5088                  mean = 0;
   5089          
   5090                #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
   5091          
   5092                  zoffset = parser.linearval('Z');
   5093          
   5094                #endif
   5095          
   5096                #if ABL_GRID
   5097          
   5098                  xy_probe_feedrate_mm_s = MMM_TO_MMS(parser.linearval('S', XY_PROBE_SPEED));
   5099          
   5100                  left_probe_bed_position  = parser.seenval('L') ? (int)RAW_X_POSITION(parser.value_linear_units()) : LEFT_PROBE_BED_POSITION;
   5101                  right_probe_bed_position = parser.seenval('R') ? (int)RAW_X_POSITION(parser.value_linear_units()) : RIGHT_PROBE_BED_POSITION;
   5102                  front_probe_bed_position = parser.seenval('F') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : FRONT_PROBE_BED_POSITION;
   5103                  back_probe_bed_position  = parser.seenval('B') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : BACK_PROBE_BED_POSITION;
   5104          
   5105                  const bool left_out_l = left_probe_bed_position < MIN_PROBE_X,
   5106                             left_out = left_out_l || left_probe_bed_position > right_probe_bed_position - (MIN_PROBE_EDGE),
   5107                             right_out_r = right_probe_bed_position > MAX_PROBE_X,
   5108                             right_out = right_out_r || right_probe_bed_position < left_probe_bed_position + MIN_PROBE_EDGE,
   5109                             front_out_f = front_probe_bed_position < MIN_PROBE_Y,
   5110                             front_out = front_out_f || front_probe_bed_position > back_probe_bed_position - (MIN_PROBE_EDGE),
   5111                             back_out_b = back_probe_bed_position > MAX_PROBE_Y,
   5112                             back_out = back_out_b || back_probe_bed_position < front_probe_bed_position + MIN_PROBE_EDGE;
   5113          
   5114                  if (left_out || right_out || front_out || back_out) {
   5115                    if (left_out) {
   5116                      out_of_range_error(PSTR("(L)eft"));
   5117                      left_probe_bed_position = left_out_l ? MIN_PROBE_X : right_probe_bed_position - (MIN_PROBE_EDGE);
   5118                    }
   5119                    if (right_out) {
   5120                      out_of_range_error(PSTR("(R)ight"));
   5121                      right_probe_bed_position = right_out_r ? MAX_PROBE_X : left_probe_bed_position + MIN_PROBE_EDGE;
   5122                    }
   5123                    if (front_out) {
   5124                      out_of_range_error(PSTR("(F)ront"));
   5125                      front_probe_bed_position = front_out_f ? MIN_PROBE_Y : back_probe_bed_position - (MIN_PROBE_EDGE);
   5126                    }
   5127                    if (back_out) {
   5128                      out_of_range_error(PSTR("(B)ack"));
   5129                      back_probe_bed_position = back_out_b ? MAX_PROBE_Y : front_probe_bed_position + MIN_PROBE_EDGE;
   5130                    }
   5131                    return;
   5132                  }
   5133          
   5134                  // probe at the points of a lattice grid
   5135                  xGridSpacing = (right_probe_bed_position - left_probe_bed_position) / (abl_grid_points_x - 1);
   5136                  yGridSpacing = (back_probe_bed_position - front_probe_bed_position) / (abl_grid_points_y - 1);
   5137          
   5138                #endif // ABL_GRID
   5139          
   5140                if (verbose_level > 0) {
   5141                  SERIAL_PROTOCOLPGM("G29 Auto Bed Leveling");
   5142                  if (dryrun) SERIAL_PROTOCOLPGM(" (DRYRUN)");
   5143                  SERIAL_EOL();
   5144                }
   5145          
   5146                stepper.synchronize();
   5147          
   5148                // Disable auto bed leveling during G29.
   5149                // Be formal so G29 can be done successively without G28.
   5150                set_bed_leveling_enabled(false);
   5151          
   5152                #if HAS_BED_PROBE
   5153                  // Deploy the probe. Probe will raise if needed.
   5154                  if (DEPLOY_PROBE()) {
   5155                    set_bed_leveling_enabled(abl_should_enable);
   5156                    return;
   5157                  }
   5158                #endif
   5159          
   5160                if (!faux) setup_for_endstop_or_probe_move();
   5161          
   5162                #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
   5163          
   5164                  #if ENABLED(PROBE_MANUALLY)
   5165                    if (!no_action)
   5166                  #endif
   5167                  if ( xGridSpacing != bilinear_grid_spacing[X_AXIS]
   5168                    || yGridSpacing != bilinear_grid_spacing[Y_AXIS]
   5169                    || left_probe_bed_position != bilinear_start[X_AXIS]
   5170                    || front_probe_bed_position != bilinear_start[Y_AXIS]
   5171                  ) {
   5172                    // Reset grid to 0.0 or "not probed". (Also disables ABL)
   5173                    reset_bed_level();
   5174          
   5175                    // Initialize a grid with the given dimensions
   5176                    bilinear_grid_spacing[X_AXIS] = xGridSpacing;
   5177                    bilinear_grid_spacing[Y_AXIS] = yGridSpacing;
   5178                    bilinear_start[X_AXIS] = left_probe_bed_position;
   5179                    bilinear_start[Y_AXIS] = front_probe_bed_position;
   5180          
   5181                    // Can't re-enable (on error) until the new grid is written
   5182                    abl_should_enable = false;
   5183                  }
   5184          
   5185                #endif // AUTO_BED_LEVELING_BILINEAR
   5186          
   5187                #if ENABLED(AUTO_BED_LEVELING_3POINT)
   5188          
   5189                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   5190                    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> 3-point Leveling");
   5191                  #endif
   5192          
   5193                  // Probe at 3 arbitrary points
   5194                  points[0].z = points[1].z = points[2].z = 0;
   5195          
   5196                #endif // AUTO_BED_LEVELING_3POINT
   5197          
   5198              } // !g29_in_progress
   5199          
   5200              #if ENABLED(PROBE_MANUALLY)
   5201          
   5202                // For manual probing, get the next index to probe now.
   5203                // On the first probe this will be incremented to 0.
   5204                if (!no_action) {
   5205                  ++abl_probe_index;
   5206                  g29_in_progress = true;
   5207                }
   5208          
   5209                // Abort current G29 procedure, go back to idle state
   5210                if (seenA && g29_in_progress) {
   5211                  SERIAL_PROTOCOLLNPGM("Manual G29 aborted");
   5212                  #if HAS_SOFTWARE_ENDSTOPS
   5213                    soft_endstops_enabled = enable_soft_endstops;
   5214                  #endif
   5215                  set_bed_leveling_enabled(abl_should_enable);
   5216                  g29_in_progress = false;
   5217                  #if ENABLED(LCD_BED_LEVELING)
   5218                    lcd_wait_for_move = false;
   5219                  #endif
   5220                }
   5221          
   5222                // Query G29 status
   5223                if (verbose_level || seenQ) {
   5224                  SERIAL_PROTOCOLPGM("Manual G29 ");
   5225                  if (g29_in_progress) {
   5226                    SERIAL_PROTOCOLPAIR("point ", min(abl_probe_index + 1, abl2));
   5227                    SERIAL_PROTOCOLLNPAIR(" of ", abl2);
   5228                  }
   5229                  else
   5230                    SERIAL_PROTOCOLLNPGM("idle");
   5231                }
   5232          
   5233                if (no_action) return;
   5234          
   5235                if (abl_probe_index == 0) {
   5236                  // For the initial G29 save software endstop state
   5237                  #if HAS_SOFTWARE_ENDSTOPS
   5238                    enable_soft_endstops = soft_endstops_enabled;
   5239                  #endif
   5240                }
   5241                else {
   5242                  // For G29 after adjusting Z.
   5243                  // Save the previous Z before going to the next point
   5244                  measured_z = current_position[Z_AXIS];
   5245          
   5246                  #if ENABLED(AUTO_BED_LEVELING_LINEAR)
   5247          
   5248                    mean += measured_z;
   5249                    eqnBVector[abl_probe_index] = measured_z;
   5250                    eqnAMatrix[abl_probe_index + 0 * abl2] = xProbe;
   5251                    eqnAMatrix[abl_probe_index + 1 * abl2] = yProbe;
   5252                    eqnAMatrix[abl_probe_index + 2 * abl2] = 1;
   5253          
   5254                    incremental_LSF(&lsf_results, xProbe, yProbe, measured_z);
   5255          
   5256                  #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
   5257          
   5258                    z_values[xCount][yCount] = measured_z + zoffset;
   5259          
   5260                    #if ENABLED(DEBUG_LEVELING_FEATURE)
   5261                      if (DEBUGGING(LEVELING)) {
   5262                        SERIAL_PROTOCOLPAIR("Save X", xCount);
   5263                        SERIAL_PROTOCOLPAIR(" Y", yCount);
   5264                        SERIAL_PROTOCOLLNPAIR(" Z", measured_z + zoffset);
   5265                      }
   5266                    #endif
   5267          
   5268                  #elif ENABLED(AUTO_BED_LEVELING_3POINT)
   5269          
   5270                    points[abl_probe_index].z = measured_z;
   5271          
   5272                  #endif
   5273                }
   5274          
   5275                //
   5276                // If there's another point to sample, move there with optional lift.
   5277                //
   5278          
   5279                #if ABL_GRID
   5280          
   5281                  // Skip any unreachable points
   5282                  while (abl_probe_index < abl2) {
   5283          
   5284                    // Set xCount, yCount based on abl_probe_index, with zig-zag
   5285                    PR_OUTER_VAR = abl_probe_index / PR_INNER_END;
   5286                    PR_INNER_VAR = abl_probe_index - (PR_OUTER_VAR * PR_INNER_END);
   5287          
   5288                    // Probe in reverse order for every other row/column
   5289                    bool zig = (PR_OUTER_VAR & 1); // != ((PR_OUTER_END) & 1);
   5290          
   5291                    if (zig) PR_INNER_VAR = (PR_INNER_END - 1) - PR_INNER_VAR;
   5292          
   5293                    const float xBase = xCount * xGridSpacing + left_probe_bed_position,
   5294                                yBase = yCount * yGridSpacing + front_probe_bed_position;
   5295          
   5296                    xProbe = FLOOR(xBase + (xBase < 0 ? 0 : 0.5));
   5297                    yProbe = FLOOR(yBase + (yBase < 0 ? 0 : 0.5));
   5298          
   5299                    #if ENABLED(AUTO_BED_LEVELING_LINEAR)
   5300                      indexIntoAB[xCount][yCount] = abl_probe_index;
   5301                    #endif
   5302          
   5303                    // Keep looping till a reachable point is found
   5304                    if (position_is_reachable(xProbe, yProbe)) break;
   5305                    ++abl_probe_index;
   5306                  }
   5307          
   5308                  // Is there a next point to move to?
   5309                  if (abl_probe_index < abl2) {
   5310                    _manual_goto_xy(xProbe, yProbe); // Can be used here too!
   5311                    #if HAS_SOFTWARE_ENDSTOPS
   5312                      // Disable software endstops to allow manual adjustment
   5313                      // If G29 is not completed, they will not be re-enabled
   5314                      soft_endstops_enabled = false;
   5315                    #endif
   5316                    return;
   5317                  }
   5318                  else {
   5319          
   5320                    // Leveling done! Fall through to G29 finishing code below
   5321          
   5322                    SERIAL_PROTOCOLLNPGM("Grid probing done.");
   5323          
   5324                    // Re-enable software endstops, if needed
   5325                    #if HAS_SOFTWARE_ENDSTOPS
   5326                      soft_endstops_enabled = enable_soft_endstops;
   5327                    #endif
   5328                  }
   5329          
   5330                #elif ENABLED(AUTO_BED_LEVELING_3POINT)
   5331          
   5332                  // Probe at 3 arbitrary points
   5333                  if (abl_probe_index < abl2) {
   5334                    xProbe = points[abl_probe_index].x;
   5335                    yProbe = points[abl_probe_index].y;
   5336                    _manual_goto_xy(xProbe, yProbe);
   5337                    #if HAS_SOFTWARE_ENDSTOPS
   5338                      // Disable software endstops to allow manual adjustment
   5339                      // If G29 is not completed, they will not be re-enabled
   5340                      soft_endstops_enabled = false;
   5341                    #endif
   5342                    return;
   5343                  }
   5344                  else {
   5345          
   5346                    SERIAL_PROTOCOLLNPGM("3-point probing done.");
   5347          
   5348                    // Re-enable software endstops, if needed
   5349                    #if HAS_SOFTWARE_ENDSTOPS
   5350                      soft_endstops_enabled = enable_soft_endstops;
   5351                    #endif
   5352          
   5353                    if (!dryrun) {
   5354                      vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
   5355                      if (planeNormal.z < 0) {
   5356                        planeNormal.x *= -1;
   5357                        planeNormal.y *= -1;
   5358                        planeNormal.z *= -1;
   5359                      }
   5360                      planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
   5361          
   5362                      // Can't re-enable (on error) until the new grid is written
   5363                      abl_should_enable = false;
   5364                    }
   5365          
   5366                  }
   5367          
   5368                #endif // AUTO_BED_LEVELING_3POINT
   5369          
   5370              #else // !PROBE_MANUALLY
   5371              {
   5372                const bool stow_probe_after_each = parser.boolval('E');
   5373          
   5374                measured_z = 0;
   5375          
   5376                #if ABL_GRID
   5377          
   5378                  bool zig = PR_OUTER_END & 1;  // Always end at RIGHT and BACK_PROBE_BED_POSITION
   5379          
   5380                  measured_z = 0;
   5381          
   5382                  // Outer loop is Y with PROBE_Y_FIRST disabled
   5383                  for (uint8_t PR_OUTER_VAR = 0; PR_OUTER_VAR < PR_OUTER_END && !isnan(measured_z); PR_OUTER_VAR++) {
   5384          
   5385                    int8_t inStart, inStop, inInc;
   5386          
   5387                    if (zig) { // away from origin
   5388                      inStart = 0;
   5389                      inStop = PR_INNER_END;
   5390                      inInc = 1;
   5391                    }
   5392                    else {     // towards origin
   5393                      inStart = PR_INNER_END - 1;
   5394                      inStop = -1;
   5395                      inInc = -1;
   5396                    }
   5397          
   5398                    zig ^= true; // zag
   5399          
   5400                    // Inner loop is Y with PROBE_Y_FIRST enabled
   5401                    for (int8_t PR_INNER_VAR = inStart; PR_INNER_VAR != inStop; PR_INNER_VAR += inInc) {
   5402          
   5403                      float xBase = left_probe_bed_position + xGridSpacing * xCount,
   5404                            yBase = front_probe_bed_position + yGridSpacing * yCount;
   5405          
   5406                      xProbe = FLOOR(xBase + (xBase < 0 ? 0 : 0.5));
   5407                      yProbe = FLOOR(yBase + (yBase < 0 ? 0 : 0.5));
   5408          
   5409                      #if ENABLED(AUTO_BED_LEVELING_LINEAR)
   5410                        indexIntoAB[xCount][yCount] = ++abl_probe_index; // 0...
   5411                      #endif
   5412          
   5413                      #if IS_KINEMATIC
   5414                        // Avoid probing outside the round or hexagonal area
   5415                        if (!position_is_reachable_by_probe(xProbe, yProbe)) continue;
   5416                      #endif
   5417          
   5418                      measured_z = faux ? 0.001 * random(-100, 101) : probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
   5419          
   5420                      if (isnan(measured_z)) {
   5421                        set_bed_leveling_enabled(abl_should_enable);
   5422                        break;
   5423                      }
   5424          
   5425                      #if ENABLED(AUTO_BED_LEVELING_LINEAR)
   5426          
   5427                        mean += measured_z;
   5428                        eqnBVector[abl_probe_index] = measured_z;
   5429                        eqnAMatrix[abl_probe_index + 0 * abl2] = xProbe;
   5430                        eqnAMatrix[abl_probe_index + 1 * abl2] = yProbe;
   5431                        eqnAMatrix[abl_probe_index + 2 * abl2] = 1;
   5432          
   5433                        incremental_LSF(&lsf_results, xProbe, yProbe, measured_z);
   5434          
   5435                      #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
   5436          
   5437                        z_values[xCount][yCount] = measured_z + zoffset;
   5438          
   5439                      #endif
   5440          
   5441                      abl_should_enable = false;
   5442                      idle();
   5443          
   5444                    } // inner
   5445                  } // outer
   5446          
   5447                #elif ENABLED(AUTO_BED_LEVELING_3POINT)
   5448          
   5449                  // Probe at 3 arbitrary points
   5450          
   5451                  for (uint8_t i = 0; i < 3; ++i) {
   5452                    // Retain the last probe position
   5453                    xProbe = points[i].x;
   5454                    yProbe = points[i].y;
   5455                    measured_z = faux ? 0.001 * random(-100, 101) : probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
   5456                    if (isnan(measured_z)) {
   5457                      set_bed_leveling_enabled(abl_should_enable);
   5458                      break;
   5459                    }
   5460                    points[i].z = measured_z;
   5461                  }
   5462          
   5463                  if (!dryrun && !isnan(measured_z)) {
   5464                    vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
   5465                    if (planeNormal.z < 0) {
   5466                      planeNormal.x *= -1;
   5467                      planeNormal.y *= -1;
   5468                      planeNormal.z *= -1;
   5469                    }
   5470                    planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
   5471          
   5472                    // Can't re-enable (on error) until the new grid is written
   5473                    abl_should_enable = false;
   5474                  }
   5475          
   5476                #endif // AUTO_BED_LEVELING_3POINT
   5477          
   5478                // Raise to _Z_CLEARANCE_DEPLOY_PROBE. Stow the probe.
   5479                if (STOW_PROBE()) {
   5480                  set_bed_leveling_enabled(abl_should_enable);
   5481                  measured_z = NAN;
   5482                }
   5483              }
   5484              #endif // !PROBE_MANUALLY
   5485          
   5486              //
   5487              // G29 Finishing Code
   5488              //
   5489              // Unless this is a dry run, auto bed leveling will
   5490              // definitely be enabled after this point.
   5491              //
   5492              // If code above wants to continue leveling, it should
   5493              // return or loop before this point.
   5494              //
   5495          
   5496              #if ENABLED(DEBUG_LEVELING_FEATURE)
   5497                if (DEBUGGING(LEVELING)) DEBUG_POS("> probing complete", current_position);
   5498              #endif
   5499          
   5500              #if ENABLED(PROBE_MANUALLY)
   5501                g29_in_progress = false;
   5502                #if ENABLED(LCD_BED_LEVELING)
   5503                  lcd_wait_for_move = false;
   5504                #endif
   5505              #endif
   5506          
   5507              // Calculate leveling, print reports, correct the position
   5508              if (!isnan(measured_z)) {
   5509                #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
   5510          
   5511                  if (!dryrun) extrapolate_unprobed_bed_level();
   5512                  print_bilinear_leveling_grid();
   5513          
   5514                  refresh_bed_level();
   5515          
   5516                  #if ENABLED(ABL_BILINEAR_SUBDIVISION)
   5517                    print_bilinear_leveling_grid_virt();
   5518                  #endif
   5519          
   5520                #elif ENABLED(AUTO_BED_LEVELING_LINEAR)
   5521          
   5522                  // For LINEAR leveling calculate matrix, print reports, correct the position
   5523          
   5524                  /**
   5525                   * solve the plane equation ax + by + d = z
   5526                   * A is the matrix with rows [x y 1] for all the probed points
   5527                   * B is the vector of the Z positions
   5528                   * the normal vector to the plane is formed by the coefficients of the
   5529                   * plane equation in the standard form, which is Vx*x+Vy*y+Vz*z+d = 0
   5530                   * so Vx = -a Vy = -b Vz = 1 (we want the vector facing towards positive Z
   5531                   */
   5532                  float plane_equation_coefficients[3];
   5533          
   5534                  finish_incremental_LSF(&lsf_results);
   5535                  plane_equation_coefficients[0] = -lsf_results.A;  // We should be able to eliminate the '-' on these three lines and down below
   5536                  plane_equation_coefficients[1] = -lsf_results.B;  // but that is not yet tested.
   5537                  plane_equation_coefficients[2] = -lsf_results.D;
   5538          
   5539                  mean /= abl2;
   5540          
   5541                  if (verbose_level) {
   5542                    SERIAL_PROTOCOLPGM("Eqn coefficients: a: ");
   5543                    SERIAL_PROTOCOL_F(plane_equation_coefficients[0], 8);
   5544                    SERIAL_PROTOCOLPGM(" b: ");
   5545                    SERIAL_PROTOCOL_F(plane_equation_coefficients[1], 8);
   5546                    SERIAL_PROTOCOLPGM(" d: ");
   5547                    SERIAL_PROTOCOL_F(plane_equation_coefficients[2], 8);
   5548                    SERIAL_EOL();
   5549                    if (verbose_level > 2) {
   5550                      SERIAL_PROTOCOLPGM("Mean of sampled points: ");
   5551                      SERIAL_PROTOCOL_F(mean, 8);
   5552                      SERIAL_EOL();
   5553                    }
   5554                  }
   5555          
   5556                  // Create the matrix but don't correct the position yet
   5557                  if (!dryrun)
   5558                    planner.bed_level_matrix = matrix_3x3::create_look_at(
   5559                      vector_3(-plane_equation_coefficients[0], -plane_equation_coefficients[1], 1)    // We can eliminate the '-' here and up above
   5560                    );
   5561          
   5562                  // Show the Topography map if enabled
   5563                  if (do_topography_map) {
   5564          
   5565                    SERIAL_PROTOCOLLNPGM("\nBed Height Topography:\n"
   5566                                           "   +--- BACK --+\n"
   5567                                           "   |           |\n"
   5568                                           " L |    (+)    | R\n"
   5569                                           " E |           | I\n"
   5570                                           " F | (-) N (+) | G\n"
   5571                                           " T |           | H\n"
   5572                                           "   |    (-)    | T\n"
   5573                                           "   |           |\n"
   5574                                           "   O-- FRONT --+\n"
   5575                                           " (0,0)");
   5576          
   5577                    float min_diff = 999;
   5578          
   5579                    for (int8_t yy = abl_grid_points_y - 1; yy >= 0; yy--) {
   5580                      for (uint8_t xx = 0; xx < abl_grid_points_x; xx++) {
   5581                        int ind = indexIntoAB[xx][yy];
   5582                        float diff = eqnBVector[ind] - mean,
   5583                              x_tmp = eqnAMatrix[ind + 0 * abl2],
   5584                              y_tmp = eqnAMatrix[ind + 1 * abl2],
   5585                              z_tmp = 0;
   5586          
   5587                        apply_rotation_xyz(planner.bed_level_matrix, x_tmp, y_tmp, z_tmp);
   5588          
   5589                        NOMORE(min_diff, eqnBVector[ind] - z_tmp);
   5590          
   5591                        if (diff >= 0.0)
   5592                          SERIAL_PROTOCOLPGM(" +");   // Include + for column alignment
   5593                        else
   5594                          SERIAL_PROTOCOLCHAR(' ');
   5595                        SERIAL_PROTOCOL_F(diff, 5);
   5596                      } // xx
   5597                      SERIAL_EOL();
   5598                    } // yy
   5599                    SERIAL_EOL();
   5600          
   5601                    if (verbose_level > 3) {
   5602                      SERIAL_PROTOCOLLNPGM("\nCorrected Bed Height vs. Bed Topology:");
   5603          
   5604                      for (int8_t yy = abl_grid_points_y - 1; yy >= 0; yy--) {
   5605                        for (uint8_t xx = 0; xx < abl_grid_points_x; xx++) {
   5606                          int ind = indexIntoAB[xx][yy];
   5607                          float x_tmp = eqnAMatrix[ind + 0 * abl2],
   5608                                y_tmp = eqnAMatrix[ind + 1 * abl2],
   5609                                z_tmp = 0;
   5610          
   5611                          apply_rotation_xyz(planner.bed_level_matrix, x_tmp, y_tmp, z_tmp);
   5612          
   5613                          float diff = eqnBVector[ind] - z_tmp - min_diff;
   5614                          if (diff >= 0.0)
   5615                            SERIAL_PROTOCOLPGM(" +");
   5616                          // Include + for column alignment
   5617                          else
   5618                            SERIAL_PROTOCOLCHAR(' ');
   5619                          SERIAL_PROTOCOL_F(diff, 5);
   5620                        } // xx
   5621                        SERIAL_EOL();
   5622                      } // yy
   5623                      SERIAL_EOL();
   5624                    }
   5625                  } //do_topography_map
   5626          
   5627                #endif // AUTO_BED_LEVELING_LINEAR
   5628          
   5629                #if ABL_PLANAR
   5630          
   5631                  // For LINEAR and 3POINT leveling correct the current position
   5632          
   5633                  if (verbose_level > 0)
   5634                    planner.bed_level_matrix.debug(PSTR("\n\nBed Level Correction Matrix:"));
   5635          
   5636                  if (!dryrun) {
   5637                    //
   5638                    // Correct the current XYZ position based on the tilted plane.
   5639                    //
   5640          
   5641                    #if ENABLED(DEBUG_LEVELING_FEATURE)
   5642                      if (DEBUGGING(LEVELING)) DEBUG_POS("G29 uncorrected XYZ", current_position);
   5643                    #endif
   5644          
   5645                    float converted[XYZ];
   5646                    COPY(converted, current_position);
   5647          
   5648                    planner.leveling_active = true;
   5649                    planner.unapply_leveling(converted); // use conversion machinery
   5650                    planner.leveling_active = false;
   5651          
   5652                    // Use the last measured distance to the bed, if possible
   5653                    if ( NEAR(current_position[X_AXIS], xProbe - (X_PROBE_OFFSET_FROM_EXTRUDER))
   5654                      && NEAR(current_position[Y_AXIS], yProbe - (Y_PROBE_OFFSET_FROM_EXTRUDER))
   5655                    ) {
   5656                      const float simple_z = current_position[Z_AXIS] - measured_z;
   5657                      #if ENABLED(DEBUG_LEVELING_FEATURE)
   5658                        if (DEBUGGING(LEVELING)) {
   5659                          SERIAL_ECHOPAIR("Z from Probe:", simple_z);
   5660                          SERIAL_ECHOPAIR("  Matrix:", converted[Z_AXIS]);
   5661                          SERIAL_ECHOLNPAIR("  Discrepancy:", simple_z - converted[Z_AXIS]);
   5662                        }
   5663                      #endif
   5664                      converted[Z_AXIS] = simple_z;
   5665                    }
   5666          
   5667                    // The rotated XY and corrected Z are now current_position
   5668                    COPY(current_position, converted);
   5669          
   5670                    #if ENABLED(DEBUG_LEVELING_FEATURE)
   5671                      if (DEBUGGING(LEVELING)) DEBUG_POS("G29 corrected XYZ", current_position);
   5672                    #endif
   5673                  }
   5674          
   5675                #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
   5676          
   5677                  if (!dryrun) {
   5678                    #if ENABLED(DEBUG_LEVELING_FEATURE)
   5679                      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("G29 uncorrected Z:", current_position[Z_AXIS]);
   5680                    #endif
   5681          
   5682                    // Unapply the offset because it is going to be immediately applied
   5683                    // and cause compensation movement in Z
   5684                    current_position[Z_AXIS] -= bilinear_z_offset(current_position);
   5685          
   5686                    #if ENABLED(DEBUG_LEVELING_FEATURE)
   5687                      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR(" corrected Z:", current_position[Z_AXIS]);
   5688                    #endif
   5689                  }
   5690          
   5691                #endif // ABL_PLANAR
   5692          
   5693                #ifdef Z_PROBE_END_SCRIPT
   5694                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   5695                    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
   5696                  #endif
   5697                  enqueue_and_echo_commands_P(PSTR(Z_PROBE_END_SCRIPT));
   5698                  stepper.synchronize();
   5699                #endif
   5700          
   5701                // Auto Bed Leveling is complete! Enable if possible.
   5702                planner.leveling_active = dryrun ? abl_should_enable : true;
   5703              } // !isnan(measured_z)
   5704          
   5705              // Restore state after probing
   5706              if (!faux) clean_up_after_endstop_or_probe_move();
   5707          
   5708              #if ENABLED(DEBUG_LEVELING_FEATURE)
   5709                if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< G29");
   5710              #endif
   5711          
   5712              report_current_position();
   5713          
   5714              KEEPALIVE_STATE(IN_HANDLER);
   5715          
   5716              if (planner.leveling_active)
   5717                SYNC_PLAN_POSITION_KINEMATIC();
   5718            }
   5719          
   5720          #endif // OLDSCHOOL_ABL
   5721          
   5722          #if HAS_BED_PROBE
   5723          
   5724            /**
   5725             * G30: Do a single Z probe at the current XY
   5726             *
   5727             * Parameters:
   5728             *
   5729             *   X   Probe X position (default current X)
   5730             *   Y   Probe Y position (default current Y)
   5731             *   E   Engage the probe for each probe
   5732             */
   5733            inline void gcode_G30() {
   5734              const float xpos = parser.linearval('X', current_position[X_AXIS] + X_PROBE_OFFSET_FROM_EXTRUDER),
   5735                          ypos = parser.linearval('Y', current_position[Y_AXIS] + Y_PROBE_OFFSET_FROM_EXTRUDER);
   5736          
   5737              if (!position_is_reachable_by_probe(xpos, ypos)) return;
   5738          
   5739              // Disable leveling so the planner won't mess with us
   5740              #if HAS_LEVELING
   5741                set_bed_leveling_enabled(false);
   5742              #endif
   5743          
   5744              setup_for_endstop_or_probe_move();
   5745          
   5746              const float measured_z = probe_pt(xpos, ypos, parser.boolval('E'), 1);
   5747          
   5748              if (!isnan(measured_z)) {
   5749                SERIAL_PROTOCOLPAIR("Bed X: ", FIXFLOAT(xpos));
   5750                SERIAL_PROTOCOLPAIR(" Y: ", FIXFLOAT(ypos));
   5751                SERIAL_PROTOCOLLNPAIR(" Z: ", FIXFLOAT(measured_z));
   5752              }
   5753          
   5754              clean_up_after_endstop_or_probe_move();
   5755          
   5756              report_current_position();
   5757            }
   5758          
   5759            #if ENABLED(Z_PROBE_SLED)
   5760          
   5761              /**
   5762               * G31: Deploy the Z probe
   5763               */
   5764              inline void gcode_G31() { DEPLOY_PROBE(); }
   5765          
   5766              /**
   5767               * G32: Stow the Z probe
   5768               */
   5769              inline void gcode_G32() { STOW_PROBE(); }
   5770          
   5771            #endif // Z_PROBE_SLED
   5772          
   5773          #endif // HAS_BED_PROBE
   5774          
   5775          #if ENABLED(DELTA_AUTO_CALIBRATION)
   5776          
   5777            constexpr uint8_t _7P_STEP = 1,              // 7-point step - to change number of calibration points
   5778                              _4P_STEP = _7P_STEP * 2,   // 4-point step
   5779                              NPP      = _7P_STEP * 6;   // number of calibration points on the radius
   5780            enum CalEnum {                               // the 7 main calibration points - add definitions if needed
   5781              CEN      = 0,
   5782              __A      = 1,
   5783              _AB      = __A + _7P_STEP,
   5784              __B      = _AB + _7P_STEP,
   5785              _BC      = __B + _7P_STEP,
   5786              __C      = _BC + _7P_STEP,
   5787              _CA      = __C + _7P_STEP,
   5788            };
   5789          
   5790            #define LOOP_CAL_PT(VAR, S, N) for (uint8_t VAR=S; VAR<=NPP; VAR+=N)
   5791            #define F_LOOP_CAL_PT(VAR, S, N) for (float VAR=S; VAR<NPP+0.9999; VAR+=N)
   5792            #define I_LOOP_CAL_PT(VAR, S, N) for (float VAR=S; VAR>CEN+0.9999; VAR-=N)
   5793            #define LOOP_CAL_ALL(VAR) LOOP_CAL_PT(VAR, CEN, 1)
   5794            #define LOOP_CAL_RAD(VAR) LOOP_CAL_PT(VAR, __A, _7P_STEP)
   5795            #define LOOP_CAL_ACT(VAR, _4P, _OP) LOOP_CAL_PT(VAR, _OP ? _AB : __A, _4P ? _4P_STEP : _7P_STEP)
   5796          
   5797            static void print_signed_float(const char * const prefix, const float &f) {
   5798              SERIAL_PROTOCOLPGM("  ");
   5799              serialprintPGM(prefix);
   5800              SERIAL_PROTOCOLCHAR(':');
   5801              if (f >= 0) SERIAL_CHAR('+');
   5802              SERIAL_PROTOCOL_F(f, 2);
   5803            }
   5804          
   5805            static void print_G33_settings(const bool end_stops, const bool tower_angles) {
   5806              SERIAL_PROTOCOLPAIR(".Height:", delta_height);
   5807              if (end_stops) {
   5808                print_signed_float(PSTR("Ex"), delta_endstop_adj[A_AXIS]);
   5809                print_signed_float(PSTR("Ey"), delta_endstop_adj[B_AXIS]);
   5810                print_signed_float(PSTR("Ez"), delta_endstop_adj[C_AXIS]);
   5811              }
   5812              if (end_stops && tower_angles) {
   5813                SERIAL_PROTOCOLPAIR("  Radius:", delta_radius);
   5814                SERIAL_EOL();
   5815                SERIAL_CHAR('.');
   5816                SERIAL_PROTOCOL_SP(13);
   5817              }
   5818              if (tower_angles) {
   5819                print_signed_float(PSTR("Tx"), delta_tower_angle_trim[A_AXIS]);
   5820                print_signed_float(PSTR("Ty"), delta_tower_angle_trim[B_AXIS]);
   5821                print_signed_float(PSTR("Tz"), delta_tower_angle_trim[C_AXIS]);
   5822              }
   5823              if ((!end_stops && tower_angles) || (end_stops && !tower_angles)) { // XOR
   5824                SERIAL_PROTOCOLPAIR("  Radius:", delta_radius);
   5825              }
   5826              SERIAL_EOL();
   5827            }
   5828          
   5829            static void print_G33_results(const float z_at_pt[NPP + 1], const bool tower_points, const bool opposite_points) {
   5830              SERIAL_PROTOCOLPGM(".    ");
   5831              print_signed_float(PSTR("c"), z_at_pt[CEN]);
   5832              if (tower_points) {
   5833                print_signed_float(PSTR(" x"), z_at_pt[__A]);
   5834                print_signed_float(PSTR(" y"), z_at_pt[__B]);
   5835                print_signed_float(PSTR(" z"), z_at_pt[__C]);
   5836              }
   5837              if (tower_points && opposite_points) {
   5838                SERIAL_EOL();
   5839                SERIAL_CHAR('.');
   5840                SERIAL_PROTOCOL_SP(13);
   5841              }
   5842              if (opposite_points) {
   5843                print_signed_float(PSTR("yz"), z_at_pt[_BC]);
   5844                print_signed_float(PSTR("zx"), z_at_pt[_CA]);
   5845                print_signed_float(PSTR("xy"), z_at_pt[_AB]);
   5846              }
   5847              SERIAL_EOL();
   5848            }
   5849          
   5850            /**
   5851             * After G33:
   5852             *  - Move to the print ceiling (DELTA_HOME_TO_SAFE_ZONE only)
   5853             *  - Stow the probe
   5854             *  - Restore endstops state
   5855             *  - Select the old tool, if needed
   5856             */
   5857            static void G33_cleanup(
   5858              #if HOTENDS > 1
   5859                const uint8_t old_tool_index
   5860              #endif
   5861            ) {
   5862              #if ENABLED(DELTA_HOME_TO_SAFE_ZONE)
   5863                do_blocking_move_to_z(delta_clip_start_height);
   5864              #endif
   5865              STOW_PROBE();
   5866              clean_up_after_endstop_or_probe_move();
   5867              #if HOTENDS > 1
   5868                tool_change(old_tool_index, 0, true);
   5869              #endif
   5870            }
   5871          
   5872            inline float calibration_probe(const float nx, const float ny, const bool stow) {
   5873              #if HAS_BED_PROBE
   5874                return probe_pt(nx, ny, stow, 0, false);
   5875              #else
   5876                UNUSED(stow);
   5877                return lcd_probe_pt(nx, ny);
   5878              #endif
   5879            }
   5880          
   5881            static float probe_G33_points(float z_at_pt[NPP + 1], const int8_t probe_points, const bool towers_set, const bool stow_after_each) {
   5882              const bool _0p_calibration      = probe_points == 0,
   5883                         _1p_calibration      = probe_points == 1,
   5884                         _4p_calibration      = probe_points == 2,
   5885                         _4p_opposite_points  = _4p_calibration && !towers_set,
   5886                         _7p_calibration      = probe_points >= 3 || probe_points == 0,
   5887                         _7p_no_intermediates = probe_points == 3,
   5888                         _7p_1_intermediates  = probe_points == 4,
   5889                         _7p_2_intermediates  = probe_points == 5,
   5890                         _7p_4_intermediates  = probe_points == 6,
   5891                         _7p_6_intermediates  = probe_points == 7,
   5892                         _7p_8_intermediates  = probe_points == 8,
   5893                         _7p_11_intermediates = probe_points == 9,
   5894                         _7p_14_intermediates = probe_points == 10,
   5895                         _7p_intermed_points  = probe_points >= 4,
   5896                         _7p_6_centre         = probe_points >= 5 && probe_points <= 7,
   5897                         _7p_9_centre         = probe_points >= 8;
   5898          
   5899              LOOP_CAL_ALL(axis) z_at_pt[axis] = 0.0;
   5900          
   5901              if (!_0p_calibration) {
   5902          
   5903                if (!_7p_no_intermediates && !_7p_4_intermediates && !_7p_11_intermediates) { // probe the center
   5904                  z_at_pt[CEN] += calibration_probe(0, 0, stow_after_each);
   5905                  if (isnan(z_at_pt[CEN])) return NAN;
   5906                }
   5907          
   5908                if (_7p_calibration) { // probe extra center points
   5909                  const float start  = _7p_9_centre ? _CA + _7P_STEP / 3.0 : _7p_6_centre ? _CA : __C,
   5910                              steps  = _7p_9_centre ? _4P_STEP / 3.0 : _7p_6_centre ? _7P_STEP : _4P_STEP;
   5911                  I_LOOP_CAL_PT(axis, start, steps) {
   5912                    const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
   5913                                r = delta_calibration_radius * 0.1;
   5914                    z_at_pt[CEN] += calibration_probe(cos(a) * r, sin(a) * r, stow_after_each);
   5915                    if (isnan(z_at_pt[CEN])) return NAN;
   5916                 }
   5917                  z_at_pt[CEN] /= float(_7p_2_intermediates ? 7 : probe_points);
   5918                }
   5919          
   5920                if (!_1p_calibration) {  // probe the radius
   5921                  const CalEnum start  = _4p_opposite_points ? _AB : __A;
   5922                  const float   steps  = _7p_14_intermediates ? _7P_STEP / 15.0 : // 15r * 6 + 10c = 100
   5923                                         _7p_11_intermediates ? _7P_STEP / 12.0 : // 12r * 6 +  9c = 81
   5924                                         _7p_8_intermediates  ? _7P_STEP /  9.0 : //  9r * 6 + 10c = 64
   5925                                         _7p_6_intermediates  ? _7P_STEP /  7.0 : //  7r * 6 +  7c = 49
   5926                                         _7p_4_intermediates  ? _7P_STEP /  5.0 : //  5r * 6 +  6c = 36
   5927                                         _7p_2_intermediates  ? _7P_STEP /  3.0 : //  3r * 6 +  7c = 25
   5928                                         _7p_1_intermediates  ? _7P_STEP /  2.0 : //  2r * 6 +  4c = 16
   5929                                         _7p_no_intermediates ? _7P_STEP :        //  1r * 6 +  3c = 9
   5930                                         _4P_STEP;                                // .5r * 6 +  1c = 4
   5931                  bool zig_zag = true;
   5932                  F_LOOP_CAL_PT(axis, start, _7p_9_centre ? steps * 3 : steps) {
   5933                    const int8_t offset = _7p_9_centre ? 1 : 0;
   5934                    for (int8_t circle = -offset; circle <= offset; circle++) {
   5935                      const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
   5936                                  r = delta_calibration_radius * (1 + 0.1 * (zig_zag ? circle : - circle)),
   5937                                  interpol = fmod(axis, 1);
   5938                      const float z_temp = calibration_probe(cos(a) * r, sin(a) * r, stow_after_each);
   5939                      if (isnan(z_temp)) return NAN;
   5940                      // split probe point to neighbouring calibration points
   5941                      z_at_pt[uint8_t(round(axis - interpol + NPP - 1)) % NPP + 1] += z_temp * sq(cos(RADIANS(interpol * 90)));
   5942                      z_at_pt[uint8_t(round(axis - interpol))           % NPP + 1] += z_temp * sq(sin(RADIANS(interpol * 90)));
   5943                    }
   5944                    zig_zag = !zig_zag;
   5945                  }
   5946                  if (_7p_intermed_points)
   5947                    LOOP_CAL_RAD(axis)
   5948                      z_at_pt[axis] /= _7P_STEP / steps;
   5949                }
   5950          
   5951                float S1 = z_at_pt[CEN],
   5952                      S2 = sq(z_at_pt[CEN]);
   5953                int16_t N = 1;
   5954                if (!_1p_calibration) { // std dev from zero plane
   5955                  LOOP_CAL_ACT(axis, _4p_calibration, _4p_opposite_points) {
   5956                    S1 += z_at_pt[axis];
   5957                    S2 += sq(z_at_pt[axis]);
   5958                    N++;
   5959                  }
   5960                  return round(SQRT(S2 / N) * 1000.0) / 1000.0 + 0.00001;
   5961                }
   5962              }
   5963          
   5964              return 0.00001;
   5965            }
   5966          
   5967            #if HAS_BED_PROBE
   5968          
   5969              static bool G33_auto_tune() {
   5970                float z_at_pt[NPP + 1]      = { 0.0 },
   5971                      z_at_pt_base[NPP + 1] = { 0.0 },
   5972                      z_temp, h_fac = 0.0, r_fac = 0.0, a_fac = 0.0, norm = 0.8;
   5973          
   5974                #define ZP(N,I) ((N) * z_at_pt[I])
   5975                #define Z06(I)  ZP(6, I)
   5976                #define Z03(I)  ZP(3, I)
   5977                #define Z02(I)  ZP(2, I)
   5978                #define Z01(I)  ZP(1, I)
   5979                #define Z32(I)  ZP(3/2, I)
   5980          
   5981                SERIAL_PROTOCOLPGM("AUTO TUNE baseline");
   5982                SERIAL_EOL();
   5983                if (isnan(probe_G33_points(z_at_pt_base, 3, true, false))) return false;
   5984                print_G33_results(z_at_pt_base, true, true);
   5985          
   5986                LOOP_XYZ(axis) {
   5987                  delta_endstop_adj[axis] -= 1.0;
   5988                  recalc_delta_settings();
   5989          
   5990                  endstops.enable(true);
   5991                  if (!home_delta()) return false;
   5992                  endstops.not_homing();
   5993          
   5994                  SERIAL_PROTOCOLPGM("Tuning E");
   5995                  SERIAL_CHAR(tolower(axis_codes[axis]));
   5996                  SERIAL_EOL();
   5997          
   5998                  if (isnan(probe_G33_points(z_at_pt, 3, true, false))) return false;
   5999                  LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
   6000                  print_G33_results(z_at_pt, true, true);
   6001                  delta_endstop_adj[axis] += 1.0;
   6002                  recalc_delta_settings();
   6003                  switch (axis) {
   6004                    case A_AXIS :
   6005                      h_fac += 4.0 / (Z03(CEN) +Z01(__A)                               +Z32(_CA) +Z32(_AB)); // Offset by X-tower end-stop
   6006                      break;
   6007                    case B_AXIS :
   6008                      h_fac += 4.0 / (Z03(CEN)           +Z01(__B)           +Z32(_BC)           +Z32(_AB)); // Offset by Y-tower end-stop
   6009                      break;
   6010                    case C_AXIS :
   6011                      h_fac += 4.0 / (Z03(CEN)                     +Z01(__C) +Z32(_BC) +Z32(_CA)          ); // Offset by Z-tower end-stop
   6012                      break;
   6013                  }
   6014                }
   6015                h_fac /= 3.0;
   6016                h_fac *= norm; // Normalize to 1.02 for Kossel mini
   6017          
   6018                for (int8_t zig_zag = -1; zig_zag < 2; zig_zag += 2) {
   6019                  delta_radius += 1.0 * zig_zag;
   6020                  recalc_delta_settings();
   6021          
   6022                  endstops.enable(true);
   6023                  if (!home_delta()) return false;
   6024                  endstops.not_homing();
   6025          
   6026                  SERIAL_PROTOCOLPGM("Tuning R");
   6027                  SERIAL_PROTOCOL(zig_zag == -1 ? "-" : "+");
   6028                  SERIAL_EOL();
   6029                  if (isnan(probe_G33_points(z_at_pt, 3, true, false))) return false;
   6030                  LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
   6031                  print_G33_results(z_at_pt, true, true);
   6032                  delta_radius -= 1.0 * zig_zag;
   6033                  recalc_delta_settings();
   6034                  r_fac -= zig_zag * 6.0 / (Z03(__A) +Z03(__B) +Z03(__C) +Z03(_BC) +Z03(_CA) +Z03(_AB)); // Offset by delta radius
   6035                }
   6036                r_fac /= 2.0;
   6037                r_fac *= 3 * norm; // Normalize to 2.25 for Kossel mini
   6038          
   6039                LOOP_XYZ(axis) {
   6040                  delta_tower_angle_trim[axis] += 1.0;
   6041                  delta_endstop_adj[(axis + 1) % 3] -= 1.0 / 4.5;
   6042                  delta_endstop_adj[(axis + 2) % 3] += 1.0 / 4.5;
   6043                  z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
   6044                  delta_height -= z_temp;
   6045                  LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
   6046                  recalc_delta_settings();
   6047          
   6048                  endstops.enable(true);
   6049                  if (!home_delta()) return false;
   6050                  endstops.not_homing();
   6051          
   6052                  SERIAL_PROTOCOLPGM("Tuning T");
   6053                  SERIAL_CHAR(tolower(axis_codes[axis]));
   6054                  SERIAL_EOL();
   6055          
   6056                  if (isnan(probe_G33_points(z_at_pt, 3, true, false))) return false;
   6057                  LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
   6058                  print_G33_results(z_at_pt, true, true);
   6059          
   6060                  delta_tower_angle_trim[axis] -= 1.0;
   6061                  delta_endstop_adj[(axis+1) % 3] += 1.0/4.5;
   6062                  delta_endstop_adj[(axis+2) % 3] -= 1.0/4.5;
   6063                  z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
   6064                  delta_height -= z_temp;
   6065                  LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
   6066                  recalc_delta_settings();
   6067                  switch (axis) {
   6068                    case A_AXIS :
   6069                      a_fac += 4.0 / (          Z06(__B) -Z06(__C)           +Z06(_CA) -Z06(_AB)); // Offset by alpha tower angle
   6070                      break;
   6071                    case B_AXIS :
   6072                      a_fac += 4.0 / (-Z06(__A)          +Z06(__C) -Z06(_BC)           +Z06(_AB)); // Offset by beta tower angle
   6073                      break;
   6074                    case C_AXIS :
   6075                      a_fac += 4.0 / (Z06(__A) -Z06(__B)           +Z06(_BC) -Z06(_CA)          ); // Offset by gamma tower angle
   6076                      break;
   6077                  }
   6078                }
   6079                a_fac /= 3.0;
   6080                a_fac *= norm; // Normalize to 0.83 for Kossel mini
   6081          
   6082                endstops.enable(true);
   6083                if (!home_delta()) return false;
   6084                endstops.not_homing();
   6085                print_signed_float(PSTR( "H_FACTOR: "), h_fac);
   6086                print_signed_float(PSTR(" R_FACTOR: "), r_fac);
   6087                print_signed_float(PSTR(" A_FACTOR: "), a_fac);
   6088                SERIAL_EOL();
   6089                SERIAL_PROTOCOLPGM("Copy these values to Configuration.h");
   6090                SERIAL_EOL();
   6091                return true;
   6092              }
   6093          
   6094            #endif // HAS_BED_PROBE
   6095          
   6096            /**
   6097             * G33 - Delta '1-4-7-point' Auto-Calibration
   6098             *       Calibrate height, endstops, delta radius, and tower angles.
   6099             *
   6100             * Parameters:
   6101             *
   6102             *   Pn  Number of probe points:
   6103             *      P0     No probe. Normalize only.
   6104             *      P1     Probe center and set height only.
   6105             *      P2     Probe center and towers. Set height, endstops and delta radius.
   6106             *      P3     Probe all positions: center, towers and opposite towers. Set all.
   6107             *      P4-P10 Probe all positions + at different itermediate locations and average them.
   6108             *
   6109             *   T   Don't calibrate tower angle corrections
   6110             *
   6111             *   Cn.nn  Calibration precision; when omitted calibrates to maximum precision
   6112             *
   6113             *   Fn  Force to run at least n iterations and takes the best result
   6114             *
   6115             *   A   Auto tune calibartion factors (set in Configuration.h)
   6116             *
   6117             *   Vn  Verbose level:
   6118             *      V0  Dry-run mode. Report settings and probe results. No calibration.
   6119             *      V1  Report start and end settings only
   6120             *      V2  Report settings at each iteration
   6121             *      V3  Report settings and probe results
   6122             *
   6123             *   E   Engage the probe for each point
   6124             */
   6125            inline void gcode_G33() {
   6126          
   6127              const int8_t probe_points = parser.intval('P', DELTA_CALIBRATION_DEFAULT_POINTS);
   6128              if (!WITHIN(probe_points, 0, 10)) {
   6129                SERIAL_PROTOCOLLNPGM("?(P)oints is implausible (0-10).");
   6130                return;
   6131              }
   6132          
   6133              const int8_t verbose_level = parser.byteval('V', 1);
   6134              if (!WITHIN(verbose_level, 0, 3)) {
   6135                SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-3).");
   6136                return;
   6137              }
   6138          
   6139              const float calibration_precision = parser.floatval('C', 0.0);
   6140              if (calibration_precision < 0) {
   6141                SERIAL_PROTOCOLLNPGM("?(C)alibration precision is implausible (>=0).");
   6142                return;
   6143              }
   6144          
   6145              const int8_t force_iterations = parser.intval('F', 0);
   6146              if (!WITHIN(force_iterations, 0, 30)) {
   6147                SERIAL_PROTOCOLLNPGM("?(F)orce iteration is implausible (0-30).");
   6148                return;
   6149              }
   6150          
   6151              const bool towers_set           = !parser.boolval('T'),
   6152                         auto_tune            = parser.boolval('A'),
   6153                         stow_after_each      = parser.boolval('E'),
   6154                         _0p_calibration      = probe_points == 0,
   6155                         _1p_calibration      = probe_points == 1,
   6156                         _4p_calibration      = probe_points == 2,
   6157                         _7p_9_centre         = probe_points >= 8,
   6158                         _tower_results       = (_4p_calibration && towers_set)
   6159                                                || probe_points >= 3 || probe_points == 0,
   6160                         _opposite_results    = (_4p_calibration && !towers_set)
   6161                                                || probe_points >= 3 || probe_points == 0,
   6162                         _endstop_results     = probe_points != 1,
   6163                         _angle_results       = (probe_points >= 3 || probe_points == 0) && towers_set;
   6164              const static char save_message[] PROGMEM = "Save with M500 and/or copy to Configuration.h";
   6165              int8_t iterations = 0;
   6166              float test_precision,
   6167                    zero_std_dev = (verbose_level ? 999.0 : 0.0), // 0.0 in dry-run mode : forced end
   6168                    zero_std_dev_min = zero_std_dev,
   6169                    e_old[ABC] = {
   6170                      delta_endstop_adj[A_AXIS],
   6171                      delta_endstop_adj[B_AXIS],
   6172                      delta_endstop_adj[C_AXIS]
   6173                    },
   6174                    dr_old = delta_radius,
   6175                    zh_old = delta_height,
   6176                    ta_old[ABC] = {
   6177                      delta_tower_angle_trim[A_AXIS],
   6178                      delta_tower_angle_trim[B_AXIS],
   6179                      delta_tower_angle_trim[C_AXIS]
   6180                    };
   6181          
   6182              SERIAL_PROTOCOLLNPGM("G33 Auto Calibrate");
   6183          
   6184              if (!_1p_calibration && !_0p_calibration) {  // test if the outer radius is reachable
   6185                LOOP_CAL_RAD(axis) {
   6186                  const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
   6187                              r = delta_calibration_radius * (1 + (_7p_9_centre ? 0.1 : 0.0));
   6188                  if (!position_is_reachable(cos(a) * r, sin(a) * r)) {
   6189                    SERIAL_PROTOCOLLNPGM("?(M665 B)ed radius is implausible.");
   6190                    return;
   6191                  }
   6192                }
   6193              }
   6194          
   6195              stepper.synchronize();
   6196              #if HAS_LEVELING
   6197                reset_bed_level(); // After calibration bed-level data is no longer valid
   6198              #endif
   6199          
   6200              #if HOTENDS > 1
   6201                const uint8_t old_tool_index = active_extruder;
   6202                tool_change(0, 0, true);
   6203                #define G33_CLEANUP() G33_cleanup(old_tool_index)
   6204              #else
   6205                #define G33_CLEANUP() G33_cleanup()
   6206              #endif
   6207          
   6208              setup_for_endstop_or_probe_move();
   6209              endstops.enable(true);
   6210              if (!_0p_calibration) {
   6211                if (!home_delta())
   6212                  return;
   6213                endstops.not_homing();
   6214              }
   6215          
   6216              if (auto_tune) {
   6217                #if HAS_BED_PROBE
   6218                  G33_auto_tune();
   6219                #else
   6220                  SERIAL_PROTOCOLLNPGM("A probe is needed for auto-tune");
   6221                #endif
   6222                G33_CLEANUP();
   6223                return;
   6224              }
   6225          
   6226              // Report settings
   6227          
   6228              const char *checkingac = PSTR("Checking... AC"); // TODO: Make translatable string
   6229              serialprintPGM(checkingac);
   6230              if (verbose_level == 0) SERIAL_PROTOCOLPGM(" (DRY-RUN)");
   6231              SERIAL_EOL();
   6232              lcd_setstatusPGM(checkingac);
   6233          
   6234              print_G33_settings(_endstop_results, _angle_results);
   6235          
   6236              do {
   6237          
   6238                float z_at_pt[NPP + 1] = { 0.0 };
   6239          
   6240                test_precision = zero_std_dev;
   6241          
   6242                iterations++;
   6243          
   6244                // Probe the points
   6245          
   6246                zero_std_dev = probe_G33_points(z_at_pt, probe_points, towers_set, stow_after_each);
   6247                if (isnan(zero_std_dev)) {
   6248                  SERIAL_PROTOCOLPGM("Correct delta_radius with M665 R or end-stops with M666 X Y Z");
   6249                  SERIAL_EOL();
   6250                  return G33_CLEANUP();
   6251                }
   6252          
   6253                // Solve matrices
   6254          
   6255                if ((zero_std_dev < test_precision || iterations <= force_iterations) && zero_std_dev > calibration_precision) {
   6256                  if (zero_std_dev < zero_std_dev_min) {
   6257                    COPY(e_old, delta_endstop_adj);
   6258                    dr_old = delta_radius;
   6259                    zh_old = delta_height;
   6260                    COPY(ta_old, delta_tower_angle_trim);
   6261                  }
   6262          
   6263                  float e_delta[ABC] = { 0.0 }, r_delta = 0.0, t_delta[ABC] = { 0.0 };
   6264                  const float r_diff = delta_radius - delta_calibration_radius,
   6265                              h_factor = 1 / 6.0 *
   6266                                #ifdef H_FACTOR
   6267                                  (H_FACTOR),                                       // Set in Configuration.h
   6268                                #else
   6269                                  (1.00 + r_diff * 0.001),                          // 1.02 for r_diff = 20mm
   6270                                #endif
   6271                              r_factor = 1 / 6.0 *
   6272                                #ifdef R_FACTOR
   6273                                  -(R_FACTOR),                                      // Set in Configuration.h
   6274                                #else
   6275                                  -(1.75 + 0.005 * r_diff + 0.001 * sq(r_diff)),    // 2.25 for r_diff = 20mm
   6276                                #endif
   6277                              a_factor = 1 / 6.0 *
   6278                                #ifdef A_FACTOR
   6279                                  (A_FACTOR);                                       // Set in Configuration.h
   6280                                #else
   6281                                  (66.66 / delta_calibration_radius);               // 0.83 for cal_rd = 80mm
   6282                                #endif
   6283          
   6284                  #define ZP(N,I) ((N) * z_at_pt[I])
   6285                  #define Z6(I) ZP(6, I)
   6286                  #define Z4(I) ZP(4, I)
   6287                  #define Z2(I) ZP(2, I)
   6288                  #define Z1(I) ZP(1, I)
   6289          
   6290                  #if !HAS_BED_PROBE
   6291                    test_precision = 0.00; // forced end
   6292                  #endif
   6293          
   6294                  switch (probe_points) {
   6295                    case 0:
   6296                      test_precision = 0.00; // forced end
   6297                      break;
   6298          
   6299                    case 1:
   6300                      test_precision = 0.00; // forced end
   6301                      LOOP_XYZ(axis) e_delta[axis] = Z1(CEN);
   6302                      break;
   6303          
   6304                    case 2:
   6305                      if (towers_set) {
   6306                        e_delta[A_AXIS] = (Z6(CEN) +Z4(__A) -Z2(__B) -Z2(__C)) * h_factor;
   6307                        e_delta[B_AXIS] = (Z6(CEN) -Z2(__A) +Z4(__B) -Z2(__C)) * h_factor;
   6308                        e_delta[C_AXIS] = (Z6(CEN) -Z2(__A) -Z2(__B) +Z4(__C)) * h_factor;
   6309                        r_delta         = (Z6(CEN) -Z2(__A) -Z2(__B) -Z2(__C)) * r_factor;
   6310                      }
   6311                      else {
   6312                        e_delta[A_AXIS] = (Z6(CEN) -Z4(_BC) +Z2(_CA) +Z2(_AB)) * h_factor;
   6313                        e_delta[B_AXIS] = (Z6(CEN) +Z2(_BC) -Z4(_CA) +Z2(_AB)) * h_factor;
   6314                        e_delta[C_AXIS] = (Z6(CEN) +Z2(_BC) +Z2(_CA) -Z4(_AB)) * h_factor;
   6315                        r_delta         = (Z6(CEN) -Z2(_BC) -Z2(_CA) -Z2(_AB)) * r_factor;
   6316                      }
   6317                      break;
   6318          
   6319                    default:
   6320                      e_delta[A_AXIS] = (Z6(CEN) +Z2(__A) -Z1(__B) -Z1(__C) -Z2(_BC) +Z1(_CA) +Z1(_AB)) * h_factor;
   6321                      e_delta[B_AXIS] = (Z6(CEN) -Z1(__A) +Z2(__B) -Z1(__C) +Z1(_BC) -Z2(_CA) +Z1(_AB)) * h_factor;
   6322                      e_delta[C_AXIS] = (Z6(CEN) -Z1(__A) -Z1(__B) +Z2(__C) +Z1(_BC) +Z1(_CA) -Z2(_AB)) * h_factor;
   6323                      r_delta         = (Z6(CEN) -Z1(__A) -Z1(__B) -Z1(__C) -Z1(_BC) -Z1(_CA) -Z1(_AB)) * r_factor;
   6324          
   6325                      if (towers_set) {
   6326                        t_delta[A_AXIS] = (         -Z4(__B) +Z4(__C)          -Z4(_CA) +Z4(_AB)) * a_factor;
   6327                        t_delta[B_AXIS] = ( Z4(__A)          -Z4(__C) +Z4(_BC)          -Z4(_AB)) * a_factor;
   6328                        t_delta[C_AXIS] = (-Z4(__A) +Z4(__B)          -Z4(_BC) +Z4(_CA)         ) * a_factor;
   6329                        e_delta[A_AXIS] += (t_delta[B_AXIS] - t_delta[C_AXIS]) / 4.5;
   6330                        e_delta[B_AXIS] += (t_delta[C_AXIS] - t_delta[A_AXIS]) / 4.5;
   6331                        e_delta[C_AXIS] += (t_delta[A_AXIS] - t_delta[B_AXIS]) / 4.5;
   6332                      }
   6333                      break;
   6334                  }
   6335          
   6336                  LOOP_XYZ(axis) delta_endstop_adj[axis] += e_delta[axis];
   6337                  delta_radius += r_delta;
   6338                  LOOP_XYZ(axis) delta_tower_angle_trim[axis] += t_delta[axis];
   6339                }
   6340                else if (zero_std_dev >= test_precision) {   // step one back
   6341                  COPY(delta_endstop_adj, e_old);
   6342                  delta_radius = dr_old;
   6343                  delta_height = zh_old;
   6344                  COPY(delta_tower_angle_trim, ta_old);
   6345                }
   6346          
   6347                if (verbose_level != 0) {                                    // !dry run
   6348                  // normalise angles to least squares
   6349                  if (_angle_results) {
   6350                    float a_sum = 0.0;
   6351                    LOOP_XYZ(axis) a_sum += delta_tower_angle_trim[axis];
   6352                    LOOP_XYZ(axis) delta_tower_angle_trim[axis] -= a_sum / 3.0;
   6353                  }
   6354          
   6355                  // adjust delta_height and endstops by the max amount
   6356                  const float z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
   6357                  delta_height -= z_temp;
   6358                  LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
   6359                }
   6360                recalc_delta_settings();
   6361                NOMORE(zero_std_dev_min, zero_std_dev);
   6362          
   6363                // print report
   6364          
   6365                if (verbose_level > 2)
   6366                  print_G33_results(z_at_pt, _tower_results, _opposite_results);
   6367          
   6368                if (verbose_level != 0) {                                    // !dry run
   6369                  if ((zero_std_dev >= test_precision && iterations > force_iterations) || zero_std_dev <= calibration_precision) {  // end iterations
   6370                    SERIAL_PROTOCOLPGM("Calibration OK");
   6371                    SERIAL_PROTOCOL_SP(32);
   6372                    #if HAS_BED_PROBE
   6373                      if (zero_std_dev >= test_precision && !_1p_calibration)
   6374                        SERIAL_PROTOCOLPGM("rolling back.");
   6375                      else
   6376                    #endif
   6377                      {
   6378                        SERIAL_PROTOCOLPGM("std dev:");
   6379                        SERIAL_PROTOCOL_F(zero_std_dev_min, 3);
   6380                      }
   6381                    SERIAL_EOL();
   6382                    char mess[21];
   6383                    strcpy_P(mess, PSTR("Calibration sd:"));
   6384                    if (zero_std_dev_min < 1)
   6385                      sprintf_P(&mess[15], PSTR("0.%03i"), (int)round(zero_std_dev_min * 1000.0));
   6386                    else
   6387                      sprintf_P(&mess[15], PSTR("%03i.x"), (int)round(zero_std_dev_min));
   6388                    lcd_setstatus(mess);
   6389                    print_G33_settings(_endstop_results, _angle_results);
   6390                    serialprintPGM(save_message);
   6391                    SERIAL_EOL();
   6392                  }
   6393                  else {                                                     // !end iterations
   6394                    char mess[15];
   6395                    if (iterations < 31)
   6396                      sprintf_P(mess, PSTR("Iteration : %02i"), (int)iterations);
   6397                    else
   6398                      strcpy_P(mess, PSTR("No convergence"));
   6399                    SERIAL_PROTOCOL(mess);
   6400                    SERIAL_PROTOCOL_SP(32);
   6401                    SERIAL_PROTOCOLPGM("std dev:");
   6402                    SERIAL_PROTOCOL_F(zero_std_dev, 3);
   6403                    SERIAL_EOL();
   6404                    lcd_setstatus(mess);
   6405                    if (verbose_level > 1)
   6406                      print_G33_settings(_endstop_results, _angle_results);
   6407                  }
   6408                }
   6409                else {                                                       // dry run
   6410                  const char *enddryrun = PSTR("End DRY-RUN");
   6411                  serialprintPGM(enddryrun);
   6412                  SERIAL_PROTOCOL_SP(35);
   6413                  SERIAL_PROTOCOLPGM("std dev:");
   6414                  SERIAL_PROTOCOL_F(zero_std_dev, 3);
   6415                  SERIAL_EOL();
   6416          
   6417                  char mess[21];
   6418                  strcpy_P(mess, enddryrun);
   6419                  strcpy_P(&mess[11], PSTR(" sd:"));
   6420                  if (zero_std_dev < 1)
   6421                    sprintf_P(&mess[15], PSTR("0.%03i"), (int)round(zero_std_dev * 1000.0));
   6422                  else
   6423                    sprintf_P(&mess[15], PSTR("%03i.x"), (int)round(zero_std_dev));
   6424                  lcd_setstatus(mess);
   6425                }
   6426          
   6427                endstops.enable(true);
   6428                if (!home_delta())
   6429                  return;
   6430                endstops.not_homing();
   6431          
   6432              }
   6433              while (((zero_std_dev < test_precision && iterations < 31) || iterations <= force_iterations) && zero_std_dev > calibration_precision);
   6434          
   6435              G33_CLEANUP();
   6436            }
   6437          
   6438          #endif // DELTA_AUTO_CALIBRATION
   6439          
   6440          #if ENABLED(G38_PROBE_TARGET)
   6441          
   6442            static bool G38_run_probe() {
   6443          
   6444              bool G38_pass_fail = false;
   6445          
   6446              #if MULTIPLE_PROBING > 1
   6447                // Get direction of move and retract
   6448                float retract_mm[XYZ];
   6449                LOOP_XYZ(i) {
   6450                  float dist = destination[i] - current_position[i];
   6451                  retract_mm[i] = FABS(dist) < G38_MINIMUM_MOVE ? 0 : home_bump_mm((AxisEnum)i) * (dist > 0 ? -1 : 1);
   6452                }
   6453              #endif
   6454          
   6455              stepper.synchronize();  // wait until the machine is idle
   6456          
   6457              // Move until destination reached or target hit
   6458              endstops.enable(true);
   6459              G38_move = true;
   6460              G38_endstop_hit = false;
   6461              prepare_move_to_destination();
   6462              stepper.synchronize();
   6463              G38_move = false;
   6464          
   6465              endstops.hit_on_purpose();
   6466              set_current_from_steppers_for_axis(ALL_AXES);
   6467              SYNC_PLAN_POSITION_KINEMATIC();
   6468          
   6469              if (G38_endstop_hit) {
   6470          
   6471                G38_pass_fail = true;
   6472          
   6473                #if MULTIPLE_PROBING > 1
   6474                  // Move away by the retract distance
   6475                  set_destination_from_current();
   6476                  LOOP_XYZ(i) destination[i] += retract_mm[i];
   6477                  endstops.enable(false);
   6478                  prepare_move_to_destination();
   6479                  stepper.synchronize();
   6480          
   6481                  feedrate_mm_s /= 4;
   6482          
   6483                  // Bump the target more slowly
   6484                  LOOP_XYZ(i) destination[i] -= retract_mm[i] * 2;
   6485          
   6486                  endstops.enable(true);
   6487                  G38_move = true;
   6488                  prepare_move_to_destination();
   6489                  stepper.synchronize();
   6490                  G38_move = false;
   6491          
   6492                  set_current_from_steppers_for_axis(ALL_AXES);
   6493                  SYNC_PLAN_POSITION_KINEMATIC();
   6494                #endif
   6495              }
   6496          
   6497              endstops.hit_on_purpose();
   6498              endstops.not_homing();
   6499              return G38_pass_fail;
   6500            }
   6501          
   6502            /**
   6503             * G38.2 - probe toward workpiece, stop on contact, signal error if failure
   6504             * G38.3 - probe toward workpiece, stop on contact
   6505             *
   6506             * Like G28 except uses Z min probe for all axes
   6507             */
   6508            inline void gcode_G38(bool is_38_2) {
   6509              // Get X Y Z E F
   6510              gcode_get_destination();
   6511          
   6512              setup_for_endstop_or_probe_move();
   6513          
   6514              // If any axis has enough movement, do the move
   6515              LOOP_XYZ(i)
   6516                if (FABS(destination[i] - current_position[i]) >= G38_MINIMUM_MOVE) {
   6517                  if (!parser.seenval('F')) feedrate_mm_s = homing_feedrate_mm_s[(AxisEnum)i];
   6518                  // If G38.2 fails throw an error
   6519                  if (!G38_run_probe() && is_38_2) {
   6520                    SERIAL_ERROR_START();
   6521                    SERIAL_ERRORLNPGM("Failed to reach target");
   6522                  }
   6523                  break;
   6524                }
   6525          
   6526              clean_up_after_endstop_or_probe_move();
   6527            }
   6528          
   6529          #endif // G38_PROBE_TARGET
   6530          
   6531          #if HAS_MESH
   6532          
   6533            /**
   6534             * G42: Move X & Y axes to mesh coordinates (I & J)
   6535             */
   6536            inline void gcode_G42() {
   6537              #if ENABLED(NO_MOTION_BEFORE_HOMING)
   6538                if (axis_unhomed_error()) return;
   6539              #endif
   6540          
   6541              if (IsRunning()) {
   6542                const bool hasI = parser.seenval('I');
   6543                const int8_t ix = hasI ? parser.value_int() : 0;
   6544                const bool hasJ = parser.seenval('J');
   6545                const int8_t iy = hasJ ? parser.value_int() : 0;
   6546          
   6547                if ((hasI && !WITHIN(ix, 0, GRID_MAX_POINTS_X - 1)) || (hasJ && !WITHIN(iy, 0, GRID_MAX_POINTS_Y - 1))) {
   6548                  SERIAL_ECHOLNPGM(MSG_ERR_MESH_XY);
   6549                  return;
   6550                }
   6551          
   6552                set_destination_from_current();
   6553                if (hasI) destination[X_AXIS] = _GET_MESH_X(ix);
   6554                if (hasJ) destination[Y_AXIS] = _GET_MESH_Y(iy);
   6555                if (parser.boolval('P')) {
   6556                  if (hasI) destination[X_AXIS] -= X_PROBE_OFFSET_FROM_EXTRUDER;
   6557                  if (hasJ) destination[Y_AXIS] -= Y_PROBE_OFFSET_FROM_EXTRUDER;
   6558                }
   6559          
   6560                const float fval = parser.linearval('F');
   6561                if (fval > 0.0) feedrate_mm_s = MMM_TO_MMS(fval);
   6562          
   6563                // SCARA kinematic has "safe" XY raw moves
   6564                #if IS_SCARA
   6565                  prepare_uninterpolated_move_to_destination();
   6566                #else
   6567                  prepare_move_to_destination();
   6568                #endif
   6569              }
   6570            }
   6571          
   6572          #endif // HAS_MESH
   6573          
   6574          /**
   6575           * G92: Set current position to given X Y Z E
   6576           */

   \                                 In section .text, align 4
   6577          inline void gcode_G92() {
   \                     _Z9gcode_G92v: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   6578          
   6579            stepper.synchronize();
   \   00000002   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   6580          
   6581            #if ENABLED(CNC_COORDINATE_SYSTEMS)
   6582              switch (parser.subcode) {
   6583                case 1:
   6584                  // Zero the G92 values and restore current position
   6585                  #if !IS_SCARA
   6586                    LOOP_XYZ(i) {
   6587                      const float v = position_shift[i];
   6588                      if (v) {
   6589                        position_shift[i] = 0;
   6590                        update_software_endstops((AxisEnum)i);
   6591                      }
   6592                    }
   6593                  #endif // Not SCARA
   6594                  return;
   6595              }
   6596            #endif
   6597          
   6598            #if ENABLED(CNC_COORDINATE_SYSTEMS)
   6599              #define IS_G92_0 (parser.subcode == 0)
   6600            #else
   6601              #define IS_G92_0 true
   6602            #endif
   6603          
   6604            bool didE = false;
   \   00000006   0x2400             MOVS     R4,#+0
   6605          //  #if IS_SCARA || !HAS_POSITION_SHIFT
   6606            #if 1	//mks dlp
   6607              bool didXYZ = false;
   \   00000008   0x4625             MOV      R5,R4
   6608            #else
   6609              constexpr bool didXYZ = false;
   6610            #endif
   6611          
   6612            if (IS_G92_0) LOOP_XYZE(i) {
   \   0000000A   0x4626             MOV      R6,R4
   \   0000000C   0xE003             B.N      ??gcode_G92_0
   6613              if (parser.seenval(axis_codes[i])) {
   6614                const float l = parser.value_axis_units((AxisEnum)i),
   6615                            v = i == E_AXIS ? l : LOGICAL_TO_NATIVE(l, i),
   6616                            d = v - current_position[i];
   6617                if (!NEAR_ZERO(d)) {
   6618                  //#if IS_SCARA || !HAS_POSITION_SHIFT
   6619          		#if 1	//mks dlp
   6620                    if (i == E_AXIS) didE = true; else didXYZ = true;
   \                     ??gcode_G92_1: (+1)
   \   0000000E   0x2501             MOVS     R5,#+1
   6621                    current_position[i] = v;        // Without workspaces revert to Marlin 1.0 behavior
   \                     ??gcode_G92_2: (+1)
   \   00000010   0xED80 0x0A09      VSTR     S0,[R0, #+36]
   \                     ??gcode_G92_3: (+1)
   \   00000014   0x1C76             ADDS     R6,R6,#+1
   \                     ??gcode_G92_0: (+1)
   \   00000016   0x2E04             CMP      R6,#+4
   \   00000018   0xDA2B             BGE.N    ??gcode_G92_4
   \   0000001A   0x481E             LDR.N    R0,??gcode_G92_5+0x8
   \   0000001C   0x5630             LDRSB    R0,[R6, R0]
   \   0000001E   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD0F6             BEQ.N    ??gcode_G92_3
   \   00000026   0x4630             MOV      R0,R6
   \   00000028   0xB240             SXTB     R0,R0
   \   0000002A   0x.... 0x....      BL       _ZN11GCodeParser16value_axis_unitsE8AxisEnum
   \   0000002E   0x2E03             CMP      R6,#+3
   \   00000030   0xD006             BEQ.N    ??gcode_G92_6
   \   00000032   0x4819             LDR.N    R0,??gcode_G92_5+0xC
   \   00000034   0xEB00 0x0086      ADD      R0,R0,R6, LSL #+2
   \   00000038   0xEDD0 0x0A01      VLDR     S1,[R0, #+4]
   \   0000003C   0xEE30 0x0A60      VSUB.F32 S0,S0,S1
   \                     ??gcode_G92_6: (+1)
   \   00000040   0x4816             LDR.N    R0,??gcode_G92_5+0x10
   \   00000042   0xEB00 0x0086      ADD      R0,R0,R6, LSL #+2
   \   00000046   0xEDD0 0x0A09      VLDR     S1,[R0, #+36]
   \   0000004A   0xEE70 0x0A60      VSUB.F32 S1,S0,S1
   \   0000004E   0xED9F 0x1A0F      VLDR.W   S2,??gcode_G92_5  ;; 0xb58637bd
   \   00000052   0xEEF4 0x0A41      VCMP.F32 S1,S2
   \   00000056   0xEEF1 0xFA10      FMSTAT   
   \   0000005A   0xDB06             BLT.N    ??gcode_G92_7
   \   0000005C   0xED9F 0x1A0C      VLDR.W   S2,??gcode_G92_5+0x4  ;; 0x358637be
   \   00000060   0xEEF4 0x0A41      VCMP.F32 S1,S2
   \   00000064   0xEEF1 0xFA10      FMSTAT   
   \   00000068   0xD4D4             BMI.N    ??gcode_G92_3
   \                     ??gcode_G92_7: (+1)
   \   0000006A   0x2E03             CMP      R6,#+3
   \   0000006C   0xD1CF             BNE.N    ??gcode_G92_1
   \   0000006E   0x2401             MOVS     R4,#+1
   \   00000070   0xE7CE             B.N      ??gcode_G92_2
   6622                  #elif HAS_POSITION_SHIFT
   6623                    if (i == E_AXIS) {
   6624                      didE = true;
   6625                      current_position[E_AXIS] = v; // When using coordinate spaces, only E is set directly
   6626                    }
   6627                    else {
   6628                      position_shift[i] += d;       // Other axes simply offset the coordinate space
   6629                      update_software_endstops((AxisEnum)i);
   6630                    }
   6631                  #endif
   6632                }
   6633              }
   6634            }
   6635          
   6636            #if ENABLED(CNC_COORDINATE_SYSTEMS)
   6637              // Apply workspace offset to the active coordinate system
   6638              if (WITHIN(active_coordinate_system, 0, MAX_COORDINATE_SYSTEMS - 1))
   6639                COPY(coordinate_system[active_coordinate_system], position_shift);
   6640            #endif
   6641          
   6642            if (didXYZ)
   \                     ??gcode_G92_4: (+1)
   \   00000072   0x2D00             CMP      R5,#+0
   \   00000074   0xD002             BEQ.N    ??gcode_G92_8
   6643              SYNC_PLAN_POSITION_KINEMATIC();
   \   00000076   0x.... 0x....      BL       _Z18sync_plan_positionv
   \   0000007A   0xE003             B.N      ??gcode_G92_9
   6644            else if (didE)
   \                     ??gcode_G92_8: (+1)
   \   0000007C   0x2C00             CMP      R4,#+0
   \   0000007E   0xD001             BEQ.N    ??gcode_G92_9
   6645              sync_plan_position_e();
   \   00000080   0x.... 0x....      BL       _Z20sync_plan_position_ev
   6646          
   6647            report_current_position();
   \                     ??gcode_G92_9: (+1)
   \   00000084   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000088   0x.... 0x....      B.W      _Z23report_current_positionv
   \                     ??gcode_G92_5:
   \   0000008C   0xB58637BD         DC32     0xb58637bd
   \   00000090   0x358637BE         DC32     0x358637be
   \   00000094   0x........         DC32     axis_codes
   \   00000098   0x........         DC32     soft_endstops_enabled
   \   0000009C   0x........         DC32     axis_relative_modes
   6648          }
   6649          
   6650          #if HAS_RESUME_CONTINUE
   6651          
   6652            /**
   6653             * M0: Unconditional stop - Wait for user button press on LCD
   6654             * M1: Conditional stop   - Wait for user button press on LCD
   6655             */
   6656            inline void gcode_M0_M1() {
   6657              const char * const args = parser.string_arg;
   6658          
   6659              millis_t ms = 0;
   6660              bool hasP = false, hasS = false;
   6661              if (parser.seenval('P')) {
   6662                ms = parser.value_millis(); // milliseconds to wait
   6663                hasP = ms > 0;
   6664              }
   6665              if (parser.seenval('S')) {
   6666                ms = parser.value_millis_from_seconds(); // seconds to wait
   6667                hasS = ms > 0;
   6668              }
   6669          
   6670              #if ENABLED(ULTIPANEL)
   6671          
   6672                if (!hasP && !hasS && args && *args)
   6673                  lcd_setstatus(args, true);
   6674                else {
   6675                  LCD_MESSAGEPGM(MSG_USERWAIT);
   6676                  #if ENABLED(LCD_PROGRESS_BAR) && PROGRESS_MSG_EXPIRE > 0
   6677                    dontExpireStatus();
   6678                  #endif
   6679                }
   6680          
   6681              #else
   6682          
   6683                if (!hasP && !hasS && args && *args) {
   6684                  SERIAL_ECHO_START();
   6685                  SERIAL_ECHOLN(args);
   6686                }
   6687          
   6688              #endif
   6689          
   6690              KEEPALIVE_STATE(PAUSED_FOR_USER);
   6691              wait_for_user = true;
   6692          
   6693              stepper.synchronize();
   6694              refresh_cmd_timeout();
   6695          
   6696              if (ms > 0) {
   6697                ms += previous_cmd_ms;  // wait until this time for a click
   6698                while (PENDING(millis(), ms) && wait_for_user) idle();
   6699              }
   6700              else {
   6701                #if ENABLED(ULTIPANEL)
   6702                  if (lcd_detected()) {
   6703                    while (wait_for_user) idle();
   6704                    print_job_timer.isPaused() ? LCD_MESSAGEPGM(WELCOME_MSG) : LCD_MESSAGEPGM(MSG_RESUMING);
   6705                  }
   6706                #else
   6707                  while (wait_for_user) idle();
   6708                #endif
   6709              }
   6710          
   6711              wait_for_user = false;
   6712              KEEPALIVE_STATE(IN_HANDLER);
   6713            }
   6714          
   6715          #endif // HAS_RESUME_CONTINUE
   6716          
   6717          #if ENABLED(SPINDLE_LASER_ENABLE)
   6718            /**
   6719             * M3: Spindle Clockwise
   6720             * M4: Spindle Counter-clockwise
   6721             *
   6722             *  S0 turns off spindle.
   6723             *
   6724             *  If no speed PWM output is defined then M3/M4 just turns it on.
   6725             *
   6726             *  At least 12.8KHz (50Hz * 256) is needed for spindle PWM.
   6727             *  Hardware PWM is required. ISRs are too slow.
   6728             *
   6729             * NOTE: WGM for timers 3, 4, and 5 must be either Mode 1 or Mode 5.
   6730             *       No other settings give a PWM signal that goes from 0 to 5 volts.
   6731             *
   6732             *       The system automatically sets WGM to Mode 1, so no special
   6733             *       initialization is needed.
   6734             *
   6735             *       WGM bits for timer 2 are automatically set by the system to
   6736             *       Mode 1. This produces an acceptable 0 to 5 volt signal.
   6737             *       No special initialization is needed.
   6738             *
   6739             * NOTE: A minimum PWM frequency of 50 Hz is needed. All prescaler
   6740             *       factors for timers 2, 3, 4, and 5 are acceptable.
   6741             *
   6742             *  SPINDLE_LASER_ENABLE_PIN needs an external pullup or it may power on
   6743             *  the spindle/laser during power-up or when connecting to the host
   6744             *  (usually goes through a reset which sets all I/O pins to tri-state)
   6745             *
   6746             *  PWM duty cycle goes from 0 (off) to 255 (always on).
   6747             */
   6748          
   6749            // Wait for spindle to come up to speed
   6750            inline void delay_for_power_up() { dwell(SPINDLE_LASER_POWERUP_DELAY); }
   6751          
   6752            // Wait for spindle to stop turning
   6753            inline void delay_for_power_down() { dwell(SPINDLE_LASER_POWERDOWN_DELAY); }
   6754          
   6755            /**
   6756             * ocr_val_mode() is used for debugging and to get the points needed to compute the RPM vs ocr_val line
   6757             *
   6758             * it accepts inputs of 0-255
   6759             */
   6760          
   6761            inline void ocr_val_mode() {
   6762              uint8_t spindle_laser_power = parser.value_byte();
   6763              WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT); // turn spindle on (active low)
   6764              if (SPINDLE_LASER_PWM_INVERT) spindle_laser_power = 255 - spindle_laser_power;
   6765              analogWrite(SPINDLE_LASER_PWM_PIN, spindle_laser_power);
   6766            }
   6767          
   6768            inline void gcode_M3_M4(bool is_M3) {
   6769          
   6770              stepper.synchronize();   // wait until previous movement commands (G0/G0/G2/G3) have completed before playing with the spindle
   6771              #if SPINDLE_DIR_CHANGE
   6772                const bool rotation_dir = (is_M3 && !SPINDLE_INVERT_DIR || !is_M3 && SPINDLE_INVERT_DIR) ? HIGH : LOW;
   6773                if (SPINDLE_STOP_ON_DIR_CHANGE \
   6774                   && READ(SPINDLE_LASER_ENABLE_PIN) == SPINDLE_LASER_ENABLE_INVERT \
   6775                   && READ(SPINDLE_DIR_PIN) != rotation_dir
   6776                ) {
   6777                  WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);  // turn spindle off
   6778                  delay_for_power_down();
   6779                }
   6780                WRITE(SPINDLE_DIR_PIN, rotation_dir);
   6781              #endif
   6782          
   6783              /**
   6784               * Our final value for ocr_val is an unsigned 8 bit value between 0 and 255 which usually means uint8_t.
   6785               * Went to uint16_t because some of the uint8_t calculations would sometimes give 1000 0000 rather than 1111 1111.
   6786               * Then needed to AND the uint16_t result with 0x00FF to make sure we only wrote the byte of interest.
   6787               */
   6788              #if ENABLED(SPINDLE_LASER_PWM)
   6789                if (parser.seen('O')) ocr_val_mode();
   6790                else {
   6791                  const float spindle_laser_power = parser.floatval('S');
   6792                  if (spindle_laser_power == 0) {
   6793                    WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);                                    // turn spindle off (active low)
   6794                    analogWrite(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);                           // only write low byte
   6795                    delay_for_power_down();
   6796                  }
   6797                  else {
   6798                    int16_t ocr_val = (spindle_laser_power - (SPEED_POWER_INTERCEPT)) * (1.0 / (SPEED_POWER_SLOPE));  // convert RPM to PWM duty cycle
   6799                    NOMORE(ocr_val, 255);                                                                             // limit to max the Atmel PWM will support
   6800                    if (spindle_laser_power <= SPEED_POWER_MIN)
   6801                      ocr_val = (SPEED_POWER_MIN - (SPEED_POWER_INTERCEPT)) * (1.0 / (SPEED_POWER_SLOPE));            // minimum setting
   6802                    if (spindle_laser_power >= SPEED_POWER_MAX)
   6803                      ocr_val = (SPEED_POWER_MAX - (SPEED_POWER_INTERCEPT)) * (1.0 / (SPEED_POWER_SLOPE));            // limit to max RPM
   6804                    if (SPINDLE_LASER_PWM_INVERT) ocr_val = 255 - ocr_val;
   6805                    WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT);                                     // turn spindle on (active low)
   6806                    analogWrite(SPINDLE_LASER_PWM_PIN, ocr_val & 0xFF);                                               // only write low byte
   6807                    delay_for_power_up();
   6808                  }
   6809                }
   6810              #else
   6811                WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT); // turn spindle on (active low) if spindle speed option not enabled
   6812                delay_for_power_up();
   6813              #endif
   6814            }
   6815          
   6816           /**
   6817            * M5 turn off spindle
   6818            */
   6819            inline void gcode_M5() {
   6820              stepper.synchronize();
   6821              WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);
   6822              delay_for_power_down();
   6823            }
   6824          
   6825          #endif // SPINDLE_LASER_ENABLE
   6826          
   6827          /**
   6828           * M17: Enable power on all stepper motors
   6829           */

   \                                 In section .text, align 4
   6830          inline void gcode_M17() {
   \                     _Z9gcode_M17v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   6831            LCD_MESSAGEPGM(MSG_NO_MOVE);
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x4803             LDR.N    R0,??gcode_M17_0
   \   00000006   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   6832            enable_all_steppers();
   \   0000000A   0xE8BD 0x4001      POP      {R0,LR}
   \   0000000E   0x.... 0x....      B.W      _Z19enable_all_steppersv
   \   00000012   0xBF00             Nop      
   \                     ??gcode_M17_0:
   \   00000014   0x........         DC32     _ZZ9gcode_M17vEs
   6833          }
   6834          
   6835          #if ENABLED(ADVANCED_PAUSE_FEATURE)
   6836          
   6837            static float resume_position[XYZE];
   6838            static bool move_away_flag = false;
   6839            #if ENABLED(SDSUPPORT)
   6840              static bool sd_print_paused = false;
   6841            #endif
   6842          
   6843            static void filament_change_beep(const int8_t max_beep_count, const bool init=false) {
   6844              static millis_t next_buzz = 0;
   6845              static int8_t runout_beep = 0;
   6846          
   6847              if (init) next_buzz = runout_beep = 0;
   6848          
   6849              const millis_t ms = millis();
   6850              if (ELAPSED(ms, next_buzz)) {
   6851                if (max_beep_count < 0 || runout_beep < max_beep_count + 5) { // Only beep as long as we're supposed to
   6852                  next_buzz = ms + ((max_beep_count < 0 || runout_beep < max_beep_count) ? 2500 : 400);
   6853                  BUZZ(300, 2000);
   6854                  runout_beep++;
   6855                }
   6856              }
   6857            }
   6858          
   6859            static void ensure_safe_temperature() {
   6860              bool heaters_heating = true;
   6861          
   6862              wait_for_heatup = true;    // M108 will clear this
   6863              while (wait_for_heatup && heaters_heating) {
   6864                idle();
   6865                heaters_heating = false;
   6866                HOTEND_LOOP() {
   6867                  if (thermalManager.degTargetHotend(e) && abs(thermalManager.degHotend(e) - thermalManager.degTargetHotend(e)) > TEMP_HYSTERESIS) {
   6868                    heaters_heating = true;
   6869                    #if ENABLED(ULTIPANEL)
   6870                      lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_WAIT_FOR_NOZZLES_TO_HEAT);
   6871                    #endif
   6872                    break;
   6873                  }
   6874                }
   6875              }
   6876            }
   6877          
   6878            #if IS_KINEMATIC
   6879              #define RUNPLAN(RATE_MM_S) planner.buffer_line_kinematic(destination, RATE_MM_S, active_extruder)
   6880            #else
   6881              #define RUNPLAN(RATE_MM_S) buffer_line_to_destination(RATE_MM_S)
   6882            #endif
   6883          
   6884            void do_pause_e_move(const float &length, const float fr) {
   6885              current_position[E_AXIS] += length / planner.e_factor[active_extruder];
   6886              set_destination_from_current();
   6887              RUNPLAN(fr);
   6888              stepper.synchronize();
   6889            }
   6890          
   6891            static bool pause_print(const float &retract, const point_t &park_point, const float &unload_length = 0,
   6892                                    const int8_t max_beep_count = 0, const bool show_lcd = false
   6893            ) {
   6894              if (move_away_flag) return false; // already paused
   6895          
   6896              #ifdef ACTION_ON_PAUSE
   6897                SERIAL_ECHOLNPGM("//action:" ACTION_ON_PAUSE);
   6898              #endif
   6899          
   6900              if (!DEBUGGING(DRYRUN) && unload_length != 0) {
   6901                #if ENABLED(PREVENT_COLD_EXTRUSION)
   6902                  if (!thermalManager.allow_cold_extrude &&
   6903                      thermalManager.degTargetHotend(active_extruder) < thermalManager.extrude_min_temp) {
   6904                    SERIAL_ERROR_START();
   6905                    SERIAL_ERRORLNPGM(MSG_TOO_COLD_FOR_M600);
   6906                    return false;
   6907                  }
   6908                #endif
   6909          
   6910                ensure_safe_temperature(); // wait for extruder to heat up before unloading
   6911              }
   6912          
   6913              // Indicate that the printer is paused
   6914              move_away_flag = true;
   6915          
   6916              // Pause the print job and timer
   6917              #if ENABLED(SDSUPPORT)
   6918                if (card.sdprinting) {
   6919                  card.pauseSDPrint();
   6920                  sd_print_paused = true;
   6921                }
   6922              #endif
   6923              print_job_timer.pause();
   6924          
   6925              // Show initial message and wait for synchronize steppers
   6926              if (show_lcd) {
   6927                #if ENABLED(ULTIPANEL)
   6928                  lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INIT);
   6929                #endif
   6930              }
   6931          
   6932              // Save current position
   6933              stepper.synchronize();
   6934              COPY(resume_position, current_position);
   6935          
   6936              // Initial retract before move to filament change position
   6937              if (retract && !thermalManager.tooColdToExtrude(active_extruder))
   6938                do_pause_e_move(retract, PAUSE_PARK_RETRACT_FEEDRATE);
   6939          
   6940              // Park the nozzle by moving up by z_lift and then moving to (x_pos, y_pos)
   6941              Nozzle::park(2, park_point);
   6942          
   6943              if (unload_length != 0) {
   6944                if (show_lcd) {
   6945                  #if ENABLED(ULTIPANEL)
   6946                    lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_UNLOAD);
   6947                    idle();
   6948                  #endif
   6949                }
   6950          
   6951                // Unload filament
   6952                do_pause_e_move(unload_length, FILAMENT_CHANGE_UNLOAD_FEEDRATE);
   6953              }
   6954          
   6955              if (show_lcd) {
   6956                #if ENABLED(ULTIPANEL)
   6957                  lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INSERT);
   6958                #endif
   6959              }
   6960          
   6961              #if HAS_BUZZER
   6962                filament_change_beep(max_beep_count, true);
   6963              #endif
   6964          
   6965              idle();
   6966          
   6967              // Disable extruders steppers for manual filament changing (only on boards that have separate ENABLE_PINS)
   6968              #if E0_ENABLE_PIN != X_ENABLE_PIN && E1_ENABLE_PIN != Y_ENABLE_PIN
   6969                disable_e_steppers();
   6970                safe_delay(100);
   6971              #endif
   6972          
   6973              // Start the heater idle timers
   6974              const millis_t nozzle_timeout = (millis_t)(PAUSE_PARK_NOZZLE_TIMEOUT) * 1000UL;
   6975          
   6976              HOTEND_LOOP()
   6977                thermalManager.start_heater_idle_timer(e, nozzle_timeout);
   6978          
   6979              return true;
   6980            }
   6981          
   6982            static void wait_for_filament_reload(const int8_t max_beep_count = 0) {
   6983              bool nozzle_timed_out = false;
   6984          
   6985              // Wait for filament insert by user and press button
   6986              KEEPALIVE_STATE(PAUSED_FOR_USER);
   6987              wait_for_user = true;    // LCD click or M108 will clear this
   6988              while (wait_for_user) {
   6989                #if HAS_BUZZER
   6990                  filament_change_beep(max_beep_count);
   6991                #endif
   6992          
   6993                // If the nozzle has timed out, wait for the user to press the button to re-heat the nozzle, then
   6994                // re-heat the nozzle, re-show the insert screen, restart the idle timers, and start over
   6995                if (!nozzle_timed_out)
   6996                  HOTEND_LOOP()
   6997                    nozzle_timed_out |= thermalManager.is_heater_idle(e);
   6998          
   6999                if (nozzle_timed_out) {
   7000                  #if ENABLED(ULTIPANEL)
   7001                    lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_CLICK_TO_HEAT_NOZZLE);
   7002                  #endif
   7003          
   7004                  // Wait for LCD click or M108
   7005                  while (wait_for_user) idle(true);
   7006          
   7007                  // Re-enable the heaters if they timed out
   7008                  HOTEND_LOOP() thermalManager.reset_heater_idle_timer(e);
   7009          
   7010                  // Wait for the heaters to reach the target temperatures
   7011                  ensure_safe_temperature();
   7012          
   7013                  #if ENABLED(ULTIPANEL)
   7014                    lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INSERT);
   7015                  #endif
   7016          
   7017                  // Start the heater idle timers
   7018                  const millis_t nozzle_timeout = (millis_t)(PAUSE_PARK_NOZZLE_TIMEOUT) * 1000UL;
   7019          
   7020                  HOTEND_LOOP()
   7021                    thermalManager.start_heater_idle_timer(e, nozzle_timeout);
   7022          
   7023                  wait_for_user = true; /* Wait for user to load filament */
   7024                  nozzle_timed_out = false;
   7025          
   7026                  #if HAS_BUZZER
   7027                    filament_change_beep(max_beep_count, true);
   7028                  #endif
   7029                }
   7030          
   7031                idle(true);
   7032              }
   7033              KEEPALIVE_STATE(IN_HANDLER);
   7034            }
   7035          
   7036            static void resume_print(const float &load_length = 0, const float &initial_extrude_length = 0, const int8_t max_beep_count = 0) {
   7037              bool nozzle_timed_out = false;
   7038          
   7039              if (!move_away_flag) return;
   7040          
   7041              // Re-enable the heaters if they timed out
   7042              HOTEND_LOOP() {
   7043                nozzle_timed_out |= thermalManager.is_heater_idle(e);
   7044                thermalManager.reset_heater_idle_timer(e);
   7045              }
   7046          
   7047              if (nozzle_timed_out) ensure_safe_temperature();
   7048          
   7049              #if HAS_BUZZER
   7050                filament_change_beep(max_beep_count, true);
   7051              #endif
   7052          
   7053              set_destination_from_current();
   7054          
   7055              if (load_length != 0) {
   7056                #if ENABLED(ULTIPANEL)
   7057                  // Show "insert filament"
   7058                  if (nozzle_timed_out)
   7059                    lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INSERT);
   7060                #endif
   7061          
   7062                KEEPALIVE_STATE(PAUSED_FOR_USER);
   7063                wait_for_user = true;    // LCD click or M108 will clear this
   7064                while (wait_for_user && nozzle_timed_out) {
   7065                  #if HAS_BUZZER
   7066                    filament_change_beep(max_beep_count);
   7067                  #endif
   7068                  idle(true);
   7069                }
   7070                KEEPALIVE_STATE(IN_HANDLER);
   7071          
   7072                #if ENABLED(ULTIPANEL)
   7073                  // Show "load" message
   7074                  lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_LOAD);
   7075                #endif
   7076          
   7077                // Load filament
   7078                do_pause_e_move(load_length, FILAMENT_CHANGE_LOAD_FEEDRATE);
   7079              }
   7080          
   7081              #if ENABLED(ULTIPANEL) && ADVANCED_PAUSE_EXTRUDE_LENGTH > 0
   7082          
   7083                if (!thermalManager.tooColdToExtrude(active_extruder)) {
   7084                  float extrude_length = initial_extrude_length;
   7085          
   7086                  do {
   7087                    if (extrude_length > 0) {
   7088                      // "Wait for filament extrude"
   7089                      lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_EXTRUDE);
   7090          
   7091                      // Extrude filament to get into hotend
   7092                      do_pause_e_move(extrude_length, ADVANCED_PAUSE_EXTRUDE_FEEDRATE);
   7093                    }
   7094          
   7095                    // Show "Extrude More" / "Resume" menu and wait for reply
   7096                    KEEPALIVE_STATE(PAUSED_FOR_USER);
   7097                    wait_for_user = false;
   7098                    lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_OPTION);
   7099                    while (advanced_pause_menu_response == ADVANCED_PAUSE_RESPONSE_WAIT_FOR) idle(true);
   7100                    KEEPALIVE_STATE(IN_HANDLER);
   7101          
   7102                    extrude_length = ADVANCED_PAUSE_EXTRUDE_LENGTH;
   7103          
   7104                    // Keep looping if "Extrude More" was selected
   7105                  } while (advanced_pause_menu_response == ADVANCED_PAUSE_RESPONSE_EXTRUDE_MORE);
   7106                }
   7107          
   7108              #endif
   7109          
   7110              #if ENABLED(ULTIPANEL)
   7111                // "Wait for print to resume"
   7112                lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_RESUME);
   7113              #endif
   7114          
   7115              // Set extruder to saved position
   7116              destination[E_AXIS] = current_position[E_AXIS] = resume_position[E_AXIS];
   7117              planner.set_e_position_mm(current_position[E_AXIS]);
   7118          
   7119              // Move XY to starting position, then Z
   7120              do_blocking_move_to_xy(resume_position[X_AXIS], resume_position[Y_AXIS], NOZZLE_PARK_XY_FEEDRATE);
   7121              do_blocking_move_to_z(resume_position[Z_AXIS], NOZZLE_PARK_Z_FEEDRATE);
   7122          
   7123              #if ENABLED(FILAMENT_RUNOUT_SENSOR)
   7124                filament_ran_out = false;
   7125              #endif
   7126          
   7127              #if ENABLED(ULTIPANEL)
   7128                // Show status screen
   7129                lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_STATUS);
   7130              #endif
   7131          
   7132              #ifdef ACTION_ON_RESUME
   7133                SERIAL_ECHOLNPGM("//action:" ACTION_ON_RESUME);
   7134              #endif
   7135          
   7136              #if ENABLED(SDSUPPORT)
   7137                if (sd_print_paused) {
   7138                  card.startFileprint();
   7139                  sd_print_paused = false;
   7140                }
   7141              #endif
   7142          
   7143              move_away_flag = false;
   7144            }
   7145          #endif // ADVANCED_PAUSE_FEATURE
   7146          
   7147          #if ENABLED(SDSUPPORT)
   7148          
   7149            /**
   7150             * M20: List SD card to serial output
   7151             */

   \                                 In section .text, align 4
   7152            inline void gcode_M20() {
   \                     _Z9gcode_M20v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   7153              SERIAL_PROTOCOLLNPGM(MSG_BEGIN_FILE_LIST);
   \   00000002   0x4805             LDR.N    R0,??gcode_M20_0
   \   00000004   0x.... 0x....      BL       _Z14serialprintPGMPKc
   7154              card.ls();
   \   00000008   0x4804             LDR.N    R0,??gcode_M20_0+0x4
   \   0000000A   0x.... 0x....      BL       _ZN10CardReader2lsEv
   7155              SERIAL_PROTOCOLLNPGM(MSG_END_FILE_LIST);
   \   0000000E   0x4804             LDR.N    R0,??gcode_M20_0+0x8
   \   00000010   0xE8BD 0x4002      POP      {R1,LR}
   \   00000014   0x.... 0x....      B.W      _Z14serialprintPGMPKc
   \                     ??gcode_M20_0:
   \   00000018   0x........         DC32     _ZZ9gcode_M20vEs
   \   0000001C   0x........         DC32     card
   \   00000020   0x........         DC32     _ZZ9gcode_M20vEs_0
   7156            }
   7157          
   7158            /**
   7159             * M21: Init SD Card
   7160             */
   7161            inline void gcode_M21() { card.initsd(); }
   7162          
   7163            /**
   7164             * M22: Release SD Card
   7165             */

   \                                 In section .text, align 4
   7166            inline void gcode_M22() { card.release(); }
   \                     _Z9gcode_M22v: (+1)
   \   00000000   0x4801             LDR.N    R0,??gcode_M22_0
   \   00000002   0x.... 0x....      B.W      _ZN10CardReader7releaseEv
   \   00000006   0xBF00             Nop      
   \                     ??gcode_M22_0:
   \   00000008   0x........         DC32     card
   7167          
   7168            /**
   7169             * M23: Open a file
   7170             */
   7171             #ifdef USE_MKS_WIFI    
   7172            inline void gcode_M23() { 
   7173            	if(card.openFile(parser.command_ptr, true) < 0)
   7174            	{
   7175            		/*for 8.3 principle*/
   7176          		char *gSuffix = strstr((char *)parser.command_ptr, ".g");
   7177          		if(!gSuffix)
   7178          		{
   7179          			gSuffix = strstr((char *)parser.command_ptr, ".G");		
   7180          		}
   7181          		if(gSuffix)
   7182          		{
   7183          			*(gSuffix + 2) = '\0';
   7184          			if((uint32_t)gSuffix - (uint32_t)parser.command_ptr > 8)
   7185          			{
   7186          				parser.command_ptr[7] = '~';
   7187          				parser.command_ptr[8] = '.';
   7188          				parser.command_ptr[9] = 'g';
   7189          				parser.command_ptr[10] = '\0';
   7190          			}
   7191          			card.openFile(parser.command_ptr, true) ;
   7192          		}
   7193            	}
   7194            }
   7195          #else

   \                                 In section .text, align 4
   7196            inline void gcode_M23() {
   \                     _Z9gcode_M23v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   7197              // Simplify3D includes the size, so zero out all spaces (#7227)
   7198              for (char *fn = parser.string_arg; *fn; ++fn) if (*fn == ' ') *fn = '\0';
   \   00000002   0x480D             LDR.N    R0,??gcode_M23_0
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0xE004             B.N      ??gcode_M23_1
   \                     ??gcode_M23_2: (+1)
   \   00000008   0x2A20             CMP      R2,#+32
   \   0000000A   0xD101             BNE.N    ??gcode_M23_3
   \   0000000C   0x2200             MOVS     R2,#+0
   \   0000000E   0x700A             STRB     R2,[R1, #+0]
   \                     ??gcode_M23_3: (+1)
   \   00000010   0x1C49             ADDS     R1,R1,#+1
   \                     ??gcode_M23_1: (+1)
   \   00000012   0xF991 0x2000      LDRSB    R2,[R1, #+0]
   \   00000016   0x2A00             CMP      R2,#+0
   \   00000018   0xD1F6             BNE.N    ??gcode_M23_2
   7199              card.openFile(parser.string_arg, true);
   \   0000001A   0x4C08             LDR.N    R4,??gcode_M23_0+0x4
   \   0000001C   0x2301             MOVS     R3,#+1
   \   0000001E   0x461A             MOV      R2,R3
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       _ZN10CardReader8openFileEPcbb
   7200              strcpy(curFileName, mksReprint.filename);//(uint8_t *)&mksReprint.filename[0]
   \   00000028   0xF604 0x41CC      ADDW     R1,R4,#+3276
   \   0000002C   0x4804             LDR.N    R0,??gcode_M23_0+0x8
   \   0000002E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000032   0x.... 0x....      B.W      strcpy
   \   00000036   0xBF00             Nop      
   \                     ??gcode_M23_0:
   \   00000038   0x........         DC32     _ZN11GCodeParser10string_argE
   \   0000003C   0x........         DC32     card
   \   00000040   0x........         DC32     curFileName
   7201            }
   7202          #endif
   7203            /**
   7204             * M24: Start or Resume SD Print
   7205             */

   \                                 In section .text, align 4
   7206            inline void gcode_M24() {
   \                     _Z9gcode_M24v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   7207            	mks_resumePrint();
   \   00000002   0x.... 0x....      BL       mks_resumePrint
   7208            
   7209              #if ENABLED(PARK_HEAD_ON_PAUSE)
   7210                resume_print();
   7211              #endif
   7212          	
   7213          	#ifdef USE_MKS_WIFI
   7214          	if(card.lastOpenOk())
   7215          	#endif	
   7216          		if(mksReprint.mks_printer_state != MKS_REPRINTING && mksReprint.mks_printer_state != MKS_REPRINTED)
   \   00000006   0x4C08             LDR.N    R4,??gcode_M24_0
   \   00000008   0xF894 0x0D10      LDRB     R0,[R4, #+3344]
   \   0000000C   0x28AA             CMP      R0,#+170
   \   0000000E   0xD00A             BEQ.N    ??gcode_M24_1
   \   00000010   0x28AB             CMP      R0,#+171
   \   00000012   0xD008             BEQ.N    ??gcode_M24_1
   7217          		{
   7218          	    	card.startFileprint();
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       _ZN10CardReader14startFileprintEv
   7219          	    	print_job_timer.start();
   \   0000001A   0xF504 0x6060      ADD      R0,R4,#+3584
   \   0000001E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000022   0x.... 0x....      B.W      _ZN9Stopwatch5startEv
   7220          		}
   7221            }
   \                     ??gcode_M24_1: (+1)
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
   \                     ??gcode_M24_0:
   \   00000028   0x........         DC32     card
   7222          
   7223            /**
   7224             * M25: Pause SD Print
   7225             */

   \                                 In section .text, align 4
   7226            inline void gcode_M25() {
   \                     _Z9gcode_M25v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   7227              card.pauseSDPrint();
   \   00000002   0x4C06             LDR.N    R4,??gcode_M25_0
   \   00000004   0x4620             MOV      R0,R4
   \   00000006   0x.... 0x....      BL       _ZN10CardReader12pauseSDPrintEv
   7228              print_job_timer.pause();
   \   0000000A   0xF504 0x6060      ADD      R0,R4,#+3584
   \   0000000E   0x.... 0x....      BL       _ZN9Stopwatch5pauseEv
   7229          
   7230              #if ENABLED(PARK_HEAD_ON_PAUSE)
   7231                enqueue_and_echo_commands_P(PSTR("M125")); // Must be enqueued with pauseSDPrint set to be last in the buffer
   7232              #endif
   7233          	
   7234          	mksReprint.mks_printer_state = MKS_PAUSING;
   \   00000012   0x20A8             MOVS     R0,#+168
   \   00000014   0xF884 0x0D10      STRB     R0,[R4, #+3344]
   7235            }
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
   \   0000001A   0xBF00             Nop      
   \                     ??gcode_M25_0:
   \   0000001C   0x........         DC32     card
   7236          /**
   7237          	 * M998: Stop SD Print
   7238          */

   \                                 In section .text, align 4
   7239          	inline void gcode_M998() {
   \                     _Z10gcode_M998v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   7240          		if(mksReprint.mks_printer_state == MKS_REPRINTED)	
   \   00000002   0x4C17             LDR.N    R4,??gcode_M998_0
   \   00000004   0xF894 0x0D10      LDRB     R0,[R4, #+3344]
   \   00000008   0x28AB             CMP      R0,#+171
   \   0000000A   0xD028             BEQ.N    ??gcode_M998_1
   7241          		return;
   7242          			
   7243          		mksReprint.mks_printer_state = MKS_IDLE;
   \   0000000C   0x20A6             MOVS     R0,#+166
   \   0000000E   0xF884 0x0D10      STRB     R0,[R4, #+3344]
   7244                  if(gCfgItems.pwroff_save_mode != 1)
   \   00000012   0x4814             LDR.N    R0,??gcode_M998_0+0x4
   \   00000014   0xF890 0x017B      LDRB     R0,[R0, #+379]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD006             BEQ.N    ??gcode_M998_2
   7245          		    epr_write_data(EPR_SAV_FLAG, (uint8_t *)&mksReprint.mks_printer_state,sizeof(mksReprint.mks_printer_state));
   \   0000001C   0x2201             MOVS     R2,#+1
   \   0000001E   0xF504 0x6151      ADD      R1,R4,#+3344
   \   00000022   0xF44F 0x707A      MOV      R0,#+1000
   \   00000026   0x.... 0x....      BL       epr_write_data
   7246          
   7247          		card.stopSDPrint();
   \                     ??gcode_M998_2: (+1)
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       _ZN10CardReader11stopSDPrintEv
   7248          		clear_command_queue();
   \   00000030   0x.... 0x....      BL       _Z19clear_command_queuev
   7249          		quickstop_stepper();
   \   00000034   0x.... 0x....      BL       _Z17quickstop_stepperv
   7250          		print_job_timer.stop();
   \   00000038   0xF504 0x6060      ADD      R0,R4,#+3584
   \   0000003C   0x.... 0x....      BL       _ZN9Stopwatch4stopEv
   7251          		thermalManager.disable_all_heaters();
   \   00000040   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
   7252          		#if FAN_COUNT > 0
   7253          			for (uint8_t i = 0; i < FAN_COUNT; i++) 
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xE005             B.N      ??gcode_M998_3
   7254                      {         
   7255                          fanSpeeds[i] = 0;
   \                     ??gcode_M998_4: (+1)
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x4907             LDR.N    R1,??gcode_M998_0+0x8
   \   0000004C   0x6008             STR      R0,[R1, #+0]
   7256                          #if 1
   7257                          MKS_FAN_TIM = 0 ;
   \   0000004E   0x4907             LDR.N    R1,??gcode_M998_0+0xC  ;; 0x42408288
   \   00000050   0x6008             STR      R0,[R1, #+0]
   7258                          #endif
   7259                       }
   \   00000052   0x2001             MOVS     R0,#+1
   \                     ??gcode_M998_3: (+1)
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD0F7             BEQ.N    ??gcode_M998_4
   7260          		#endif
   7261          		wait_for_heatup = false;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x4905             LDR.N    R1,??gcode_M998_0+0x10
   \   0000005C   0x7548             STRB     R0,[R1, #+21]
   7262          	}
   \                     ??gcode_M998_1: (+1)
   \   0000005E   0xBD10             POP      {R4,PC}          ;; return
   \                     ??gcode_M998_0:
   \   00000060   0x........         DC32     card
   \   00000064   0x........         DC32     gCfgItems
   \   00000068   0x........         DC32     fanSpeeds
   \   0000006C   0x42408288         DC32     0x42408288
   \   00000070   0x........         DC32     axis_relative_modes
   7263          
   7264            /**
   7265             * M26: Set SD Card file index
   7266             */

   \                                 In section .text, align 4
   7267            inline void gcode_M26() {
   \                     _Z9gcode_M26v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   7268              if (card.cardOK && parser.seenval('S'))
   \   00000002   0x4C09             LDR.N    R4,??gcode_M26_0
   \   00000004   0xF894 0x09BB      LDRB     R0,[R4, #+2491]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD00C             BEQ.N    ??gcode_M26_1
   \   0000000C   0x2053             MOVS     R0,#+83
   \   0000000E   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD007             BEQ.N    ??gcode_M26_1
   7269                card.setIndex(parser.value_long());
   \   00000016   0x.... 0x....      BL       _ZN11GCodeParser10value_longEv
   \   0000001A   0x4601             MOV      R1,R0
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000022   0x.... 0x....      B.W      _ZN10CardReader8setIndexEl
   7270            }
   \                     ??gcode_M26_1: (+1)
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
   \                     ??gcode_M26_0:
   \   00000028   0x........         DC32     card
   7271          
   7272            /**
   7273             * M27: Get SD Card status
   7274             */

   \                                 In section .text, align 4
   7275            inline void gcode_M27() { card.getStatus(); }
   \                     _Z9gcode_M27v: (+1)
   \   00000000   0x4801             LDR.N    R0,??gcode_M27_0
   \   00000002   0x.... 0x....      B.W      _ZN10CardReader9getStatusEv
   \   00000006   0xBF00             Nop      
   \                     ??gcode_M27_0:
   \   00000008   0x........         DC32     card
   7276          
   7277            /**
   7278             * M28: Start SD Write
   7279             */

   \                                 In section .text, align 4
   7280            inline void gcode_M28() { card.openFile(parser.string_arg, false); }
   \                     _Z9gcode_M28v: (+1)
   \   00000000   0x2301             MOVS     R3,#+1
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x4802             LDR.N    R0,??gcode_M28_0
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x4802             LDR.N    R0,??gcode_M28_0+0x4
   \   0000000A   0x.... 0x....      B.W      _ZN10CardReader8openFileEPcbb
   \   0000000E   0xBF00             Nop      
   \                     ??gcode_M28_0:
   \   00000010   0x........         DC32     _ZN11GCodeParser10string_argE
   \   00000014   0x........         DC32     card
   7281          
   7282            /**
   7283             * M29: Stop SD Write
   7284             * Processed in write to file routine above
   7285             */

   \                                 In section .text, align 2
   7286            inline void gcode_M29() {
   7287              // card.saving = false;
   7288            }
   \                     _Z9gcode_M29v: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   7289          
   7290            /**
   7291             * M30 <filename>: Delete SD Card file
   7292             */

   \                                 In section .text, align 4
   7293            inline void gcode_M30() {
   \                     _Z9gcode_M30v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   7294              if (card.cardOK) {
   \   00000002   0x4C08             LDR.N    R4,??gcode_M30_0
   \   00000004   0xF894 0x09BB      LDRB     R0,[R4, #+2491]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD00A             BEQ.N    ??gcode_M30_1
   7295                card.closefile();
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       _ZN10CardReader9closefileEb
   7296                card.removeFile(parser.string_arg);
   \   00000014   0x4804             LDR.N    R0,??gcode_M30_0+0x4
   \   00000016   0x6801             LDR      R1,[R0, #+0]
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001E   0x.... 0x....      B.W      _ZN10CardReader10removeFileEPc
   7297              }
   7298            }
   \                     ??gcode_M30_1: (+1)
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
   \                     ??gcode_M30_0:
   \   00000024   0x........         DC32     card
   \   00000028   0x........         DC32     _ZN11GCodeParser10string_argE
   7299          
   7300          #endif // SDSUPPORT
   7301          
   7302          /**
   7303           * M31: Get the time since the start of SD Print (or last M109)
   7304           */

   \                                 In section .text, align 4
   7305          inline void gcode_M31() {
   \                     _Z9gcode_M31v: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
   7306            char buffer[21];
   7307            duration_t elapsed = print_job_timer.duration();
   \   00000004   0x480D             LDR.N    R0,??gcode_M31_0
   \   00000006   0x.... 0x....      BL       _ZN9Stopwatch8durationEv
   \   0000000A   0x9000             STR      R0,[SP, #+0]
   \   0000000C   0xA900             ADD      R1,SP,#+0
   \   0000000E   0xA801             ADD      R0,SP,#+4
   \   00000010   0x.... 0x....      BL       _ZN10duration_tC1ERKj
   7308            elapsed.toString(buffer);
   \   00000014   0xA902             ADD      R1,SP,#+8
   \   00000016   0x.... 0x....      BL       _ZNK10duration_t8toStringEPc
   7309            lcd_setstatus(buffer);
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0xA802             ADD      R0,SP,#+8
   \   0000001E   0x.... 0x....      BL       _Z13lcd_setstatusPKcb
   7310          
   7311            SERIAL_ECHO_START();
   \   00000022   0x4807             LDR.N    R0,??gcode_M31_0+0x4
   \   00000024   0x.... 0x....      BL       _Z14serialprintPGMPKc
   7312            SERIAL_ECHOLNPAIR("Print time: ", buffer);
   \   00000028   0xA902             ADD      R1,SP,#+8
   \   0000002A   0x4806             LDR.N    R0,??gcode_M31_0+0x8
   \   0000002C   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
   \   00000030   0x210A             MOVS     R1,#+10
   \   00000032   0x4805             LDR.N    R0,??gcode_M31_0+0xC
   \   00000034   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   7313          }
   \   00000038   0xB009             ADD      SP,SP,#+36
   \   0000003A   0xBD00             POP      {PC}             ;; return
   \                     ??gcode_M31_0:
   \   0000003C   0x........         DC32     card+0xE00
   \   00000040   0x........         DC32     echomagic
   \   00000044   0x........         DC32     _ZZ9gcode_M31vEs
   \   00000048   0x........         DC32     Serial6
   7314          
   7315          #if ENABLED(SDSUPPORT)
   7316          
   7317            /**
   7318             * M32: Select file and start SD Print
   7319             *
   7320             * Examples:
   7321             *
   7322             *    M32 !PATH/TO/FILE.GCO#      ; Start FILE.GCO
   7323             *    M32 P !PATH/TO/FILE.GCO#    ; Start FILE.GCO as a procedure
   7324             *    M32 S60 !PATH/TO/FILE.GCO#  ; Start FILE.GCO at byte 60
   7325             *
   7326             */

   \                                 In section .text, align 4
   7327            inline void gcode_M32() {
   \                     _Z9gcode_M32v: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   7328              if (card.sdprinting) stepper.synchronize();
   \   00000002   0x4C17             LDR.N    R4,??gcode_M32_0
   \   00000004   0xF894 0x09B8      LDRB     R0,[R4, #+2488]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD001             BEQ.N    ??gcode_M32_1
   \   0000000C   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   7329          
   7330              if (card.cardOK|| card.usbOK) {
   \                     ??gcode_M32_1: (+1)
   \   00000010   0xF604 0x10B8      ADDW     R0,R4,#+2488
   \   00000014   0x78C1             LDRB     R1,[R0, #+3]
   \   00000016   0x7900             LDRB     R0,[R0, #+4]
   \   00000018   0x4308             ORRS     R0,R0,R1
   \   0000001A   0xD020             BEQ.N    ??gcode_M32_2
   7331                const bool call_procedure = parser.boolval('P');
   \   0000001C   0x2050             MOVS     R0,#+80
   \   0000001E   0x.... 0x....      BL       _ZN11GCodeParser7boolvalEc
   \   00000022   0x4605             MOV      R5,R0
   7332          
   7333                card.openFile(parser.string_arg, true, call_procedure);
   \   00000024   0x462B             MOV      R3,R5
   \   00000026   0x2201             MOVS     R2,#+1
   \   00000028   0x480E             LDR.N    R0,??gcode_M32_0+0x4
   \   0000002A   0x6801             LDR      R1,[R0, #+0]
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       _ZN10CardReader8openFileEPcbb
   7334          
   7335                if (parser.seenval('S')) card.setIndex(parser.value_long());
   \   00000032   0x2053             MOVS     R0,#+83
   \   00000034   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD005             BEQ.N    ??gcode_M32_3
   \   0000003C   0x.... 0x....      BL       _ZN11GCodeParser10value_longEv
   \   00000040   0x4601             MOV      R1,R0
   \   00000042   0x4620             MOV      R0,R4
   \   00000044   0x.... 0x....      BL       _ZN10CardReader8setIndexEl
   7336          
   7337                card.startFileprint();
   \                     ??gcode_M32_3: (+1)
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0x.... 0x....      BL       _ZN10CardReader14startFileprintEv
   7338          
   7339                // Procedure calls count as normal print time.
   7340                if (!call_procedure) print_job_timer.start();
   \   0000004E   0x2D00             CMP      R5,#+0
   \   00000050   0xD105             BNE.N    ??gcode_M32_2
   \   00000052   0xF504 0x6060      ADD      R0,R4,#+3584
   \   00000056   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000005A   0x.... 0x....      B.W      _ZN9Stopwatch5startEv
   7341              }
   7342            }
   \                     ??gcode_M32_2: (+1)
   \   0000005E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \                     ??gcode_M32_0:
   \   00000060   0x........         DC32     card
   \   00000064   0x........         DC32     _ZN11GCodeParser10string_argE
   7343          
   7344            #if ENABLED(LONG_FILENAME_HOST_SUPPORT)
   7345          
   7346              /**
   7347               * M33: Get the long full path of a file or folder
   7348               *
   7349               * Parameters:
   7350               *   <dospath> Case-insensitive DOS-style path to a file or folder
   7351               *
   7352               * Example:
   7353               *   M33 miscel~1/armchair/armcha~1.gco
   7354               *
   7355               * Output:
   7356               *   /Miscellaneous/Armchair/Armchair.gcode
   7357               */
   7358              inline void gcode_M33() {
   7359                card.printLongPath(parser.string_arg);
   7360              }
   7361          
   7362            #endif
   7363          
   7364            #if ENABLED(SDCARD_SORT_ALPHA) && ENABLED(SDSORT_GCODE)
   7365              /**
   7366               * M34: Set SD Card Sorting Options
   7367               */
   7368              inline void gcode_M34() {
   7369                if (parser.seen('S')) card.setSortOn(parser.value_bool());
   7370                if (parser.seenval('F')) {
   7371                  const int v = parser.value_long();
   7372                  card.setSortFolders(v < 0 ? -1 : v > 0 ? 1 : 0);
   7373                }
   7374                //if (parser.seen('R')) card.setSortReverse(parser.value_bool());
   7375              }
   7376            #endif // SDCARD_SORT_ALPHA && SDSORT_GCODE
   7377          
   7378            /**
   7379             * M928: Start SD Write
   7380             */

   \                                 In section .text, align 4
   7381            inline void gcode_M928() {
   7382              card.openLogFile(parser.string_arg);
   \                     _Z10gcode_M928v: (+1)
   \   00000000   0x4802             LDR.N    R0,??gcode_M928_0
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x4802             LDR.N    R0,??gcode_M928_0+0x4
   \   00000006   0x.... 0x....      B.W      _ZN10CardReader11openLogFileEPc
   \   0000000A   0xBF00             Nop      
   \                     ??gcode_M928_0:
   \   0000000C   0x........         DC32     _ZN11GCodeParser10string_argE
   \   00000010   0x........         DC32     card
   7383            }
   7384          
   7385          #endif // SDSUPPORT
   7386          
   7387          /**
   7388           * Sensitive pin test for M42, M226
   7389           */

   \                                 In section .text, align 2, keep-with-next
   7390          static bool pin_is_protected(const int8_t pin) {
   7391            static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   7392            for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
   \                     _Z16pin_is_protecteda: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xE000             B.N      ??pin_is_protected_0
   \                     ??pin_is_protected_1: (+1)
   \   00000004   0x1C49             ADDS     R1,R1,#+1
   \                     ??pin_is_protected_0: (+1)
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x2928             CMP      R1,#+40
   \   0000000A   0xD206             BCS.N    ??pin_is_protected_2
   7393              if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   \   0000000C   0x.... 0x....      ADR.W    R2,??sensitive_pins
   \   00000010   0x568A             LDRSB    R2,[R1, R2]
   \   00000012   0x4290             CMP      R0,R2
   \   00000014   0xD1F6             BNE.N    ??pin_is_protected_1
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x4770             BX       LR
   7394            return false;
   \                     ??pin_is_protected_2: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x4770             BX       LR               ;; return
   7395          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??sensitive_pins:
   \   00000000   0x00 0x01          DC8 0, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 0, 2, 3, 4, -1, -1
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0x01 0x00    
   \              0x02 0x03    
   \              0x04 0xFF    
   \              0xFF         
   \   00000013   0xFF 0x08          DC8 -1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF         
   \   00000024   0xFF 0xFF          DC8 -1, -1, -1, -1
   \              0xFF 0xFF    
   7396          
   7397          /**
   7398           * M42: Change pin status via GCode
   7399           *
   7400           *  P<pin>  Pin number (LED if omitted)
   7401           *  S<byte> Pin status from 0 - 255
   7402           */

   \                                 In section .text, align 4
   7403          inline void gcode_M42() {
   \                     _Z9gcode_M42v: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   7404            if (!parser.seenval('S')) return;
   \   00000002   0x2053             MOVS     R0,#+83
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD02B             BEQ.N    ??gcode_M42_0
   7405            const byte pin_status = parser.value_byte();
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser10value_byteEv
   \   00000010   0x4604             MOV      R4,R0
   7406          
   7407            const int pin_number = parser.intval('P', LED_PIN);
   \   00000012   0xF04F 0x31FF      MOV      R1,#-1
   \   00000016   0x2050             MOVS     R0,#+80
   \   00000018   0x.... 0x....      BL       _ZN11GCodeParser6intvalEcs
   \   0000001C   0x0005             MOVS     R5,R0
   7408            if (pin_number < 0) return;
   \   0000001E   0xD421             BMI.N    ??gcode_M42_0
   7409          
   7410            if (pin_is_protected(pin_number)) {
   \   00000020   0xB240             SXTB     R0,R0
   \   00000022   0x.... 0x....      BL       _Z16pin_is_protecteda
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD007             BEQ.N    ??gcode_M42_1
   7411              SERIAL_ERROR_START();
   \   0000002A   0x480F             LDR.N    R0,??gcode_M42_2
   \   0000002C   0x.... 0x....      BL       _Z14serialprintPGMPKc
   7412              SERIAL_ERRORLNPGM(MSG_ERR_PROTECTED_PIN);
   \   00000030   0x480E             LDR.N    R0,??gcode_M42_2+0x4
   \   00000032   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000036   0x.... 0x....      B.W      _Z14serialprintPGMPKc
   7413              return;
   7414            }
   7415          
   7416            pinMode(pin_number, OUTPUT);
   7417            digitalWrite(pin_number, pin_status);
   \                     ??gcode_M42_1: (+1)
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0x4622             MOV      R2,R4
   \   0000003E   0xB252             SXTB     R2,R2
   \   00000040   0xD408             BMI.N    ??gcode_M42_3
   \   00000042   0x480B             LDR.N    R0,??gcode_M42_2+0x8
   \   00000044   0xF830 0x1015      LDRH     R1,[R0, R5, LSL #+1]
   \   00000048   0x480A             LDR.N    R0,??gcode_M42_2+0xC
   \   0000004A   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   0000004E   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000052   0xE003             B.N      ??gcode_M42_4
   \                     ??gcode_M42_3: (+1)
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0x4608             MOV      R0,R1
   \   00000058   0x.... 0x....      BL       HAL_GPIO_WritePin
   7418            //analogWrite(pin_number, pin_status);
   7419          
   7420            #if FAN_COUNT > 0
   7421              switch (pin_number) {
   \                     ??gcode_M42_4: (+1)
   \   0000005C   0x2D08             CMP      R5,#+8
   \   0000005E   0xD101             BNE.N    ??gcode_M42_0
   7422                #if HAS_FAN0
   7423                  case FAN_PIN: fanSpeeds[0] = pin_status; break;
   \   00000060   0x4805             LDR.N    R0,??gcode_M42_2+0x10
   \   00000062   0x6004             STR      R4,[R0, #+0]
   7424                #endif
   7425                #if HAS_FAN1
   7426                  case FAN1_PIN: fanSpeeds[1] = pin_status; break;
   7427                #endif
   7428                #if HAS_FAN2
   7429                  case FAN2_PIN: fanSpeeds[2] = pin_status; break;
   7430                #endif
   7431              }
   7432            #endif
   7433          }
   \                     ??gcode_M42_0: (+1)
   \   00000064   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \   00000066   0xBF00             Nop      
   \                     ??gcode_M42_2:
   \   00000068   0x........         DC32     errormagic
   \   0000006C   0x........         DC32     _ZZ9gcode_M42vEs
   \   00000070   0x........         DC32     gArrayGpioPin
   \   00000074   0x........         DC32     gArrayGpioPort
   \   00000078   0x........         DC32     fanSpeeds
   7434          
   7435          #if ENABLED(PINS_DEBUGGING)
   7436          
   7437            #include "pinsDebug.h"
   7438          
   7439            inline void toggle_pins() {
   7440              const bool I_flag = parser.boolval('I');
   7441              const int repeat = parser.intval('R', 1),
   7442                        start = parser.intval('S'),
   7443                        end = parser.intval('L', NUM_DIGITAL_PINS - 1),
   7444                        wait = parser.intval('W', 500);
   7445          
   7446              for (uint8_t pin = start; pin <= end; pin++) {
   7447                //report_pin_state_extended(pin, I_flag, false);
   7448          
   7449                if (!I_flag && pin_is_protected(pin)) {
   7450                  report_pin_state_extended(pin, I_flag, true, "Untouched ");
   7451                  SERIAL_EOL();
   7452                }
   7453                else {
   7454                  report_pin_state_extended(pin, I_flag, true, "Pulsing   ");
   7455                  #if AVR_AT90USB1286_FAMILY // Teensy IDEs don't know about these pins so must use FASTIO
   7456                    if (pin == TEENSY_E2) {
   7457                      SET_OUTPUT(TEENSY_E2);
   7458                      for (int16_t j = 0; j < repeat; j++) {
   7459                        WRITE(TEENSY_E2, LOW);  safe_delay(wait);
   7460                        WRITE(TEENSY_E2, HIGH); safe_delay(wait);
   7461                        WRITE(TEENSY_E2, LOW);  safe_delay(wait);
   7462                      }
   7463                    }
   7464                    else if (pin == TEENSY_E3) {
   7465                      SET_OUTPUT(TEENSY_E3);
   7466                      for (int16_t j = 0; j < repeat; j++) {
   7467                        WRITE(TEENSY_E3, LOW);  safe_delay(wait);
   7468                        WRITE(TEENSY_E3, HIGH); safe_delay(wait);
   7469                        WRITE(TEENSY_E3, LOW);  safe_delay(wait);
   7470                      }
   7471                    }
   7472                    else
   7473                  #endif
   7474                  {
   7475                    pinMode(pin, OUTPUT);
   7476                    for (int16_t j = 0; j < repeat; j++) {
   7477                      digitalWrite(pin, 0); safe_delay(wait);
   7478                      digitalWrite(pin, 1); safe_delay(wait);
   7479                      digitalWrite(pin, 0); safe_delay(wait);
   7480                    }
   7481                  }
   7482          
   7483                }
   7484                SERIAL_EOL();
   7485              }
   7486              SERIAL_ECHOLNPGM("Done.");
   7487          
   7488            } // toggle_pins
   7489          
   7490            inline void servo_probe_test() {
   7491              #if !(NUM_SERVOS > 0 && HAS_SERVO_0)
   7492          
   7493                SERIAL_ERROR_START();
   7494                SERIAL_ERRORLNPGM("SERVO not setup");
   7495          
   7496              #elif !HAS_Z_SERVO_ENDSTOP
   7497          
   7498                SERIAL_ERROR_START();
   7499                SERIAL_ERRORLNPGM("Z_ENDSTOP_SERVO_NR not setup");
   7500          
   7501              #else // HAS_Z_SERVO_ENDSTOP
   7502          
   7503                const uint8_t probe_index = parser.byteval('P', Z_ENDSTOP_SERVO_NR);
   7504          
   7505                SERIAL_PROTOCOLLNPGM("Servo probe test");
   7506                SERIAL_PROTOCOLLNPAIR(".  using index:  ", probe_index);
   7507                SERIAL_PROTOCOLLNPAIR(".  deploy angle: ", z_servo_angle[0]);
   7508                SERIAL_PROTOCOLLNPAIR(".  stow angle:   ", z_servo_angle[1]);
   7509          
   7510                bool probe_inverting;
   7511          
   7512                #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
   7513          
   7514                  #define PROBE_TEST_PIN Z_MIN_PIN
   7515          
   7516                  SERIAL_PROTOCOLLNPAIR(". probe uses Z_MIN pin: ", PROBE_TEST_PIN);
   7517                  SERIAL_PROTOCOLLNPGM(". uses Z_MIN_ENDSTOP_INVERTING (ignores Z_MIN_PROBE_ENDSTOP_INVERTING)");
   7518                  SERIAL_PROTOCOLPGM(". Z_MIN_ENDSTOP_INVERTING: ");
   7519          
   7520                  #if Z_MIN_ENDSTOP_INVERTING
   7521                    SERIAL_PROTOCOLLNPGM("true");
   7522                  #else
   7523                    SERIAL_PROTOCOLLNPGM("false");
   7524                  #endif
   7525          
   7526                  probe_inverting = Z_MIN_ENDSTOP_INVERTING;
   7527          
   7528                #elif ENABLED(Z_MIN_PROBE_ENDSTOP)
   7529          
   7530                  #define PROBE_TEST_PIN Z_MIN_PROBE_PIN
   7531                  SERIAL_PROTOCOLLNPAIR(". probe uses Z_MIN_PROBE_PIN: ", PROBE_TEST_PIN);
   7532                  SERIAL_PROTOCOLLNPGM(". uses Z_MIN_PROBE_ENDSTOP_INVERTING (ignores Z_MIN_ENDSTOP_INVERTING)");
   7533                  SERIAL_PROTOCOLPGM(". Z_MIN_PROBE_ENDSTOP_INVERTING: ");
   7534          
   7535                  #if Z_MIN_PROBE_ENDSTOP_INVERTING
   7536                    SERIAL_PROTOCOLLNPGM("true");
   7537                  #else
   7538                    SERIAL_PROTOCOLLNPGM("false");
   7539                  #endif
   7540          
   7541                  probe_inverting = Z_MIN_PROBE_ENDSTOP_INVERTING;
   7542          
   7543                #endif
   7544          
   7545                SERIAL_PROTOCOLLNPGM(". deploy & stow 4 times");
   7546                SET_INPUT_PULLUP(PROBE_TEST_PIN);
   7547                bool deploy_state, stow_state;
   7548                for (uint8_t i = 0; i < 4; i++) {
   7549                  MOVE_SERVO(probe_index, z_servo_angle[0]); //deploy
   7550                  safe_delay(500);
   7551                  deploy_state = READ(PROBE_TEST_PIN);
   7552                  MOVE_SERVO(probe_index, z_servo_angle[1]); //stow
   7553                  safe_delay(500);
   7554                  stow_state = READ(PROBE_TEST_PIN);
   7555                }
   7556                if (probe_inverting != deploy_state) SERIAL_PROTOCOLLNPGM("WARNING - INVERTING setting probably backwards");
   7557          
   7558                refresh_cmd_timeout();
   7559          
   7560                if (deploy_state != stow_state) {
   7561                  SERIAL_PROTOCOLLNPGM("BLTouch clone detected");
   7562                  if (deploy_state) {
   7563                    SERIAL_PROTOCOLLNPGM(".  DEPLOYED state: HIGH (logic 1)");
   7564                    SERIAL_PROTOCOLLNPGM(".  STOWED (triggered) state: LOW (logic 0)");
   7565                  }
   7566                  else {
   7567                    SERIAL_PROTOCOLLNPGM(".  DEPLOYED state: LOW (logic 0)");
   7568                    SERIAL_PROTOCOLLNPGM(".  STOWED (triggered) state: HIGH (logic 1)");
   7569                  }
   7570                  #if ENABLED(BLTOUCH)
   7571                    SERIAL_PROTOCOLLNPGM("ERROR: BLTOUCH enabled - set this device up as a Z Servo Probe with inverting as true.");
   7572                  #endif
   7573          
   7574                }
   7575                else {                                           // measure active signal length
   7576                  MOVE_SERVO(probe_index, z_servo_angle[0]);     // deploy
   7577                  safe_delay(500);
   7578                  SERIAL_PROTOCOLLNPGM("please trigger probe");
   7579                  uint16_t probe_counter = 0;
   7580          
   7581                  // Allow 30 seconds max for operator to trigger probe
   7582                  for (uint16_t j = 0; j < 500 * 30 && probe_counter == 0 ; j++) {
   7583          
   7584                    safe_delay(2);
   7585          
   7586                    if (0 == j % (500 * 1)) // keep cmd_timeout happy
   7587                      refresh_cmd_timeout();
   7588          
   7589                    if (deploy_state != READ(PROBE_TEST_PIN)) { // probe triggered
   7590          
   7591                      for (probe_counter = 1; probe_counter < 50 && deploy_state != READ(PROBE_TEST_PIN); ++probe_counter)
   7592                        safe_delay(2);
   7593          
   7594                      if (probe_counter == 50)
   7595                        SERIAL_PROTOCOLLNPGM("Z Servo Probe detected"); // >= 100mS active time
   7596                      else if (probe_counter >= 2)
   7597                        SERIAL_PROTOCOLLNPAIR("BLTouch compatible probe detected - pulse width (+/- 4mS): ", probe_counter * 2); // allow 4 - 100mS pulse
   7598                      else
   7599                        SERIAL_PROTOCOLLNPGM("noise detected - please re-run test"); // less than 2mS pulse
   7600          
   7601                      MOVE_SERVO(probe_index, z_servo_angle[1]); //stow
   7602          
   7603                    }  // pulse detected
   7604          
   7605                  } // for loop waiting for trigger
   7606          
   7607                  if (probe_counter == 0) SERIAL_PROTOCOLLNPGM("trigger not detected");
   7608          
   7609                } // measure active signal length
   7610          
   7611              #endif
   7612          
   7613            } // servo_probe_test
   7614          
   7615            /**
   7616             * M43: Pin debug - report pin state, watch pins, toggle pins and servo probe test/report
   7617             *
   7618             *  M43         - report name and state of pin(s)
   7619             *                  P<pin>  Pin to read or watch. If omitted, reads all pins.
   7620             *                  I       Flag to ignore Marlin's pin protection.
   7621             *
   7622             *  M43 W       - Watch pins -reporting changes- until reset, click, or M108.
   7623             *                  P<pin>  Pin to read or watch. If omitted, read/watch all pins.
   7624             *                  I       Flag to ignore Marlin's pin protection.
   7625             *
   7626             *  M43 E<bool> - Enable / disable background endstop monitoring
   7627             *                  - Machine continues to operate
   7628             *                  - Reports changes to endstops
   7629             *                  - Toggles LED_PIN when an endstop changes
   7630             *                  - Can not reliably catch the 5mS pulse from BLTouch type probes
   7631             *
   7632             *  M43 T       - Toggle pin(s) and report which pin is being toggled
   7633             *                  S<pin>  - Start Pin number.   If not given, will default to 0
   7634             *                  L<pin>  - End Pin number.   If not given, will default to last pin defined for this board
   7635             *                  I<bool> - Flag to ignore Marlin's pin protection.   Use with caution!!!!
   7636             *                  R       - Repeat pulses on each pin this number of times before continueing to next pin
   7637             *                  W       - Wait time (in miliseconds) between pulses.  If not given will default to 500
   7638             *
   7639             *  M43 S       - Servo probe test
   7640             *                  P<index> - Probe index (optional - defaults to 0
   7641             */
   7642            inline void gcode_M43() {
   7643          
   7644              if (parser.seen('T')) {   // must be first or else its "S" and "E" parameters will execute endstop or servo test
   7645                toggle_pins();
   7646                return;
   7647              }
   7648          
   7649              // Enable or disable endstop monitoring
   7650              if (parser.seen('E')) {
   7651                endstop_monitor_flag = parser.value_bool();
   7652                SERIAL_PROTOCOLPGM("endstop monitor ");
   7653                serialprintPGM(endstop_monitor_flag ? PSTR("en") : PSTR("dis"));
   7654                SERIAL_PROTOCOLLNPGM("abled");
   7655                return;
   7656              }
   7657          
   7658              if (parser.seen('S')) {
   7659                servo_probe_test();
   7660                return;
   7661              }
   7662          
   7663              // Get the range of pins to test or watch
   7664              const uint8_t first_pin = parser.byteval('P'),
   7665                            last_pin = parser.seenval('P') ? first_pin : NUM_DIGITAL_PINS - 1;
   7666          
   7667              if (first_pin > last_pin) return;
   7668          
   7669              const bool ignore_protection = parser.boolval('I');
   7670          
   7671              // Watch until click, M108, or reset
   7672              if (parser.boolval('W')) {
   7673                SERIAL_PROTOCOLLNPGM("Watching pins");
   7674                byte pin_state[last_pin - first_pin + 1];
   7675                for (int8_t pin = first_pin; pin <= last_pin; pin++) {
   7676                  if (pin_is_protected(pin) && !ignore_protection) continue;
   7677                  pinMode(pin, INPUT_PULLUP);
   7678                  delay(1);
   7679                  /*
   7680                    if (IS_ANALOG(pin))
   7681                      pin_state[pin - first_pin] = analogRead(pin - analogInputToDigitalPin(0)); // int16_t pin_state[...]
   7682                    else
   7683                  //*/
                          ^
Warning[Pe009]: nested comment is not allowed
   7684                      pin_state[pin - first_pin] = digitalRead(pin);
   7685                }
   7686          
   7687                #if HAS_RESUME_CONTINUE
   7688                  wait_for_user = true;
   7689                  KEEPALIVE_STATE(PAUSED_FOR_USER);
   7690                #endif
   7691          
   7692                for (;;) {
   7693                  for (int8_t pin = first_pin; pin <= last_pin; pin++) {
   7694                    if (pin_is_protected(pin) && !ignore_protection) continue;
   7695                    const byte val =
   7696                      /*
   7697                        IS_ANALOG(pin)
   7698                          ? analogRead(pin - analogInputToDigitalPin(0)) : // int16_t val
   7699                          :
   7700                      //*/
                              ^
Warning[Pe009]: nested comment is not allowed
   7701                        digitalRead(pin);
   7702                    if (val != pin_state[pin - first_pin]) {
   7703                      report_pin_state_extended(pin, ignore_protection, false);
   7704                      pin_state[pin - first_pin] = val;
   7705                    }
   7706                  }
   7707          
   7708                  #if HAS_RESUME_CONTINUE
   7709                    if (!wait_for_user) {
   7710                      KEEPALIVE_STATE(IN_HANDLER);
   7711                      break;
   7712                    }
   7713                  #endif
   7714          
   7715                  safe_delay(200);
   7716                }
   7717                return;
   7718              }
   7719          
   7720              // Report current state of selected pin(s)
   7721              for (uint8_t pin = first_pin; pin <= last_pin; pin++)
   7722                report_pin_state_extended(pin, ignore_protection, true);
   7723            }
   7724          
   7725          #endif // PINS_DEBUGGING
   7726          
   7727          #if ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
   7728          
   7729            /**
   7730             * M48: Z probe repeatability measurement function.
   7731             *
   7732             * Usage:
   7733             *   M48 <P#> <X#> <Y#> <V#> <E> <L#>
   7734             *     P = Number of sampled points (4-50, default 10)
   7735             *     X = Sample X position
   7736             *     Y = Sample Y position
   7737             *     V = Verbose level (0-4, default=1)
   7738             *     E = Engage Z probe for each reading
   7739             *     L = Number of legs of movement before probe
   7740             *     S = Schizoid (Or Star if you prefer)
   7741             *
   7742             * This function requires the machine to be homed before invocation.
   7743             */
   7744            inline void gcode_M48() {
   7745          
   7746              if (axis_unhomed_error()) return;
   7747          
   7748              const int8_t verbose_level = parser.byteval('V', 1);
   7749              if (!WITHIN(verbose_level, 0, 4)) {
   7750                SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-4).");
   7751                return;
   7752              }
   7753          
   7754              if (verbose_level > 0)
   7755                SERIAL_PROTOCOLLNPGM("M48 Z-Probe Repeatability Test");
   7756          
   7757              const int8_t n_samples = parser.byteval('P', 10);
   7758              if (!WITHIN(n_samples, 4, 50)) {
   7759                SERIAL_PROTOCOLLNPGM("?Sample size not plausible (4-50).");
   7760                return;
   7761              }
   7762          
   7763              const bool stow_probe_after_each = parser.boolval('E');
   7764          
   7765              float X_current = current_position[X_AXIS],
   7766                    Y_current = current_position[Y_AXIS];
   7767          
   7768              const float X_probe_location = parser.linearval('X', X_current + X_PROBE_OFFSET_FROM_EXTRUDER),
   7769                          Y_probe_location = parser.linearval('Y', Y_current + Y_PROBE_OFFSET_FROM_EXTRUDER);
   7770          
   7771              #if DISABLED(DELTA)
   7772                if (!WITHIN(X_probe_location, MIN_PROBE_X, MAX_PROBE_X)) {
   7773                  out_of_range_error(PSTR("X"));
   7774                  return;
   7775                }
   7776                if (!WITHIN(Y_probe_location, MIN_PROBE_Y, MAX_PROBE_Y)) {
   7777                  out_of_range_error(PSTR("Y"));
   7778                  return;
   7779                }
   7780              #else
   7781                if (!position_is_reachable_by_probe(X_probe_location, Y_probe_location)) {
   7782                  SERIAL_PROTOCOLLNPGM("? (X,Y) location outside of probeable radius.");
   7783                  return;
   7784                }
   7785              #endif
   7786          
   7787              bool seen_L = parser.seen('L');
   7788              uint8_t n_legs = seen_L ? parser.value_byte() : 0;
   7789              if (n_legs > 15) {
   7790                SERIAL_PROTOCOLLNPGM("?Number of legs in movement not plausible (0-15).");
   7791                return;
   7792              }
   7793              if (n_legs == 1) n_legs = 2;
   7794          
   7795              const bool schizoid_flag = parser.boolval('S');
   7796              if (schizoid_flag && !seen_L) n_legs = 7;
   7797          
   7798              /**
   7799               * Now get everything to the specified probe point So we can safely do a
   7800               * probe to get us close to the bed.  If the Z-Axis is far from the bed,
   7801               * we don't want to use that as a starting point for each probe.
   7802               */
   7803              if (verbose_level > 2)
   7804                SERIAL_PROTOCOLLNPGM("Positioning the probe...");
   7805          
   7806              // Disable bed level correction in M48 because we want the raw data when we probe
   7807          
   7808              #if HAS_LEVELING
   7809                const bool was_enabled = planner.leveling_active;
   7810                set_bed_leveling_enabled(false);
   7811              #endif
   7812          
   7813              setup_for_endstop_or_probe_move();
   7814          
   7815              double mean = 0.0, sigma = 0.0, min = 99999.9, max = -99999.9, sample_set[n_samples];
   7816          
   7817              // Move to the first point, deploy, and probe
   7818              const float t = probe_pt(X_probe_location, Y_probe_location, stow_probe_after_each, verbose_level);
   7819              bool probing_good = !isnan(t);
   7820          
   7821              if (probing_good) {
   7822                //randomSeed(millis());
   7823          	  srand(millis());
   7824          
   7825                for (uint8_t n = 0; n < n_samples; n++) {
   7826                  if (n_legs) {
   7827                    const int dir = (random(0, 10) > 5.0) ? -1 : 1;  // clockwise or counter clockwise
   7828                    float angle = random(0.0, 360.0);
   7829                    const float radius = random(
   7830                      #if ENABLED(DELTA)
   7831                        0.1250000000 * (DELTA_PROBEABLE_RADIUS),
   7832                        0.3333333333 * (DELTA_PROBEABLE_RADIUS)
   7833                      #else
   7834                        5.0, 0.125 * min(X_BED_SIZE, Y_BED_SIZE)
   7835                      #endif
   7836                    );
   7837          
   7838                    if (verbose_level > 3) {
   7839                      SERIAL_ECHOPAIR("Starting radius: ", radius);
   7840                      SERIAL_ECHOPAIR("   angle: ", angle);
   7841                      SERIAL_ECHOPGM(" Direction: ");
   7842                      if (dir > 0) SERIAL_ECHOPGM("Counter-");
   7843                      SERIAL_ECHOLNPGM("Clockwise");
   7844                    }
   7845          
   7846                    for (uint8_t l = 0; l < n_legs - 1; l++) {
   7847                      double delta_angle;
   7848          
   7849                      if (schizoid_flag)
   7850                        // The points of a 5 point star are 72 degrees apart.  We need to
   7851                        // skip a point and go to the next one on the star.
   7852                        delta_angle = dir * 2.0 * 72.0;
   7853          
   7854                      else
   7855                        // If we do this line, we are just trying to move further
   7856                        // around the circle.
   7857                        delta_angle = dir * (float) random(25, 45);
   7858          
   7859                      angle += delta_angle;
   7860          
   7861                      while (angle > 360.0)   // We probably do not need to keep the angle between 0 and 2*PI, but the
   7862                        angle -= 360.0;       // Arduino documentation says the trig functions should not be given values
   7863                      while (angle < 0.0)     // outside of this range.   It looks like they behave correctly with
   7864                        angle += 360.0;       // numbers outside of the range, but just to be safe we clamp them.
   7865          
   7866                      X_current = X_probe_location - (X_PROBE_OFFSET_FROM_EXTRUDER) + cos(RADIANS(angle)) * radius;
   7867                      Y_current = Y_probe_location - (Y_PROBE_OFFSET_FROM_EXTRUDER) + sin(RADIANS(angle)) * radius;
   7868          
   7869                      #if DISABLED(DELTA)
   7870                        X_current = constrain(X_current, X_MIN_POS, X_MAX_POS);
   7871                        Y_current = constrain(Y_current, Y_MIN_POS, Y_MAX_POS);
   7872                      #else
   7873                        // If we have gone out too far, we can do a simple fix and scale the numbers
   7874                        // back in closer to the origin.
   7875                        while (!position_is_reachable_by_probe(X_current, Y_current)) {
   7876                          X_current *= 0.8;
   7877                          Y_current *= 0.8;
   7878                          if (verbose_level > 3) {
   7879                            SERIAL_ECHOPAIR("Pulling point towards center:", X_current);
   7880                            SERIAL_ECHOLNPAIR(", ", Y_current);
   7881                          }
   7882                        }
   7883                      #endif
   7884                      if (verbose_level > 3) {
   7885                        SERIAL_PROTOCOLPGM("Going to:");
   7886                        SERIAL_ECHOPAIR(" X", X_current);
   7887                        SERIAL_ECHOPAIR(" Y", Y_current);
   7888                        SERIAL_ECHOLNPAIR(" Z", current_position[Z_AXIS]);
   7889                      }
   7890                      do_blocking_move_to_xy(X_current, Y_current);
   7891                    } // n_legs loop
   7892                  } // n_legs
   7893          
   7894                  // Probe a single point
   7895                  sample_set[n] = probe_pt(X_probe_location, Y_probe_location, stow_probe_after_each, 0);
   7896          
   7897                  // Break the loop if the probe fails
   7898                  probing_good = !isnan(sample_set[n]);
   7899                  if (!probing_good) break;
   7900          
   7901                  /**
   7902                   * Get the current mean for the data points we have so far
   7903                   */
   7904                  double sum = 0.0;
   7905                  for (uint8_t j = 0; j <= n; j++) sum += sample_set[j];
   7906                  mean = sum / (n + 1);
   7907          
   7908                  NOMORE(min, sample_set[n]);
   7909                  NOLESS(max, sample_set[n]);
   7910          
   7911                  /**
   7912                   * Now, use that mean to calculate the standard deviation for the
   7913                   * data points we have so far
   7914                   */
   7915                  sum = 0.0;
   7916                  for (uint8_t j = 0; j <= n; j++)
   7917                    sum += sq(sample_set[j] - mean);
   7918          
   7919                  sigma = SQRT(sum / (n + 1));
   7920                  if (verbose_level > 0) {
   7921                    if (verbose_level > 1) {
   7922                      SERIAL_PROTOCOL(n + 1);
   7923                      SERIAL_PROTOCOLPGM(" of ");
   7924                      SERIAL_PROTOCOL((int)n_samples);
   7925                      SERIAL_PROTOCOLPGM(": z: ");
   7926                      SERIAL_PROTOCOL_F(sample_set[n], 3);
   7927                      if (verbose_level > 2) {
   7928                        SERIAL_PROTOCOLPGM(" mean: ");
   7929                        SERIAL_PROTOCOL_F(mean, 4);
   7930                        SERIAL_PROTOCOLPGM(" sigma: ");
   7931                        SERIAL_PROTOCOL_F(sigma, 6);
   7932                        SERIAL_PROTOCOLPGM(" min: ");
   7933                        SERIAL_PROTOCOL_F(min, 3);
   7934                        SERIAL_PROTOCOLPGM(" max: ");
   7935                        SERIAL_PROTOCOL_F(max, 3);
   7936                        SERIAL_PROTOCOLPGM(" range: ");
   7937                        SERIAL_PROTOCOL_F(max-min, 3);
   7938                      }
   7939                      SERIAL_EOL();
   7940                    }
   7941                  }
   7942          
   7943                } // n_samples loop
   7944              }
   7945          
   7946              STOW_PROBE();
   7947          
   7948              if (probing_good) {
   7949                SERIAL_PROTOCOLLNPGM("Finished!");
   7950          
   7951                if (verbose_level > 0) {
   7952                  SERIAL_PROTOCOLPGM("Mean: ");
   7953                  SERIAL_PROTOCOL_F(mean, 6);
   7954                  SERIAL_PROTOCOLPGM(" Min: ");
   7955                  SERIAL_PROTOCOL_F(min, 3);
   7956                  SERIAL_PROTOCOLPGM(" Max: ");
   7957                  SERIAL_PROTOCOL_F(max, 3);
   7958                  SERIAL_PROTOCOLPGM(" Range: ");
   7959                  SERIAL_PROTOCOL_F(max-min, 3);
   7960                  SERIAL_EOL();
   7961                }
   7962          
   7963                SERIAL_PROTOCOLPGM("Standard Deviation: ");
   7964                SERIAL_PROTOCOL_F(sigma, 6);
   7965                SERIAL_EOL();
   7966                SERIAL_EOL();
   7967              }
   7968          
   7969              clean_up_after_endstop_or_probe_move();
   7970          
   7971              // Re-enable bed level correction if it had been on
   7972              #if HAS_LEVELING
   7973                set_bed_leveling_enabled(was_enabled);
   7974              #endif
   7975          
   7976              report_current_position();
   7977            }
   7978          
   7979          #endif // Z_MIN_PROBE_REPEATABILITY_TEST
   7980          
   7981          #if ENABLED(G26_MESH_VALIDATION)
   7982          
   7983            inline void gcode_M49() {
   7984              g26_debug_flag ^= true;
   7985              SERIAL_PROTOCOLPGM("G26 Debug ");
   7986              serialprintPGM(g26_debug_flag ? PSTR("on.\n") : PSTR("off.\n"));
   7987            }
   7988          
   7989          #endif // G26_MESH_VALIDATION
   7990          
   7991          #if ENABLED(ULTRA_LCD) && ENABLED(LCD_SET_PROGRESS_MANUALLY)
   7992            /**
   7993             * M73: Set percentage complete (for display on LCD)
   7994             *
   7995             * Example:
   7996             *   M73 P25 ; Set progress to 25%
   7997             *
   7998             * Notes:
   7999             *   This has no effect during an SD print job
   8000             */
   8001            inline void gcode_M73() {
   8002              if (!IS_SD_PRINTING && parser.seen('P')) {
   8003                progress_bar_percent = parser.value_byte();
   8004                NOMORE(progress_bar_percent, 100);
   8005              }
   8006            }
   8007          #endif // ULTRA_LCD && LCD_SET_PROGRESS_MANUALLY
   8008          
   8009          /**
   8010           * M75: Start print timer
   8011           */

   \                                 In section .text, align 4
   8012          inline void gcode_M75() { print_job_timer.start(); }
   \                     _Z9gcode_M75v: (+1)
   \   00000000   0x4801             LDR.N    R0,??gcode_M75_0
   \   00000002   0x.... 0x....      B.W      _ZN9Stopwatch5startEv
   \   00000006   0xBF00             Nop      
   \                     ??gcode_M75_0:
   \   00000008   0x........         DC32     card+0xE00
   8013          
   8014          /**
   8015           * M76: Pause print timer
   8016           */

   \                                 In section .text, align 4
   8017          inline void gcode_M76() { print_job_timer.pause(); }
   \                     _Z9gcode_M76v: (+1)
   \   00000000   0x4801             LDR.N    R0,??gcode_M76_0
   \   00000002   0x.... 0x....      B.W      _ZN9Stopwatch5pauseEv
   \   00000006   0xBF00             Nop      
   \                     ??gcode_M76_0:
   \   00000008   0x........         DC32     card+0xE00
   8018          
   8019          /**
   8020           * M77: Stop print timer
   8021           */

   \                                 In section .text, align 4
   8022          inline void gcode_M77() { print_job_timer.stop(); }
   \                     _Z9gcode_M77v: (+1)
   \   00000000   0x4801             LDR.N    R0,??gcode_M77_0
   \   00000002   0x.... 0x....      B.W      _ZN9Stopwatch4stopEv
   \   00000006   0xBF00             Nop      
   \                     ??gcode_M77_0:
   \   00000008   0x........         DC32     card+0xE00
   8023          
   8024          #if ENABLED(PRINTCOUNTER)
   8025            /**
   8026             * M78: Show print statistics
   8027             */
   8028            inline void gcode_M78() {
   8029              // "M78 S78" will reset the statistics
   8030              if (parser.intval('S') == 78)
   8031                print_job_timer.initStats();
   8032              else
   8033                print_job_timer.showStats();
   8034            }
   8035          #endif
   8036          
   8037          /**
   8038           * M104: Set hot end temperature
   8039           */

   \                                 In section .text, align 4
   8040          inline void gcode_M104() {
   \                     _Z10gcode_M104v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   8041            if (get_target_extruder_from_command(104)) return;
   \   00000006   0x2068             MOVS     R0,#+104
   \   00000008   0x.... 0x....      BL       _Z32get_target_extruder_from_commandt
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD158             BNE.N    ??gcode_M104_1
   8042            if (DEBUGGING(DRYRUN)) return;
   \   00000010   0x4C2E             LDR.N    R4,??gcode_M104_2+0x4
   \   00000012   0x7BE0             LDRB     R0,[R4, #+15]
   \   00000014   0x0700             LSLS     R0,R0,#+28
   \   00000016   0xD454             BMI.N    ??gcode_M104_1
   8043          
   8044            #if ENABLED(SINGLENOZZLE)
   8045              if (target_extruder != active_extruder) return;
   8046            #endif
   8047          
   8048            if (parser.seenval('S')) {
   \   00000018   0x2053             MOVS     R0,#+83
   \   0000001A   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD049             BEQ.N    ??gcode_M104_3
   8049              const int16_t temp = parser.value_celsius();
                                          ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   00000022   0x.... 0x....      BL       _ZN11GCodeParser13value_celsiusEv
   \   00000026   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   0000002A   0xEE10 0x1A10      VMOV     R1,S0
   8050              thermalManager.setTargetHotend(temp, target_extruder);
   \   0000002E   0x7DA0             LDRB     R0,[R4, #+22]
   \   00000030   0xB209             SXTH     R1,R1
   \   00000032   0xEE00 0x1A10      VMOV     S0,R1
   \   00000036   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000003A   0x.... 0x....      BL       _ZN11Temperature15setTargetHotendEfh
   8051          
   8052              #if ENABLED(DUAL_X_CARRIAGE)
   8053                if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && target_extruder == 0)
   8054                  thermalManager.setTargetHotend(temp ? temp + duplicate_extruder_temp_offset : 0, 1);
   8055              #endif
   8056          
   8057              #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
   8058                /**
   8059                 * Stop the timer at the end of print. Start is managed by 'heat and wait' M109.
   8060                 * We use half EXTRUDE_MINTEMP here to allow nozzles to be put into hot
   8061                 * standby mode, for instance in a dual extruder setup, without affecting
   8062                 * the running print timer.
   8063                 */
   8064                if (parser.value_celsius() <= (EXTRUDE_MINTEMP) / 2) {
   \   0000003E   0x.... 0x....      BL       _ZN11GCodeParser13value_celsiusEv
   \   00000042   0xEDDF 0x0A21      VLDR.W   S1,??gcode_M104_2  ;; 0x42aa0001
   \   00000046   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   0000004A   0xEEF1 0xFA10      FMSTAT   
   \   0000004E   0xD506             BPL.N    ??gcode_M104_4
   8065                  print_job_timer.stop();
   \   00000050   0x481F             LDR.N    R0,??gcode_M104_2+0x8
   \   00000052   0x.... 0x....      BL       _ZN9Stopwatch4stopEv
   8066                  LCD_MESSAGEPGM(WELCOME_MSG);
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0x481E             LDR.N    R0,??gcode_M104_2+0xC
   \   0000005A   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   8067                }
   8068              #endif
   8069          
   8070              //if (parser.value_celsius() > thermalManager.degHotend(target_extruder))
   8071              //  lcd_status_printf_P(0, PSTR("E%i %s"), target_extruder + 1, MSG_HEATING);
   8072          		if(parser.value_celsius() > thermalManager.degHotend(target_extruder))
   \                     ??gcode_M104_4: (+1)
   \   0000005E   0x7DA0             LDRB     R0,[R4, #+22]
   \   00000060   0x.... 0x....      BL       _ZN11Temperature9degHotendEh
   \   00000064   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   00000068   0x.... 0x....      BL       _ZN11GCodeParser13value_celsiusEv
   \   0000006C   0xEEB4 0x8A40      VCMP.F32 S16,S0
   \   00000070   0xEEF1 0xFA10      FMSTAT   
   \   00000074   0xD51F             BPL.N    ??gcode_M104_3
   8073          		{
   8074          		switch(target_extruder)
   \   00000076   0x7DA0             LDRB     R0,[R4, #+22]
   \   00000078   0x2804             CMP      R0,#+4
   \   0000007A   0xD81C             BHI.N    ??gcode_M104_3
   \   0000007C   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??gcode_M104_0:
   \   00000080   0x03 0x08          DC8      0x3,0x8,0xD,0x12
   \              0x0D 0x12    
   \   00000084   0x17 0x00          DC8      0x17,0x0
   8075          			{
   8076          			case 0:
   8077          				LCD_MESSAGEPGM("E1 Heating...");
   \                     ??gcode_M104_5: (+1)
   \   00000086   0x2100             MOVS     R1,#+0
   \   00000088   0x4813             LDR.N    R0,??gcode_M104_2+0x10
   \   0000008A   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   8078          				break;
   \   0000008E   0xE012             B.N      ??gcode_M104_3
   8079          			case 1:
   8080          				LCD_MESSAGEPGM("E2 Heating...");
   \                     ??gcode_M104_6: (+1)
   \   00000090   0x2100             MOVS     R1,#+0
   \   00000092   0x4812             LDR.N    R0,??gcode_M104_2+0x14
   \   00000094   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   8081          				break;
   \   00000098   0xE00D             B.N      ??gcode_M104_3
   8082          			case 2:
   8083          				LCD_MESSAGEPGM("E3 Heating...");
   \                     ??gcode_M104_7: (+1)
   \   0000009A   0x2100             MOVS     R1,#+0
   \   0000009C   0x4810             LDR.N    R0,??gcode_M104_2+0x18
   \   0000009E   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   8084          				break;
   \   000000A2   0xE008             B.N      ??gcode_M104_3
   8085          			case 3:
   8086          				LCD_MESSAGEPGM("E4 Heating...");
   \                     ??gcode_M104_8: (+1)
   \   000000A4   0x2100             MOVS     R1,#+0
   \   000000A6   0x480F             LDR.N    R0,??gcode_M104_2+0x1C
   \   000000A8   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   8087          				break;
   \   000000AC   0xE003             B.N      ??gcode_M104_3
   8088          			case 4:
   8089          				LCD_MESSAGEPGM("E5 Heating...");
   \                     ??gcode_M104_9: (+1)
   \   000000AE   0x2100             MOVS     R1,#+0
   \   000000B0   0x480D             LDR.N    R0,??gcode_M104_2+0x20
   \   000000B2   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   8090          				break;
   8091          			default: break;
   8092          				
   8093          			}
   8094          		}    
   8095            }
   8096          
   8097            #if ENABLED(AUTOTEMP)
   8098              planner.autotemp_M104_M109();
   \                     ??gcode_M104_3: (+1)
   \   000000B6   0xECBD 0x8B02      VPOP     {D8}
   \   000000BA   0xE8BD 0x4010      POP      {R4,LR}
   \   000000BE   0x.... 0x....      B.W      _ZN7Planner18autotemp_M104_M109Ev
   \                     ??gcode_M104_1: (+1)
   \   000000C2   0xECBD 0x8B02      VPOP     {D8}
   \   000000C6   0xBD10             POP      {R4,PC}          ;; return
   \                     ??gcode_M104_2:
   \   000000C8   0x42AA0001         DC32     0x42aa0001
   \   000000CC   0x........         DC32     axis_relative_modes
   \   000000D0   0x........         DC32     card+0xE00
   \   000000D4   0x........         DC32     _ZZ10gcode_M104vEs
   \   000000D8   0x........         DC32     _ZZ10gcode_M104vEs_0
   \   000000DC   0x........         DC32     _ZZ10gcode_M104vEs_1
   \   000000E0   0x........         DC32     _ZZ10gcode_M104vEs_2
   \   000000E4   0x........         DC32     _ZZ10gcode_M104vEs_3
   \   000000E8   0x........         DC32     _ZZ10gcode_M104vEs_4
   8099            #endif
   8100          }
   8101          
   8102          /**
   8103           * M105: Read hot end and bed temperature
   8104           */

   \                                 In section .text, align 4
   8105          inline void gcode_M105() {
   \                     _Z10gcode_M105v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   8106            if (get_target_extruder_from_command(105)) return;
   \   00000002   0x2069             MOVS     R0,#+105
   \   00000004   0x.... 0x....      BL       _Z32get_target_extruder_from_commandt
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD10B             BNE.N    ??gcode_M105_0
   8107          
   8108            #if HAS_TEMP_HOTEND || HAS_TEMP_BED
   8109              SERIAL_PROTOCOLPGM(MSG_OK);
   8110              thermalManager.print_heaterstates();
   8111            #else // !HAS_TEMP_HOTEND && !HAS_TEMP_BED
   8112              SERIAL_ERROR_START();
   \   0000000C   0x4806             LDR.N    R0,??gcode_M105_1
   \   0000000E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   8113              SERIAL_ERRORLNPGM(MSG_ERR_NO_THERMISTORS);
   \   00000012   0x4806             LDR.N    R0,??gcode_M105_1+0x4
   \   00000014   0x.... 0x....      BL       _Z14serialprintPGMPKc
   8114            #endif
   8115          
   8116            SERIAL_EOL();
   \   00000018   0x210A             MOVS     R1,#+10
   \   0000001A   0x4805             LDR.N    R0,??gcode_M105_1+0x8
   \   0000001C   0xE8BD 0x4004      POP      {R2,LR}
   \   00000020   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   \                     ??gcode_M105_0: (+1)
   \   00000024   0xBD01             POP      {R0,PC}          ;; return
   \   00000026   0xBF00             Nop      
   \                     ??gcode_M105_1:
   \   00000028   0x........         DC32     errormagic
   \   0000002C   0x........         DC32     _ZZ10gcode_M105vEs
   \   00000030   0x........         DC32     Serial6
   8117          }
   8118          
   8119          #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
   8120          
   8121            /**
   8122             * M155: Set temperature auto-report interval. M155 S<seconds>
   8123             */
   8124            inline void gcode_M155() {
   8125              if (parser.seenval('S'))
   8126                thermalManager.set_auto_report_interval(parser.value_byte());
   8127            }
   8128          
   8129          #endif // AUTO_REPORT_TEMPERATURES
   8130          
   8131          #if FAN_COUNT > 0
   8132          
   8133            /**
   8134             * M106: Set Fan Speed
   8135             *
   8136             *  S<int>   Speed between 0-255
   8137             *  P<index> Fan index, if more than one fan
   8138             *
   8139             * With EXTRA_FAN_SPEED enabled:
   8140             *
   8141             *  T<int>   Restore/Use/Set Temporary Speed:
   8142             *           1     = Restore previous speed after T2
   8143             *           2     = Use temporary speed set with T3-255
   8144             *           3-255 = Set the speed for use with T2
   8145             */

   \                                 In section .text, align 4
   8146            inline void gcode_M106() {
   \                     _Z10gcode_M106v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   8147              const uint8_t p = parser.byteval('P');
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x2050             MOVS     R0,#+80
   \   00000006   0x.... 0x....      BL       _ZN11GCodeParser7bytevalEch
   8148              if (p < FAN_COUNT) {
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD111             BNE.N    ??gcode_M106_0
   8149                #if ENABLED(EXTRA_FAN_SPEED)
   8150                  const int16_t t = parser.intval('T');
   8151                  if (t > 0) {
   8152                    switch (t) {
   8153                      case 1:
   8154                        fanSpeeds[p] = old_fanSpeeds[p];
   8155                        break;
   8156                      case 2:
   8157                        old_fanSpeeds[p] = fanSpeeds[p];
   8158                        fanSpeeds[p] = new_fanSpeeds[p];
   8159                        break;
   8160                      default:
   8161                        new_fanSpeeds[p] = min(t, 255);
   8162                        break;
   8163                    }
   8164                    return;
   8165                  }
   8166                #endif // EXTRA_FAN_SPEED
   8167                const uint16_t s = parser.ushortval('S', 255);
   \   0000000E   0x21FF             MOVS     R1,#+255
   \   00000010   0x2053             MOVS     R0,#+83
   \   00000012   0x.... 0x....      BL       _ZN11GCodeParser9ushortvalEct
   8168                fanSpeeds[p] = min(s, 255);
   \   00000016   0x21FF             MOVS     R1,#+255
   \   00000018   0x28FF             CMP      R0,#+255
   \   0000001A   0xDC00             BGT.N    ??gcode_M106_1
   \   0000001C   0x4601             MOV      R1,R0
   \                     ??gcode_M106_1: (+1)
   \   0000001E   0x4A05             LDR.N    R2,??gcode_M106_2
   \   00000020   0x6011             STR      R1,[R2, #+0]
   8169          	  MKS_FAN_TIM = s*10000/255;
   \   00000022   0xF242 0x7110      MOVW     R1,#+10000
   \   00000026   0x4348             MULS     R0,R1,R0
   \   00000028   0x21FF             MOVS     R1,#+255
   \   0000002A   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000002E   0x4902             LDR.N    R1,??gcode_M106_2+0x4  ;; 0x42408288
   \   00000030   0x6008             STR      R0,[R1, #+0]
   8170              }
   8171            }
   \                     ??gcode_M106_0: (+1)
   \   00000032   0xBD01             POP      {R0,PC}          ;; return
   \                     ??gcode_M106_2:
   \   00000034   0x........         DC32     fanSpeeds
   \   00000038   0x42408288         DC32     0x42408288
   8172          
   8173            /**
   8174             * M107: Fan Off
   8175             */

   \                                 In section .text, align 4
   8176            inline void gcode_M107() {
   \                     _Z10gcode_M107v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   8177              const uint16_t p = parser.ushortval('P');
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x2050             MOVS     R0,#+80
   \   00000006   0x.... 0x....      BL       _ZN11GCodeParser9ushortvalEct
   8178              if (p < FAN_COUNT) 
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD104             BNE.N    ??gcode_M107_0
   8179              {
   8180          		fanSpeeds[p] = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x4902             LDR.N    R1,??gcode_M107_1
   \   00000012   0x6008             STR      R0,[R1, #+0]
   8181          		MKS_FAN_TIM = 0 ;
   \   00000014   0x4902             LDR.N    R1,??gcode_M107_1+0x4  ;; 0x42408288
   \   00000016   0x6008             STR      R0,[R1, #+0]
   8182              }
   8183            }
   \                     ??gcode_M107_0: (+1)
   \   00000018   0xBD01             POP      {R0,PC}          ;; return
   \   0000001A   0xBF00             Nop      
   \                     ??gcode_M107_1:
   \   0000001C   0x........         DC32     fanSpeeds
   \   00000020   0x42408288         DC32     0x42408288
   8184          
   8185          #endif // FAN_COUNT > 0
   8186          
   8187          #if DISABLED(EMERGENCY_PARSER)
   8188          
   8189            /**
   8190             * M108: Stop the waiting for heaters in M109, M190, M303. Does not affect the target temperature.
   8191             */

   \                                 In section .text, align 4
   8192            inline void gcode_M108() { wait_for_heatup = false; }
   \                     _Z10gcode_M108v: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4901             LDR.N    R1,??gcode_M108_0
   \   00000004   0x7548             STRB     R0,[R1, #+21]
   \   00000006   0x4770             BX       LR               ;; return
   \                     ??gcode_M108_0:
   \   00000008   0x........         DC32     axis_relative_modes
   8193          
   8194          
   8195            /**
   8196             * M112: Emergency Stop
   8197             */

   \                                 In section .text, align 4
   8198            inline void gcode_M112() { kill(PSTR(MSG_KILLED)); }
   \                     _Z10gcode_M112v: (+1)
   \   00000000   0x4801             LDR.N    R0,??gcode_M112_0
   \   00000002   0x.... 0x....      B.W      _Z4killPKc
   \   00000006   0xBF00             Nop      
   \                     ??gcode_M112_0:
   \   00000008   0x........         DC32     _ZZ10gcode_M112vEs
   8199          
   8200          
   8201            /**
   8202             * M410: Quickstop - Abort all planned moves
   8203             *
   8204             * This will stop the carriages mid-move, so most likely they
   8205             * will be out of sync with the stepper position after this.
   8206             */

   \                                 In section .text, align 2
   8207            inline void gcode_M410() { quickstop_stepper(); }
   \                     _Z10gcode_M410v: (+1)
   \   00000000   0x.... 0x....      B.W      _Z17quickstop_stepperv
   8208          
   8209          #endif
   8210          
   8211          /**
   8212           * M109: Sxxx Wait for extruder(s) to reach temperature. Waits only when heating.
   8213           *       Rxxx Wait for extruder(s) to reach temperature. Waits when heating and cooling.
   8214           */
   8215          
   8216          #ifndef MIN_COOLING_SLOPE_DEG
   8217            #define MIN_COOLING_SLOPE_DEG 1.50
   8218          #endif
   8219          #ifndef MIN_COOLING_SLOPE_TIME
   8220            #define MIN_COOLING_SLOPE_TIME 60
   8221          #endif
   8222          

   \                                 In section .text, align 4
   8223          inline void gcode_M109() {
   \                     _Z10gcode_M109v: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0xED2D 0x8B02      VPUSH    {D8}
   8224          
   8225            if (get_target_extruder_from_command(109)) return;
   \   00000008   0x206D             MOVS     R0,#+109
   \   0000000A   0x.... 0x....      BL       _Z32get_target_extruder_from_commandt
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xF040 0x80F3      BNE.W    ??gcode_M109_1
   8226            if (DEBUGGING(DRYRUN)) return;
   \   00000014   0x4C7E             LDR.N    R4,??gcode_M109_2+0xC
   \   00000016   0x7BE0             LDRB     R0,[R4, #+15]
   \   00000018   0x0700             LSLS     R0,R0,#+28
   \   0000001A   0xF100 0x80EE      BMI.W    ??gcode_M109_1
   8227          
   8228            #if ENABLED(SINGLENOZZLE)
   8229              if (target_extruder != active_extruder) return;
   8230            #endif
   8231          
   8232            const bool no_wait_for_cooling = parser.seenval('S');
   \   0000001E   0x2053             MOVS     R0,#+83
   \   00000020   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000024   0x0005             MOVS     R5,R0
   8233            if (no_wait_for_cooling || parser.seenval('R')) {
   \   00000026   0xD105             BNE.N    ??gcode_M109_3
   \   00000028   0x2052             MOVS     R0,#+82
   \   0000002A   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xF000 0x80E3      BEQ.W    ??gcode_M109_1
   8234              const int16_t temp = parser.value_celsius();
                                          ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??gcode_M109_3: (+1)
   \   00000034   0x.... 0x....      BL       _ZN11GCodeParser13value_celsiusEv
   \   00000038   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   0000003C   0xEE10 0x1A10      VMOV     R1,S0
   8235              thermalManager.setTargetHotend(temp, target_extruder);
   \   00000040   0x7DA0             LDRB     R0,[R4, #+22]
   \   00000042   0xB209             SXTH     R1,R1
   \   00000044   0xEE00 0x1A10      VMOV     S0,R1
   \   00000048   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000004C   0x.... 0x....      BL       _ZN11Temperature15setTargetHotendEfh
   8236          
   8237              #if ENABLED(DUAL_X_CARRIAGE)
   8238                if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && target_extruder == 0)
   8239                  thermalManager.setTargetHotend(temp ? temp + duplicate_extruder_temp_offset : 0, 1);
   8240              #endif
   8241          
   8242              #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
   8243                /**
   8244                 * Use half EXTRUDE_MINTEMP to allow nozzles to be put into hot
   8245                 * standby mode, (e.g., in a dual extruder setup) without affecting
   8246                 * the running print timer.
   8247                 */
   8248                if (parser.value_celsius() <= (EXTRUDE_MINTEMP) / 2) {
   \   00000050   0x4E70             LDR.N    R6,??gcode_M109_2+0x10
   \   00000052   0x.... 0x....      BL       _ZN11GCodeParser13value_celsiusEv
   \   00000056   0xEDDF 0x0A6B      VLDR.W   S1,??gcode_M109_2  ;; 0x42aa0001
   \   0000005A   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   0000005E   0xEEF1 0xFA10      FMSTAT   
   \   00000062   0x4630             MOV      R0,R6
   \   00000064   0xD506             BPL.N    ??gcode_M109_4
   8249                  print_job_timer.stop();
   \   00000066   0x.... 0x....      BL       _ZN9Stopwatch4stopEv
   8250                  LCD_MESSAGEPGM(WELCOME_MSG);
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0x486A             LDR.N    R0,??gcode_M109_2+0x14
   \   0000006E   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   \   00000072   0xE001             B.N      ??gcode_M109_5
   8251                }
   8252                else
   8253                  print_job_timer.start();
   \                     ??gcode_M109_4: (+1)
   \   00000074   0x.... 0x....      BL       _ZN9Stopwatch5startEv
   8254              #endif
   8255          
   8256              //if (thermalManager.isHeatingHotend(target_extruder)) lcd_status_printf_P(0, PSTR("E%i %s"), target_extruder + 1, MSG_HEATING);
   8257          	if (parser.value_celsius() > thermalManager.degHotend(target_extruder))
   \                     ??gcode_M109_5: (+1)
   \   00000078   0x7DA0             LDRB     R0,[R4, #+22]
   \   0000007A   0x.... 0x....      BL       _ZN11Temperature9degHotendEh
   \   0000007E   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   00000082   0x.... 0x....      BL       _ZN11GCodeParser13value_celsiusEv
   \   00000086   0xEEB4 0x8A40      VCMP.F32 S16,S0
   \   0000008A   0xEEF1 0xFA10      FMSTAT   
   \   0000008E   0xD51F             BPL.N    ??gcode_M109_6
   8258          	{
   8259          			switch(target_extruder)
   \   00000090   0x7DA0             LDRB     R0,[R4, #+22]
   \   00000092   0x2804             CMP      R0,#+4
   \   00000094   0xD81C             BHI.N    ??gcode_M109_6
   \   00000096   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??gcode_M109_0:
   \   0000009A   0x03 0x08          DC8      0x3,0x8,0xD,0x12
   \              0x0D 0x12    
   \   0000009E   0x17 0x00          DC8      0x17,0x0
   8260          			{
   8261          			case 0:
   8262          				LCD_MESSAGEPGM("E1 Heating...");
   \                     ??gcode_M109_7: (+1)
   \   000000A0   0x2100             MOVS     R1,#+0
   \   000000A2   0x485E             LDR.N    R0,??gcode_M109_2+0x18
   \   000000A4   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   8263          				break;
   \   000000A8   0xE012             B.N      ??gcode_M109_6
   8264          			case 1:
   8265          				LCD_MESSAGEPGM("E2 Heating...");
   \                     ??gcode_M109_8: (+1)
   \   000000AA   0x2100             MOVS     R1,#+0
   \   000000AC   0x485C             LDR.N    R0,??gcode_M109_2+0x1C
   \   000000AE   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   8266          				break;
   \   000000B2   0xE00D             B.N      ??gcode_M109_6
   8267          			case 2:
   8268          				LCD_MESSAGEPGM("E3 Heating...");
   \                     ??gcode_M109_9: (+1)
   \   000000B4   0x2100             MOVS     R1,#+0
   \   000000B6   0x485B             LDR.N    R0,??gcode_M109_2+0x20
   \   000000B8   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   8269          				break;
   \   000000BC   0xE008             B.N      ??gcode_M109_6
   8270          			case 3:
   8271          				LCD_MESSAGEPGM("E4 Heating...");
   \                     ??gcode_M109_10: (+1)
   \   000000BE   0x2100             MOVS     R1,#+0
   \   000000C0   0x4859             LDR.N    R0,??gcode_M109_2+0x24
   \   000000C2   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   8272          				break;
   \   000000C6   0xE003             B.N      ??gcode_M109_6
   8273          			case 4:
   8274          				LCD_MESSAGEPGM("E5 Heating...");
   \                     ??gcode_M109_11: (+1)
   \   000000C8   0x2100             MOVS     R1,#+0
   \   000000CA   0x4858             LDR.N    R0,??gcode_M109_2+0x28
   \   000000CC   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   8275          				break;
   8276          			default: break;
   8277          			}
   8278          	}
   8279          
   8280            }
   8281            else return;
   8282          
   8283            #if ENABLED(AUTOTEMP)
   8284              planner.autotemp_M104_M109();
   \                     ??gcode_M109_6: (+1)
   \   000000D0   0x.... 0x....      BL       _ZN7Planner18autotemp_M104_M109Ev
   8285            #endif
   8286          
   8287            #if TEMP_RESIDENCY_TIME > 0
   8288              millis_t residency_start_ms = 0;
   \   000000D4   0x2600             MOVS     R6,#+0
   8289              // Loop until the temperature has stabilized
   8290              #define TEMP_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_RESIDENCY_TIME) * 1000UL))
   8291            #else
   8292              // Loop until the temperature is very close target
   8293              #define TEMP_CONDITIONS (wants_to_cool ? thermalManager.isCoolingHotend(target_extruder) : thermalManager.isHeatingHotend(target_extruder))
   8294            #endif
   8295          
   8296            float target_temp = -1.0, old_temp = 9999.0;
   \   000000D6   0xEEBF 0x8A00      VMOV.F32 S16,#-1.0
   \   000000DA   0xEDDF 0x8A4B      VLDR.W   S17,??gcode_M109_2+0x4  ;; 0x461c3c00
   8297            bool wants_to_cool = false;
   \   000000DE   0x4637             MOV      R7,R6
   8298            wait_for_heatup = true;
   \   000000E0   0x2001             MOVS     R0,#+1
   \   000000E2   0x7560             STRB     R0,[R4, #+21]
   8299            millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
   \   000000E4   0x46B0             MOV      R8,R6
   \   000000E6   0x46B1             MOV      R9,R6
   8300          
   8301            #if DISABLED(BUSY_WHILE_HEATING)
   8302              KEEPALIVE_STATE(NOT_BUSY);
   8303            #endif
   8304          
   8305            #if ENABLED(PRINTER_EVENT_LEDS)
   8306              const float start_temp = thermalManager.degHotend(target_extruder);
   8307              uint8_t old_blue = 0;
   8308            #endif
   8309            
   8310            mks_heating_busy = 1;
   \   000000E8   0x7360             STRB     R0,[R4, #+13]
   \   000000EA   0xF8DF 0xB144      LDR.W    R11,??gcode_M109_2+0x2C
   8311          
   8312            do {
   8313              // Target temperature might be changed during the loop
   8314              if (target_temp != thermalManager.degTargetHotend(target_extruder)) {
   \                     ??gcode_M109_12: (+1)
   \   000000EE   0xF894 0xA016      LDRB     R10,[R4, #+22]
   \   000000F2   0x4650             MOV      R0,R10
   \   000000F4   0x.... 0x....      BL       _ZN11Temperature15degTargetHotendEh
   \   000000F8   0xEEB4 0x8A40      VCMP.F32 S16,S0
   \   000000FC   0xEEF1 0xFA10      FMSTAT   
   \   00000100   0xD00C             BEQ.N    ??gcode_M109_13
   8315                wants_to_cool = thermalManager.isCoolingHotend(target_extruder);
   \   00000102   0x4650             MOV      R0,R10
   \   00000104   0x.... 0x....      BL       _ZN11Temperature15isCoolingHotendEh
   \   00000108   0x4607             MOV      R7,R0
   8316                target_temp = thermalManager.degTargetHotend(target_extruder);
   \   0000010A   0x4650             MOV      R0,R10
   \   0000010C   0x.... 0x....      BL       _ZN11Temperature15degTargetHotendEh
   \   00000110   0xEEB0 0x8A40      VMOV.F32 S16,S0
   8317          
   8318                // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
   8319                if (no_wait_for_cooling && wants_to_cool) break;
   \   00000114   0x4628             MOV      R0,R5
   \   00000116   0x4639             MOV      R1,R7
   \   00000118   0x4208             TST      R0,R1
   \   0000011A   0xD161             BNE.N    ??gcode_M109_14
   8320              }
   8321          
   8322              now = millis();
   \                     ??gcode_M109_13: (+1)
   \   0000011C   0x.... 0x....      BL       HAL_GetTick
   \   00000120   0x4682             MOV      R10,R0
   8323              if (ELAPSED(now, next_temp_ms)) { //Print temp & remaining time every 1s while waiting
   \   00000122   0xEBBA 0x0008      SUBS     R0,R10,R8
   \   00000126   0xD41C             BMI.N    ??gcode_M109_15
   8324                next_temp_ms = now + 1000UL;
   \   00000128   0xF50A 0x787A      ADD      R8,R10,#+1000
   8325                //thermalManager.print_heaterstates();    //mks 2018-08
   8326                #if TEMP_RESIDENCY_TIME > 0
   8327                  SERIAL_PROTOCOLPGM(" W:");
   \   0000012C   0x4841             LDR.N    R0,??gcode_M109_2+0x30
   \   0000012E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   8328                  if (residency_start_ms)
   \   00000132   0x2E00             CMP      R6,#+0
   \   00000134   0xD00D             BEQ.N    ??gcode_M109_16
   8329                    SERIAL_PROTOCOL(long((((TEMP_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL));
   \   00000136   0x220A             MOVS     R2,#+10
   \   00000138   0xF242 0x7010      MOVW     R0,#+10000
   \   0000013C   0xEBA0 0x000A      SUB      R0,R0,R10
   \   00000140   0x1830             ADDS     R0,R6,R0
   \   00000142   0xF44F 0x717A      MOV      R1,#+1000
   \   00000146   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   0000014A   0x4658             MOV      R0,R11
   \   0000014C   0x.... 0x....      BL       _ZN5Print5printEli
   \   00000150   0xE003             B.N      ??gcode_M109_17
   8330                  else
   8331                    SERIAL_PROTOCOLCHAR('?');
   \                     ??gcode_M109_16: (+1)
   \   00000152   0x213F             MOVS     R1,#+63
   \   00000154   0x4658             MOV      R0,R11
   \   00000156   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   8332                #endif
   8333                SERIAL_EOL();
   \                     ??gcode_M109_17: (+1)
   \   0000015A   0x210A             MOVS     R1,#+10
   \   0000015C   0x4658             MOV      R0,R11
   \   0000015E   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   8334              }
   8335          
   8336              idle();
   \                     ??gcode_M109_15: (+1)
   \   00000162   0x.... 0x....      BL       _Z4idlev
   8337              refresh_cmd_timeout(); // to prevent stepper_inactive_time from running out
   \   00000166   0x.... 0x....      BL       _Z19refresh_cmd_timeoutv
   8338          
   8339              const float temp = thermalManager.degHotend(target_extruder);
   \   0000016A   0x7DA0             LDRB     R0,[R4, #+22]
   \   0000016C   0x.... 0x....      BL       _ZN11Temperature9degHotendEh
   8340          
   8341              #if ENABLED(PRINTER_EVENT_LEDS)
   8342                // Gradually change LED strip from violet to red as nozzle heats up
   8343                if (!wants_to_cool) {
   8344                  const uint8_t blue = map(constrain(temp, start_temp, target_temp), start_temp, target_temp, 255, 0);
   8345                  if (blue != old_blue) {
   8346                    old_blue = blue;
   8347                    leds.set_color(
   8348                      MakeLEDColor(255, 0, blue, 0, pixels.getBrightness())
   8349                      #if ENABLED(NEOPIXEL_IS_SEQUENTIAL)
   8350                        , true
   8351                      #endif
   8352                    );
   8353                  }
   8354                }
   8355              #endif
   8356          
   8357              #if TEMP_RESIDENCY_TIME > 0
   8358          
   8359                const float temp_diff = FABS(target_temp - temp);
   \   00000170   0xEE78 0x0A40      VSUB.F32 S1,S16,S0
   \   00000174   0xEEF0 0x0AE0      VABS.F32 S1,S1
   8360          
   8361                if (!residency_start_ms) {
   \   00000178   0x2E00             CMP      R6,#+0
   \   0000017A   0xD108             BNE.N    ??gcode_M109_18
   8362                  // Start the TEMP_RESIDENCY_TIME timer when we reach target temp for the first time.
   8363                  if (temp_diff < TEMP_WINDOW) residency_start_ms = now;
   \   0000017C   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \   00000180   0xEEF4 0x0A41      VCMP.F32 S1,S2
   \   00000184   0xEEF1 0xFA10      FMSTAT   
   \   00000188   0xD509             BPL.N    ??gcode_M109_19
   \   0000018A   0x4656             MOV      R6,R10
   \   0000018C   0xE007             B.N      ??gcode_M109_19
   8364                }
   8365                else if (temp_diff > TEMP_HYSTERESIS) {
   \                     ??gcode_M109_18: (+1)
   \   0000018E   0xED9F 0x1A1F      VLDR.W   S2,??gcode_M109_2+0x8  ;; 0x40400001
   \   00000192   0xEEF4 0x0A41      VCMP.F32 S1,S2
   \   00000196   0xEEF1 0xFA10      FMSTAT   
   \   0000019A   0xDB00             BLT.N    ??gcode_M109_19
   8366                  // Restart the timer whenever the temperature falls outside the hysteresis.
   8367                  residency_start_ms = now;
   \   0000019C   0x4656             MOV      R6,R10
   8368                }
   8369          
   8370              #endif
   8371          
   8372              // Prevent a wait-forever situation if R is misused i.e. M109 R0
   8373              if (wants_to_cool) {
   \                     ??gcode_M109_19: (+1)
   \   0000019E   0x2F00             CMP      R7,#+0
   \   000001A0   0xD014             BEQ.N    ??gcode_M109_20
   8374                // break after MIN_COOLING_SLOPE_TIME seconds
   8375                // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG
   8376                if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
   \   000001A2   0xF1B9 0x0F00      CMP      R9,#+0
   \   000001A6   0xD002             BEQ.N    ??gcode_M109_21
   \   000001A8   0xEBBA 0x0009      SUBS     R0,R10,R9
   \   000001AC   0xD40E             BMI.N    ??gcode_M109_20
   8377                  if (old_temp - temp < MIN_COOLING_SLOPE_DEG) break;
   \                     ??gcode_M109_21: (+1)
   \   000001AE   0xEE78 0x0AC0      VSUB.F32 S1,S17,S0
   \   000001B2   0xEEB7 0x1A08      VMOV.F32 S2,#1.5
   \   000001B6   0xEEF4 0x0A41      VCMP.F32 S1,S2
   \   000001BA   0xEEF1 0xFA10      FMSTAT   
   \   000001BE   0xD40F             BMI.N    ??gcode_M109_14
   8378                  next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME;
   \   000001C0   0xF50A 0x496A      ADD      R9,R10,#+59904
   \   000001C4   0xF109 0x0960      ADD      R9,R9,#+96
   8379                  old_temp = temp;
   \   000001C8   0xEEF0 0x8A40      VMOV.F32 S17,S0
   8380                }
   8381              }
   8382          
   8383            } while (wait_for_heatup && TEMP_CONDITIONS);
   \                     ??gcode_M109_20: (+1)
   \   000001CC   0x7D60             LDRB     R0,[R4, #+21]
   \   000001CE   0x2800             CMP      R0,#+0
   \   000001D0   0xD006             BEQ.N    ??gcode_M109_14
   \   000001D2   0x2E00             CMP      R6,#+0
   \   000001D4   0xD08B             BEQ.N    ??gcode_M109_12
   \   000001D6   0xEBAA 0x0006      SUB      R0,R10,R6
   \   000001DA   0x4917             LDR.N    R1,??gcode_M109_2+0x34  ;; 0xffffd8f0
   \   000001DC   0x1808             ADDS     R0,R1,R0
   \   000001DE   0xD486             BMI.N    ??gcode_M109_12
   8384            
   8385            mks_heating_busy = 0;
   \                     ??gcode_M109_14: (+1)
   \   000001E0   0x2000             MOVS     R0,#+0
   \   000001E2   0x7360             STRB     R0,[R4, #+13]
   8386          
   8387            if (wait_for_heatup) {
   \   000001E4   0x7D60             LDRB     R0,[R4, #+21]
   \   000001E6   0x2800             CMP      R0,#+0
   \   000001E8   0xD007             BEQ.N    ??gcode_M109_1
   8388              LCD_MESSAGEPGM(MSG_HEATING_COMPLETE);
   \   000001EA   0x2100             MOVS     R1,#+0
   \   000001EC   0x4813             LDR.N    R0,??gcode_M109_2+0x38
   \   000001EE   0xECBD 0x8B02      VPOP     {D8}
   \   000001F2   0xE8BD 0x4FF4      POP      {R2,R4-R11,LR}
   \   000001F6   0x.... 0x....      B.W      _Z16lcd_setstatusPGMPKca
   8389              #if ENABLED(PRINTER_EVENT_LEDS)
   8390                leds.set_white();
   8391              #endif
   8392            }
   8393          
   8394            #if DISABLED(BUSY_WHILE_HEATING)
   8395              KEEPALIVE_STATE(IN_HANDLER);
   8396            #endif
   8397          }
   \                     ??gcode_M109_1: (+1)
   \   000001FA   0xECBD 0x8B02      VPOP     {D8}
   \   000001FE   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
   \   00000202   0xBF00             Nop      
   \                     ??gcode_M109_2:
   \   00000204   0x42AA0001         DC32     0x42aa0001
   \   00000208   0x461C3C00         DC32     0x461c3c00
   \   0000020C   0x40400001         DC32     0x40400001
   \   00000210   0x........         DC32     axis_relative_modes
   \   00000214   0x........         DC32     card+0xE00
   \   00000218   0x........         DC32     _ZZ10gcode_M109vEs
   \   0000021C   0x........         DC32     _ZZ10gcode_M109vEs_0
   \   00000220   0x........         DC32     _ZZ10gcode_M109vEs_1
   \   00000224   0x........         DC32     _ZZ10gcode_M109vEs_2
   \   00000228   0x........         DC32     _ZZ10gcode_M109vEs_3
   \   0000022C   0x........         DC32     _ZZ10gcode_M109vEs_4
   \   00000230   0x........         DC32     Serial6
   \   00000234   0x........         DC32     _ZZ10gcode_M109vEs_5
   \   00000238   0xFFFFD8F0         DC32     0xffffd8f0
   \   0000023C   0x........         DC32     _ZZ10gcode_M109vEs_6
   8398          
   8399          #if HAS_TEMP_BED
   8400          
   8401            #ifndef MIN_COOLING_SLOPE_DEG_BED
   8402              #define MIN_COOLING_SLOPE_DEG_BED 1.50
   8403            #endif
   8404            #ifndef MIN_COOLING_SLOPE_TIME_BED
   8405              #define MIN_COOLING_SLOPE_TIME_BED 60
   8406            #endif
   8407          
   8408            /**
   8409             * M190: Sxxx Wait for bed current temp to reach target temp. Waits only when heating
   8410             *       Rxxx Wait for bed current temp to reach target temp. Waits when heating and cooling
   8411             */
   8412            inline void gcode_M190() {
   8413              if (DEBUGGING(DRYRUN)) return;
   8414          
   8415              LCD_MESSAGEPGM(MSG_BED_HEATING);
   8416              const bool no_wait_for_cooling = parser.seenval('S');
   8417              if (no_wait_for_cooling || parser.seenval('R')) {
   8418                thermalManager.setTargetBed(parser.value_celsius());
   8419                #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
   8420                  if (parser.value_celsius() > BED_MINTEMP)
   8421                    print_job_timer.start();
   8422                #endif
   8423              }
   8424              else return;
   8425          
   8426              #if TEMP_BED_RESIDENCY_TIME > 0
   8427                millis_t residency_start_ms = 0;
   8428                // Loop until the temperature has stabilized
   8429                #define TEMP_BED_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_BED_RESIDENCY_TIME) * 1000UL))
   8430              #else
   8431                // Loop until the temperature is very close target
   8432                #define TEMP_BED_CONDITIONS (wants_to_cool ? thermalManager.isCoolingBed() : thermalManager.isHeatingBed())
   8433              #endif
   8434          
   8435              float target_temp = -1.0, old_temp = 9999.0;
   8436              bool wants_to_cool = false;
   8437              wait_for_heatup = true;
   8438              millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
   8439          
   8440              #if DISABLED(BUSY_WHILE_HEATING)
   8441                KEEPALIVE_STATE(NOT_BUSY);
   8442              #endif
   8443          
   8444              target_extruder = active_extruder; // for print_heaterstates
   8445          
   8446              #if ENABLED(PRINTER_EVENT_LEDS)
   8447                const float start_temp = thermalManager.degBed();
   8448                uint8_t old_red = 255;
   8449              #endif
   8450          	mks_heating_busy = 1;
   8451          
   8452              do {
   8453                // Target temperature might be changed during the loop
   8454                if (target_temp != thermalManager.degTargetBed()) {
   8455                  wants_to_cool = thermalManager.isCoolingBed();
   8456                  target_temp = thermalManager.degTargetBed();
   8457          
   8458                  // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
   8459                  if (no_wait_for_cooling && wants_to_cool) break;
   8460                }
   8461          
   8462                now = millis();
   8463                if (ELAPSED(now, next_temp_ms)) { //Print Temp Reading every 1 second while heating up.
   8464                  next_temp_ms = now + 1000UL;
   8465                  thermalManager.print_heaterstates();
   8466                  #if TEMP_BED_RESIDENCY_TIME > 0
   8467                    SERIAL_PROTOCOLPGM(" W:");
   8468                    if (residency_start_ms)
   8469                      SERIAL_PROTOCOL(long((((TEMP_BED_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL));
   8470                    else
   8471                      SERIAL_PROTOCOLCHAR('?');
   8472                  #endif
   8473                  SERIAL_EOL();
   8474                }
   8475          
   8476                idle();
   8477                refresh_cmd_timeout(); // to prevent stepper_inactive_time from running out
   8478          
   8479                const float temp = thermalManager.degBed();
   8480          
   8481                #if ENABLED(PRINTER_EVENT_LEDS)
   8482                  // Gradually change LED strip from blue to violet as bed heats up
   8483                  if (!wants_to_cool) {
   8484                    const uint8_t red = map(constrain(temp, start_temp, target_temp), start_temp, target_temp, 0, 255);
   8485                    if (red != old_red) {
   8486                      old_red = red;
   8487                      leds.set_color(
   8488                        MakeLEDColor(red, 0, 255, 0, pixels.getBrightness())
   8489                        #if ENABLED(NEOPIXEL_IS_SEQUENTIAL)
   8490                          , true
   8491                        #endif
   8492                      );
   8493                    }
   8494                  }
   8495                #endif
   8496          
   8497                #if TEMP_BED_RESIDENCY_TIME > 0
   8498          
   8499                  const float temp_diff = FABS(target_temp - temp);
   8500          
   8501                  if (!residency_start_ms) {
   8502                    // Start the TEMP_BED_RESIDENCY_TIME timer when we reach target temp for the first time.
   8503                    if (temp_diff < TEMP_BED_WINDOW) residency_start_ms = now;
   8504                  }
   8505                  else if (temp_diff > TEMP_BED_HYSTERESIS) {
   8506                    // Restart the timer whenever the temperature falls outside the hysteresis.
   8507                    residency_start_ms = now;
   8508                  }
   8509          
   8510                #endif // TEMP_BED_RESIDENCY_TIME > 0
   8511          
   8512                // Prevent a wait-forever situation if R is misused i.e. M190 R0
   8513                if (wants_to_cool) {
   8514                  // Break after MIN_COOLING_SLOPE_TIME_BED seconds
   8515                  // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG_BED
   8516                  if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
   8517                    if (old_temp - temp < MIN_COOLING_SLOPE_DEG_BED) break;
   8518                    next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME_BED;
   8519                    old_temp = temp;
   8520                  }
   8521                }
   8522          
   8523              } while (wait_for_heatup && TEMP_BED_CONDITIONS);
   8524          
   8525          	mks_heating_busy = 0;
   8526          
   8527              if (wait_for_heatup) LCD_MESSAGEPGM(MSG_BED_DONE);
   8528              #if DISABLED(BUSY_WHILE_HEATING)
   8529                KEEPALIVE_STATE(IN_HANDLER);
   8530              #endif
   8531            }
   8532          
   8533          #endif // HAS_TEMP_BED
   8534          
   8535          /**
   8536           * M110: Set Current Line Number
   8537           */

   \                                 In section .text, align 4
   8538          inline void gcode_M110() {
   \                     _Z10gcode_M110v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   8539            if (parser.seenval('N')) gcode_LastN = parser.value_long();
   \   00000002   0x204E             MOVS     R0,#+78
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD003             BEQ.N    ??gcode_M110_0
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser10value_longEv
   \   00000010   0x4901             LDR.N    R1,??gcode_M110_1
   \   00000012   0x6708             STR      R0,[R1, #+112]
   8540          }
   \                     ??gcode_M110_0: (+1)
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
   \   00000016   0xBF00             Nop      
   \                     ??gcode_M110_1:
   \   00000018   0x........         DC32     axis_relative_modes
   8541          
   8542          /**
   8543           * M111: Set the debug level
   8544           */

   \                                 In section .text, align 4
   8545          inline void gcode_M111() {
   \                     _Z10gcode_M111v: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   8546            if (parser.seen('S')) marlin_debug_flags = parser.byteval('S');
   \   00000002   0x4C1B             LDR.N    R4,??gcode_M111_0
   \   00000004   0x2053             MOVS     R0,#+83
   \   00000006   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD004             BEQ.N    ??gcode_M111_1
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x2053             MOVS     R0,#+83
   \   00000012   0x.... 0x....      BL       _ZN11GCodeParser7bytevalEch
   \   00000016   0x73E0             STRB     R0,[R4, #+15]
   8547          
   8548            const static char str_debug_1[] PROGMEM = MSG_DEBUG_ECHO,
   8549                              str_debug_2[] PROGMEM = MSG_DEBUG_INFO,
   8550                              str_debug_4[] PROGMEM = MSG_DEBUG_ERRORS,
   8551                              str_debug_8[] PROGMEM = MSG_DEBUG_DRYRUN,
   8552                              str_debug_16[] PROGMEM = MSG_DEBUG_COMMUNICATION
   8553                              #if ENABLED(DEBUG_LEVELING_FEATURE)
   8554                                , str_debug_32[] PROGMEM = MSG_DEBUG_LEVELING
   8555                              #endif
   8556                              ;
   8557          
   8558            const static char* const debug_strings[] PROGMEM = {
   8559              str_debug_1, str_debug_2, str_debug_4, str_debug_8, str_debug_16
   8560              #if ENABLED(DEBUG_LEVELING_FEATURE)
   8561                , str_debug_32
   8562              #endif
   8563            };
   8564          
   8565            SERIAL_ECHO_START();
   \                     ??gcode_M111_1: (+1)
   \   00000018   0x4816             LDR.N    R0,??gcode_M111_0+0x4
   \   0000001A   0x.... 0x....      BL       _Z14serialprintPGMPKc
   8566            SERIAL_ECHOPGM(MSG_DEBUG_PREFIX);
   \   0000001E   0x4816             LDR.N    R0,??gcode_M111_0+0x8
   \   00000020   0x.... 0x....      BL       _Z14serialprintPGMPKc
   8567            if (marlin_debug_flags) {
   \   00000024   0x7BE0             LDRB     R0,[R4, #+15]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD018             BEQ.N    ??gcode_M111_2
   8568              uint8_t comma = 0;
   \   0000002A   0x2600             MOVS     R6,#+0
   8569              for (uint8_t i = 0; i < COUNT(debug_strings); i++) {
   \   0000002C   0x4635             MOV      R5,R6
   \                     ??gcode_M111_3: (+1)
   \   0000002E   0x2D05             CMP      R5,#+5
   \   00000030   0xD217             BCS.N    ??gcode_M111_4
   8570                if (TEST(marlin_debug_flags, i)) {
   \   00000032   0x7BE0             LDRB     R0,[R4, #+15]
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0x40A9             LSLS     R1,R1,R5
   \   00000038   0x4208             TST      R0,R1
   \   0000003A   0xD00D             BEQ.N    ??gcode_M111_5
   8571                  if (comma++) SERIAL_CHAR(',');
   \   0000003C   0x4630             MOV      R0,R6
   \   0000003E   0x1C46             ADDS     R6,R0,#+1
   \   00000040   0xB2C0             UXTB     R0,R0
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD003             BEQ.N    ??gcode_M111_6
   \   00000046   0x212C             MOVS     R1,#+44
   \   00000048   0x480C             LDR.N    R0,??gcode_M111_0+0xC
   \   0000004A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   8572                  //serialprintPGM((char*)pgm_read_word(&debug_strings[i]));
   8573                  serialprintPGM((char*)&(debug_strings[i]));
   \                     ??gcode_M111_6: (+1)
   \   0000004E   0x480C             LDR.N    R0,??gcode_M111_0+0x10
   \   00000050   0xEB00 0x0085      ADD      R0,R0,R5, LSL #+2
   \   00000054   0x.... 0x....      BL       _Z14serialprintPGMPKc
   8574                }
   8575              }
   \                     ??gcode_M111_5: (+1)
   \   00000058   0x1C6D             ADDS     R5,R5,#+1
   \   0000005A   0xE7E8             B.N      ??gcode_M111_3
   8576            }
   8577            else {
   8578              SERIAL_ECHOPGM(MSG_DEBUG_OFF);
   \                     ??gcode_M111_2: (+1)
   \   0000005C   0x4809             LDR.N    R0,??gcode_M111_0+0x14
   \   0000005E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   8579            }
   8580            SERIAL_EOL();
   \                     ??gcode_M111_4: (+1)
   \   00000062   0x210A             MOVS     R1,#+10
   \   00000064   0x4805             LDR.N    R0,??gcode_M111_0+0xC
   \   00000066   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000006A   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   \   0000006E   0xBF00             Nop      
   \                     ??gcode_M111_0:
   \   00000070   0x........         DC32     axis_relative_modes
   \   00000074   0x........         DC32     echomagic
   \   00000078   0x........         DC32     _ZZ10gcode_M111vEs_4
   \   0000007C   0x........         DC32     Serial6
   \   00000080   0x........         DC32     _ZZ10gcode_M111vE13debug_strings
   \   00000084   0x........         DC32     _ZZ10gcode_M111vEs_5
   8581          }

   \                                 In section .rodata, align 4
   \                     _ZZ10gcode_M111vE11str_debug_1:
   \   00000000   0x45 0x43          DC8 "ECHO"
   \              0x48 0x4F    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     _ZZ10gcode_M111vE11str_debug_2:
   \   00000000   0x49 0x4E          DC8 "INFO"
   \              0x46 0x4F    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     _ZZ10gcode_M111vE11str_debug_4:
   \   00000000   0x45 0x52          DC8 "ERRORS"
   \              0x52 0x4F    
   \              0x52 0x53    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     _ZZ10gcode_M111vE11str_debug_8:
   \   00000000   0x44 0x52          DC8 "DRYRUN"
   \              0x59 0x52    
   \              0x55 0x4E    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     _ZZ10gcode_M111vE12str_debug_16:
   \   00000000   0x43 0x4F          DC8 "COMMUNICATION"
   \              0x4D 0x4D    
   \              0x55 0x4E    
   \              0x49 0x43    
   \              0x41 0x54    
   \              0x49 0x4F    
   \              0x4E 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     _ZZ10gcode_M111vE13debug_strings:
   \   00000000   0x........         DC32 _ZZ10gcode_M111vE11str_debug_1, _ZZ10gcode_M111vE11str_debug_2
   \              0x........   
   \   00000008   0x........         DC32 _ZZ10gcode_M111vE11str_debug_4, _ZZ10gcode_M111vE11str_debug_8
   \              0x........   
   \   00000010   0x........         DC32 _ZZ10gcode_M111vE12str_debug_16
   8582          
   8583          #if ENABLED(HOST_KEEPALIVE_FEATURE)
   8584          
   8585            /**
   8586             * M113: Get or set Host Keepalive interval (0 to disable)
   8587             *
   8588             *   S<seconds> Optional. Set the keepalive interval.
   8589             */
   8590            inline void gcode_M113() {
   8591              if (parser.seenval('S')) {
   8592                host_keepalive_interval = parser.value_byte();
   8593                NOMORE(host_keepalive_interval, 60);
   8594              }
   8595              else {
   8596                SERIAL_ECHO_START();
   8597                SERIAL_ECHOLNPAIR("M113 S", (unsigned long)host_keepalive_interval);
   8598              }
   8599            }
   8600          
   8601          #endif
   8602          
   8603          #if ENABLED(BARICUDA)
   8604          
   8605            #if HAS_HEATER_1
   8606              /**
   8607               * M126: Heater 1 valve open
   8608               */
   8609              inline void gcode_M126() { baricuda_valve_pressure = parser.byteval('S', 255); }
   8610              /**
   8611               * M127: Heater 1 valve close
   8612               */
   8613              inline void gcode_M127() { baricuda_valve_pressure = 0; }
   8614            #endif
   8615          
   8616            #if HAS_HEATER_2
   8617              /**
   8618               * M128: Heater 2 valve open
   8619               */
   8620              inline void gcode_M128() { baricuda_e_to_p_pressure = parser.byteval('S', 255); }
   8621              /**
   8622               * M129: Heater 2 valve close
   8623               */
   8624              inline void gcode_M129() { baricuda_e_to_p_pressure = 0; }
   8625            #endif
   8626          
   8627          #endif // BARICUDA
   8628          
   8629          /**
   8630           * M140: Set bed temperature
   8631           */

   \                                 In section .text, align 4
   8632          inline void gcode_M140() {
   8633            if (DEBUGGING(DRYRUN)) return;
   \                     _Z10gcode_M140v: (+1)
   \   00000000   0x4808             LDR.N    R0,??gcode_M140_0
   \   00000002   0x7BC0             LDRB     R0,[R0, #+15]
   \   00000004   0x0700             LSLS     R0,R0,#+28
   \   00000006   0xD500             BPL.N    ??gcode_M140_1
   \   00000008   0x4770             BX       LR
   8634            if (parser.seenval('S')) thermalManager.setTargetBed(parser.value_celsius());
   \                     ??gcode_M140_1: (+1)
   \   0000000A   0xB580             PUSH     {R7,LR}
   \   0000000C   0x2053             MOVS     R0,#+83
   \   0000000E   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD005             BEQ.N    ??gcode_M140_2
   \   00000016   0x.... 0x....      BL       _ZN11GCodeParser13value_celsiusEv
   \   0000001A   0xE8BD 0x4001      POP      {R0,LR}
   \   0000001E   0x.... 0x....      B.W      _ZN11Temperature12setTargetBedEf
   8635          }
   \                     ??gcode_M140_2: (+1)
   \   00000022   0xBD01             POP      {R0,PC}          ;; return
   \                     ??gcode_M140_0:
   \   00000024   0x........         DC32     axis_relative_modes
   8636          
   8637          #if ENABLED(ULTIPANEL)
   8638          
   8639            /**
   8640             * M145: Set the heatup state for a material in the LCD menu
   8641             *
   8642             *   S<material> (0=PLA, 1=ABS)
   8643             *   H<hotend temp>
   8644             *   B<bed temp>
   8645             *   F<fan speed>
   8646             */
   8647            inline void gcode_M145() {
   8648              const uint8_t material = (uint8_t)parser.intval('S');
   8649              if (material >= COUNT(lcd_preheat_hotend_temp)) {
   8650                SERIAL_ERROR_START();
   8651                SERIAL_ERRORLNPGM(MSG_ERR_MATERIAL_INDEX);
   8652              }
   8653              else {
   8654                int v;
   8655                if (parser.seenval('H')) {
   8656                  v = parser.value_int();
   8657                  lcd_preheat_hotend_temp[material] = constrain(v, EXTRUDE_MINTEMP, HEATER_0_MAXTEMP - 15);
   8658                }
   8659                if (parser.seenval('F')) {
   8660                  v = parser.value_int();
   8661                  lcd_preheat_fan_speed[material] = constrain(v, 0, 255);
   8662                }
   8663                #if TEMP_SENSOR_BED != 0
   8664                  if (parser.seenval('B')) {
   8665                    v = parser.value_int();
   8666                    lcd_preheat_bed_temp[material] = constrain(v, BED_MINTEMP, BED_MAXTEMP - 15);
   8667                  }
   8668                #endif
   8669              }
   8670            }
   8671          
   8672          #endif // ULTIPANEL
   8673          
   8674          #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
   8675            /**
   8676             * M149: Set temperature units
   8677             */
   8678            inline void gcode_M149() {
   8679                   if (parser.seenval('C')) parser.set_input_temp_units(TEMPUNIT_C);
   8680              else if (parser.seenval('K')) parser.set_input_temp_units(TEMPUNIT_K);
   8681              else if (parser.seenval('F')) parser.set_input_temp_units(TEMPUNIT_F);
   8682            }
   8683          #endif
   8684          
   8685          #if HAS_POWER_SWITCH
   8686          
   8687            /**
   8688             * M80   : Turn on the Power Supply
   8689             * M80 S : Report the current state and exit
   8690             */
   8691            inline void gcode_M80() {
   8692          
   8693              // S: Report the current power supply state and exit
   8694              if (parser.seen('S')) {
   8695                serialprintPGM(powersupply_on ? PSTR("PS:1\n") : PSTR("PS:0\n"));
   8696                return;
   8697              }
   8698          
   8699              OUT_WRITE(PS_ON_PIN, PS_ON_AWAKE); // GND
   8700          
   8701              /**
   8702               * If you have a switch on suicide pin, this is useful
   8703               * if you want to start another print with suicide feature after
   8704               * a print without suicide...
   8705               */
   8706              #if HAS_SUICIDE
   8707                OUT_WRITE(SUICIDE_PIN, HIGH);
   8708              #endif
   8709          
   8710              #if ENABLED(HAVE_TMC2130)
   8711                delay(100);
   8712                tmc2130_init(); // Settings only stick when the driver has power
   8713              #endif
   8714          
   8715              powersupply_on = true;
   8716          
   8717              #if ENABLED(ULTIPANEL)
   8718                LCD_MESSAGEPGM(WELCOME_MSG);
   8719              #endif
   8720          
   8721              #if ENABLED(HAVE_TMC2208)
   8722                delay(100);
   8723                tmc2208_init();
   8724              #endif
   8725            }
   8726          
   8727          #endif // HAS_POWER_SWITCH
   8728          
   8729          /**
   8730           * M81: Turn off Power, including Power Supply, if there is one.
   8731           *
   8732           *      This code should ALWAYS be available for EMERGENCY SHUTDOWN!
   8733           */

   \                                 In section .text, align 4
   8734          inline void gcode_M81() {
   \                     _Z9gcode_M81v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   8735            thermalManager.disable_all_heaters();
   \   00000002   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
   8736            stepper.finish_and_disable();
   \   00000006   0x.... 0x....      BL       _ZN7Stepper18finish_and_disableEv
   8737          
   8738            #if FAN_COUNT > 0
   8739              for (uint8_t i = 0; i < FAN_COUNT; i++) fanSpeeds[i] = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x4906             LDR.N    R1,??gcode_M81_0
   \   0000000E   0xE002             B.N      ??gcode_M81_1
   \                     ??gcode_M81_2: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x6008             STR      R0,[R1, #+0]
   \   00000014   0x2001             MOVS     R0,#+1
   \                     ??gcode_M81_1: (+1)
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD0FA             BEQ.N    ??gcode_M81_2
   8740              #if ENABLED(PROBING_FANS_OFF)
   8741                fans_paused = false;
   8742                ZERO(paused_fanSpeeds);
   8743              #endif
   8744            #endif
   8745          
   8746            safe_delay(1000); // Wait 1 second before switching off
   \   0000001A   0xF44F 0x707A      MOV      R0,#+1000
   \   0000001E   0xE8BD 0x4002      POP      {R1,LR}
   \   00000022   0x.... 0x....      B.W      _Z10safe_delaym
   \   00000026   0xBF00             Nop      
   \                     ??gcode_M81_0:
   \   00000028   0x........         DC32     fanSpeeds
   8747          
   8748            #if HAS_SUICIDE
   8749              stepper.synchronize();
   8750              suicide();
   8751            #elif HAS_POWER_SWITCH
   8752              OUT_WRITE(PS_ON_PIN, PS_ON_ASLEEP);
   8753              powersupply_on = false;
   8754            #endif
   8755          
   8756            #if ENABLED(ULTIPANEL)
   8757              LCD_MESSAGEPGM(MACHINE_NAME " " MSG_OFF ".");
   8758            #endif
   8759          }
   8760          
   8761          /**
   8762           * M82: Set E codes absolute (default)
   8763           */

   \                                 In section .text, align 4
   8764          inline void gcode_M82() { axis_relative_modes[E_AXIS] = false; }
   \                     _Z9gcode_M82v: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4901             LDR.N    R1,??gcode_M82_0
   \   00000004   0x70C8             STRB     R0,[R1, #+3]
   \   00000006   0x4770             BX       LR               ;; return
   \                     ??gcode_M82_0:
   \   00000008   0x........         DC32     axis_relative_modes
   8765          
   8766          /**
   8767           * M83: Set E codes relative while in Absolute Coordinates (G90) mode
   8768           */

   \                                 In section .text, align 4
   8769          inline void gcode_M83() { axis_relative_modes[E_AXIS] = true; }
   \                     _Z9gcode_M83v: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x4901             LDR.N    R1,??gcode_M83_0
   \   00000004   0x70C8             STRB     R0,[R1, #+3]
   \   00000006   0x4770             BX       LR               ;; return
   \                     ??gcode_M83_0:
   \   00000008   0x........         DC32     axis_relative_modes
   8770          
   8771          /**
   8772           * M18, M84: Disable stepper motors
   8773           */

   \                                 In section .text, align 4
   8774          inline void gcode_M18_M84() {
   \                     _Z13gcode_M18_M84v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   8775            if (parser.seenval('S')) {
   \   00000002   0x2053             MOVS     R0,#+83
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD004             BEQ.N    ??gcode_M18_M84_0
   8776              stepper_inactive_time = parser.value_millis_from_seconds();
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser25value_millis_from_secondsEv
   \   00000010   0x491C             LDR.N    R1,??gcode_M18_M84_1
   \   00000012   0x6088             STR      R0,[R1, #+8]
   \   00000014   0xBD01             POP      {R0,PC}
   8777            }
   8778            else {
   8779              bool all_axis = !((parser.seen('X')) || (parser.seen('Y')) || (parser.seen('Z')) || (parser.seen('E')));
   \                     ??gcode_M18_M84_0: (+1)
   \   00000016   0x2058             MOVS     R0,#+88
   \   00000018   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD111             BNE.N    ??gcode_M18_M84_2
   \   00000020   0x2059             MOVS     R0,#+89
   \   00000022   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD10C             BNE.N    ??gcode_M18_M84_2
   \   0000002A   0x205A             MOVS     R0,#+90
   \   0000002C   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD107             BNE.N    ??gcode_M18_M84_2
   \   00000034   0x2045             MOVS     R0,#+69
   \   00000036   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000003A   0xF000 0x0001      AND      R0,R0,#0x1
   \   0000003E   0xF080 0x0001      EOR      R0,R0,#0x1
   \   00000042   0xE000             B.N      ??gcode_M18_M84_3
   \                     ??gcode_M18_M84_2: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   8780              if (all_axis) {
   \                     ??gcode_M18_M84_3: (+1)
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD003             BEQ.N    ??gcode_M18_M84_4
   8781                stepper.finish_and_disable();
   \   0000004A   0xE8BD 0x4001      POP      {R0,LR}
   \   0000004E   0x.... 0x....      B.W      _ZN7Stepper18finish_and_disableEv
   8782              }
   8783              else {
   8784                stepper.synchronize();
   \                     ??gcode_M18_M84_4: (+1)
   \   00000052   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   8785                if (parser.seen('X')) disable_X();
   \   00000056   0x2058             MOVS     R0,#+88
   \   00000058   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   8786                if (parser.seen('Y')) disable_Y();
   \   0000005C   0x2059             MOVS     R0,#+89
   \   0000005E   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   8787                if (parser.seen('Z')) disable_Z();
   \   00000062   0x205A             MOVS     R0,#+90
   \   00000064   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD009             BEQ.N    ??gcode_M18_M84_5
   \   0000006C   0x2201             MOVS     R2,#+1
   \   0000006E   0x4806             LDR.N    R0,??gcode_M18_M84_1+0x4
   \   00000070   0x8881             LDRH     R1,[R0, #+4]
   \   00000072   0x4806             LDR.N    R0,??gcode_M18_M84_1+0x8
   \   00000074   0x6880             LDR      R0,[R0, #+8]
   \   00000076   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x4904             LDR.N    R1,??gcode_M18_M84_1+0xC
   \   0000007E   0x7288             STRB     R0,[R1, #+10]
   8788                #if E0_ENABLE_PIN != X_ENABLE_PIN && E1_ENABLE_PIN != Y_ENABLE_PIN // Only enable on boards that have separate ENABLE_PINS
   8789                  if (parser.seen('E')) disable_e_steppers();
   8790                #endif
   8791              }
   8792          
   8793              #if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(ULTIPANEL)  // Only needed with an LCD
   8794                ubl.lcd_map_control = defer_return_to_status = false;
   8795              #endif
   8796            }
   8797          }
   \                     ??gcode_M18_M84_5: (+1)
   \   00000080   0xBD01             POP      {R0,PC}          ;; return
   \   00000082   0xBF00             Nop      
   \                     ??gcode_M18_M84_1:
   \   00000084   0x........         DC32     previous_cmd_ms
   \   00000088   0x........         DC32     gArrayGpioPin
   \   0000008C   0x........         DC32     gArrayGpioPort
   \   00000090   0x........         DC32     axis_relative_modes
   8798          
   8799          /**
   8800           * M85: Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
   8801           */

   \                                 In section .text, align 4
   8802          inline void gcode_M85() {
   \                     _Z9gcode_M85v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   8803            if (parser.seen('S')) max_inactive_time = parser.value_millis_from_seconds();
   \   00000002   0x2053             MOVS     R0,#+83
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD003             BEQ.N    ??gcode_M85_0
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser25value_millis_from_secondsEv
   \   00000010   0x4901             LDR.N    R1,??gcode_M85_1
   \   00000012   0x6048             STR      R0,[R1, #+4]
   8804          }
   \                     ??gcode_M85_0: (+1)
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
   \   00000016   0xBF00             Nop      
   \                     ??gcode_M85_1:
   \   00000018   0x........         DC32     previous_cmd_ms
   8805          
   8806          /**
   8807           * Multi-stepper support for M92, M201, M203
   8808           */
   8809          #if ENABLED(DISTINCT_E_FACTORS)
   8810            #define GET_TARGET_EXTRUDER(CMD) if (get_target_extruder_from_command(CMD)) return
   8811            #define TARGET_EXTRUDER target_extruder
   8812          #else
   8813            #define GET_TARGET_EXTRUDER(CMD) NOOP
   8814            #define TARGET_EXTRUDER 0
   8815          #endif
   8816          
   8817          /**
   8818           * M92: Set axis steps-per-unit for one or more axes, X, Y, Z, and E.
   8819           *      (Follows the same syntax as G92)
   8820           *
   8821           *      With multiple extruders use T to specify which one.
   8822           */

   \                                 In section .text, align 4
   8823          inline void gcode_M92() {
   \                     _Z9gcode_M92v: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   8824          
   8825            GET_TARGET_EXTRUDER(92);
   8826          
   8827            LOOP_XYZE(i) {
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0x4D21             LDR.N    R5,??gcode_M92_0
   \   00000006   0xE008             B.N      ??gcode_M92_1
   8828              if (parser.seen(axis_codes[i])) {
   8829                if (i == E_AXIS) {
   8830                  const float value = parser.value_per_axis_unit((AxisEnum)(E_AXIS + TARGET_EXTRUDER));
   8831                  if (value < 20.0) {
   8832                    float factor = planner.axis_steps_per_mm[E_AXIS + TARGET_EXTRUDER] / value; // increase e constants if M92 E14 is given for netfab.
   8833                    planner.max_jerk[E_AXIS] *= factor;
   8834                    planner.max_feedrate_mm_s[E_AXIS + TARGET_EXTRUDER] *= factor;
   8835                    planner.max_acceleration_steps_per_s2[E_AXIS + TARGET_EXTRUDER] *= factor;
   8836                  }
   8837                  planner.axis_steps_per_mm[E_AXIS + TARGET_EXTRUDER] = value;
   8838                }
   8839                else {
   8840                  planner.axis_steps_per_mm[i] = parser.value_per_axis_unit((AxisEnum)i);
   \                     ??gcode_M92_2: (+1)
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0xB240             SXTB     R0,R0
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser19value_per_axis_unitE8AxisEnum
   \   00000010   0xEB05 0x0084      ADD      R0,R5,R4, LSL #+2
   \   00000014   0xED80 0x0A00      VSTR     S0,[R0, #0]
   8841                }
   \                     ??gcode_M92_3: (+1)
   \   00000018   0x1C64             ADDS     R4,R4,#+1
   \                     ??gcode_M92_1: (+1)
   \   0000001A   0x2C04             CMP      R4,#+4
   \   0000001C   0xDA31             BGE.N    ??gcode_M92_4
   \   0000001E   0x481C             LDR.N    R0,??gcode_M92_0+0x4
   \   00000020   0x5620             LDRSB    R0,[R4, R0]
   \   00000022   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD0F6             BEQ.N    ??gcode_M92_3
   \   0000002A   0x2C03             CMP      R4,#+3
   \   0000002C   0xD1EC             BNE.N    ??gcode_M92_2
   \   0000002E   0x2003             MOVS     R0,#+3
   \   00000030   0x.... 0x....      BL       _ZN11GCodeParser19value_per_axis_unitE8AxisEnum
   \   00000034   0xEEF3 0x0A04      VMOV.F32 S1,#20.0
   \   00000038   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   0000003C   0xEEF1 0xFA10      FMSTAT   
   \   00000040   0xD51C             BPL.N    ??gcode_M92_5
   \   00000042   0xEDD5 0x0A03      VLDR     S1,[R5, #+12]
   \   00000046   0xEEC0 0x0A80      VDIV.F32 S1,S1,S0
   \   0000004A   0x4812             LDR.N    R0,??gcode_M92_0+0x8
   \   0000004C   0xED90 0x1A03      VLDR     S2,[R0, #+12]
   \   00000050   0xEE21 0x1A20      VMUL.F32 S2,S2,S1
   \   00000054   0xED80 0x1A03      VSTR     S2,[R0, #+12]
   \   00000058   0x480F             LDR.N    R0,??gcode_M92_0+0xC
   \   0000005A   0xED90 0x1A03      VLDR     S2,[R0, #+12]
   \   0000005E   0xEE21 0x1A20      VMUL.F32 S2,S2,S1
   \   00000062   0xED80 0x1A03      VSTR     S2,[R0, #+12]
   \   00000066   0x480D             LDR.N    R0,??gcode_M92_0+0x10
   \   00000068   0xED90 0x1A03      VLDR     S2,[R0, #+12]
   \   0000006C   0xEEB8 0x1A41      VCVT.F32.U32 S2,S2
   \   00000070   0xEE61 0x0A20      VMUL.F32 S1,S2,S1
   \   00000074   0xEEFC 0x0AE0      VCVT.U32.F32 S1,S1
   \   00000078   0xEDC0 0x0A03      VSTR     S1,[R0, #+12]
   \                     ??gcode_M92_5: (+1)
   \   0000007C   0xED85 0x0A03      VSTR     S0,[R5, #+12]
   \   00000080   0xE7CA             B.N      ??gcode_M92_3
   8842              }
   8843            }
   8844            planner.refresh_positioning();
   \                     ??gcode_M92_4: (+1)
   \   00000082   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000086   0x.... 0x....      B.W      _ZN7Planner19refresh_positioningEv
   \   0000008A   0xBF00             Nop      
   \                     ??gcode_M92_0:
   \   0000008C   0x........         DC32     _ZN7Planner17axis_steps_per_mmE
   \   00000090   0x........         DC32     axis_codes
   \   00000094   0x........         DC32     _ZN7Planner8max_jerkE
   \   00000098   0x........         DC32     _ZN7Planner17max_feedrate_mm_sE
   \   0000009C   0x........         DC32     _ZN7Planner29max_acceleration_steps_per_s2E
   8845          }
   8846          
   8847          /**
   8848           * Output the current position to serial
   8849           */

   \                                 In section .text, align 2, keep-with-next
   8850          void report_mksdlp_position() {
   \                     _Z22report_mksdlp_positionv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   8851          //	SERIAL_PROTOCOLPGM("X:");
   8852          //	SERIAL_PROTOCOL(/*LOGICAL_X_POSITION*/(current_position[X_AXIS]));
   8853          //	SERIAL_PROTOCOLPGM(" Y:");
   8854          //	SERIAL_PROTOCOL(/*LOGICAL_Y_POSITION*/(current_position[Y_AXIS]));
   8855          
   8856            SERIAL_PROTOCOLPGM("Layer:");
   \   00000002   0x.... 0x....      ADR.W    R0,`?<Constant "Layer:">`
   \   00000006   0x.... 0x....      BL       _Z14serialprintPGMPKc
   8857            SERIAL_PROTOCOL(mksdlp.get_currentLayer());
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable115_1
   \   0000000E   0x.... 0x....      BL       _ZN7MKS_DLP16get_currentLayerEv
   \   00000012   0x.... 0x....      LDR.W    R5,??DataTable109
   \   00000016   0x220A             MOVS     R2,#+10
   \   00000018   0x4601             MOV      R1,R0
   \   0000001A   0x4628             MOV      R0,R5
   \   0000001C   0x.... 0x....      BL       _ZN5Print5printEii
   8858          	
   8859            SERIAL_PROTOCOLPGM(" Z:");
   \   00000020   0x....             ADR.N    R0,??DataTable104_1  ;; " Z:"
   \   00000022   0x.... 0x....      BL       _Z14serialprintPGMPKc
   8860            SERIAL_PROTOCOL(/*LOGICAL_Z_POSITION*/(current_position[Z_AXIS]));
   \   00000026   0x2102             MOVS     R1,#+2
   \   00000028   0x460C             MOV      R4,R1
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable111_1
   \   0000002E   0x6AC0             LDR      R0,[R0, #+44]
   \   00000030   0x.... 0x....      BL       __aeabi_f2d
   \   00000034   0xEC41 0x0B10      VMOV     D0,R0,R1
   \   00000038   0x4621             MOV      R1,R4
   \   0000003A   0x4628             MOV      R0,R5
   \   0000003C   0x.... 0x....      BL       _ZN5Print5printEdi
   8861          //	SERIAL_PROTOCOLPGM(" E:");
   8862          //	SERIAL_PROTOCOL(current_position[E_AXIS]);
   8863          	
   8864            stepper.report_positions();
   \   00000040   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000044   0x.... 0x....      B.W      _ZN7Stepper16report_positionsEv
   8865          	
   8866          }
   8867          
   8868           

   \                                 In section .text, align 2, keep-with-next
   8869          void report_current_position() {
   \                     _Z23report_current_positionv: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   8870            SERIAL_PROTOCOLPGM("X:");
   \   00000002   0x....             ADR.N    R0,??DataTable104_2  ;; 0x58, 0x3A, 0x00, 0x00
   \   00000004   0x.... 0x....      BL       _Z14serialprintPGMPKc
   8871            SERIAL_PROTOCOL(/*LOGICAL_X_POSITION*/(current_position[X_AXIS]));
   \   00000008   0x.... 0x....      LDR.W    R5,??DataTable109
   \   0000000C   0x.... 0x....      LDR.W    R6,??DataTable107
   \   00000010   0x2102             MOVS     R1,#+2
   \   00000012   0x460C             MOV      R4,R1
   \   00000014   0x6A70             LDR      R0,[R6, #+36]
   \   00000016   0x.... 0x....      BL       __aeabi_f2d
   \   0000001A   0xEC41 0x0B10      VMOV     D0,R0,R1
   \   0000001E   0x4621             MOV      R1,R4
   \   00000020   0x4628             MOV      R0,R5
   \   00000022   0x.... 0x....      BL       _ZN5Print5printEdi
   8872            SERIAL_PROTOCOLPGM(" Y:");
   \   00000026   0x....             ADR.N    R0,??DataTable104_3  ;; " Y:"
   \   00000028   0x.... 0x....      BL       _Z14serialprintPGMPKc
   8873            SERIAL_PROTOCOL(/*LOGICAL_Y_POSITION*/(current_position[Y_AXIS]));
   \   0000002C   0x6AB0             LDR      R0,[R6, #+40]
   \   0000002E   0x.... 0x....      BL       __aeabi_f2d
   \   00000032   0xEC41 0x0B10      VMOV     D0,R0,R1
   \   00000036   0x4621             MOV      R1,R4
   \   00000038   0x4628             MOV      R0,R5
   \   0000003A   0x.... 0x....      BL       _ZN5Print5printEdi
   8874          
   8875            SERIAL_PROTOCOLPGM(" Z:");
   \   0000003E   0x....             ADR.N    R0,??DataTable104_1  ;; " Z:"
   \   00000040   0x.... 0x....      BL       _Z14serialprintPGMPKc
   8876            SERIAL_PROTOCOL(/*LOGICAL_Z_POSITION*/(current_position[Z_AXIS]));
   \   00000044   0x6AF0             LDR      R0,[R6, #+44]
   \   00000046   0x.... 0x....      BL       __aeabi_f2d
   \   0000004A   0xEC41 0x0B10      VMOV     D0,R0,R1
   \   0000004E   0x4621             MOV      R1,R4
   \   00000050   0x4628             MOV      R0,R5
   \   00000052   0x.... 0x....      BL       _ZN5Print5printEdi
   8877            SERIAL_PROTOCOLPGM(" E:");
   \   00000056   0x....             ADR.N    R0,??DataTable104_4  ;; " E:"
   \   00000058   0x.... 0x....      BL       _Z14serialprintPGMPKc
   8878            SERIAL_PROTOCOL(current_position[E_AXIS]);
   \   0000005C   0x6B30             LDR      R0,[R6, #+48]
   \   0000005E   0x.... 0x....      BL       __aeabi_f2d
   \   00000062   0xEC41 0x0B10      VMOV     D0,R0,R1
   \   00000066   0x4621             MOV      R1,R4
   \   00000068   0x4628             MOV      R0,R5
   \   0000006A   0x.... 0x....      BL       _ZN5Print5printEdi
   8879          
   8880            stepper.report_positions();
   \   0000006E   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000072   0x.... 0x....      B.W      _ZN7Stepper16report_positionsEv
   8881          
   8882            #if IS_SCARA
   8883              SERIAL_PROTOCOLPAIR("SCARA Theta:", stepper.get_axis_position_degrees(A_AXIS));
   8884              SERIAL_PROTOCOLLNPAIR("   Psi+Theta:", stepper.get_axis_position_degrees(B_AXIS));
   8885              SERIAL_EOL();
   8886            #endif
   8887          }
   8888          
   8889          #ifdef M114_DETAIL
   8890          
   8891            void report_xyze(const float pos[], const uint8_t n = 4, const uint8_t precision = 3) {
   8892              char str[12];
   8893              for (uint8_t i = 0; i < n; i++) {
   8894                SERIAL_CHAR(' ');
   8895                SERIAL_CHAR(axis_codes[i]);
   8896                SERIAL_CHAR(':');
   8897                SERIAL_PROTOCOL(dtostrf(pos[i], 8, precision, str));
   8898              }
   8899              SERIAL_EOL();
   8900            }
   8901          
   8902            inline void report_xyz(const float pos[]) { report_xyze(pos, 3); }
   8903          
   8904            void report_current_position_detail() {
   8905          
   8906              stepper.synchronize();
   8907          
   8908              SERIAL_PROTOCOLPGM("\nLogical:");
   8909              const float logical[XYZ] = {
   8910                LOGICAL_X_POSITION(current_position[X_AXIS]),
   8911                LOGICAL_Y_POSITION(current_position[Y_AXIS]),
   8912                LOGICAL_Z_POSITION(current_position[Z_AXIS])
   8913              };
   8914              report_xyze(logical);
   8915          
   8916              SERIAL_PROTOCOLPGM("Raw:    ");
   8917              report_xyz(current_position);
   8918          
   8919              float leveled[XYZ] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] };
   8920          
   8921              #if PLANNER_LEVELING
   8922                SERIAL_PROTOCOLPGM("Leveled:");
   8923                planner.apply_leveling(leveled);
   8924                report_xyz(leveled);
   8925          
   8926                SERIAL_PROTOCOLPGM("UnLevel:");
   8927                float unleveled[XYZ] = { leveled[X_AXIS], leveled[Y_AXIS], leveled[Z_AXIS] };
   8928                planner.unapply_leveling(unleveled);
   8929                report_xyz(unleveled);
   8930              #endif
   8931          
   8932              #if IS_KINEMATIC
   8933                #if IS_SCARA
   8934                  SERIAL_PROTOCOLPGM("ScaraK: ");
   8935                #else
   8936                  SERIAL_PROTOCOLPGM("DeltaK: ");
   8937                #endif
   8938                inverse_kinematics(leveled);  // writes delta[]
   8939                report_xyz(delta);
   8940              #endif
   8941          
   8942              SERIAL_PROTOCOLPGM("Stepper:");
   8943              LOOP_XYZE(i) {
   8944                SERIAL_CHAR(' ');
   8945                SERIAL_CHAR(axis_codes[i]);
   8946                SERIAL_CHAR(':');
   8947                SERIAL_PROTOCOL(stepper.position((AxisEnum)i));
   8948              }
   8949              SERIAL_EOL();
   8950          
   8951              #if IS_SCARA
   8952                const float deg[XYZ] = {
   8953                  stepper.get_axis_position_degrees(A_AXIS),
   8954                  stepper.get_axis_position_degrees(B_AXIS)
   8955                };
   8956                SERIAL_PROTOCOLPGM("Degrees:");
   8957                report_xyze(deg, 2);
   8958              #endif
   8959          
   8960              SERIAL_PROTOCOLPGM("FromStp:");
   8961              get_cartesian_from_steppers();  // writes cartes[XYZ] (with forward kinematics)
   8962              const float from_steppers[XYZE] = { cartes[X_AXIS], cartes[Y_AXIS], cartes[Z_AXIS], stepper.get_axis_position_mm(E_AXIS) };
   8963              report_xyze(from_steppers);
   8964          
   8965              const float diff[XYZE] = {
   8966                from_steppers[X_AXIS] - leveled[X_AXIS],
   8967                from_steppers[Y_AXIS] - leveled[Y_AXIS],
   8968                from_steppers[Z_AXIS] - leveled[Z_AXIS],
   8969                from_steppers[E_AXIS] - current_position[E_AXIS]
   8970              };
   8971              SERIAL_PROTOCOLPGM("Differ: ");
   8972              report_xyze(diff);
   8973            }
   8974          #endif // M114_DETAIL
   8975          
   8976          /**
   8977           * M114: Report current position to host
   8978           */

   \                                 In section .text, align 2
   8979          inline void gcode_M114() {
   \                     _Z10gcode_M114v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   8980          
   8981            #ifdef M114_DETAIL
   8982              if (parser.seen('D')) {
   8983                report_current_position_detail();
   8984                return;
   8985              }
   8986            #endif
   8987          
   8988            stepper.synchronize();
   \   00000002   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   8989            report_current_position();
   \   00000006   0xE8BD 0x4001      POP      {R0,LR}
   \   0000000A   0x.... 0x....      B.W      _Z23report_current_positionv
   8990          }
   8991          
   8992          /**
   8993           * M115: Capabilities string
   8994           */
   8995          
   8996          #if ENABLED(EXTENDED_CAPABILITIES_REPORT)

   \                                 In section .text, align 2, keep-with-next
   8997            static void cap_line(const char * const name, bool ena=false) {
   \                     _Z8cap_linePKcb: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   8998              SERIAL_PROTOCOLPGM("Cap:");
   \   00000006   0x.... 0x....      ADR.W    R0,`?<Constant "Cap:">`
   \   0000000A   0x.... 0x....      BL       _Z14serialprintPGMPKc
   8999              serialprintPGM(name);
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9000              SERIAL_PROTOCOLPGM(":");
   \   00000014   0x....             ADR.N    R0,??DataTable104_5  ;; ":"
   \   00000016   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9001              SERIAL_PROTOCOLLN(int(ena ? 1 : 0));
   \   0000001A   0x.... 0x....      LDR.W    R4,??DataTable109
   \   0000001E   0x220A             MOVS     R2,#+10
   \   00000020   0x4629             MOV      R1,R5
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       _ZN5Print5printEii
   \   00000028   0x210A             MOVS     R1,#+10
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000030   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   9002            }
   9003          #endif
   9004          

   \                                 In section .text, align 4
   9005          inline void gcode_M115() {
   \                     _Z10gcode_M115v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   9006            SERIAL_PROTOCOLLNPGM(MSG_M115_REPORT);
   \   00000002   0x481E             LDR.N    R0,??gcode_M115_0
   \   00000004   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9007          
   9008            #if ENABLED(EXTENDED_CAPABILITIES_REPORT)
   9009          
   9010              // SERIAL_XON_XOFF
   9011              cap_line(PSTR("SERIAL_XON_XOFF")
   9012                #if ENABLED(SERIAL_XON_XOFF)
   9013                  , true
   9014                #endif
   9015              );
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x481D             LDR.N    R0,??gcode_M115_0+0x4
   \   0000000C   0x.... 0x....      BL       _Z8cap_linePKcb
   9016          
   9017              // EEPROM (M500, M501)
   9018              cap_line(PSTR("EEPROM")
   9019                #if ENABLED(EEPROM_SETTINGS)
   9020                  , true
   9021                #endif
   9022              );
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0x481C             LDR.N    R0,??gcode_M115_0+0x8
   \   00000014   0x.... 0x....      BL       _Z8cap_linePKcb
   9023          
   9024              // Volumetric Extrusion (M200)
   9025              cap_line(PSTR("VOLUMETRIC")
   9026                #if DISABLED(NO_VOLUMETRICS)
   9027                  , true
   9028                #endif
   9029              );
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x481B             LDR.N    R0,??gcode_M115_0+0xC
   \   0000001C   0x.... 0x....      BL       _Z8cap_linePKcb
   9030          
   9031              // AUTOREPORT_TEMP (M155)
   9032              cap_line(PSTR("AUTOREPORT_TEMP")
   9033                #if ENABLED(AUTO_REPORT_TEMPERATURES)
   9034                  , true
   9035                #endif
   9036              );
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0x481A             LDR.N    R0,??gcode_M115_0+0x10
   \   00000024   0x.... 0x....      BL       _Z8cap_linePKcb
   9037          
   9038              // PROGRESS (M530 S L, M531 <file>, M532 X L)
   9039              cap_line(PSTR("PROGRESS"));
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x4819             LDR.N    R0,??gcode_M115_0+0x14
   \   0000002C   0x.... 0x....      BL       _Z8cap_linePKcb
   9040          
   9041              // Print Job timer M75, M76, M77
   9042              cap_line(PSTR("PRINT_JOB"), true);
   \   00000030   0x2101             MOVS     R1,#+1
   \   00000032   0x4818             LDR.N    R0,??gcode_M115_0+0x18
   \   00000034   0x.... 0x....      BL       _Z8cap_linePKcb
   9043          
   9044              // AUTOLEVEL (G29)
   9045              cap_line(PSTR("AUTOLEVEL")
   9046                #if HAS_AUTOLEVEL
   9047                  , true
   9048                #endif
   9049              );
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x4817             LDR.N    R0,??gcode_M115_0+0x1C
   \   0000003C   0x.... 0x....      BL       _Z8cap_linePKcb
   9050          
   9051              // Z_PROBE (G30)
   9052              cap_line(PSTR("Z_PROBE")
   9053                #if HAS_BED_PROBE
   9054                  , true
   9055                #endif
   9056              );
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0x4816             LDR.N    R0,??gcode_M115_0+0x20
   \   00000044   0x.... 0x....      BL       _Z8cap_linePKcb
   9057          
   9058              // MESH_REPORT (M420 V)
   9059              cap_line(PSTR("LEVELING_DATA")
   9060                #if HAS_LEVELING
   9061                  , true
   9062                #endif
   9063              );
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0x4815             LDR.N    R0,??gcode_M115_0+0x24
   \   0000004C   0x.... 0x....      BL       _Z8cap_linePKcb
   9064          
   9065              // BUILD_PERCENT (M73)
   9066              cap_line(PSTR("BUILD_PERCENT")
   9067                #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
   9068                  , true
   9069                #endif
   9070              );
   \   00000050   0x2100             MOVS     R1,#+0
   \   00000052   0x4814             LDR.N    R0,??gcode_M115_0+0x28
   \   00000054   0x.... 0x....      BL       _Z8cap_linePKcb
   9071          
   9072              // SOFTWARE_POWER (M80, M81)
   9073              cap_line(PSTR("SOFTWARE_POWER")
   9074                #if HAS_POWER_SWITCH
   9075                  , true
   9076                #endif
   9077              );
   \   00000058   0x2100             MOVS     R1,#+0
   \   0000005A   0x4813             LDR.N    R0,??gcode_M115_0+0x2C
   \   0000005C   0x.... 0x....      BL       _Z8cap_linePKcb
   9078          
   9079              // CASE LIGHTS (M355)
   9080              cap_line(PSTR("TOGGLE_LIGHTS")
   9081                #if HAS_CASE_LIGHT
   9082                  , true
   9083                #endif
   9084              );
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0x4812             LDR.N    R0,??gcode_M115_0+0x30
   \   00000064   0x.... 0x....      BL       _Z8cap_linePKcb
   9085              cap_line(PSTR("CASE_LIGHT_BRIGHTNESS")
   9086                #if HAS_CASE_LIGHT
   9087                  , USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN)
   9088                #endif
   9089              );
   \   00000068   0x2100             MOVS     R1,#+0
   \   0000006A   0x4811             LDR.N    R0,??gcode_M115_0+0x34
   \   0000006C   0x.... 0x....      BL       _Z8cap_linePKcb
   9090          
   9091              // EMERGENCY_PARSER (M108, M112, M410)
   9092              cap_line(PSTR("EMERGENCY_PARSER")
   9093                #if ENABLED(EMERGENCY_PARSER)
   9094                  , true
   9095                #endif
   9096              );
   \   00000070   0x2100             MOVS     R1,#+0
   \   00000072   0x4810             LDR.N    R0,??gcode_M115_0+0x38
   \   00000074   0xE8BD 0x4004      POP      {R2,LR}
   \   00000078   0x.... 0x....      B.W      _Z8cap_linePKcb
   \                     ??gcode_M115_0:
   \   0000007C   0x........         DC32     _ZZ10gcode_M115vEs
   \   00000080   0x........         DC32     _ZZ10gcode_M115vEs_0
   \   00000084   0x........         DC32     _ZZ10gcode_M115vEs_1
   \   00000088   0x........         DC32     _ZZ10gcode_M115vEs_2
   \   0000008C   0x........         DC32     _ZZ10gcode_M115vEs_3
   \   00000090   0x........         DC32     _ZZ10gcode_M115vEs_4
   \   00000094   0x........         DC32     _ZZ10gcode_M115vEs_5
   \   00000098   0x........         DC32     _ZZ10gcode_M115vEs_6
   \   0000009C   0x........         DC32     _ZZ10gcode_M115vEs_7
   \   000000A0   0x........         DC32     _ZZ10gcode_M115vEs_8
   \   000000A4   0x........         DC32     _ZZ10gcode_M115vEs_9
   \   000000A8   0x........         DC32     _ZZ10gcode_M115vEs__10_
   \   000000AC   0x........         DC32     _ZZ10gcode_M115vEs__11_
   \   000000B0   0x........         DC32     _ZZ10gcode_M115vEs__12_
   \   000000B4   0x........         DC32     _ZZ10gcode_M115vEs__13_
   9097          
   9098            #endif // EXTENDED_CAPABILITIES_REPORT
   9099          }
   9100          
   9101          /**
   9102           * M117: Set LCD Status Message
   9103           */

   \                                 In section .text, align 4
   9104          inline void gcode_M117() { lcd_setstatus(parser.string_arg); }
   \                     _Z10gcode_M117v: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x4802             LDR.N    R0,??gcode_M117_0
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x.... 0x....      B.W      _Z13lcd_setstatusPKcb
   \   0000000A   0xBF00             Nop      
   \                     ??gcode_M117_0:
   \   0000000C   0x........         DC32     _ZN11GCodeParser10string_argE
   9105          
   9106          /**
   9107           * M118: Display a message in the host console.
   9108           *
   9109           *  A1  Append '// ' for an action command, as in OctoPrint
   9110           *  E1  Have the host 'echo:' the text
   9111           */

   \                                 In section .text, align 4
   9112          inline void gcode_M118() {
   \                     _Z10gcode_M118v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   9113            if (parser.boolval('E')) SERIAL_ECHO_START();
   \   00000002   0x2045             MOVS     R0,#+69
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser7boolvalEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD002             BEQ.N    ??gcode_M118_0
   \   0000000C   0x480B             LDR.N    R0,??gcode_M118_1
   \   0000000E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9114            if (parser.boolval('A')) SERIAL_ECHOPGM("// ");
   \                     ??gcode_M118_0: (+1)
   \   00000012   0x2041             MOVS     R0,#+65
   \   00000014   0x.... 0x....      BL       _ZN11GCodeParser7boolvalEc
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD002             BEQ.N    ??gcode_M118_2
   \   0000001C   0x4808             LDR.N    R0,??gcode_M118_1+0x4
   \   0000001E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9115            SERIAL_ECHOLN(parser.string_arg);
   \                     ??gcode_M118_2: (+1)
   \   00000022   0x4C08             LDR.N    R4,??gcode_M118_1+0x8
   \   00000024   0x4808             LDR.N    R0,??gcode_M118_1+0xC
   \   00000026   0x6801             LDR      R1,[R0, #+0]
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   0000002E   0x210A             MOVS     R1,#+10
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0xE8BD 0x4010      POP      {R4,LR}
   \   00000036   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   \   0000003A   0xBF00             Nop      
   \                     ??gcode_M118_1:
   \   0000003C   0x........         DC32     echomagic
   \   00000040   0x........         DC32     _ZZ10gcode_M118vEs
   \   00000044   0x........         DC32     Serial6
   \   00000048   0x........         DC32     _ZN11GCodeParser10string_argE
   9116          }
   9117          
   9118          /**
   9119           * M119: Output endstop states to serial output
   9120           */

   \                                 In section .text, align 2
   9121          inline void gcode_M119() { endstops.M119(); }
   \                     _Z10gcode_M119v: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN8Endstops4M119Ev
   9122          
   9123          /**
   9124           * M120: Enable endstops and set non-homing endstop state to "enabled"
   9125           */

   \                                 In section .text, align 2
   9126          inline void gcode_M120() { endstops.enable_globally(true); }
   \                     _Z10gcode_M120v: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x.... 0x....      B.W      _ZN8Endstops15enable_globallyEb
   9127          
   9128          /**
   9129           * M121: Disable endstops and set non-homing endstop state to "disabled"
   9130           */

   \                                 In section .text, align 2
   9131          inline void gcode_M121() { endstops.enable_globally(false); }
   \                     _Z10gcode_M121v: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x.... 0x....      B.W      _ZN8Endstops15enable_globallyEb
   9132          
   9133          #if ENABLED(PARK_HEAD_ON_PAUSE)
   9134          
   9135            /**
   9136             * M125: Store current position and move to filament change position.
   9137             *       Called on pause (by M25) to prevent material leaking onto the
   9138             *       object. On resume (M24) the head will be moved back and the
   9139             *       print will resume.
   9140             *
   9141             *       If Marlin is compiled without SD Card support, M125 can be
   9142             *       used directly to pause the print and move to park position,
   9143             *       resuming with a button click or M108.
   9144             *
   9145             *    L = override retract length
   9146             *    X = override X
   9147             *    Y = override Y
   9148             *    Z = override Z raise
   9149             */
   9150            inline void gcode_M125() {
   9151          
   9152              // Initial retract before move to filament change position
   9153              const float retract = parser.seen('L') ? parser.value_axis_units(E_AXIS) : 0
   9154                #ifdef PAUSE_PARK_RETRACT_LENGTH
   9155                  - (PAUSE_PARK_RETRACT_LENGTH)
   9156                #endif
   9157              ;
   9158          
   9159              point_t park_point = NOZZLE_PARK_POINT;
   9160          
   9161              // Move XY axes to filament change position or given position
   9162              if (parser.seenval('X')) park_point.x = parser.linearval('X');
   9163              if (parser.seenval('Y')) park_point.y = parser.linearval('Y');
   9164          
   9165              // Lift Z axis
   9166              if (parser.seenval('Z')) park_point.z = parser.linearval('Z');
   9167          
   9168              #if HOTENDS > 1 && DISABLED(DUAL_X_CARRIAGE)
   9169                park_point.x += (active_extruder ? hotend_offset[X_AXIS][active_extruder] : 0);
   9170                park_point.y += (active_extruder ? hotend_offset[Y_AXIS][active_extruder] : 0);
   9171              #endif
   9172          
   9173              #if DISABLED(SDSUPPORT)
   9174                const bool job_running = print_job_timer.isRunning();
   9175              #endif
   9176          
   9177              if (pause_print(retract, park_point)) {
   9178                #if DISABLED(SDSUPPORT)
   9179                  // Wait for lcd click or M108
   9180                  wait_for_filament_reload();
   9181          
   9182                  // Return to print position and continue
   9183                  resume_print();
   9184          
   9185                  if (job_running) print_job_timer.start();
   9186                #endif
   9187              }
   9188            }
   9189          
   9190          #endif // PARK_HEAD_ON_PAUSE
   9191          
   9192          #if HAS_COLOR_LEDS
   9193          
   9194            /**
   9195             * M150: Set Status LED Color - Use R-U-B-W for R-G-B-W
   9196             *       and Brightness       - Use P (for NEOPIXEL only)
   9197             *
   9198             * Always sets all 3 or 4 components. If a component is left out, set to 0.
   9199             *                                    If brightness is left out, no value changed
   9200             *
   9201             * Examples:
   9202             *
   9203             *   M150 R255       ; Turn LED red
   9204             *   M150 R255 U127  ; Turn LED orange (PWM only)
   9205             *   M150            ; Turn LED off
   9206             *   M150 R U B      ; Turn LED white
   9207             *   M150 W          ; Turn LED white using a white LED
   9208             *   M150 P127       ; Set LED 50% brightness
   9209             *   M150 P          ; Set LED full brightness
   9210             */
   9211            inline void gcode_M150() {
   9212              leds.set_color(MakeLEDColor(
   9213                parser.seen('R') ? (parser.has_value() ? parser.value_byte() : 255) : 0,
   9214                parser.seen('U') ? (parser.has_value() ? parser.value_byte() : 255) : 0,
   9215                parser.seen('B') ? (parser.has_value() ? parser.value_byte() : 255) : 0,
   9216                parser.seen('W') ? (parser.has_value() ? parser.value_byte() : 255) : 0,
   9217                parser.seen('P') ? (parser.has_value() ? parser.value_byte() : 255) : pixels.getBrightness()
   9218              ));
   9219            }
   9220          
   9221          #endif // HAS_COLOR_LEDS
   9222          
   9223          #if DISABLED(NO_VOLUMETRICS)
   9224          
   9225            /**
   9226             * M200: Set filament diameter and set E axis units to cubic units
   9227             *
   9228             *    T<extruder> - Optional extruder number. Current extruder if omitted.
   9229             *    D<linear> - Diameter of the filament. Use "D0" to switch back to linear units on the E axis.
   9230             */

   \                                 In section .text, align 4
   9231            inline void gcode_M200() {
   \                     _Z10gcode_M200v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   9232          
   9233              if (get_target_extruder_from_command(200)) return;
   \   00000004   0x20C8             MOVS     R0,#+200
   \   00000006   0x.... 0x....      BL       _Z32get_target_extruder_from_commandt
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD11F             BNE.N    ??gcode_M200_0
   9234          
   9235              if (parser.seen('D')) {
   \   0000000E   0x2044             MOVS     R0,#+68
   \   00000010   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD018             BEQ.N    ??gcode_M200_1
   9236                // setting any extruder filament size disables volumetric on the assumption that
   9237                // slicers either generate in extruder values as cubic mm or as as filament feeds
   9238                // for all extruders
   9239                if ( (parser.volumetric_enabled = (parser.value_linear_units() != 0.0)) )
   \   00000018   0x4C0D             LDR.N    R4,??gcode_M200_2
   \   0000001A   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   0000001E   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   00000022   0xEEF1 0xFA10      FMSTAT   
   \   00000026   0xD002             BEQ.N    ??gcode_M200_3
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x7020             STRB     R0,[R4, #+0]
   \   0000002C   0xE001             B.N      ??gcode_M200_4
   \                     ??gcode_M200_3: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x7020             STRB     R0,[R4, #+0]
   \                     ??gcode_M200_4: (+1)
   \   00000032   0x7820             LDRB     R0,[R4, #+0]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD008             BEQ.N    ??gcode_M200_1
   9240                  planner.set_filament_size(target_extruder, parser.value_linear_units());
   \   00000038   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   0000003C   0xED8D 0x0A00      VSTR     S0,[SP, #+0]
   \   00000040   0xA900             ADD      R1,SP,#+0
   \   00000042   0x4804             LDR.N    R0,??gcode_M200_2+0x4
   \   00000044   0x7D80             LDRB     R0,[R0, #+22]
   \   00000046   0x.... 0x....      BL       _ZN7Planner17set_filament_sizeEhRKf
   9241              }
   9242              planner.calculate_volumetric_multipliers();
   \                     ??gcode_M200_1: (+1)
   \   0000004A   0x.... 0x....      BL       _ZN7Planner32calculate_volumetric_multipliersEv
   9243            }
   \                     ??gcode_M200_0: (+1)
   \   0000004E   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   \                     ??gcode_M200_2:
   \   00000050   0x........         DC32     _ZN11GCodeParser18volumetric_enabledE
   \   00000054   0x........         DC32     axis_relative_modes
   9244          
   9245          #endif // !NO_VOLUMETRICS
   9246          
   9247          /**
   9248           * M201: Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)
   9249           *
   9250           *       With multiple extruders use T to specify which one.
   9251           */

   \                                 In section .text, align 4
   9252          inline void gcode_M201() {
   \                     _Z10gcode_M201v: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   9253          
   9254            GET_TARGET_EXTRUDER(201);
   9255          
   9256            LOOP_XYZE(i) {
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0xE012             B.N      ??gcode_M201_0
   9257              if (parser.seen(axis_codes[i])) {
   \                     ??gcode_M201_1: (+1)
   \   00000006   0x480C             LDR.N    R0,??gcode_M201_2
   \   00000008   0x5620             LDRSB    R0,[R4, R0]
   \   0000000A   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD00B             BEQ.N    ??gcode_M201_3
   \   00000012   0x4625             MOV      R5,R4
   9258                const uint8_t a = i + (i == E_AXIS ? TARGET_EXTRUDER : 0);
   9259                planner.max_acceleration_mm_per_s2[a] = parser.value_axis_units((AxisEnum)a);
                                                             ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   00000014   0x4628             MOV      R0,R5
   \   00000016   0xB240             SXTB     R0,R0
   \   00000018   0x.... 0x....      BL       _ZN11GCodeParser16value_axis_unitsE8AxisEnum
   \   0000001C   0xEEBC 0x0AC0      VCVT.U32.F32 S0,S0
   \   00000020   0x4806             LDR.N    R0,??gcode_M201_2+0x4
   \   00000022   0xEB00 0x0085      ADD      R0,R0,R5, LSL #+2
   \   00000026   0xED80 0x0A00      VSTR     S0,[R0, #0]
   9260              }
   9261            }
   \                     ??gcode_M201_3: (+1)
   \   0000002A   0x1C64             ADDS     R4,R4,#+1
   \                     ??gcode_M201_0: (+1)
   \   0000002C   0x2C04             CMP      R4,#+4
   \   0000002E   0xDBEA             BLT.N    ??gcode_M201_1
   9262            // steps per sq second need to be updated to agree with the units per sq second (as they are what is used in the planner)
   9263            planner.reset_acceleration_rates();
   \   00000030   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000034   0x.... 0x....      B.W      _ZN7Planner24reset_acceleration_ratesEv
   \                     ??gcode_M201_2:
   \   00000038   0x........         DC32     axis_codes
   \   0000003C   0x........         DC32     _ZN7Planner26max_acceleration_mm_per_s2E
   9264          }
   9265          
   9266          #if 0 // Not used for Sprinter/grbl gen6
   9267            inline void gcode_M202() {
   9268              LOOP_XYZE(i) {
   9269                if (parser.seen(axis_codes[i])) axis_travel_steps_per_sqr_second[i] = parser.value_axis_units((AxisEnum)i) * planner.axis_steps_per_mm[i];
   9270              }
   9271            }
   9272          #endif
   9273          
   9274          
   9275          /**
   9276           * M203: Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in units/sec
   9277           *
   9278           *       With multiple extruders use T to specify which one.
   9279           */

   \                                 In section .text, align 4
   9280          inline void gcode_M203() {
   \                     _Z10gcode_M203v: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   9281          
   9282            GET_TARGET_EXTRUDER(203);
   9283          
   9284            LOOP_XYZE(i)
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0xE010             B.N      ??gcode_M203_0
   9285              if (parser.seen(axis_codes[i])) {
   \                     ??gcode_M203_1: (+1)
   \   00000006   0x480A             LDR.N    R0,??gcode_M203_2
   \   00000008   0x5620             LDRSB    R0,[R4, R0]
   \   0000000A   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD009             BEQ.N    ??gcode_M203_3
   \   00000012   0x4625             MOV      R5,R4
   9286                const uint8_t a = i + (i == E_AXIS ? TARGET_EXTRUDER : 0);
   9287                planner.max_feedrate_mm_s[a] = parser.value_axis_units((AxisEnum)a);
   \   00000014   0x4628             MOV      R0,R5
   \   00000016   0xB240             SXTB     R0,R0
   \   00000018   0x.... 0x....      BL       _ZN11GCodeParser16value_axis_unitsE8AxisEnum
   \   0000001C   0x4805             LDR.N    R0,??gcode_M203_2+0x4
   \   0000001E   0xEB00 0x0085      ADD      R0,R0,R5, LSL #+2
   \   00000022   0xED80 0x0A00      VSTR     S0,[R0, #0]
   9288              }
   \                     ??gcode_M203_3: (+1)
   \   00000026   0x1C64             ADDS     R4,R4,#+1
   \                     ??gcode_M203_0: (+1)
   \   00000028   0x2C04             CMP      R4,#+4
   \   0000002A   0xDBEC             BLT.N    ??gcode_M203_1
   9289          }
   \   0000002C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \   0000002E   0xBF00             Nop      
   \                     ??gcode_M203_2:
   \   00000030   0x........         DC32     axis_codes
   \   00000034   0x........         DC32     _ZN7Planner17max_feedrate_mm_sE
   9290          
   9291          /**
   9292           * M204: Set Accelerations in units/sec^2 (M204 P1200 R3000 T3000)
   9293           *
   9294           *    P = Printing moves
   9295           *    R = Retract only (no X, Y, Z) moves
   9296           *    T = Travel (non printing) moves
   9297           *
   9298           *  Also sets minimum segment time in ms (B20000) to prevent buffer under-runs and M20 minimum feedrate
   9299           */

   \                                 In section .text, align 4
   9300          inline void gcode_M204() {
   \                     _Z10gcode_M204v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   9301            if (parser.seen('S')) {  // Kept for legacy compatibility. Should NOT BE USED for new developments.
   \   00000002   0x2053             MOVS     R0,#+83
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD00E             BEQ.N    ??gcode_M204_0
   9302              planner.travel_acceleration = planner.acceleration = parser.value_linear_units();
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000010   0x4821             LDR.N    R0,??gcode_M204_1
   \   00000012   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   00000016   0x4821             LDR.N    R0,??gcode_M204_1+0x4
   \   00000018   0xED80 0x0A00      VSTR     S0,[R0, #0]
   9303              SERIAL_ECHOLNPAIR("Setting Print and Travel Acceleration: ", planner.acceleration);
   \   0000001C   0x4820             LDR.N    R0,??gcode_M204_1+0x8
   \   0000001E   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   00000022   0x210A             MOVS     R1,#+10
   \   00000024   0x481F             LDR.N    R0,??gcode_M204_1+0xC
   \   00000026   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   9304            }
   9305            if (parser.seen('P')) {
   \                     ??gcode_M204_0: (+1)
   \   0000002A   0x2050             MOVS     R0,#+80
   \   0000002C   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD00B             BEQ.N    ??gcode_M204_2
   9306              planner.acceleration = parser.value_linear_units();
   \   00000034   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000038   0x4817             LDR.N    R0,??gcode_M204_1
   \   0000003A   0xED80 0x0A00      VSTR     S0,[R0, #0]
   9307              SERIAL_ECHOLNPAIR("Setting Print Acceleration: ", planner.acceleration);
   \   0000003E   0x481A             LDR.N    R0,??gcode_M204_1+0x10
   \   00000040   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   00000044   0x210A             MOVS     R1,#+10
   \   00000046   0x4817             LDR.N    R0,??gcode_M204_1+0xC
   \   00000048   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   9308            }
   9309            if (parser.seen('R')) {
   \                     ??gcode_M204_2: (+1)
   \   0000004C   0x2052             MOVS     R0,#+82
   \   0000004E   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD00B             BEQ.N    ??gcode_M204_3
   9310              planner.retract_acceleration = parser.value_linear_units();
   \   00000056   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   0000005A   0x4814             LDR.N    R0,??gcode_M204_1+0x14
   \   0000005C   0xED80 0x0A00      VSTR     S0,[R0, #0]
   9311              SERIAL_ECHOLNPAIR("Setting Retract Acceleration: ", planner.retract_acceleration);
   \   00000060   0x4813             LDR.N    R0,??gcode_M204_1+0x18
   \   00000062   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   00000066   0x210A             MOVS     R1,#+10
   \   00000068   0x480E             LDR.N    R0,??gcode_M204_1+0xC
   \   0000006A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   9312            }
   9313            if (parser.seen('T')) {
   \                     ??gcode_M204_3: (+1)
   \   0000006E   0x2054             MOVS     R0,#+84
   \   00000070   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD00D             BEQ.N    ??gcode_M204_4
   9314              planner.travel_acceleration = parser.value_linear_units();
   \   00000078   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   0000007C   0x4807             LDR.N    R0,??gcode_M204_1+0x4
   \   0000007E   0xED80 0x0A00      VSTR     S0,[R0, #0]
   9315              SERIAL_ECHOLNPAIR("Setting Travel Acceleration: ", planner.travel_acceleration);
   \   00000082   0x480C             LDR.N    R0,??gcode_M204_1+0x1C
   \   00000084   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   00000088   0x210A             MOVS     R1,#+10
   \   0000008A   0x4806             LDR.N    R0,??gcode_M204_1+0xC
   \   0000008C   0xE8BD 0x4004      POP      {R2,LR}
   \   00000090   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   9316            }
   9317          }
   \                     ??gcode_M204_4: (+1)
   \   00000094   0xBD01             POP      {R0,PC}          ;; return
   \   00000096   0xBF00             Nop      
   \                     ??gcode_M204_1:
   \   00000098   0x........         DC32     _ZN7Planner12accelerationE
   \   0000009C   0x........         DC32     _ZN7Planner19travel_accelerationE
   \   000000A0   0x........         DC32     _ZZ10gcode_M204vEs
   \   000000A4   0x........         DC32     Serial6
   \   000000A8   0x........         DC32     _ZZ10gcode_M204vEs_0
   \   000000AC   0x........         DC32     _ZN7Planner20retract_accelerationE
   \   000000B0   0x........         DC32     _ZZ10gcode_M204vEs_1
   \   000000B4   0x........         DC32     _ZZ10gcode_M204vEs_2
   9318          
   9319          /**
   9320           * M205: Set Advanced Settings
   9321           *
   9322           *    S = Min Feed Rate (units/s)
   9323           *    T = Min Travel Feed Rate (units/s)
   9324           *    B = Min Segment Time (Âµs)
   9325           *    X = Max X Jerk (units/sec^2)
   9326           *    Y = Max Y Jerk (units/sec^2)
   9327           *    Z = Max Z Jerk (units/sec^2)
   9328           *    E = Max E Jerk (units/sec^2)
   9329           */

   \                                 In section .text, align 4
   9330          inline void gcode_M205() {
   \                     _Z10gcode_M205v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   9331            if (parser.seen('S')) planner.min_feedrate_mm_s = parser.value_linear_units();
   \   00000002   0x2053             MOVS     R0,#+83
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD004             BEQ.N    ??gcode_M205_0
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000010   0x481F             LDR.N    R0,??gcode_M205_1
   \   00000012   0xED80 0x0A00      VSTR     S0,[R0, #0]
   9332            if (parser.seen('T')) planner.min_travel_feedrate_mm_s = parser.value_linear_units();
   \                     ??gcode_M205_0: (+1)
   \   00000016   0x2054             MOVS     R0,#+84
   \   00000018   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD004             BEQ.N    ??gcode_M205_2
   \   00000020   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000024   0x481B             LDR.N    R0,??gcode_M205_1+0x4
   \   00000026   0xED80 0x0A00      VSTR     S0,[R0, #0]
   9333            if (parser.seen('B')) planner.min_segment_time_us = parser.value_ulong();
   \                     ??gcode_M205_2: (+1)
   \   0000002A   0x2042             MOVS     R0,#+66
   \   0000002C   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD003             BEQ.N    ??gcode_M205_3
   \   00000034   0x.... 0x....      BL       _ZN11GCodeParser11value_ulongEv
   \   00000038   0x4917             LDR.N    R1,??gcode_M205_1+0x8
   \   0000003A   0x6008             STR      R0,[R1, #+0]
   9334            if (parser.seen('X')) planner.max_jerk[X_AXIS] = parser.value_linear_units();
   \                     ??gcode_M205_3: (+1)
   \   0000003C   0x2058             MOVS     R0,#+88
   \   0000003E   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD004             BEQ.N    ??gcode_M205_4
   \   00000046   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   0000004A   0x4814             LDR.N    R0,??gcode_M205_1+0xC
   \   0000004C   0xED80 0x0A00      VSTR     S0,[R0, #0]
   9335            if (parser.seen('Y')) planner.max_jerk[Y_AXIS] = parser.value_linear_units();
   \                     ??gcode_M205_4: (+1)
   \   00000050   0x2059             MOVS     R0,#+89
   \   00000052   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD004             BEQ.N    ??gcode_M205_5
   \   0000005A   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   0000005E   0x480F             LDR.N    R0,??gcode_M205_1+0xC
   \   00000060   0xED80 0x0A01      VSTR     S0,[R0, #+4]
   9336            if (parser.seen('Z')) planner.max_jerk[Z_AXIS] = parser.value_linear_units();
   \                     ??gcode_M205_5: (+1)
   \   00000064   0x205A             MOVS     R0,#+90
   \   00000066   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD004             BEQ.N    ??gcode_M205_6
   \   0000006E   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000072   0x480A             LDR.N    R0,??gcode_M205_1+0xC
   \   00000074   0xED80 0x0A02      VSTR     S0,[R0, #+8]
   9337            if (parser.seen('E')) planner.max_jerk[E_AXIS] = parser.value_linear_units();
   \                     ??gcode_M205_6: (+1)
   \   00000078   0x2045             MOVS     R0,#+69
   \   0000007A   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD004             BEQ.N    ??gcode_M205_7
   \   00000082   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000086   0x4805             LDR.N    R0,??gcode_M205_1+0xC
   \   00000088   0xED80 0x0A03      VSTR     S0,[R0, #+12]
   9338          }
   \                     ??gcode_M205_7: (+1)
   \   0000008C   0xBD01             POP      {R0,PC}          ;; return
   \   0000008E   0xBF00             Nop      
   \                     ??gcode_M205_1:
   \   00000090   0x........         DC32     _ZN7Planner17min_feedrate_mm_sE
   \   00000094   0x........         DC32     _ZN7Planner24min_travel_feedrate_mm_sE
   \   00000098   0x........         DC32     _ZN7Planner19min_segment_time_usE
   \   0000009C   0x........         DC32     _ZN7Planner8max_jerkE
   9339          
   9340          #if HAS_M206_COMMAND
   9341          
   9342            /**
   9343             * M206: Set Additional Homing Offset (X Y Z). SCARA aliases T=X, P=Y
   9344             *
   9345             * *** @thinkyhead: I recommend deprecating M206 for SCARA in favor of M665.
   9346             * ***              M206 for SCARA will remain enabled in 1.1.x for compatibility.
   9347             * ***              In the next 1.2 release, it will simply be disabled by default.
   9348             */

   \                                 In section .text, align 4
   9349            inline void gcode_M206() {
   \                     _Z10gcode_M206v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   9350              LOOP_XYZ(i)
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0xE00C             B.N      ??gcode_M206_0
   9351                if (parser.seen(axis_codes[i]))
   \                     ??gcode_M206_1: (+1)
   \   00000006   0x4809             LDR.N    R0,??gcode_M206_2
   \   00000008   0x5620             LDRSB    R0,[R4, R0]
   \   0000000A   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD005             BEQ.N    ??gcode_M206_3
   9352                  set_home_offset((AxisEnum)i, parser.value_linear_units());
   \   00000012   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0xB240             SXTB     R0,R0
   \   0000001A   0x.... 0x....      BL       _Z15set_home_offset8AxisEnumf
   \                     ??gcode_M206_3: (+1)
   \   0000001E   0x1C64             ADDS     R4,R4,#+1
   \                     ??gcode_M206_0: (+1)
   \   00000020   0x2C03             CMP      R4,#+3
   \   00000022   0xDBF0             BLT.N    ??gcode_M206_1
   9353          
   9354              #if ENABLED(MORGAN_SCARA)
   9355                if (parser.seen('T')) set_home_offset(A_AXIS, parser.value_float()); // Theta
   9356                if (parser.seen('P')) set_home_offset(B_AXIS, parser.value_float()); // Psi
   9357              #endif
   9358          
   9359              report_current_position();
   \   00000024   0xE8BD 0x4010      POP      {R4,LR}
   \   00000028   0x.... 0x....      B.W      _Z23report_current_positionv
   \                     ??gcode_M206_2:
   \   0000002C   0x........         DC32     axis_codes
   9360            }
   9361          
   9362          #endif // HAS_M206_COMMAND
   9363          
   9364          #if ENABLED(DELTA)
   9365            /**
   9366             * M665: Set delta configurations
   9367             *
   9368             *    H = delta height
   9369             *    L = diagonal rod
   9370             *    R = delta radius
   9371             *    S = segments per second
   9372             *    B = delta calibration radius
   9373             *    X = Alpha (Tower 1) angle trim
   9374             *    Y = Beta (Tower 2) angle trim
   9375             *    Z = Rotate A and B by this angle
   9376             */
   9377            inline void gcode_M665() {
   9378              if (parser.seen('H')) delta_height                   = parser.value_linear_units();
   9379              if (parser.seen('L')) delta_diagonal_rod             = parser.value_linear_units();
   9380              if (parser.seen('R')) delta_radius                   = parser.value_linear_units();
   9381              if (parser.seen('S')) delta_segments_per_second      = parser.value_float();
   9382              if (parser.seen('B')) delta_calibration_radius       = parser.value_float();
   9383              if (parser.seen('X')) delta_tower_angle_trim[A_AXIS] = parser.value_float();
   9384              if (parser.seen('Y')) delta_tower_angle_trim[B_AXIS] = parser.value_float();
   9385              if (parser.seen('Z')) delta_tower_angle_trim[C_AXIS] = parser.value_float();
   9386              recalc_delta_settings();
   9387            }
   9388            /**
   9389             * M666: Set delta endstop adjustment
   9390             */
   9391            inline void gcode_M666() {
   9392              #if ENABLED(DEBUG_LEVELING_FEATURE)
   9393                if (DEBUGGING(LEVELING)) {
   9394                  SERIAL_ECHOLNPGM(">>> gcode_M666");
   9395                }
   9396              #endif
   9397              LOOP_XYZ(i) {
   9398                if (parser.seen(axis_codes[i])) {
   9399                  if (parser.value_linear_units() * Z_HOME_DIR <= 0)
   9400                    delta_endstop_adj[i] = parser.value_linear_units();
   9401                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   9402                    if (DEBUGGING(LEVELING)) {
   9403                      SERIAL_ECHOPAIR("delta_endstop_adj[", axis_codes[i]);
   9404                      SERIAL_ECHOLNPAIR("] = ", delta_endstop_adj[i]);
   9405                    }
   9406                  #endif
   9407                }
   9408              }
   9409              #if ENABLED(DEBUG_LEVELING_FEATURE)
   9410                if (DEBUGGING(LEVELING)) {
   9411                  SERIAL_ECHOLNPGM("<<< gcode_M666");
   9412                }
   9413              #endif
   9414            }
   9415          
   9416          #elif IS_SCARA
   9417          
   9418            /**
   9419             * M665: Set SCARA settings
   9420             *
   9421             * Parameters:
   9422             *
   9423             *   S[segments-per-second] - Segments-per-second
   9424             *   P[theta-psi-offset]    - Theta-Psi offset, added to the shoulder (A/X) angle
   9425             *   T[theta-offset]        - Theta     offset, added to the elbow    (B/Y) angle
   9426             *
   9427             *   A, P, and X are all aliases for the shoulder angle
   9428             *   B, T, and Y are all aliases for the elbow angle
   9429             */
   9430            inline void gcode_M665() {
   9431              if (parser.seen('S')) delta_segments_per_second = parser.value_float();
   9432          
   9433              const bool hasA = parser.seen('A'), hasP = parser.seen('P'), hasX = parser.seen('X');
   9434              const uint8_t sumAPX = hasA + hasP + hasX;
   9435              if (sumAPX == 1)
   9436                home_offset[A_AXIS] = parser.value_float();
   9437              else if (sumAPX > 1) {
   9438                SERIAL_ERROR_START();
   9439                SERIAL_ERRORLNPGM("Only one of A, P, or X is allowed.");
   9440                return;
   9441              }
   9442          
   9443              const bool hasB = parser.seen('B'), hasT = parser.seen('T'), hasY = parser.seen('Y');
   9444              const uint8_t sumBTY = hasB + hasT + hasY;
   9445              if (sumBTY == 1)
   9446                home_offset[B_AXIS] = parser.value_float();
   9447              else if (sumBTY > 1) {
   9448                SERIAL_ERROR_START();
   9449                SERIAL_ERRORLNPGM("Only one of B, T, or Y is allowed.");
   9450                return;
   9451              }
   9452            }
   9453          
   9454          
   9455          
   9456          #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
   9457          
   9458            /**
   9459             * M666: For Z Dual Endstop setup, set z axis offset to the z2 axis.
   9460             */
   9461            inline void gcode_M666() {
   9462              SERIAL_ECHOPGM("Dual Endstop Adjustment (mm): ");
   9463              #if ENABLED(X_DUAL_ENDSTOPS)
   9464                if (parser.seen('X')) x_endstop_adj = parser.value_linear_units();
   9465                SERIAL_ECHOPAIR(" X", x_endstop_adj);
   9466              #endif
   9467              #if ENABLED(Y_DUAL_ENDSTOPS)
   9468                if (parser.seen('Y')) y_endstop_adj = parser.value_linear_units();
   9469                SERIAL_ECHOPAIR(" Y", y_endstop_adj);
   9470              #endif
   9471              #if ENABLED(Z_DUAL_ENDSTOPS)
   9472                if (parser.seen('Z')) z_endstop_adj = parser.value_linear_units();
   9473                SERIAL_ECHOPAIR(" Z", z_endstop_adj);
   9474              #endif
   9475              SERIAL_EOL();
   9476            }
   9477          
   9478          #endif // !DELTA && Z_DUAL_ENDSTOPS
   9479          
   9480          #if ENABLED(FWRETRACT)
   9481          
   9482            /**
   9483             * M207: Set firmware retraction values
   9484             *
   9485             *   S[+units]    retract_length
   9486             *   W[+units]    swap_retract_length (multi-extruder)
   9487             *   F[units/min] retract_feedrate_mm_s
   9488             *   Z[units]     retract_zlift
   9489             */
   9490            inline void gcode_M207() {
   9491              if (parser.seen('S')) retract_length = parser.value_axis_units(E_AXIS);
   9492              if (parser.seen('F')) retract_feedrate_mm_s = MMM_TO_MMS(parser.value_axis_units(E_AXIS));
   9493              if (parser.seen('Z')) retract_zlift = parser.value_linear_units();
   9494              if (parser.seen('W')) swap_retract_length = parser.value_axis_units(E_AXIS);
   9495            }
   9496          
   9497            /**
   9498             * M208: Set firmware un-retraction values
   9499             *
   9500             *   S[+units]    retract_recover_length (in addition to M207 S*)
   9501             *   W[+units]    swap_retract_recover_length (multi-extruder)
   9502             *   F[units/min] retract_recover_feedrate_mm_s
   9503             *   R[units/min] swap_retract_recover_feedrate_mm_s
   9504             */
   9505            inline void gcode_M208() {
   9506              if (parser.seen('S')) retract_recover_length = parser.value_axis_units(E_AXIS);
   9507              if (parser.seen('F')) retract_recover_feedrate_mm_s = MMM_TO_MMS(parser.value_axis_units(E_AXIS));
   9508              if (parser.seen('R')) swap_retract_recover_feedrate_mm_s = MMM_TO_MMS(parser.value_axis_units(E_AXIS));
   9509              if (parser.seen('W')) swap_retract_recover_length = parser.value_axis_units(E_AXIS);
   9510            }
   9511          
   9512            /**
   9513             * M209: Enable automatic retract (M209 S1)
   9514             *   For slicers that don't support G10/11, reversed extrude-only
   9515             *   moves will be classified as retraction.
   9516             */
   9517            inline void gcode_M209() {
   9518              if (MIN_AUTORETRACT <= MAX_AUTORETRACT) {
   9519                if (parser.seen('S')) {
   9520                  autoretract_enabled = parser.value_bool();
   9521                  for (uint8_t i = 0; i < EXTRUDERS; i++) retracted[i] = false;
   9522                }
   9523              }
   9524            }
   9525          
   9526          #endif // FWRETRACT
   9527          
   9528          /**
   9529           * M211: Enable, Disable, and/or Report software endstops
   9530           *
   9531           * Usage: M211 S1 to enable, M211 S0 to disable, M211 alone for report
   9532           */

   \                                 In section .text, align 4
   9533          inline void gcode_M211() {
   \                     _Z10gcode_M211v: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   9534            SERIAL_ECHO_START();
   \   00000002   0x482E             LDR.N    R0,??gcode_M211_0
   \   00000004   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9535            #if HAS_SOFTWARE_ENDSTOPS
   9536              if (parser.seen('S')) soft_endstops_enabled = parser.value_bool();
   \   00000008   0x4C2D             LDR.N    R4,??gcode_M211_0+0x4
   \   0000000A   0x2053             MOVS     R0,#+83
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD002             BEQ.N    ??gcode_M211_1
   \   00000014   0x.... 0x....      BL       _ZN11GCodeParser10value_boolEv
   \   00000018   0x7020             STRB     R0,[R4, #+0]
   9537              SERIAL_ECHOPGM(MSG_SOFT_ENDSTOPS);
   \                     ??gcode_M211_1: (+1)
   \   0000001A   0x482A             LDR.N    R0,??gcode_M211_0+0x8
   \   0000001C   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9538              serialprintPGM(soft_endstops_enabled ? PSTR(MSG_ON) : PSTR(MSG_OFF));
   \   00000020   0x7820             LDRB     R0,[R4, #+0]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD001             BEQ.N    ??gcode_M211_2
   \   00000026   0x4828             LDR.N    R0,??gcode_M211_0+0xC
   \   00000028   0xE000             B.N      ??gcode_M211_3
   \                     ??gcode_M211_2: (+1)
   \   0000002A   0x4828             LDR.N    R0,??gcode_M211_0+0x10
   \                     ??gcode_M211_3: (+1)
   \   0000002C   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9539            #else
   9540              SERIAL_ECHOPGM(MSG_SOFT_ENDSTOPS);
   9541              SERIAL_ECHOPGM(MSG_OFF);
   9542            #endif
   9543            SERIAL_ECHOPGM(MSG_SOFT_MIN);
   \   00000030   0x4827             LDR.N    R0,??gcode_M211_0+0x14
   \   00000032   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9544            SERIAL_ECHOPAIR(    MSG_X, LOGICAL_X_POSITION(soft_endstop_min[X_AXIS]));
   \   00000036   0x4D27             LDR.N    R5,??gcode_M211_0+0x18
   \   00000038   0xED94 0x0A04      VLDR     S0,[R4, #+16]
   \   0000003C   0xEDD4 0x0A01      VLDR     S1,[R4, #+4]
   \   00000040   0xEE30 0x0A20      VADD.F32 S0,S0,S1
   \   00000044   0x4628             MOV      R0,R5
   \   00000046   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   9545            SERIAL_ECHOPAIR(" " MSG_Y, LOGICAL_Y_POSITION(soft_endstop_min[Y_AXIS]));
   \   0000004A   0x4E23             LDR.N    R6,??gcode_M211_0+0x1C
   \   0000004C   0xED94 0x0A05      VLDR     S0,[R4, #+20]
   \   00000050   0xEDD4 0x0A02      VLDR     S1,[R4, #+8]
   \   00000054   0xEE30 0x0A20      VADD.F32 S0,S0,S1
   \   00000058   0x4630             MOV      R0,R6
   \   0000005A   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   9546            SERIAL_ECHOPAIR(" " MSG_Z, LOGICAL_Z_POSITION(soft_endstop_min[Z_AXIS]));
   \   0000005E   0x4F1F             LDR.N    R7,??gcode_M211_0+0x20
   \   00000060   0xED94 0x0A06      VLDR     S0,[R4, #+24]
   \   00000064   0xEDD4 0x0A03      VLDR     S1,[R4, #+12]
   \   00000068   0xEE30 0x0A20      VADD.F32 S0,S0,S1
   \   0000006C   0x4638             MOV      R0,R7
   \   0000006E   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   9547            SERIAL_ECHOPGM(MSG_SOFT_MAX);
   \   00000072   0x481B             LDR.N    R0,??gcode_M211_0+0x24
   \   00000074   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9548            SERIAL_ECHOPAIR(    MSG_X, LOGICAL_X_POSITION(soft_endstop_max[X_AXIS]));
   \   00000078   0xED94 0x0A07      VLDR     S0,[R4, #+28]
   \   0000007C   0xEDD4 0x0A01      VLDR     S1,[R4, #+4]
   \   00000080   0xEE30 0x0A20      VADD.F32 S0,S0,S1
   \   00000084   0x4628             MOV      R0,R5
   \   00000086   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   9549            SERIAL_ECHOPAIR(" " MSG_Y, LOGICAL_Y_POSITION(soft_endstop_max[Y_AXIS]));
   \   0000008A   0xED94 0x0A08      VLDR     S0,[R4, #+32]
   \   0000008E   0xEDD4 0x0A02      VLDR     S1,[R4, #+8]
   \   00000092   0xEE30 0x0A20      VADD.F32 S0,S0,S1
   \   00000096   0x4630             MOV      R0,R6
   \   00000098   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   9550            SERIAL_ECHOLNPAIR(" " MSG_Z, LOGICAL_Z_POSITION(soft_endstop_max[Z_AXIS]));
   \   0000009C   0xED94 0x0A09      VLDR     S0,[R4, #+36]
   \   000000A0   0xEDD4 0x0A03      VLDR     S1,[R4, #+12]
   \   000000A4   0xEE30 0x0A20      VADD.F32 S0,S0,S1
   \   000000A8   0x4638             MOV      R0,R7
   \   000000AA   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   000000AE   0x210A             MOVS     R1,#+10
   \   000000B0   0x480C             LDR.N    R0,??gcode_M211_0+0x28
   \   000000B2   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \   000000B6   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   \   000000BA   0xBF00             Nop      
   \                     ??gcode_M211_0:
   \   000000BC   0x........         DC32     echomagic
   \   000000C0   0x........         DC32     soft_endstops_enabled
   \   000000C4   0x........         DC32     _ZZ10gcode_M211vEs
   \   000000C8   0x........         DC32     _ZZ10gcode_M211vEs_0
   \   000000CC   0x........         DC32     _ZZ10gcode_M211vEs_1
   \   000000D0   0x........         DC32     _ZZ10gcode_M211vEs_2
   \   000000D4   0x........         DC32     _ZZ10gcode_M211vEs_3
   \   000000D8   0x........         DC32     _ZZ10gcode_M211vEs_4
   \   000000DC   0x........         DC32     _ZZ10gcode_M211vEs_5
   \   000000E0   0x........         DC32     _ZZ10gcode_M211vEs_6
   \   000000E4   0x........         DC32     Serial6
   9551          }
   9552          
   9553          #if HOTENDS > 1
   9554          
   9555            /**
   9556             * M218 - set hotend offset (in linear units)
   9557             *
   9558             *   T<tool>
   9559             *   X<xoffset>
   9560             *   Y<yoffset>
   9561             *   Z<zoffset> - Available with DUAL_X_CARRIAGE and SWITCHING_NOZZLE
   9562             */
   9563            inline void gcode_M218() {
   9564              if (get_target_extruder_from_command(218) || target_extruder == 0) return;
   9565          
   9566              if (parser.seenval('X')) hotend_offset[X_AXIS][target_extruder] = parser.value_linear_units();
   9567              if (parser.seenval('Y')) hotend_offset[Y_AXIS][target_extruder] = parser.value_linear_units();
   9568          
   9569              #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
   9570                if (parser.seenval('Z')) hotend_offset[Z_AXIS][target_extruder] = parser.value_linear_units();
   9571              #endif
   9572          
   9573              SERIAL_ECHO_START();
   9574              SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
   9575              HOTEND_LOOP() {
   9576                SERIAL_CHAR(' ');
   9577                SERIAL_ECHO(hotend_offset[X_AXIS][e]);
   9578                SERIAL_CHAR(',');
   9579                SERIAL_ECHO(hotend_offset[Y_AXIS][e]);
   9580                #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
   9581                  SERIAL_CHAR(',');
   9582                  SERIAL_ECHO(hotend_offset[Z_AXIS][e]);
   9583                #endif
   9584              }
   9585              SERIAL_EOL();
   9586            }
   9587          
   9588          #endif // HOTENDS > 1
   9589          
   9590          /**
   9591           * M220: Set speed percentage factor, aka "Feed Rate" (M220 S95)
   9592           */

   \                                 In section .text, align 4
   9593          inline void gcode_M220() {
   \                     _Z10gcode_M220v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   9594            if (parser.seenval('S')) feedrate_percentage = parser.value_int();
   \   00000002   0x2053             MOVS     R0,#+83
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD003             BEQ.N    ??gcode_M220_0
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser9value_intEv
   \   00000010   0x4901             LDR.N    R1,??gcode_M220_1
   \   00000012   0x8408             STRH     R0,[R1, #+32]
   9595          }
   \                     ??gcode_M220_0: (+1)
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
   \   00000016   0xBF00             Nop      
   \                     ??gcode_M220_1:
   \   00000018   0x........         DC32     axis_relative_modes
   9596          
   9597          /**
   9598           * M221: Set extrusion percentage (M221 T0 S95)
   9599           */

   \                                 In section .text, align 4
   9600          inline void gcode_M221() {
   \                     _Z10gcode_M221v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   9601            if (get_target_extruder_from_command(221)) return;
   \   00000002   0x20DD             MOVS     R0,#+221
   \   00000004   0x.... 0x....      BL       _Z32get_target_extruder_from_commandt
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD110             BNE.N    ??gcode_M221_0
   9602            if (parser.seenval('S')) {
   \   0000000C   0x2053             MOVS     R0,#+83
   \   0000000E   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD00B             BEQ.N    ??gcode_M221_0
   9603              planner.flow_percentage[target_extruder] = parser.value_int();
   \   00000016   0x.... 0x....      BL       _ZN11GCodeParser9value_intEv
   \   0000001A   0x4905             LDR.N    R1,??gcode_M221_1
   \   0000001C   0x7D89             LDRB     R1,[R1, #+22]
   \   0000001E   0x4A05             LDR.N    R2,??gcode_M221_1+0x4
   \   00000020   0xF822 0x0011      STRH     R0,[R2, R1, LSL #+1]
   9604              planner.refresh_e_factor(target_extruder);
   \   00000024   0x4608             MOV      R0,R1
   \   00000026   0xE8BD 0x4002      POP      {R1,LR}
   \   0000002A   0x.... 0x....      B.W      _ZN7Planner16refresh_e_factorEh
   9605            }
   9606          }
   \                     ??gcode_M221_0: (+1)
   \   0000002E   0xBD01             POP      {R0,PC}          ;; return
   \                     ??gcode_M221_1:
   \   00000030   0x........         DC32     axis_relative_modes
   \   00000034   0x........         DC32     _ZN7Planner15flow_percentageE
   9607          
   9608          /**
   9609           * M226: Wait until the specified pin reaches the state required (M226 P<pin> S<state>)
   9610           */

   \                                 In section .text, align 4
   9611          inline void gcode_M226() {
   \                     _Z10gcode_M226v: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   9612            if (parser.seen('P')) {
   \   00000002   0x2050             MOVS     R0,#+80
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD03E             BEQ.N    ??gcode_M226_0
   9613              const int pin_number = parser.value_int(),
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser9value_intEv
   \   00000010   0x4604             MOV      R4,R0
   9614                        pin_state = parser.intval('S', -1); // required pin state - default is inverted
   \   00000012   0xF04F 0x31FF      MOV      R1,#-1
   \   00000016   0x2053             MOVS     R0,#+83
   \   00000018   0x.... 0x....      BL       _ZN11GCodeParser6intvalEcs
   \   0000001C   0x4605             MOV      R5,R0
   9615          
   9616              if (WITHIN(pin_state, -1, 1) && pin_number > -1 && !pin_is_protected(pin_number)) {
   \   0000001E   0x1C68             ADDS     R0,R5,#+1
   \   00000020   0x2803             CMP      R0,#+3
   \   00000022   0xD232             BCS.N    ??gcode_M226_0
   \   00000024   0x2C00             CMP      R4,#+0
   \   00000026   0xD430             BMI.N    ??gcode_M226_0
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0xB240             SXTB     R0,R0
   \   0000002C   0x.... 0x....      BL       _Z16pin_is_protecteda
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD12A             BNE.N    ??gcode_M226_0
   9617          
   9618                int target = LOW;
   \   00000034   0x2600             MOVS     R6,#+0
   9619          
   9620                stepper.synchronize();
   \   00000036   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   9621          
   9622                pinMode(pin_number, INPUT);
   9623                switch (pin_state) {
   \   0000003A   0x2D01             CMP      R5,#+1
   \   0000003C   0xD003             BEQ.N    ??gcode_M226_1
   \   0000003E   0xF1B5 0x3FFF      CMP      R5,#-1
   \   00000042   0xD002             BEQ.N    ??gcode_M226_2
   \   00000044   0xE00F             B.N      ??gcode_M226_3
   9624                  case 1:
   9625                    target = HIGH;
   \                     ??gcode_M226_1: (+1)
   \   00000046   0x2601             MOVS     R6,#+1
   9626                    break;
   \   00000048   0xE00D             B.N      ??gcode_M226_3
   9627                  case 0:
   9628                    target = LOW;
   9629                    break;
   9630                  case -1:
   9631                    target = !digitalRead(pin_number);
   \                     ??gcode_M226_2: (+1)
   \   0000004A   0x2C00             CMP      R4,#+0
   \   0000004C   0xD50B             BPL.N    ??gcode_M226_3
   \   0000004E   0x480F             LDR.N    R0,??gcode_M226_4
   \   00000050   0xF830 0x1014      LDRH     R1,[R0, R4, LSL #+1]
   \   00000054   0x480E             LDR.N    R0,??gcode_M226_4+0x4
   \   00000056   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000005A   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   0000005E   0x4606             MOV      R6,R0
   \   00000060   0xE001             B.N      ??gcode_M226_3
   9632                    break;
   9633                }
   9634          
   9635                while (digitalRead(pin_number) != target) idle();
   \                     ??gcode_M226_5: (+1)
   \   00000062   0x.... 0x....      BL       _Z4idlev
   \                     ??gcode_M226_3: (+1)
   \   00000066   0x2C00             CMP      R4,#+0
   \   00000068   0xD408             BMI.N    ??gcode_M226_6
   \   0000006A   0x4808             LDR.N    R0,??gcode_M226_4
   \   0000006C   0xF830 0x1014      LDRH     R1,[R0, R4, LSL #+1]
   \   00000070   0x4807             LDR.N    R0,??gcode_M226_4+0x4
   \   00000072   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000076   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   0000007A   0xE004             B.N      ??gcode_M226_7
   \                     ??gcode_M226_6: (+1)
   \   0000007C   0x4630             MOV      R0,R6
   \   0000007E   0x1E40             SUBS     R0,R0,#+1
   \   00000080   0x4180             SBCS     R0,R0,R0
   \   00000082   0x43C0             MVNS     R0,R0
   \   00000084   0x0FC0             LSRS     R0,R0,#+31
   \                     ??gcode_M226_7: (+1)
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD1EB             BNE.N    ??gcode_M226_5
   9636          
   9637              } // pin_state -1 0 1 && pin_number > -1
   9638            } // parser.seen('P')
   9639          }
   \                     ??gcode_M226_0: (+1)
   \   0000008A   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??gcode_M226_4:
   \   0000008C   0x........         DC32     gArrayGpioPin
   \   00000090   0x........         DC32     gArrayGpioPort
   9640          
   9641          #if ENABLED(EXPERIMENTAL_I2CBUS)
   9642          
   9643            /**
   9644             * M260: Send data to a I2C slave device
   9645             *
   9646             * This is a PoC, the formating and arguments for the GCODE will
   9647             * change to be more compatible, the current proposal is:
   9648             *
   9649             *  M260 A<slave device address base 10> ; Sets the I2C slave address the data will be sent to
   9650             *
   9651             *  M260 B<byte-1 value in base 10>
   9652             *  M260 B<byte-2 value in base 10>
   9653             *  M260 B<byte-3 value in base 10>
   9654             *
   9655             *  M260 S1 ; Send the buffered data and reset the buffer
   9656             *  M260 R1 ; Reset the buffer without sending data
   9657             *
   9658             */
   9659            inline void gcode_M260() {
   9660              // Set the target address
   9661              if (parser.seen('A')) i2c.address(parser.value_byte());
   9662          
   9663              // Add a new byte to the buffer
   9664              if (parser.seen('B')) i2c.addbyte(parser.value_byte());
   9665          
   9666              // Flush the buffer to the bus
   9667              if (parser.seen('S')) i2c.send();
   9668          
   9669              // Reset and rewind the buffer
   9670              else if (parser.seen('R')) i2c.reset();
   9671            }
   9672          
   9673            /**
   9674             * M261: Request X bytes from I2C slave device
   9675             *
   9676             * Usage: M261 A<slave device address base 10> B<number of bytes>
   9677             */
   9678            inline void gcode_M261() {
   9679              if (parser.seen('A')) i2c.address(parser.value_byte());
   9680          
   9681              uint8_t bytes = parser.byteval('B', 1);
   9682          
   9683              if (i2c.addr && bytes && bytes <= TWIBUS_BUFFER_SIZE) {
   9684                i2c.relay(bytes);
   9685              }
   9686              else {
   9687                SERIAL_ERROR_START();
   9688                SERIAL_ERRORLN("Bad i2c request");
   9689              }
   9690            }
   9691          
   9692          #endif // EXPERIMENTAL_I2CBUS
   9693          
   9694          #if HAS_SERVOS
   9695          
   9696            /**
   9697             * M280: Get or set servo position. P<index> [S<angle>]
   9698             */
   9699            inline void gcode_M280() {
   9700              if (!parser.seen('P')) return;
   9701              const int servo_index = parser.value_int();
   9702              if (WITHIN(servo_index, 0, NUM_SERVOS - 1)) {
   9703                if (parser.seen('S'))
   9704                  MOVE_SERVO(servo_index, parser.value_int());
   9705                else {
   9706                  SERIAL_ECHO_START();
   9707                  SERIAL_ECHOPAIR(" Servo ", servo_index);
   9708                  SERIAL_ECHOLNPAIR(": ", servo[servo_index].read());
   9709                }
   9710              }
   9711              else {
   9712                SERIAL_ERROR_START();
   9713                SERIAL_ECHOPAIR("Servo ", servo_index);
   9714                SERIAL_ECHOLNPGM(" out of range");
   9715              }
   9716            }
   9717          
   9718          #endif // HAS_SERVOS
   9719          
   9720          #if ENABLED(BABYSTEPPING)
   9721          
   9722            #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
   9723              FORCE_INLINE void mod_zprobe_zoffset(const float &offs) {
   9724                zprobe_zoffset += offs;
   9725                SERIAL_ECHO_START();
   9726                SERIAL_ECHOLNPAIR(MSG_PROBE_Z_OFFSET ": ", zprobe_zoffset);
   9727              }
   9728            #endif
   9729          
   9730            /**
   9731             * M290: Babystepping
   9732             */
   9733            inline void gcode_M290() {
   9734              #if ENABLED(BABYSTEP_XY)
   9735                for (uint8_t a = X_AXIS; a <= Z_AXIS; a++)
   9736                  if (parser.seenval(axis_codes[a]) || (a == Z_AXIS && parser.seenval('S'))) {
   9737                    const float offs = constrain(parser.value_axis_units((AxisEnum)a), -2, 2);
   9738                    thermalManager.babystep_axis((AxisEnum)a, offs * planner.axis_steps_per_mm[a]);
   9739                    #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
   9740                      if (a == Z_AXIS && (!parser.seen('P') || parser.value_bool())) mod_zprobe_zoffset(offs);
   9741                    #endif
   9742                  }
   9743              #else
   9744                if (parser.seenval('Z') || parser.seenval('S')) {
   9745                  const float offs = constrain(parser.value_axis_units(Z_AXIS), -2, 2);
   9746                  thermalManager.babystep_axis(Z_AXIS, offs * planner.axis_steps_per_mm[Z_AXIS]);
   9747                  #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
   9748                    if (!parser.seen('P') || parser.value_bool()) mod_zprobe_zoffset(offs);
   9749                  #endif
   9750                }
   9751              #endif
   9752            }
   9753          
   9754          #endif // BABYSTEPPING
   9755          
   9756          #if HAS_BUZZER
   9757          
   9758            /**
   9759             * M300: Play beep sound S<frequency Hz> P<duration ms>
   9760             */
   9761            inline void gcode_M300() {
   9762              uint16_t const frequency = parser.ushortval('S', 260);
   9763              uint16_t duration = parser.ushortval('P', 1000);
   9764          
   9765              // Limits the tone duration to 0-5 seconds.
   9766              NOMORE(duration, 5000);
   9767          
   9768              BUZZ(duration, frequency);
   9769            }
   9770          
   9771          #endif // HAS_BUZZER
   9772          
   9773          #if ENABLED(PIDTEMP)
   9774          
   9775            /**
   9776             * M301: Set PID parameters P I D (and optionally C, L)
   9777             *
   9778             *   P[float] Kp term
   9779             *   I[float] Ki term (unscaled)
   9780             *   D[float] Kd term (unscaled)
   9781             *
   9782             * With PID_EXTRUSION_SCALING:
   9783             *
   9784             *   C[float] Kc term
   9785             *   L[float] LPQ length
   9786             */

   \                                 In section .text, align 4
   9787            inline void gcode_M301() {
   \                     _Z10gcode_M301v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   9788          
   9789              // multi-extruder PID patch: M301 updates or prints a single extruder's PID values
   9790              // default behaviour (omitting E parameter) is to update for extruder 0 only
   9791              const uint8_t e = parser.byteval('E'); // extruder being updated
   9792          
   9793              if (e < HOTENDS) { // catch bad input value
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x2045             MOVS     R0,#+69
   \   00000006   0x.... 0x....      BL       _ZN11GCodeParser7bytevalEch
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD159             BNE.N    ??gcode_M301_0
   9794                if (parser.seen('P')) PID_PARAM(Kp, e) = parser.value_float();
   \   0000000E   0x2050             MOVS     R0,#+80
   \   00000010   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD004             BEQ.N    ??gcode_M301_1
   \   00000018   0x.... 0x....      BL       _ZN11GCodeParser11value_floatEv
   \   0000001C   0x4830             LDR.N    R0,??gcode_M301_2
   \   0000001E   0xED80 0x0A00      VSTR     S0,[R0, #0]
   9795                if (parser.seen('I')) PID_PARAM(Ki, e) = scalePID_i(parser.value_float());
   \                     ??gcode_M301_1: (+1)
   \   00000022   0x2049             MOVS     R0,#+73
   \   00000024   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD00D             BEQ.N    ??gcode_M301_3
   \   0000002C   0x.... 0x....      BL       _ZN11GCodeParser11value_floatEv
   \   00000030   0xEE10 0x0A10      VMOV     R0,S0
   \   00000034   0x.... 0x....      BL       __aeabi_f2d
   \   00000038   0x4A2A             LDR.N    R2,??gcode_M301_2+0x4  ;; 0x88e368f1
   \   0000003A   0x4B2B             LDR.N    R3,??gcode_M301_2+0x8  ;; 0x3fc4f8b5
   \   0000003C   0x.... 0x....      BL       __aeabi_dmul
   \   00000040   0x.... 0x....      BL       __aeabi_d2f
   \   00000044   0x4929             LDR.N    R1,??gcode_M301_2+0xC
   \   00000046   0x6008             STR      R0,[R1, #+0]
   9796                if (parser.seen('D')) PID_PARAM(Kd, e) = scalePID_d(parser.value_float());
   \                     ??gcode_M301_3: (+1)
   \   00000048   0x4C29             LDR.N    R4,??gcode_M301_2+0x10
   \   0000004A   0x2044             MOVS     R0,#+68
   \   0000004C   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD00C             BEQ.N    ??gcode_M301_4
   \   00000054   0x.... 0x....      BL       _ZN11GCodeParser11value_floatEv
   \   00000058   0xEE10 0x0A10      VMOV     R0,S0
   \   0000005C   0x.... 0x....      BL       __aeabi_f2d
   \   00000060   0x4A20             LDR.N    R2,??gcode_M301_2+0x4  ;; 0x88e368f1
   \   00000062   0x4B21             LDR.N    R3,??gcode_M301_2+0x8  ;; 0x3fc4f8b5
   \   00000064   0x.... 0x....      BL       __aeabi_ddiv
   \   00000068   0x.... 0x....      BL       __aeabi_d2f
   \   0000006C   0x6020             STR      R0,[R4, #+0]
   9797                #if ENABLED(PID_EXTRUSION_SCALING)
   9798                  if (parser.seen('C')) PID_PARAM(Kc, e) = parser.value_float();
   9799                  if (parser.seen('L')) lpq_len = parser.value_float();
   9800                  NOMORE(lpq_len, LPQ_MAX_LEN);
   9801                #endif
   9802          
   9803                thermalManager.updatePID();
   \                     ??gcode_M301_4: (+1)
   \   0000006E   0x.... 0x....      BL       _ZN11Temperature9updatePIDEv
   9804                SERIAL_ECHO_START();
   \   00000072   0x4820             LDR.N    R0,??gcode_M301_2+0x14
   \   00000074   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9805                #if ENABLED(PID_PARAMS_PER_HOTEND)
   9806                  SERIAL_ECHOPAIR(" e:", e); // specify extruder in serial output
   9807                #endif // PID_PARAMS_PER_HOTEND
   9808                SERIAL_ECHOPAIR(" p:", PID_PARAM(Kp, e));
   \   00000078   0x4819             LDR.N    R0,??gcode_M301_2
   \   0000007A   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   0000007E   0x481E             LDR.N    R0,??gcode_M301_2+0x18
   \   00000080   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   9809                SERIAL_ECHOPAIR(" i:", unscalePID_i(PID_PARAM(Ki, e)));
   \   00000084   0x4819             LDR.N    R0,??gcode_M301_2+0xC
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0x.... 0x....      BL       __aeabi_f2d
   \   0000008C   0x4A15             LDR.N    R2,??gcode_M301_2+0x4  ;; 0x88e368f1
   \   0000008E   0x4B16             LDR.N    R3,??gcode_M301_2+0x8  ;; 0x3fc4f8b5
   \   00000090   0x.... 0x....      BL       __aeabi_ddiv
   \   00000094   0xEC41 0x0B10      VMOV     D0,R0,R1
   \   00000098   0x4818             LDR.N    R0,??gcode_M301_2+0x1C
   \   0000009A   0x.... 0x....      BL       _Z17serial_echopair_PPKcd
   9810                SERIAL_ECHOPAIR(" d:", unscalePID_d(PID_PARAM(Kd, e)));
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0x.... 0x....      BL       __aeabi_f2d
   \   000000A4   0x4A0F             LDR.N    R2,??gcode_M301_2+0x4  ;; 0x88e368f1
   \   000000A6   0x4B10             LDR.N    R3,??gcode_M301_2+0x8  ;; 0x3fc4f8b5
   \   000000A8   0x.... 0x....      BL       __aeabi_dmul
   \   000000AC   0xEC41 0x0B10      VMOV     D0,R0,R1
   \   000000B0   0x4813             LDR.N    R0,??gcode_M301_2+0x20
   \   000000B2   0x.... 0x....      BL       _Z17serial_echopair_PPKcd
   9811                #if ENABLED(PID_EXTRUSION_SCALING)
   9812                  //Kc does not have scaling applied above, or in resetting defaults
   9813                  SERIAL_ECHOPAIR(" c:", PID_PARAM(Kc, e));
   9814                #endif
   9815                SERIAL_EOL();
   \   000000B6   0x210A             MOVS     R1,#+10
   \   000000B8   0x4812             LDR.N    R0,??gcode_M301_2+0x24
   \   000000BA   0xE8BD 0x4010      POP      {R4,LR}
   \   000000BE   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   9816              }
   9817              else {
   9818                SERIAL_ERROR_START();
   \                     ??gcode_M301_0: (+1)
   \   000000C2   0x4811             LDR.N    R0,??gcode_M301_2+0x28
   \   000000C4   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9819                SERIAL_ERRORLN(MSG_INVALID_EXTRUDER);
   \   000000C8   0x4C0E             LDR.N    R4,??gcode_M301_2+0x24
   \   000000CA   0x4910             LDR.N    R1,??gcode_M301_2+0x2C
   \   000000CC   0x4620             MOV      R0,R4
   \   000000CE   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   000000D2   0x210A             MOVS     R1,#+10
   \   000000D4   0x4620             MOV      R0,R4
   \   000000D6   0xE8BD 0x4010      POP      {R4,LR}
   \   000000DA   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   \   000000DE   0xBF00             Nop      
   \                     ??gcode_M301_2:
   \   000000E0   0x........         DC32     _ZN11Temperature2KpE
   \   000000E4   0x88E368F1         DC32     0x88e368f1
   \   000000E8   0x3FC4F8B5         DC32     0x3fc4f8b5
   \   000000EC   0x........         DC32     _ZN11Temperature2KiE
   \   000000F0   0x........         DC32     _ZN11Temperature2KdE
   \   000000F4   0x........         DC32     echomagic
   \   000000F8   0x........         DC32     _ZZ10gcode_M301vEs
   \   000000FC   0x........         DC32     _ZZ10gcode_M301vEs_0
   \   00000100   0x........         DC32     _ZZ10gcode_M301vEs_1
   \   00000104   0x........         DC32     Serial6
   \   00000108   0x........         DC32     errormagic
   \   0000010C   0x........         DC32     _ZZ10gcode_M301vEs_2
   9820              }
   9821            }
   9822          
   9823          #endif // PIDTEMP
   9824          
   9825          #if ENABLED(PIDTEMPBED)
   9826          
   9827            inline void gcode_M304() {
   9828              if (parser.seen('P')) thermalManager.bedKp = parser.value_float();
   9829              if (parser.seen('I')) thermalManager.bedKi = scalePID_i(parser.value_float());
   9830              if (parser.seen('D')) thermalManager.bedKd = scalePID_d(parser.value_float());
   9831          
   9832              SERIAL_ECHO_START();
   9833              SERIAL_ECHOPAIR(" p:", thermalManager.bedKp);
   9834              SERIAL_ECHOPAIR(" i:", unscalePID_i(thermalManager.bedKi));
   9835              SERIAL_ECHOLNPAIR(" d:", unscalePID_d(thermalManager.bedKd));
   9836            }
   9837          
   9838          #endif // PIDTEMPBED
   9839          
   9840          #if defined(CHDK) || HAS_PHOTOGRAPH
   9841          
   9842            /**
   9843             * M240: Trigger a camera by emulating a Canon RC-1
   9844             *       See http://www.doc-diy.net/photo/rc-1_hacked/
   9845             */
   9846            inline void gcode_M240() {
   9847              #ifdef CHDK
   9848          
   9849                OUT_WRITE(CHDK, HIGH);
   9850                chdkHigh = millis();
   9851                chdkActive = true;
   9852          
   9853              #elif HAS_PHOTOGRAPH
   9854          
   9855                const uint8_t NUM_PULSES = 16;
   9856                const float PULSE_LENGTH = 0.01524;
   9857                for (int i = 0; i < NUM_PULSES; i++) {
   9858                  WRITE(PHOTOGRAPH_PIN, HIGH);
   9859                  _delay_ms(PULSE_LENGTH);
   9860                  WRITE(PHOTOGRAPH_PIN, LOW);
   9861                  _delay_ms(PULSE_LENGTH);
   9862                }
   9863                delay(7.33);
   9864                for (int i = 0; i < NUM_PULSES; i++) {
   9865                  WRITE(PHOTOGRAPH_PIN, HIGH);
   9866                  _delay_ms(PULSE_LENGTH);
   9867                  WRITE(PHOTOGRAPH_PIN, LOW);
   9868                  _delay_ms(PULSE_LENGTH);
   9869                }
   9870          
   9871              #endif // !CHDK && HAS_PHOTOGRAPH
   9872            }
   9873          
   9874          #endif // CHDK || PHOTOGRAPH_PIN
   9875          
   9876          #if HAS_LCD_CONTRAST
   9877          
   9878            /**
   9879             * M250: Read and optionally set the LCD contrast
   9880             */
   9881            inline void gcode_M250() {
   9882              if (parser.seen('C')) set_lcd_contrast(parser.value_int());
   9883              SERIAL_PROTOCOLPGM("lcd contrast value: ");
   9884              SERIAL_PROTOCOL(lcd_contrast);
   9885              SERIAL_EOL();
   9886            }
   9887          
   9888          #endif // HAS_LCD_CONTRAST
   9889          
   9890          #if ENABLED(PREVENT_COLD_EXTRUSION)
   9891          
   9892            /**
   9893             * M302: Allow cold extrudes, or set the minimum extrude temperature
   9894             *
   9895             *       S<temperature> sets the minimum extrude temperature
   9896             *       P<bool> enables (1) or disables (0) cold extrusion
   9897             *
   9898             *  Examples:
   9899             *
   9900             *       M302         ; report current cold extrusion state
   9901             *       M302 P0      ; enable cold extrusion checking
   9902             *       M302 P1      ; disables cold extrusion checking
   9903             *       M302 S0      ; always allow extrusion (disables checking)
   9904             *       M302 S170    ; only allow extrusion above 170
   9905             *       M302 S170 P1 ; set min extrude temp to 170 but leave disabled
   9906             */
   9907            inline void gcode_M302() {
   9908              const bool seen_S = parser.seen('S');
   9909              if (seen_S) {
   9910                thermalManager.extrude_min_temp = parser.value_celsius();
   9911                thermalManager.allow_cold_extrude = (thermalManager.extrude_min_temp == 0);
   9912              }
   9913          
   9914              if (parser.seen('P'))
   9915                thermalManager.allow_cold_extrude = (thermalManager.extrude_min_temp == 0) || parser.value_bool();
   9916              else if (!seen_S) {
   9917                // Report current state
   9918                SERIAL_ECHO_START();
   9919                SERIAL_ECHOPAIR("Cold extrudes are ", (thermalManager.allow_cold_extrude ? "en" : "dis"));
   9920                SERIAL_ECHOPAIR("abled (min temp ", thermalManager.extrude_min_temp);
   9921                SERIAL_ECHOLNPGM("C)");
   9922              }
   9923            }
   9924          
   9925          #endif // PREVENT_COLD_EXTRUSION
   9926          
   9927          /**
   9928           * M303: PID relay autotune
   9929           *
   9930           *       S<temperature> sets the target temperature. (default 150C)
   9931           *       E<extruder> (-1 for the bed) (default 0)
   9932           *       C<cycles>
   9933           *       U<bool> with a non-zero value will apply the result to current settings
   9934           */

   \                                 In section .text, align 4
   9935          inline void gcode_M303() {
   \                     _Z10gcode_M303v: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   9936            #if HAS_PID_HEATING
   9937              const int e = parser.intval('E'), c = parser.intval('C', 5);
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x2045             MOVS     R0,#+69
   \   00000006   0x.... 0x....      BL       _ZN11GCodeParser6intvalEcs
   \   0000000A   0x4604             MOV      R4,R0
   \   0000000C   0x2105             MOVS     R1,#+5
   \   0000000E   0x2043             MOVS     R0,#+67
   \   00000010   0x.... 0x....      BL       _ZN11GCodeParser6intvalEcs
   \   00000014   0x4605             MOV      R5,R0
   9938              const bool u = parser.boolval('U');
   \   00000016   0x2055             MOVS     R0,#+85
   \   00000018   0x.... 0x....      BL       _ZN11GCodeParser7boolvalEc
   \   0000001C   0x4606             MOV      R6,R0
   9939          
   9940              int16_t temp = parser.celsiusval('S', e < 0 ? 70 : 150);
                                    ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD502             BPL.N    ??gcode_M303_0
   \   00000022   0xED9F 0x0A10      VLDR.W   S0,??gcode_M303_1  ;; 0x46
   \   00000026   0xE001             B.N      ??gcode_M303_2
   \                     ??gcode_M303_0: (+1)
   \   00000028   0xED9F 0x0A0F      VLDR.W   S0,??gcode_M303_1+0x4  ;; 0x96
   \                     ??gcode_M303_2: (+1)
   \   0000002C   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000030   0x2053             MOVS     R0,#+83
   \   00000032   0x.... 0x....      BL       _ZN11GCodeParser10celsiusvalEcf
   \   00000036   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   0000003A   0xEE10 0x3A10      VMOV     R3,S0
   9941          
   9942              if (WITHIN(e, 0, HOTENDS - 1))
   \   0000003E   0x2C00             CMP      R4,#+0
   \   00000040   0xD102             BNE.N    ??gcode_M303_3
   9943                target_extruder = e;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x4909             LDR.N    R1,??gcode_M303_1+0x8
   \   00000046   0x7588             STRB     R0,[R1, #+22]
   9944          
   9945              #if DISABLED(BUSY_WHILE_HEATING)
   9946                KEEPALIVE_STATE(NOT_BUSY);
   9947              #endif
   9948          
   9949              thermalManager.PID_autotune(temp, e, c, u);
   \                     ??gcode_M303_3: (+1)
   \   00000048   0x4632             MOV      R2,R6
   \   0000004A   0x4629             MOV      R1,R5
   \   0000004C   0xB249             SXTB     R1,R1
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0xB240             SXTB     R0,R0
   \   00000052   0xB21B             SXTH     R3,R3
   \   00000054   0xEE00 0x3A10      VMOV     S0,R3
   \   00000058   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000005C   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000060   0x.... 0x....      B.W      _ZN11Temperature12PID_autotuneEfaab
   \                     ??gcode_M303_1:
   \   00000064   0x00000046         DC32     0x46
   \   00000068   0x00000096         DC32     0x96
   \   0000006C   0x........         DC32     axis_relative_modes
   9950          
   9951              #if DISABLED(BUSY_WHILE_HEATING)
   9952                KEEPALIVE_STATE(IN_HANDLER);
   9953              #endif
   9954            #else
   9955              SERIAL_ERROR_START();
   9956              SERIAL_ERRORLNPGM(MSG_ERR_M303_DISABLED);
   9957            #endif
   9958          }
   9959          
   9960          #if ENABLED(MORGAN_SCARA)
   9961          
   9962            bool SCARA_move_to_cal(const uint8_t delta_a, const uint8_t delta_b) {
   9963              if (IsRunning()) {
   9964                forward_kinematics_SCARA(delta_a, delta_b);
   9965                destination[X_AXIS] = cartes[X_AXIS];
   9966                destination[Y_AXIS] = cartes[Y_AXIS];
   9967                destination[Z_AXIS] = current_position[Z_AXIS];
   9968                prepare_move_to_destination();
   9969                return true;
   9970              }
   9971              return false;
   9972            }
   9973          
   9974            /**
   9975             * M360: SCARA calibration: Move to cal-position ThetaA (0 deg calibration)
   9976             */
   9977            inline bool gcode_M360() {
   9978              SERIAL_ECHOLNPGM(" Cal: Theta 0");
   9979              return SCARA_move_to_cal(0, 120);
   9980            }
   9981          
   9982            /**
   9983             * M361: SCARA calibration: Move to cal-position ThetaB (90 deg calibration - steps per degree)
   9984             */
   9985            inline bool gcode_M361() {
   9986              SERIAL_ECHOLNPGM(" Cal: Theta 90");
   9987              return SCARA_move_to_cal(90, 130);
   9988            }
   9989          
   9990            /**
   9991             * M362: SCARA calibration: Move to cal-position PsiA (0 deg calibration)
   9992             */
   9993            inline bool gcode_M362() {
   9994              SERIAL_ECHOLNPGM(" Cal: Psi 0");
   9995              return SCARA_move_to_cal(60, 180);
   9996            }
   9997          
   9998            /**
   9999             * M363: SCARA calibration: Move to cal-position PsiB (90 deg calibration - steps per degree)
  10000             */
  10001            inline bool gcode_M363() {
  10002              SERIAL_ECHOLNPGM(" Cal: Psi 90");
  10003              return SCARA_move_to_cal(50, 90);
  10004            }
  10005          
  10006            /**
  10007             * M364: SCARA calibration: Move to cal-position PsiC (90 deg to Theta calibration position)
  10008             */
  10009            inline bool gcode_M364() {
  10010              SERIAL_ECHOLNPGM(" Cal: Theta-Psi 90");
  10011              return SCARA_move_to_cal(45, 135);
  10012            }
  10013          
  10014          #endif // SCARA
  10015          
  10016          #if ENABLED(EXT_SOLENOID)
  10017          
  10018            void enable_solenoid(const uint8_t num) {
  10019              switch (num) {
  10020                case 0:
  10021                  OUT_WRITE(SOL0_PIN, HIGH);
  10022                  break;
  10023                  #if HAS_SOLENOID_1 && EXTRUDERS > 1
  10024                    case 1:
  10025                      OUT_WRITE(SOL1_PIN, HIGH);
  10026                      break;
  10027                  #endif
  10028                  #if HAS_SOLENOID_2 && EXTRUDERS > 2
  10029                    case 2:
  10030                      OUT_WRITE(SOL2_PIN, HIGH);
  10031                      break;
  10032                  #endif
  10033                  #if HAS_SOLENOID_3 && EXTRUDERS > 3
  10034                    case 3:
  10035                      OUT_WRITE(SOL3_PIN, HIGH);
  10036                      break;
  10037                  #endif
  10038                  #if HAS_SOLENOID_4 && EXTRUDERS > 4
  10039                    case 4:
  10040                      OUT_WRITE(SOL4_PIN, HIGH);
  10041                      break;
  10042                  #endif
  10043                default:
  10044                  SERIAL_ECHO_START();
  10045                  SERIAL_ECHOLNPGM(MSG_INVALID_SOLENOID);
  10046                  break;
  10047              }
  10048            }
  10049          
  10050            void enable_solenoid_on_active_extruder() { enable_solenoid(active_extruder); }
  10051          
  10052            void disable_all_solenoids() {
  10053              OUT_WRITE(SOL0_PIN, LOW);
  10054              #if HAS_SOLENOID_1 && EXTRUDERS > 1
  10055                OUT_WRITE(SOL1_PIN, LOW);
  10056              #endif
  10057              #if HAS_SOLENOID_2 && EXTRUDERS > 2
  10058                OUT_WRITE(SOL2_PIN, LOW);
  10059              #endif
  10060              #if HAS_SOLENOID_3 && EXTRUDERS > 3
  10061                OUT_WRITE(SOL3_PIN, LOW);
  10062              #endif
  10063              #if HAS_SOLENOID_4 && EXTRUDERS > 4
  10064                OUT_WRITE(SOL4_PIN, LOW);
  10065              #endif
  10066            }
  10067          
  10068            /**
  10069             * M380: Enable solenoid on the active extruder
  10070             */
  10071            inline void gcode_M380() { enable_solenoid_on_active_extruder(); }
  10072          
  10073            /**
  10074             * M381: Disable all solenoids
  10075             */
  10076            inline void gcode_M381() { disable_all_solenoids(); }
  10077          
  10078          #endif // EXT_SOLENOID
  10079          
  10080          /**
  10081           * M400: Finish all moves
  10082           */

   \                                 In section .text, align 2
  10083          inline void gcode_M400() { stepper.synchronize(); }
   \                     _Z10gcode_M400v: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN7Stepper11synchronizeEv
  10084          
  10085          #if HAS_BED_PROBE
  10086          
  10087            /**
  10088             * M401: Engage Z Servo endstop if available
  10089             */
  10090            inline void gcode_M401() { DEPLOY_PROBE(); }
  10091          
  10092            /**
  10093             * M402: Retract Z Servo endstop if enabled
  10094             */
  10095            inline void gcode_M402() { STOW_PROBE(); }
  10096          
  10097          #endif // HAS_BED_PROBE
  10098          
  10099          #if ENABLED(FILAMENT_WIDTH_SENSOR)
  10100          
  10101            /**
  10102             * M404: Display or set (in current units) the nominal filament width (3mm, 1.75mm ) W<3.0>
  10103             */
  10104            inline void gcode_M404() {
  10105              if (parser.seen('W')) {
  10106                filament_width_nominal = parser.value_linear_units();
  10107                planner.volumetric_area_nominal = CIRCLE_AREA(filament_width_nominal * 0.5);
  10108              }
  10109              else {
  10110                SERIAL_PROTOCOLPGM("Filament dia (nominal mm):");
  10111                SERIAL_PROTOCOLLN(filament_width_nominal);
  10112              }
  10113            }
  10114          
  10115            /**
  10116             * M405: Turn on filament sensor for control
  10117             */
  10118            inline void gcode_M405() {
  10119              // This is technically a linear measurement, but since it's quantized to centimeters and is a different
  10120              // unit than everything else, it uses parser.value_byte() instead of parser.value_linear_units().
  10121              if (parser.seen('D')) {
  10122                meas_delay_cm = parser.value_byte();
  10123                NOMORE(meas_delay_cm, MAX_MEASUREMENT_DELAY);
  10124              }
  10125          
  10126              if (filwidth_delay_index[1] == -1) { // Initialize the ring buffer if not done since startup
  10127                const int8_t temp_ratio = thermalManager.widthFil_to_size_ratio();
  10128          
  10129                for (uint8_t i = 0; i < COUNT(measurement_delay); ++i)
  10130                  measurement_delay[i] = temp_ratio;
  10131          
  10132                filwidth_delay_index[0] = filwidth_delay_index[1] = 0;
  10133              }
  10134          
  10135              filament_sensor = true;
  10136            }
  10137          
  10138            /**
  10139             * M406: Turn off filament sensor for control
  10140             */
  10141            inline void gcode_M406() {
  10142              filament_sensor = false;
  10143              planner.calculate_volumetric_multipliers();   // Restore correct 'volumetric_multiplier' value
  10144            }
  10145          
  10146            /**
  10147             * M407: Get measured filament diameter on serial output
  10148             */
  10149            inline void gcode_M407() {
  10150              SERIAL_PROTOCOLPGM("Filament dia (measured mm):");
  10151              SERIAL_PROTOCOLLN(filament_width_meas);
  10152            }
  10153          
  10154          #endif // FILAMENT_WIDTH_SENSOR
  10155          

   \                                 In section .text, align 2, keep-with-next
  10156          void quickstop_stepper() {
   \                     _Z17quickstop_stepperv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  10157            stepper.quick_stop();
   \   00000002   0x.... 0x....      BL       _ZN7Stepper10quick_stopEv
  10158            stepper.synchronize();
   \   00000006   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
  10159            set_current_from_steppers_for_axis(ALL_AXES);
   \   0000000A   0x2064             MOVS     R0,#+100
   \   0000000C   0x.... 0x....      BL       _Z34set_current_from_steppers_for_axis8AxisEnum
  10160            SYNC_PLAN_POSITION_KINEMATIC();
   \   00000010   0xE8BD 0x4001      POP      {R0,LR}
   \   00000014   0x....             B.N      _Z18sync_plan_positionv
  10161          }
  10162          
  10163          #if HAS_LEVELING
  10164            /**
  10165             * M420: Enable/Disable Bed Leveling and/or set the Z fade height.
  10166             *
  10167             *   S[bool]   Turns leveling on or off
  10168             *   Z[height] Sets the Z fade height (0 or none to disable)
  10169             *   V[bool]   Verbose - Print the leveling grid
  10170             *
  10171             * With AUTO_BED_LEVELING_UBL only:
  10172             *
  10173             *   L[index]  Load UBL mesh from index (0 is default)
  10174             */
  10175            inline void gcode_M420() {
  10176          
  10177              const float oldpos[] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] };
  10178          
  10179              #if ENABLED(AUTO_BED_LEVELING_UBL)
  10180          
  10181                // L to load a mesh from the EEPROM
  10182                if (parser.seen('L')) {
  10183          
  10184                  #if ENABLED(EEPROM_SETTINGS)
  10185                    const int8_t storage_slot = parser.has_value() ? parser.value_int() : ubl.storage_slot;
  10186                    const int16_t a = settings.calc_num_meshes();
  10187          
  10188                    if (!a) {
  10189                      SERIAL_PROTOCOLLNPGM("?EEPROM storage not available.");
  10190                      return;
  10191                    }
  10192          
  10193                    if (!WITHIN(storage_slot, 0, a - 1)) {
  10194                      SERIAL_PROTOCOLLNPGM("?Invalid storage slot.");
  10195                      SERIAL_PROTOCOLLNPAIR("?Use 0 to ", a - 1);
  10196                      return;
  10197                    }
  10198          
  10199                    settings.load_mesh(storage_slot);
  10200                    ubl.storage_slot = storage_slot;
  10201          
  10202                  #else
  10203          
  10204                    SERIAL_PROTOCOLLNPGM("?EEPROM storage not available.");
  10205                    return;
  10206          
  10207                  #endif
  10208                }
  10209          
  10210                // L to load a mesh from the EEPROM
  10211                if (parser.seen('L') || parser.seen('V')) {
  10212                  ubl.display_map(0);  // Currently only supports one map type
  10213                  SERIAL_ECHOLNPAIR("ubl.mesh_is_valid = ", ubl.mesh_is_valid());
  10214                  SERIAL_ECHOLNPAIR("ubl.storage_slot = ", ubl.storage_slot);
  10215                }
  10216          
  10217              #endif // AUTO_BED_LEVELING_UBL
  10218          
  10219              // V to print the matrix or mesh
  10220              if (parser.seen('V')) {
  10221                #if ABL_PLANAR
  10222                  planner.bed_level_matrix.debug(PSTR("Bed Level Correction Matrix:"));
  10223                #else
  10224                  if (leveling_is_valid()) {
  10225                    #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
  10226                      print_bilinear_leveling_grid();
  10227                      #if ENABLED(ABL_BILINEAR_SUBDIVISION)
  10228                        print_bilinear_leveling_grid_virt();
  10229                      #endif
  10230                    #elif ENABLED(MESH_BED_LEVELING)
  10231                      SERIAL_ECHOLNPGM("Mesh Bed Level data:");
  10232                      mbl_mesh_report();
  10233                    #endif
  10234                  }
  10235                #endif
  10236              }
  10237          
  10238              #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
  10239                if (parser.seen('Z')) set_z_fade_height(parser.value_linear_units(), false);
  10240              #endif
  10241          
  10242              bool to_enable = false;
  10243              if (parser.seen('S')) {
  10244                to_enable = parser.value_bool();
  10245                set_bed_leveling_enabled(to_enable);
  10246              }
  10247          
  10248              const bool new_status = planner.leveling_active;
  10249          
  10250              if (to_enable && !new_status) {
  10251                SERIAL_ERROR_START();
  10252                SERIAL_ERRORLNPGM(MSG_ERR_M420_FAILED);
  10253              }
  10254          
  10255              SERIAL_ECHO_START();
  10256              SERIAL_ECHOLNPAIR("Bed Leveling ", new_status ? MSG_ON : MSG_OFF);
  10257          
  10258              #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
  10259                SERIAL_ECHO_START();
  10260                SERIAL_ECHOPGM("Fade Height ");
  10261                if (planner.z_fade_height > 0.0)
  10262                  SERIAL_ECHOLN(planner.z_fade_height);
  10263                else
  10264                  SERIAL_ECHOLNPGM(MSG_OFF);
  10265              #endif
  10266          
  10267              // Report change in position
  10268              if (memcmp(oldpos, current_position, sizeof(oldpos)))
  10269                report_current_position();
  10270            }
  10271          #endif
  10272          
  10273          #if ENABLED(MESH_BED_LEVELING)
  10274          
  10275            /**
  10276             * M421: Set a single Mesh Bed Leveling Z coordinate
  10277             *
  10278             * Usage:
  10279             *   M421 X<linear> Y<linear> Z<linear>
  10280             *   M421 X<linear> Y<linear> Q<offset>
  10281             *   M421 I<xindex> J<yindex> Z<linear>
  10282             *   M421 I<xindex> J<yindex> Q<offset>
  10283             */
  10284            inline void gcode_M421() {
  10285              const bool hasX = parser.seen('X'), hasI = parser.seen('I');
  10286              const int8_t ix = hasI ? parser.value_int() : hasX ? mbl.probe_index_x(parser.value_linear_units()) : -1;
  10287              const bool hasY = parser.seen('Y'), hasJ = parser.seen('J');
  10288              const int8_t iy = hasJ ? parser.value_int() : hasY ? mbl.probe_index_y(parser.value_linear_units()) : -1;
  10289              const bool hasZ = parser.seen('Z'), hasQ = !hasZ && parser.seen('Q');
  10290          
  10291              if (int(hasI && hasJ) + int(hasX && hasY) != 1 || !(hasZ || hasQ)) {
  10292                SERIAL_ERROR_START();
  10293                SERIAL_ERRORLNPGM(MSG_ERR_M421_PARAMETERS);
  10294              }
  10295              else if (ix < 0 || iy < 0) {
  10296                SERIAL_ERROR_START();
  10297                SERIAL_ERRORLNPGM(MSG_ERR_MESH_XY);
  10298              }
  10299              else
  10300                mbl.set_z(ix, iy, parser.value_linear_units() + (hasQ ? mbl.z_values[ix][iy] : 0));
  10301            }
  10302          
  10303          #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
  10304          
  10305            /**
  10306             * M421: Set a single Mesh Bed Leveling Z coordinate
  10307             *
  10308             * Usage:
  10309             *   M421 I<xindex> J<yindex> Z<linear>
  10310             *   M421 I<xindex> J<yindex> Q<offset>
  10311             */
  10312            inline void gcode_M421() {
  10313              int8_t ix = parser.intval('I', -1), iy = parser.intval('J', -1);
  10314              const bool hasI = ix >= 0,
  10315                         hasJ = iy >= 0,
  10316                         hasZ = parser.seen('Z'),
  10317                         hasQ = !hasZ && parser.seen('Q');
  10318          
  10319              if (!hasI || !hasJ || !(hasZ || hasQ)) {
  10320                SERIAL_ERROR_START();
  10321                SERIAL_ERRORLNPGM(MSG_ERR_M421_PARAMETERS);
  10322              }
  10323              else if (!WITHIN(ix, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(iy, 0, GRID_MAX_POINTS_Y - 1)) {
  10324                SERIAL_ERROR_START();
  10325                SERIAL_ERRORLNPGM(MSG_ERR_MESH_XY);
  10326              }
  10327              else {
  10328                z_values[ix][iy] = parser.value_linear_units() + (hasQ ? z_values[ix][iy] : 0);
  10329                #if ENABLED(ABL_BILINEAR_SUBDIVISION)
  10330                  bed_level_virt_interpolate();
  10331                #endif
  10332              }
  10333            }
  10334          
  10335          #elif ENABLED(AUTO_BED_LEVELING_UBL)
  10336          
  10337            /**
  10338             * M421: Set a single Mesh Bed Leveling Z coordinate
  10339             *
  10340             * Usage:
  10341             *   M421 I<xindex> J<yindex> Z<linear>
  10342             *   M421 I<xindex> J<yindex> Q<offset>
  10343             *   M421 C Z<linear>
  10344             *   M421 C Q<offset>
  10345             */
  10346            inline void gcode_M421() {
  10347              int8_t ix = parser.intval('I', -1), iy = parser.intval('J', -1);
  10348              const bool hasI = ix >= 0,
  10349                         hasJ = iy >= 0,
  10350                         hasC = parser.seen('C'),
  10351                         hasZ = parser.seen('Z'),
  10352                         hasQ = !hasZ && parser.seen('Q');
  10353          
  10354              if (hasC) {
  10355                const mesh_index_pair location = ubl.find_closest_mesh_point_of_type(REAL, current_position[X_AXIS], current_position[Y_AXIS], USE_NOZZLE_AS_REFERENCE, NULL);
  10356                ix = location.x_index;
  10357                iy = location.y_index;
  10358              }
  10359          
  10360              if (int(hasC) + int(hasI && hasJ) != 1 || !(hasZ || hasQ)) {
  10361                SERIAL_ERROR_START();
  10362                SERIAL_ERRORLNPGM(MSG_ERR_M421_PARAMETERS);
  10363              }
  10364              else if (!WITHIN(ix, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(iy, 0, GRID_MAX_POINTS_Y - 1)) {
  10365                SERIAL_ERROR_START();
  10366                SERIAL_ERRORLNPGM(MSG_ERR_MESH_XY);
  10367              }
  10368              else
  10369                ubl.z_values[ix][iy] = parser.value_linear_units() + (hasQ ? ubl.z_values[ix][iy] : 0);
  10370            }
  10371          
  10372          #endif // AUTO_BED_LEVELING_UBL
  10373          
  10374          #if HAS_M206_COMMAND
  10375          
  10376            /**
  10377             * M428: Set home_offset based on the distance between the
  10378             *       current_position and the nearest "reference point."
  10379             *       If an axis is past center its endstop position
  10380             *       is the reference-point. Otherwise it uses 0. This allows
  10381             *       the Z offset to be set near the bed when using a max endstop.
  10382             *
  10383             *       M428 can't be used more than 2cm away from 0 or an endstop.
  10384             *
  10385             *       Use M206 to set these values directly.
  10386             */

   \                                 In section .text, align 4
  10387            inline void gcode_M428() {
   \                     _Z10gcode_M428v: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0xB084             SUB      SP,SP,#+16
  10388              if (axis_unhomed_error()) return;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x.... 0x....      BL       _Z18axis_unhomed_errorb
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD169             BNE.N    ??gcode_M428_0
  10389          
  10390              float diff[XYZ];
  10391              LOOP_XYZ(i) {
   \   00000012   0x2400             MOVS     R4,#+0
   \   00000014   0x4D38             LDR.N    R5,??gcode_M428_1+0x8
   \   00000016   0xAE00             ADD      R6,SP,#+0
   \   00000018   0xE001             B.N      ??gcode_M428_2
   \                     ??gcode_M428_3: (+1)
   \   0000001A   0x1C64             ADDS     R4,R4,#+1
   \   0000001C   0xB2E4             UXTB     R4,R4
   \                     ??gcode_M428_2: (+1)
   \   0000001E   0x2C03             CMP      R4,#+3
   \   00000020   0xDA4D             BGE.N    ??gcode_M428_4
  10392                diff[i] = base_home_pos((AxisEnum)i) - current_position[i];
   \   00000022   0xEB05 0x0084      ADD      R0,R5,R4, LSL #+2
   \   00000026   0xED90 0x8A09      VLDR     S16,[R0, #+36]
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0xB240             SXTB     R0,R0
   \   0000002E   0x.... 0x....      BL       _Z13base_home_pos8AxisEnum
   \   00000032   0xEE30 0x0A48      VSUB.F32 S0,S0,S16
   \   00000036   0xEB06 0x0084      ADD      R0,R6,R4, LSL #+2
   \   0000003A   0xED80 0x0A00      VSTR     S0,[R0, #0]
  10393                diff[C_AXIS] = home_offset[C_AXIS] - current_position[C_AXIS];    //mks_dlp
   \   0000003E   0xED95 0x0A17      VLDR     S0,[R5, #+92]
   \   00000042   0xEDD5 0x0A0B      VLDR     S1,[R5, #+44]
   \   00000046   0xEE30 0x0A60      VSUB.F32 S0,S0,S1
   \   0000004A   0xED8D 0x0A02      VSTR     S0,[SP, #+8]
  10394                
  10395                if (!WITHIN(diff[i], -200, 200) && home_dir((AxisEnum)i) > 0)
   \   0000004E   0xF856 0x0024      LDR      R0,[R6, R4, LSL #+2]
   \   00000052   0xEE00 0x0A10      VMOV     S0,R0
   \   00000056   0xEDDF 0x8A26      VLDR.W   S17,??gcode_M428_1  ;; 0xc3480000
   \   0000005A   0xEEB4 0x0A68      VCMP.F32 S0,S17
   \   0000005E   0xEEF1 0xFA10      FMSTAT   
   \   00000062   0xDB06             BLT.N    ??gcode_M428_5
   \   00000064   0xEDDF 0x0A23      VLDR.W   S1,??gcode_M428_1+0x4  ;; 0x43480001
   \   00000068   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   0000006C   0xEEF1 0xFA10      FMSTAT   
   \   00000070   0xD40B             BMI.N    ??gcode_M428_6
   \                     ??gcode_M428_5: (+1)
   \   00000072   0x4620             MOV      R0,R4
   \   00000074   0xB240             SXTB     R0,R0
   \   00000076   0x.... 0x....      BL       _Z8home_dir8AxisEnum
   \   0000007A   0x2801             CMP      R0,#+1
   \   0000007C   0xDB05             BLT.N    ??gcode_M428_6
  10396                  diff[i] = -current_position[i];
   \   0000007E   0xEB06 0x0084      ADD      R0,R6,R4, LSL #+2
   \   00000082   0xEEB1 0x0A48      VNEG.F32 S0,S16
   \   00000086   0xED80 0x0A00      VSTR     S0,[R0, #0]
  10397                if (!WITHIN(diff[i], -200, 200)) {
   \                     ??gcode_M428_6: (+1)
   \   0000008A   0xF856 0x0024      LDR      R0,[R6, R4, LSL #+2]
   \   0000008E   0xEE00 0x0A10      VMOV     S0,R0
   \   00000092   0xEEB4 0x0A68      VCMP.F32 S0,S17
   \   00000096   0xEEF1 0xFA10      FMSTAT   
   \   0000009A   0xDB06             BLT.N    ??gcode_M428_7
   \   0000009C   0xEDDF 0x0A15      VLDR.W   S1,??gcode_M428_1+0x4  ;; 0x43480001
   \   000000A0   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   000000A4   0xEEF1 0xFA10      FMSTAT   
   \   000000A8   0xD4B7             BMI.N    ??gcode_M428_3
  10398                  SERIAL_ERROR_START();
   \                     ??gcode_M428_7: (+1)
   \   000000AA   0x4814             LDR.N    R0,??gcode_M428_1+0xC
   \   000000AC   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10399                  SERIAL_ERRORLNPGM(MSG_ERR_M428_TOO_FAR);
   \   000000B0   0x4813             LDR.N    R0,??gcode_M428_1+0x10
   \   000000B2   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10400                  LCD_ALERTMESSAGEPGM("Err: Too far!");
   \   000000B6   0x4813             LDR.N    R0,??gcode_M428_1+0x14
   \   000000B8   0x.... 0x....      BL       _Z21lcd_setalertstatusPGMPKc
  10401                  BUZZ(200, 40);
  10402                  return;
   \   000000BC   0xE013             B.N      ??gcode_M428_0
  10403                }
  10404              }
  10405              LOOP_XYZ(i) set_home_offset((AxisEnum)i, diff[i]);
   \                     ??gcode_M428_4: (+1)
   \   000000BE   0x2400             MOVS     R4,#+0
   \   000000C0   0xE009             B.N      ??gcode_M428_8
   \                     ??gcode_M428_9: (+1)
   \   000000C2   0xA800             ADD      R0,SP,#+0
   \   000000C4   0xEB00 0x0084      ADD      R0,R0,R4, LSL #+2
   \   000000C8   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   000000CC   0x4620             MOV      R0,R4
   \   000000CE   0xB240             SXTB     R0,R0
   \   000000D0   0x.... 0x....      BL       _Z15set_home_offset8AxisEnumf
   \   000000D4   0x1C64             ADDS     R4,R4,#+1
   \                     ??gcode_M428_8: (+1)
   \   000000D6   0x2C03             CMP      R4,#+3
   \   000000D8   0xDBF3             BLT.N    ??gcode_M428_9
  10406              report_current_position();
   \   000000DA   0x.... 0x....      BL       _Z23report_current_positionv
  10407              LCD_MESSAGEPGM(MSG_HOME_OFFSETS_APPLIED);
   \   000000DE   0x2100             MOVS     R1,#+0
   \   000000E0   0x4809             LDR.N    R0,??gcode_M428_1+0x18
   \   000000E2   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
  10408              BUZZ(100, 659);
  10409              BUZZ(100, 698);
  10410            }
   \                     ??gcode_M428_0: (+1)
   \   000000E6   0xB004             ADD      SP,SP,#+16
   \   000000E8   0xECBD 0x8B02      VPOP     {D8}
   \   000000EC   0xBD70             POP      {R4-R6,PC}       ;; return
   \   000000EE   0xBF00             Nop      
   \                     ??gcode_M428_1:
   \   000000F0   0xC3480000         DC32     0xc3480000
   \   000000F4   0x43480001         DC32     0x43480001
   \   000000F8   0x........         DC32     axis_relative_modes
   \   000000FC   0x........         DC32     errormagic
   \   00000100   0x........         DC32     _ZZ10gcode_M428vEs
   \   00000104   0x........         DC32     _ZZ10gcode_M428vEs_0
   \   00000108   0x........         DC32     _ZZ10gcode_M428vEs_1
  10411          
  10412          #endif // HAS_M206_COMMAND
  10413          
  10414          /**
  10415           * M500: Store settings in EEPROM
  10416           */

   \                                 In section .text, align 2
  10417          inline void gcode_M500() {
  10418            (void)settings.save();
   \                     _Z10gcode_M500v: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN14MarlinSettings4saveEv
  10419          }
  10420          
  10421          /**
  10422           * M501: Read settings from EEPROM
  10423           */

   \                                 In section .text, align 2
  10424          inline void gcode_M501() {
  10425            (void)settings.load();
   \                     _Z10gcode_M501v: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN14MarlinSettings4loadEv
  10426          }
  10427          
  10428          /**
  10429           * M502: Revert to default settings
  10430           */

   \                                 In section .text, align 2
  10431          inline void gcode_M502() {
  10432            (void)settings.reset();
   \                     _Z10gcode_M502v: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN14MarlinSettings5resetEv
  10433          }
  10434          
  10435          #if DISABLED(DISABLE_M503)
  10436            /**
  10437             * M503: print settings currently in memory
  10438             */

   \                                 In section .text, align 2
  10439            inline void gcode_M503() {
   \                     _Z10gcode_M503v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  10440              (void)settings.report(parser.seen('S') && !parser.value_bool());
   \   00000002   0x2053             MOVS     R0,#+83
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD006             BEQ.N    ??gcode_M503_0
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser10value_boolEv
   \   00000010   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000014   0xF080 0x0001      EOR      R0,R0,#0x1
   \   00000018   0xE000             B.N      ??gcode_M503_1
   \                     ??gcode_M503_0: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \                     ??gcode_M503_1: (+1)
   \   0000001C   0xE8BD 0x4002      POP      {R1,LR}
   \   00000020   0x.... 0x....      B.W      _ZN14MarlinSettings6reportEb
  10441            }
  10442          #endif
  10443          
  10444          #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
  10445          
  10446            /**
  10447             * M540: Set whether SD card print should abort on endstop hit (M540 S<0|1>)
  10448             */
  10449            inline void gcode_M540() {
  10450              if (parser.seen('S')) stepper.abort_on_endstop_hit = parser.value_bool();
  10451            }
  10452          
  10453          #endif // ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
  10454          
  10455          #if HAS_BED_PROBE
  10456          
  10457            inline void gcode_M851() {
  10458              SERIAL_ECHO_START();
  10459              SERIAL_ECHOPGM(MSG_PROBE_Z_OFFSET);
  10460              if (parser.seen('Z')) {
  10461                const float value = parser.value_linear_units();
  10462                if (!WITHIN(value, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
  10463                  SERIAL_ECHOLNPGM(" " MSG_Z_MIN " " STRINGIFY(Z_PROBE_OFFSET_RANGE_MIN) " " MSG_Z_MAX " " STRINGIFY(Z_PROBE_OFFSET_RANGE_MAX));
  10464                  return;
  10465                }
  10466                zprobe_zoffset = value;
  10467              }
  10468              SERIAL_ECHOLNPAIR(": ", zprobe_zoffset);
  10469            }
  10470          
  10471          #endif // HAS_BED_PROBE
  10472          
  10473          #if ENABLED(SKEW_CORRECTION_GCODE)
  10474          
  10475            /**
  10476             * M852: Get or set the machine skew factors. Reports current values with no arguments.
  10477             *
  10478             *  S[xy_factor] - Alias for 'I'
  10479             *  I[xy_factor] - New XY skew factor
  10480             *  J[xz_factor] - New XZ skew factor
  10481             *  K[yz_factor] - New YZ skew factor
  10482             */
  10483            inline void gcode_M852() {
  10484              uint8_t ijk = 0, badval = 0, setval = 0;
  10485          
  10486              if (parser.seen('I') || parser.seen('S')) {
  10487                ++ijk;
  10488                const float value = parser.value_linear_units();
  10489                if (WITHIN(value, SKEW_FACTOR_MIN, SKEW_FACTOR_MAX)) {
  10490                  if (planner.xy_skew_factor != value) {
  10491                    planner.xy_skew_factor = value;
  10492                    ++setval;
  10493                  }
  10494                }
  10495                else
  10496                  ++badval;
  10497              }
  10498          
  10499              #if ENABLED(SKEW_CORRECTION_FOR_Z)
  10500          
  10501                if (parser.seen('J')) {
  10502                  ++ijk;
  10503                  const float value = parser.value_linear_units();
  10504                  if (WITHIN(value, SKEW_FACTOR_MIN, SKEW_FACTOR_MAX)) {
  10505                    if (planner.xz_skew_factor != value) {
  10506                      planner.xz_skew_factor = value;
  10507                      ++setval;
  10508                    }
  10509                  }
  10510                  else
  10511                    ++badval;
  10512                }
  10513          
  10514                if (parser.seen('K')) {
  10515                  ++ijk;
  10516                  const float value = parser.value_linear_units();
  10517                  if (WITHIN(value, SKEW_FACTOR_MIN, SKEW_FACTOR_MAX)) {
  10518                    if (planner.yz_skew_factor != value) {
  10519                      planner.yz_skew_factor = value;
  10520                      ++setval;
  10521                    }
  10522                  }
  10523                  else
  10524                    ++badval;
  10525                }
  10526          
  10527              #endif
  10528          
  10529              if (badval)
  10530                SERIAL_ECHOLNPGM(MSG_SKEW_MIN " " STRINGIFY(SKEW_FACTOR_MIN) " " MSG_SKEW_MAX " " STRINGIFY(SKEW_FACTOR_MAX));
  10531          
  10532              // When skew is changed the current position changes
  10533              if (setval) {
  10534                set_current_from_steppers_for_axis(ALL_AXES);
  10535                SYNC_PLAN_POSITION_KINEMATIC();
  10536                report_current_position();
  10537              }
  10538          
  10539              if (!ijk) {
  10540                SERIAL_ECHO_START();
  10541                SERIAL_ECHOPAIR(MSG_SKEW_FACTOR " XY: ", planner.xy_skew_factor);
  10542                #if ENABLED(SKEW_CORRECTION_FOR_Z)
  10543                  SERIAL_ECHOPAIR(" XZ: ", planner.xz_skew_factor);
  10544                  SERIAL_ECHOLNPAIR(" YZ: ", planner.yz_skew_factor);
  10545                #else
  10546                  SERIAL_EOL();
  10547                #endif
  10548              }
  10549            }
  10550          
  10551          #endif // SKEW_CORRECTION_GCODE
  10552          
  10553          #if ENABLED(ADVANCED_PAUSE_FEATURE)
  10554          
  10555            /**
  10556             * M600: Pause for filament change
  10557             *
  10558             *  E[distance] - Retract the filament this far (negative value)
  10559             *  Z[distance] - Move the Z axis by this distance
  10560             *  X[position] - Move to this X position, with Y
  10561             *  Y[position] - Move to this Y position, with X
  10562             *  U[distance] - Retract distance for removal (negative value) (manual reload)
  10563             *  L[distance] - Extrude distance for insertion (positive value) (manual reload)
  10564             *  B[count]    - Number of times to beep, -1 for indefinite (if equipped with a buzzer)
  10565             *
  10566             *  Default values are used for omitted arguments.
  10567             *
  10568             */
  10569            inline void gcode_M600() {
  10570              point_t park_point = NOZZLE_PARK_POINT;
  10571          
  10572              #if ENABLED(HOME_BEFORE_FILAMENT_CHANGE)
  10573                // Don't allow filament change without homing first
  10574                if (axis_unhomed_error()) home_all_axes();
  10575              #endif
  10576          
  10577              // Initial retract before move to filament change position
  10578              const float retract = parser.seen('E') ? parser.value_axis_units(E_AXIS) : 0
  10579                #ifdef PAUSE_PARK_RETRACT_LENGTH
  10580                  - (PAUSE_PARK_RETRACT_LENGTH)
  10581                #endif
  10582              ;
  10583          
  10584              // Lift Z axis
  10585              if (parser.seenval('Z'))
  10586                park_point.z = parser.linearval('Z');
  10587          
  10588              // Move XY axes to filament change position or given position
  10589              if (parser.seenval('X'))
  10590                park_point.x = parser.linearval('X');
  10591          
  10592              if (parser.seenval('Y'))
  10593                park_point.y = parser.linearval('Y');
  10594          
  10595              #if HOTENDS > 1 && DISABLED(DUAL_X_CARRIAGE)
  10596                park_point.x += (active_extruder ? hotend_offset[X_AXIS][active_extruder] : 0);
  10597                park_point.y += (active_extruder ? hotend_offset[Y_AXIS][active_extruder] : 0);
  10598              #endif
  10599          
  10600              // Unload filament
  10601              const float unload_length = parser.seen('U') ? parser.value_axis_units(E_AXIS) : 0
  10602                #if defined(FILAMENT_CHANGE_UNLOAD_LENGTH) && FILAMENT_CHANGE_UNLOAD_LENGTH > 0
  10603                  - (FILAMENT_CHANGE_UNLOAD_LENGTH)
  10604                #endif
  10605              ;
  10606          
  10607              // Load filament
  10608              const float load_length = parser.seen('L') ? parser.value_axis_units(E_AXIS) : 0
  10609                #ifdef FILAMENT_CHANGE_LOAD_LENGTH
  10610                  + FILAMENT_CHANGE_LOAD_LENGTH
  10611                #endif
  10612              ;
  10613          
  10614              const int beep_count = parser.intval('B',
  10615                #ifdef FILAMENT_CHANGE_NUMBER_OF_ALERT_BEEPS
  10616                  FILAMENT_CHANGE_NUMBER_OF_ALERT_BEEPS
  10617                #else
  10618                  -1
  10619                #endif
  10620              );
  10621          
  10622              const bool job_running = print_job_timer.isRunning();
  10623          
  10624              if (pause_print(retract, park_point, unload_length, beep_count, true)) {
  10625                wait_for_filament_reload(beep_count);
  10626                resume_print(load_length, ADVANCED_PAUSE_EXTRUDE_LENGTH, beep_count);
  10627              }
  10628          
  10629              // Resume the print job timer if it was running
  10630              if (job_running) print_job_timer.start();
  10631            }
  10632          
  10633          #endif // ADVANCED_PAUSE_FEATURE
  10634          
  10635          #if ENABLED(MK2_MULTIPLEXER)
  10636          
  10637            inline void select_multiplexed_stepper(const uint8_t e) {
  10638              stepper.synchronize();
  10639              disable_e_steppers();
  10640              WRITE(E_MUX0_PIN, TEST(e, 0) ? HIGH : LOW);
  10641              WRITE(E_MUX1_PIN, TEST(e, 1) ? HIGH : LOW);
  10642              WRITE(E_MUX2_PIN, TEST(e, 2) ? HIGH : LOW);
  10643              safe_delay(100);
  10644            }
  10645          
  10646            /**
  10647             * M702: Unload all extruders
  10648             */
  10649            inline void gcode_M702() {
  10650              for (uint8_t s = 0; s < E_STEPPERS; s++) {
  10651                select_multiplexed_stepper(e);
  10652                // TODO: standard unload filament function
  10653                // MK2 firmware behavior:
  10654                //  - Make sure temperature is high enough
  10655                //  - Raise Z to at least 15 to make room
  10656                //  - Extrude 1cm of filament in 1 second
  10657                //  - Under 230C quickly purge ~12mm, over 230C purge ~10mm
  10658                //  - Change E max feedrate to 80, eject the filament from the tube. Sync.
  10659                //  - Restore E max feedrate to 50
  10660              }
  10661              // Go back to the last active extruder
  10662              select_multiplexed_stepper(active_extruder);
  10663              disable_e_steppers();
  10664            }
  10665          
  10666          #endif // MK2_MULTIPLEXER
  10667          
  10668          #if ENABLED(DUAL_X_CARRIAGE)
  10669          
  10670            /**
  10671             * M605: Set dual x-carriage movement mode
  10672             *
  10673             *    M605 S0: Full control mode. The slicer has full control over x-carriage movement
  10674             *    M605 S1: Auto-park mode. The inactive head will auto park/unpark without slicer involvement
  10675             *    M605 S2 [Xnnn] [Rmmm]: Duplication mode. The second extruder will duplicate the first with nnn
  10676             *                         units x-offset and an optional differential hotend temperature of
  10677             *                         mmm degrees. E.g., with "M605 S2 X100 R2" the second extruder will duplicate
  10678             *                         the first with a spacing of 100mm in the x direction and 2 degrees hotter.
  10679             *
  10680             *    Note: the X axis should be homed after changing dual x-carriage mode.
  10681             */
  10682            inline void gcode_M605() {
  10683              stepper.synchronize();
  10684              if (parser.seen('S')) dual_x_carriage_mode = (DualXMode)parser.value_byte();
  10685              switch (dual_x_carriage_mode) {
  10686                case DXC_FULL_CONTROL_MODE:
  10687                case DXC_AUTO_PARK_MODE:
  10688                  break;
  10689                case DXC_DUPLICATION_MODE:
  10690                  if (parser.seen('X')) duplicate_extruder_x_offset = max(parser.value_linear_units(), X2_MIN_POS - x_home_pos(0));
  10691                  if (parser.seen('R')) duplicate_extruder_temp_offset = parser.value_celsius_diff();
  10692                  SERIAL_ECHO_START();
  10693                  SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
  10694                  SERIAL_CHAR(' ');
  10695                  SERIAL_ECHO(hotend_offset[X_AXIS][0]);
  10696                  SERIAL_CHAR(',');
  10697                  SERIAL_ECHO(hotend_offset[Y_AXIS][0]);
  10698                  SERIAL_CHAR(' ');
  10699                  SERIAL_ECHO(duplicate_extruder_x_offset);
  10700                  SERIAL_CHAR(',');
  10701                  SERIAL_ECHOLN(hotend_offset[Y_AXIS][1]);
  10702                  break;
  10703                default:
  10704                  dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
  10705                  break;
  10706              }
  10707              active_extruder_parked = false;
  10708              extruder_duplication_enabled = false;
  10709              delayed_move_time = 0;
  10710            }
  10711          
  10712          #elif ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
  10713          
  10714            inline void gcode_M605() {
  10715              stepper.synchronize();
  10716              extruder_duplication_enabled = parser.intval('S') == (int)DXC_DUPLICATION_MODE;
  10717              SERIAL_ECHO_START();
  10718              SERIAL_ECHOLNPAIR(MSG_DUPLICATION_MODE, extruder_duplication_enabled ? MSG_ON : MSG_OFF);
  10719            }
  10720          
  10721          #endif // DUAL_NOZZLE_DUPLICATION_MODE
  10722          
  10723          #if ENABLED(LIN_ADVANCE)
  10724            /**
  10725             * M900: Set and/or Get advance K factor and WH/D ratio
  10726             *
  10727             *  K<factor>                  Set advance K factor
  10728             *  R<ratio>                   Set ratio directly (overrides WH/D)
  10729             *  W<width> H<height> D<diam> Set ratio from WH/D
  10730             */
  10731            inline void gcode_M900() {
  10732              stepper.synchronize();
  10733          
  10734              const float newK = parser.floatval('K', -1);
  10735              if (newK >= 0) planner.extruder_advance_k = newK;
  10736          
  10737              float newR = parser.floatval('R', -1);
  10738              if (newR < 0) {
  10739                const float newD = parser.floatval('D', -1),
  10740                            newW = parser.floatval('W', -1),
  10741                            newH = parser.floatval('H', -1);
  10742                if (newD >= 0 && newW >= 0 && newH >= 0)
  10743                  newR = newD ? (newW * newH) / (sq(newD * 0.5) * M_PI) : 0;
  10744              }
  10745              if (newR >= 0) planner.advance_ed_ratio = newR;
  10746          
  10747              SERIAL_ECHO_START();
  10748              SERIAL_ECHOPAIR("Advance K=", planner.extruder_advance_k);
  10749              SERIAL_ECHOPGM(" E/D=");
  10750              const float ratio = planner.advance_ed_ratio;
  10751              if (ratio) SERIAL_ECHO(ratio); else SERIAL_ECHOPGM("Auto");
  10752              SERIAL_EOL();
  10753            }
  10754          #endif // LIN_ADVANCE
  10755          
  10756          #if HAS_TRINAMIC
  10757            static bool report_tmc_status = false;
  10758            const char extended_axis_codes[11][3] = { "X", "X2", "Y", "Y2", "Z", "Z2", "E0", "E1", "E2", "E3", "E4" };
  10759            enum TMC_AxisEnum {
  10760              TMC_X,
  10761              TMC_X2,
  10762              TMC_Y,
  10763              TMC_Y2,
  10764              TMC_Z,
  10765              TMC_Z2,
  10766              TMC_E0,
  10767              TMC_E1,
  10768              TMC_E2,
  10769              TMC_E3,
  10770              TMC_E4
  10771            };
  10772            #if ENABLED(TMC_DEBUG)
  10773              enum TMC_debug_enum {
  10774                TMC_CODES,
  10775                TMC_ENABLED,
  10776                TMC_CURRENT,
  10777                TMC_RMS_CURRENT,
  10778                TMC_MAX_CURRENT,
  10779                TMC_IRUN,
  10780                TMC_IHOLD,
  10781                TMC_CS_ACTUAL,
  10782                TMC_PWM_SCALE,
  10783                TMC_VSENSE,
  10784                TMC_STEALTHCHOP,
  10785                TMC_MICROSTEPS,
  10786                TMC_TSTEP,
  10787                TMC_TPWMTHRS,
  10788                TMC_TPWMTHRS_MMS,
  10789                TMC_OTPW,
  10790                TMC_OTPW_TRIGGERED,
  10791                TMC_TOFF,
  10792                TMC_TBL,
  10793                TMC_HEND,
  10794                TMC_HSTRT,
  10795                TMC_SGT
  10796              };
  10797              enum TMC_drv_status_enum {
  10798                TMC_DRV_CODES,
  10799                TMC_STST,
  10800                TMC_OLB,
  10801                TMC_OLA,
  10802                TMC_S2GB,
  10803                TMC_S2GA,
  10804                TMC_DRV_OTPW,
  10805                TMC_OT,
  10806                TMC_STALLGUARD,
  10807                TMC_DRV_CS_ACTUAL,
  10808                TMC_FSACTIVE,
  10809                TMC_SG_RESULT,
  10810                TMC_DRV_STATUS_HEX,
  10811                TMC_T157,
  10812                TMC_T150,
  10813                TMC_T143,
  10814                TMC_T120,
  10815                TMC_STEALTH,
  10816                TMC_S2VSB,
  10817                TMC_S2VSA
  10818              };
  10819              static void drv_status_print_hex(const char name[], const uint32_t drv_status) {
  10820                SERIAL_ECHO(name);
  10821                SERIAL_ECHOPGM(" = 0x");
  10822                for(int B=24; B>=8; B-=8){
  10823                  MYSERIAL.print((drv_status>>(B+4))&0xF, HEX);
  10824                  MYSERIAL.print((drv_status>>B)&0xF, HEX);
  10825                  MYSERIAL.print(':');
  10826                }
  10827                MYSERIAL.print((drv_status>>4)&0xF, HEX);
  10828                MYSERIAL.print((drv_status)&0xF, HEX);
  10829                SERIAL_EOL();
  10830              }
  10831          
  10832              #if ENABLED(HAVE_TMC2130)
  10833                static void tmc_status(TMC2130Stepper &st, const TMC_debug_enum i) {
  10834                  switch(i) {
  10835                    case TMC_PWM_SCALE: MYSERIAL.print(st.PWM_SCALE(), DEC); break;
  10836                    case TMC_TSTEP: SERIAL_ECHO(st.TSTEP()); break;
  10837                    case TMC_SGT: MYSERIAL.print(st.sgt(), DEC); break;
  10838                    case TMC_STEALTHCHOP: serialprintPGM(st.stealthChop() ? PSTR("true") : PSTR("false")); break;
  10839                    default: break;
  10840                  }
  10841                }
  10842                static void tmc_parse_drv_status(TMC2130Stepper &st, const TMC_drv_status_enum i) {
  10843                  switch(i) {
  10844                    case TMC_STALLGUARD: if (st.stallguard()) SERIAL_ECHOPGM("X"); break;
  10845                    case TMC_SG_RESULT:  MYSERIAL.print(st.sg_result(), DEC);      break;
  10846                    case TMC_FSACTIVE:   if (st.fsactive())   SERIAL_ECHOPGM("X"); break;
  10847                    default: break;
  10848                  }
  10849                }
  10850              #endif
  10851              #if ENABLED(HAVE_TMC2208)
  10852                static void tmc_status(TMC2208Stepper &st, const TMC_debug_enum i) {
  10853                  switch(i) {
  10854                    case TMC_TSTEP:
  10855                      {
  10856                        uint32_t data = 0;
  10857                        st.TSTEP(&data);
  10858                        MYSERIAL.print(data);
  10859                        break;
  10860                      }
  10861                    case TMC_PWM_SCALE: MYSERIAL.print(st.pwm_scale_sum(), DEC); break;
  10862                    case TMC_STEALTHCHOP: serialprintPGM(st.stealth() ? PSTR("true") : PSTR("false")); break;
  10863                    case TMC_S2VSA: if (st.s2vsa()) SERIAL_ECHOPGM("X"); break;
  10864                    case TMC_S2VSB: if (st.s2vsb()) SERIAL_ECHOPGM("X"); break;
  10865                    default: break;
  10866                  }
  10867                }
  10868                static void tmc_parse_drv_status(TMC2208Stepper &st, const TMC_drv_status_enum i) {
  10869                  switch(i) {
  10870                    case TMC_T157: if (st.t157()) SERIAL_ECHOPGM("X"); break;
  10871                    case TMC_T150: if (st.t150()) SERIAL_ECHOPGM("X"); break;
  10872                    case TMC_T143: if (st.t143()) SERIAL_ECHOPGM("X"); break;
  10873                    case TMC_T120: if (st.t120()) SERIAL_ECHOPGM("X"); break;
  10874                    default: break;
  10875                  }
  10876                }
  10877              #endif
  10878              template <typename TMC>
  10879              static void tmc_status(TMC &st, TMC_AxisEnum axis, const TMC_debug_enum i, const float spmm) {
  10880                SERIAL_ECHO('\t');
  10881                switch(i) {
  10882                  case TMC_CODES: SERIAL_ECHO(extended_axis_codes[axis]); break;
  10883                  case TMC_ENABLED: serialprintPGM(st.isEnabled() ? PSTR("true") : PSTR("false")); break;
  10884                  case TMC_CURRENT: SERIAL_ECHO(st.getCurrent()); break;
  10885                  case TMC_RMS_CURRENT: MYSERIAL.print(st.rms_current()); break;
  10886                  case TMC_MAX_CURRENT: MYSERIAL.print((float)st.rms_current()*1.41, 0); break;
  10887                  case TMC_IRUN:
  10888                    MYSERIAL.print(st.irun(), DEC);
  10889                    SERIAL_ECHOPGM("/31");
  10890                    break;
  10891                  case TMC_IHOLD:
  10892                    MYSERIAL.print(st.ihold(), DEC);
  10893                    SERIAL_ECHOPGM("/31");
  10894                    break;
  10895                  case TMC_CS_ACTUAL:
  10896                    MYSERIAL.print(st.cs_actual(), DEC);
  10897                    SERIAL_ECHOPGM("/31");
  10898                    break;
  10899          
  10900                  case TMC_VSENSE: serialprintPGM(st.vsense() ? PSTR("1=.18") : PSTR("0=.325")); break;
  10901          
  10902                  case TMC_MICROSTEPS: SERIAL_ECHO(st.microsteps()); break;
  10903                  case TMC_TPWMTHRS:
  10904                    {
  10905                      uint32_t tpwmthrs_val = st.TPWMTHRS();
  10906                      SERIAL_ECHO(tpwmthrs_val);
  10907                    }
  10908                    break;
  10909                  case TMC_TPWMTHRS_MMS:
  10910                    {
  10911                      uint32_t tpwmthrs_val = st.TPWMTHRS();
  10912                      tpwmthrs_val ? SERIAL_ECHO(12650000UL * st.microsteps() / (256 * tpwmthrs_val * spmm)) : SERIAL_ECHO('-');
  10913                    }
  10914                    break;
  10915                  case TMC_OTPW: serialprintPGM(st.otpw() ? PSTR("true") : PSTR("false")); break;
  10916                  case TMC_OTPW_TRIGGERED: serialprintPGM(st.getOTPW() ? PSTR("true") : PSTR("false")); break;
  10917                  case TMC_TOFF: MYSERIAL.print(st.toff(), DEC); break;
  10918                  case TMC_TBL: MYSERIAL.print(st.blank_time(), DEC); break;
  10919                  case TMC_HEND: MYSERIAL.print(st.hysterisis_end(), DEC); break;
  10920                  case TMC_HSTRT: MYSERIAL.print(st.hysterisis_start(), DEC); break;
  10921                  default: tmc_status(st, i); break;
  10922                }
  10923              }
  10924              template <typename TMC>
  10925              static void tmc_parse_drv_status(TMC &st, TMC_AxisEnum axis, const TMC_drv_status_enum i) {
  10926                SERIAL_ECHOPGM("\t");
  10927                switch(i) {
  10928                  case TMC_DRV_CODES:     SERIAL_ECHO(extended_axis_codes[axis]);  break;
  10929                  case TMC_STST:          if (st.stst())         SERIAL_ECHOPGM("X"); break;
  10930                  case TMC_OLB:           if (st.olb())          SERIAL_ECHOPGM("X"); break;
  10931                  case TMC_OLA:           if (st.ola())          SERIAL_ECHOPGM("X"); break;
  10932                  case TMC_S2GB:          if (st.s2gb())         SERIAL_ECHOPGM("X"); break;
  10933                  case TMC_S2GA:          if (st.s2ga())         SERIAL_ECHOPGM("X"); break;
  10934                  case TMC_DRV_OTPW:      if (st.otpw())         SERIAL_ECHOPGM("X"); break;
  10935                  case TMC_OT:            if (st.ot())           SERIAL_ECHOPGM("X"); break;
  10936                  case TMC_DRV_CS_ACTUAL: MYSERIAL.print(st.cs_actual(), DEC);        break;
  10937                  case TMC_DRV_STATUS_HEX:drv_status_print_hex(extended_axis_codes[axis], st.DRV_STATUS()); break;
  10938                  default: tmc_parse_drv_status(st, i); break;
  10939                }
  10940              }
  10941          
  10942              static void tmc_debug_loop(const TMC_debug_enum i) {
  10943                #if X_IS_TRINAMIC
  10944                  tmc_status(stepperX, TMC_X, i, planner.axis_steps_per_mm[X_AXIS]);
  10945                #endif
  10946                #if X2_IS_TRINAMIC
  10947                  tmc_status(stepperX2, TMC_X2, i, planner.axis_steps_per_mm[X_AXIS]);
  10948                #endif
  10949          
  10950                #if Y_IS_TRINAMIC
  10951                  tmc_status(stepperY, TMC_Y, i, planner.axis_steps_per_mm[Y_AXIS]);
  10952                #endif
  10953                #if Y2_IS_TRINAMIC
  10954                  tmc_status(stepperY2, TMC_Y2, i, planner.axis_steps_per_mm[Y_AXIS]);
  10955                #endif
  10956          
  10957                #if Z_IS_TRINAMIC
  10958                  tmc_status(stepperZ, TMC_Z, i, planner.axis_steps_per_mm[Z_AXIS]);
  10959                #endif
  10960                #if Z2_IS_TRINAMIC
  10961                  tmc_status(stepperZ2, TMC_Z2, i, planner.axis_steps_per_mm[Z_AXIS]);
  10962                #endif
  10963          
  10964                #if E0_IS_TRINAMIC
  10965                  tmc_status(stepperE0, TMC_E0, i, planner.axis_steps_per_mm[E_AXIS]);
  10966                #endif
  10967                #if E1_IS_TRINAMIC
  10968                  tmc_status(stepperE1, TMC_E1, i, planner.axis_steps_per_mm[E_AXIS+1]);
  10969                #endif
  10970                #if E2_IS_TRINAMIC
  10971                  tmc_status(stepperE2, TMC_E2, i, planner.axis_steps_per_mm[E_AXIS+2]);
  10972                #endif
  10973                #if E3_IS_TRINAMIC
  10974                  tmc_status(stepperE3, TMC_E3, i, planner.axis_steps_per_mm[E_AXIS+3]);
  10975                #endif
  10976                #if E4_IS_TRINAMIC
  10977                  tmc_status(stepperE4, TMC_E4, i, planner.axis_steps_per_mm[E_AXIS+4]);
  10978                #endif
  10979          
  10980                SERIAL_EOL();
  10981              }
  10982          
  10983              static void drv_status_loop(const TMC_drv_status_enum i) {
  10984                #if X_IS_TRINAMIC
  10985                  tmc_parse_drv_status(stepperX, TMC_X, i);
  10986                #endif
  10987                #if X2_IS_TRINAMIC
  10988                  tmc_parse_drv_status(stepperX2, TMC_X2, i);
  10989                #endif
  10990          
  10991                #if Y_IS_TRINAMIC
  10992                  tmc_parse_drv_status(stepperY, TMC_Y, i);
  10993                #endif
  10994                #if Y2_IS_TRINAMIC
  10995                  tmc_parse_drv_status(stepperY2, TMC_Y2, i);
  10996                #endif
  10997          
  10998                #if Z_IS_TRINAMIC
  10999                  tmc_parse_drv_status(stepperZ, TMC_Z, i);
  11000                #endif
  11001                #if Z2_IS_TRINAMIC
  11002                  tmc_parse_drv_status(stepperZ2, TMC_Z2, i);
  11003                #endif
  11004          
  11005                #if E0_IS_TRINAMIC
  11006                  tmc_parse_drv_status(stepperE0, TMC_E0, i);
  11007                #endif
  11008                #if E1_IS_TRINAMIC
  11009                  tmc_parse_drv_status(stepperE1, TMC_E1, i);
  11010                #endif
  11011                #if E2_IS_TRINAMIC
  11012                  tmc_parse_drv_status(stepperE2, TMC_E2, i);
  11013                #endif
  11014                #if E3_IS_TRINAMIC
  11015                  tmc_parse_drv_status(stepperE3, TMC_E3, i);
  11016                #endif
  11017                #if E4_IS_TRINAMIC
  11018                  tmc_parse_drv_status(stepperE4, TMC_E4, i);
  11019                #endif
  11020          
  11021                SERIAL_EOL();
  11022              }
  11023          
  11024              inline void gcode_M122() {
  11025                if (parser.seen('S')) {
  11026                  if (parser.value_bool()) {
  11027                    SERIAL_ECHOLNPGM("axis:pwm_scale |status_response|");
  11028                    report_tmc_status = true;
  11029                  } else
  11030                    report_tmc_status = false;
  11031                } else {
  11032                  SERIAL_ECHOPGM("\t");                 tmc_debug_loop(TMC_CODES);
  11033                  SERIAL_ECHOPGM("Enabled\t");          tmc_debug_loop(TMC_ENABLED);
  11034                  SERIAL_ECHOPGM("Set current");        tmc_debug_loop(TMC_CURRENT);
  11035                  SERIAL_ECHOPGM("RMS current");        tmc_debug_loop(TMC_RMS_CURRENT);
  11036                  SERIAL_ECHOPGM("MAX current");        tmc_debug_loop(TMC_MAX_CURRENT);
  11037                  SERIAL_ECHOPGM("Run current");        tmc_debug_loop(TMC_IRUN);
  11038                  SERIAL_ECHOPGM("Hold current");       tmc_debug_loop(TMC_IHOLD);
  11039                  SERIAL_ECHOPGM("CS actual\t");        tmc_debug_loop(TMC_CS_ACTUAL);
  11040                  SERIAL_ECHOPGM("PWM scale");          tmc_debug_loop(TMC_PWM_SCALE);
  11041                  SERIAL_ECHOPGM("vsense\t");           tmc_debug_loop(TMC_VSENSE);
  11042                  SERIAL_ECHOPGM("stealthChop");        tmc_debug_loop(TMC_STEALTHCHOP);
  11043                  SERIAL_ECHOPGM("msteps\t");           tmc_debug_loop(TMC_MICROSTEPS);
  11044                  SERIAL_ECHOPGM("tstep\t");            tmc_debug_loop(TMC_TSTEP);
  11045                  SERIAL_ECHOPGM("pwm\nthreshold\t");   tmc_debug_loop(TMC_TPWMTHRS);
  11046                  SERIAL_ECHOPGM("[mm/s]\t");           tmc_debug_loop(TMC_TPWMTHRS_MMS);
  11047                  SERIAL_ECHOPGM("OT prewarn");         tmc_debug_loop(TMC_OTPW);
  11048                  SERIAL_ECHOPGM("OT prewarn has\nbeen triggered"); tmc_debug_loop(TMC_OTPW_TRIGGERED);
  11049                  SERIAL_ECHOPGM("off time\t");         tmc_debug_loop(TMC_TOFF);
  11050                  SERIAL_ECHOPGM("blank time");         tmc_debug_loop(TMC_TBL);
  11051                  SERIAL_ECHOPGM("hysterisis\n-end\t"); tmc_debug_loop(TMC_HEND);
  11052                  SERIAL_ECHOPGM("-start\t");           tmc_debug_loop(TMC_HSTRT);
  11053                  SERIAL_ECHOPGM("Stallguard thrs");    tmc_debug_loop(TMC_SGT);
  11054          
  11055                  SERIAL_ECHOPGM("DRVSTATUS");          drv_status_loop(TMC_DRV_CODES);
  11056                  #if ENABLED(HAVE_TMC2130)
  11057                    SERIAL_ECHOPGM("stallguard\t");     drv_status_loop(TMC_STALLGUARD);
  11058                    SERIAL_ECHOPGM("sg_result\t");      drv_status_loop(TMC_SG_RESULT);
  11059                    SERIAL_ECHOPGM("fsactive\t");       drv_status_loop(TMC_FSACTIVE);
  11060                  #endif
  11061                  SERIAL_ECHOPGM("stst\t");             drv_status_loop(TMC_STST);
  11062                  SERIAL_ECHOPGM("olb\t");              drv_status_loop(TMC_OLB);
  11063                  SERIAL_ECHOPGM("ola\t");              drv_status_loop(TMC_OLA);
  11064                  SERIAL_ECHOPGM("s2gb\t");             drv_status_loop(TMC_S2GB);
  11065                  SERIAL_ECHOPGM("s2ga\t");             drv_status_loop(TMC_S2GA);
  11066                  SERIAL_ECHOPGM("otpw\t");             drv_status_loop(TMC_DRV_OTPW);
  11067                  SERIAL_ECHOPGM("ot\t");               drv_status_loop(TMC_OT);
  11068                  #if ENABLED(HAVE_TMC2208)
  11069                    SERIAL_ECHOPGM("157C\t");           drv_status_loop(TMC_T157);
  11070                    SERIAL_ECHOPGM("150C\t");           drv_status_loop(TMC_T150);
  11071                    SERIAL_ECHOPGM("143C\t");           drv_status_loop(TMC_T143);
  11072                    SERIAL_ECHOPGM("120C\t");           drv_status_loop(TMC_T120);
  11073                    SERIAL_ECHOPGM("s2vsa\t");          drv_status_loop(TMC_S2VSA);
  11074                    SERIAL_ECHOPGM("s2vsb\t");          drv_status_loop(TMC_S2VSB);
  11075                  #endif
  11076                  SERIAL_ECHOLNPGM("Driver registers:");drv_status_loop(TMC_DRV_STATUS_HEX);
  11077                }
  11078              }
  11079            #endif
  11080          
  11081            template<typename TMC>
  11082            static void tmc_get_current(TMC &st, const char name[]) {
  11083              SERIAL_ECHO(name);
  11084              SERIAL_ECHOPGM(" axis driver current: ");
  11085              SERIAL_ECHOLN(st.getCurrent());
  11086            }
  11087            template<typename TMC>
  11088            static void tmc_set_current(TMC &st, const char name[], const int mA) {
  11089              st.setCurrent(mA, R_SENSE, HOLD_MULTIPLIER);
  11090              tmc_get_current(st, name);
  11091            }
  11092          
  11093            template<typename TMC>
  11094            static void tmc_report_otpw(TMC &st, const char name[]) {
  11095              SERIAL_ECHO(name);
  11096              SERIAL_ECHOPGM(" axis temperature prewarn triggered: ");
  11097              serialprintPGM(st.getOTPW() ? PSTR("true") : PSTR("false"));
  11098              SERIAL_EOL();
  11099            }
  11100            template<typename TMC>
  11101            static void tmc_clear_otpw(TMC &st, const char name[]) {
  11102              st.clear_otpw();
  11103              SERIAL_ECHO(name);
  11104              SERIAL_ECHOLNPGM(" prewarn flag cleared");
  11105            }
  11106          
  11107            template<typename TMC>
  11108            static void tmc_get_pwmthrs(TMC &st, const char name[], const uint16_t spmm) {
  11109              SERIAL_ECHO(name);
  11110              SERIAL_ECHOPGM(" stealthChop max speed set to ");
  11111              SERIAL_ECHOLN(12650000UL * st.microsteps() / (256 * st.TPWMTHRS() * spmm));
  11112            }
  11113            template<typename TMC>
  11114            static void tmc_set_pwmthrs(TMC &st, const char name[], const int32_t thrs, const uint32_t spmm) {
  11115              st.TPWMTHRS(12650000UL * st.microsteps() / (256 * thrs * spmm));
  11116              tmc_get_pwmthrs(st, name, spmm);
  11117            }
  11118          
  11119            template<typename TMC>
  11120            static void tmc_get_sgt(TMC &st, const char name[]) {
  11121              SERIAL_ECHO(name);
  11122              SERIAL_ECHOPGM(" driver homing sensitivity set to ");
  11123              MYSERIAL.println(st.sgt(), DEC);
  11124            }
  11125            template<typename TMC>
  11126            static void tmc_set_sgt(TMC &st, const char name[], const int8_t sgt_val) {
  11127              st.sgt(sgt_val);
  11128              tmc_get_sgt(st, name);
  11129            }
  11130          
  11131            /**
  11132             * M906: Set motor current in milliamps using axis codes X, Y, Z, E
  11133             * Report driver currents when no axis specified
  11134             */
  11135            inline void gcode_M906() {
  11136              uint16_t values[XYZE];
  11137              LOOP_XYZE(i)
  11138                values[i] = parser.intval(axis_codes[i]);
  11139          
  11140              #if X_IS_TRINAMIC
  11141                if (values[X_AXIS]) tmc_set_current(stepperX, extended_axis_codes[TMC_X], values[X_AXIS]);
  11142                else tmc_get_current(stepperX, extended_axis_codes[TMC_X]);
  11143              #endif
  11144              #if X2_IS_TRINAMIC
  11145                if (values[X_AXIS]) tmc_set_current(stepperX2, extended_axis_codes[TMC_X2], values[X_AXIS]);
  11146                else tmc_get_current(stepperX2, extended_axis_codes[TMC_X2]);
  11147              #endif
  11148              #if Y_IS_TRINAMIC
  11149                if (values[Y_AXIS]) tmc_set_current(stepperY, extended_axis_codes[TMC_Y], values[Y_AXIS]);
  11150                else tmc_get_current(stepperY, extended_axis_codes[TMC_Y]);
  11151              #endif
  11152              #if Y2_IS_TRINAMIC
  11153                if (values[Y_AXIS]) tmc_set_current(stepperY2, extended_axis_codes[TMC_Y2], values[Y_AXIS]);
  11154                else tmc_get_current(stepperY2, extended_axis_codes[TMC_Y2]);
  11155              #endif
  11156              #if Z_IS_TRINAMIC
  11157                if (values[Z_AXIS]) tmc_set_current(stepperZ, extended_axis_codes[TMC_Z], values[Z_AXIS]);
  11158                else tmc_get_current(stepperZ, extended_axis_codes[TMC_Z]);
  11159              #endif
  11160              #if Z2_IS_TRINAMIC
  11161                if (values[Z_AXIS]) tmc_set_current(stepperZ2, extended_axis_codes[TMC_Z2], values[Z_AXIS]);
  11162                else tmc_get_current(stepperZ2, extended_axis_codes[TMC_Z2]);
  11163              #endif
  11164              #if E0_IS_TRINAMIC
  11165                if (values[E_AXIS]) tmc_set_current(stepperE0, extended_axis_codes[TMC_E0], values[E_AXIS]);
  11166                else tmc_get_current(stepperE0, extended_axis_codes[TMC_E0]);
  11167              #endif
  11168              #if E1_IS_TRINAMIC
  11169                if (values[E_AXIS]) tmc_set_current(stepperE1, extended_axis_codes[TMC_E1], values[E_AXIS]);
  11170                else tmc_get_current(stepperE1, extended_axis_codes[TMC_E1]);
  11171              #endif
  11172              #if E2_IS_TRINAMIC
  11173                if (values[E_AXIS]) tmc_set_current(stepperE2, extended_axis_codes[TMC_E2], values[E_AXIS]);
  11174                else tmc_get_current(stepperE2, extended_axis_codes[TMC_E2]);
  11175              #endif
  11176              #if E3_IS_TRINAMIC
  11177                if (values[E_AXIS]) tmc_set_current(stepperE3, extended_axis_codes[TMC_E3], values[E_AXIS]);
  11178                else tmc_get_current(stepperE3, extended_axis_codes[TMC_E3]);
  11179              #endif
  11180              #if E4_IS_TRINAMIC
  11181                if (values[E_AXIS]) tmc_set_current(stepperE4, extended_axis_codes[TMC_E4], values[E_AXIS]);
  11182                else tmc_get_current(stepperE4, extended_axis_codes[TMC_E4]);
  11183              #endif
  11184          
  11185            }
  11186          
  11187            /**
  11188             * M911: Report TMC stepper driver overtemperature pre-warn flag
  11189             * The flag is held by the library and persist until manually cleared by M912
  11190             */
  11191            inline void gcode_M911() {
  11192              #if ENABLED(X_IS_TMC2130) || (ENABLED(X_IS_TMC2208) && PIN_EXISTS(X_SERIAL_RX)) || ENABLED(IS_TRAMS)
  11193                tmc_report_otpw(stepperX, extended_axis_codes[TMC_X]);
  11194              #endif
  11195              #if ENABLED(Y_IS_TMC2130) || (ENABLED(Y_IS_TMC2208) && PIN_EXISTS(Y_SERIAL_RX)) || ENABLED(IS_TRAMS)
  11196                tmc_report_otpw(stepperY, extended_axis_codes[TMC_Y]);
  11197              #endif
  11198              #if ENABLED(Z_IS_TMC2130) || (ENABLED(Z_IS_TMC2208) && PIN_EXISTS(Z_SERIAL_RX)) || ENABLED(IS_TRAMS)
  11199                tmc_report_otpw(stepperZ, extended_axis_codes[TMC_Z]);
  11200              #endif
  11201              #if ENABLED(E0_IS_TMC2130) || (ENABLED(E0_IS_TMC2208) && PIN_EXISTS(E0_SERIAL_RX)) || ENABLED(IS_TRAMS)
  11202                tmc_report_otpw(stepperE0, extended_axis_codes[TMC_E0]);
  11203              #endif
  11204            }
  11205          
  11206            /**
  11207             * M912: Clear TMC stepper driver overtemperature pre-warn flag held by the library
  11208             */
  11209            inline void gcode_M912() {
  11210              const bool clearX = parser.seen(axis_codes[X_AXIS]), clearY = parser.seen(axis_codes[Y_AXIS]), clearZ = parser.seen(axis_codes[Z_AXIS]), clearE = parser.seen(axis_codes[E_AXIS]),
  11211                       clearAll = (!clearX && !clearY && !clearZ && !clearE) || (clearX && clearY && clearZ && clearE);
  11212              #if ENABLED(X_IS_TMC2130) || ENABLED(IS_TRAMS) || (ENABLED(X_IS_TMC2208) && PIN_EXISTS(X_SERIAL_RX))
  11213                if (clearX || clearAll) tmc_clear_otpw(stepperX, extended_axis_codes[TMC_X]);
  11214              #endif
  11215              #if ENABLED(X2_IS_TMC2130) || (ENABLED(X2_IS_TMC2208) && PIN_EXISTS(X_SERIAL_RX))
  11216                if (clearX || clearAll) tmc_clear_otpw(stepperX, extended_axis_codes[TMC_X]);
  11217              #endif
  11218          
  11219              #if ENABLED(Y_IS_TMC2130) || (ENABLED(Y_IS_TMC2208) && PIN_EXISTS(Y_SERIAL_RX))
  11220                if (clearY || clearAll) tmc_clear_otpw(stepperY, extended_axis_codes[TMC_Y]);
  11221              #endif
  11222          
  11223              #if ENABLED(Z_IS_TMC2130) || (ENABLED(Z_IS_TMC2208) && PIN_EXISTS(Z_SERIAL_RX))
  11224                if (clearZ || clearAll) tmc_clear_otpw(stepperZ, extended_axis_codes[TMC_Z]);
  11225              #endif
  11226          
  11227              #if ENABLED(E0_IS_TMC2130) || (ENABLED(E0_IS_TMC2208) && PIN_EXISTS(E0_SERIAL_RX))
  11228                if (clearE || clearAll) tmc_clear_otpw(stepperE0, extended_axis_codes[TMC_E0]);
  11229              #endif
  11230            }
  11231          
  11232            /**
  11233             * M913: Set HYBRID_THRESHOLD speed.
  11234             */
  11235            #if ENABLED(HYBRID_THRESHOLD)
  11236              inline void gcode_M913() {
  11237                uint16_t values[XYZE];
  11238                LOOP_XYZE(i)
  11239                  values[i] = parser.intval(axis_codes[i]);
  11240          
  11241                #if X_IS_TRINAMIC
  11242                  if (values[X_AXIS]) tmc_set_pwmthrs(stepperX, extended_axis_codes[TMC_X], values[X_AXIS], planner.axis_steps_per_mm[X_AXIS]);
  11243                  else tmc_get_pwmthrs(stepperX, extended_axis_codes[TMC_X], planner.axis_steps_per_mm[X_AXIS]);
  11244                #endif
  11245                #if X2_IS_TRINAMIC
  11246                  if (values[X_AXIS]) tmc_set_pwmthrs(stepperX2, extended_axis_codes[TMC_X2], values[X_AXIS], planner.axis_steps_per_mm[X_AXIS]);
  11247                  else tmc_get_pwmthrs(stepperX, extended_axis_codes[TMC_X2], planner.axis_steps_per_mm[X_AXIS]);
  11248                #endif
  11249          
  11250                #if Y_IS_TRINAMIC
  11251                  if (values[Y_AXIS]) tmc_set_pwmthrs(stepperY, extended_axis_codes[TMC_Y], values[Y_AXIS], planner.axis_steps_per_mm[Y_AXIS]);
  11252                  else tmc_get_pwmthrs(stepperY, extended_axis_codes[TMC_Y], planner.axis_steps_per_mm[Y_AXIS]);
  11253                #endif
  11254                #if Y2_IS_TRINAMIC
  11255                  if (values[Y_AXIS]) tmc_set_pwmthrs(stepperY2, extended_axis_codes[TMC_Y2], values[Y_AXIS], planner.axis_steps_per_mm[Y_AXIS]);
  11256                  else tmc_get_pwmthrs(stepperY, extended_axis_codes[TMC_Y2], planner.axis_steps_per_mm[Y_AXIS]);
  11257                #endif
  11258          
  11259                #if Z_IS_TRINAMIC
  11260                  if (values[Z_AXIS]) tmc_set_pwmthrs(stepperZ, extended_axis_codes[TMC_Z], values[Z_AXIS], planner.axis_steps_per_mm[Z_AXIS]);
  11261                  else tmc_get_pwmthrs(stepperZ, extended_axis_codes[TMC_Z], planner.axis_steps_per_mm[Z_AXIS]);
  11262                #endif
  11263                #if Z2_IS_TRINAMIC
  11264                  if (values[Z_AXIS]) tmc_set_pwmthrs(stepperZ2, extended_axis_codes[TMC_Z2], values[Z_AXIS], planner.axis_steps_per_mm[Z_AXIS]);
  11265                  else tmc_get_pwmthrs(stepperZ, extended_axis_codes[TMC_Z2], planner.axis_steps_per_mm[Z_AXIS]);
  11266                #endif
  11267          
  11268                #if E0_IS_TRINAMIC
  11269                  if (values[E_AXIS]) tmc_set_pwmthrs(stepperE0, extended_axis_codes[TMC_E0], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
  11270                  else tmc_get_pwmthrs(stepperE0, extended_axis_codes[TMC_E0], planner.axis_steps_per_mm[E_AXIS]);
  11271                #endif
  11272                #if E1_IS_TRINAMIC
  11273                  if (values[E_AXIS]) tmc_set_pwmthrs(stepperE1, extended_axis_codes[TMC_E1], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
  11274                  else tmc_get_pwmthrs(stepperE1, extended_axis_codes[TMC_E1], planner.axis_steps_per_mm[E_AXIS]);
  11275                #endif
  11276                #if E2_IS_TRINAMIC
  11277                  if (values[E_AXIS]) tmc_set_pwmthrs(stepperE2, extended_axis_codes[TMC_E2], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
  11278                  else tmc_get_pwmthrs(stepperE2, extended_axis_codes[TMC_E2], planner.axis_steps_per_mm[E_AXIS]);
  11279                #endif
  11280                #if E3_IS_TRINAMIC
  11281                  if (values[E_AXIS]) tmc_set_pwmthrs(stepperE3, extended_axis_codes[TMC_E3], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
  11282                  else tmc_get_pwmthrs(stepperE3, extended_axis_codes[TMC_E3], planner.axis_steps_per_mm[E_AXIS]);
  11283                #endif
  11284                #if E4_IS_TRINAMIC
  11285                  if (values[E_AXIS]) tmc_set_pwmthrs(stepperE4, extended_axis_codes[TMC_E4], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
  11286                  else tmc_get_pwmthrs(stepperE4, extended_axis_codes[TMC_E4], planner.axis_steps_per_mm[E_AXIS]);
  11287                #endif
  11288              }
  11289            #endif // HYBRID_THRESHOLD
  11290          
  11291            /**
  11292             * M914: Set SENSORLESS_HOMING sensitivity.
  11293             */
  11294            #if ENABLED(SENSORLESS_HOMING)
  11295              inline void gcode_M914() {
  11296                #if ENABLED(X_IS_TMC2130) || ENABLED(IS_TRAMS)
  11297                  if (parser.seen(axis_codes[X_AXIS])) tmc_set_sgt(stepperX, extended_axis_codes[TMC_X], parser.value_int());
  11298                  else tmc_get_sgt(stepperX, extended_axis_codes[TMC_X]);
  11299                #endif
  11300                #if ENABLED(X2_IS_TMC2130)
  11301                  if (parser.seen(axis_codes[X_AXIS])) tmc_set_sgt(stepperX2, extended_axis_codes[TMC_X2], parser.value_int());
  11302                  else tmc_get_sgt(stepperX2, extended_axis_codes[TMC_X2]);
  11303                #endif
  11304                #if ENABLED(Y_IS_TMC2130) || ENABLED(IS_TRAMS)
  11305                  if (parser.seen(axis_codes[Y_AXIS])) tmc_set_sgt(stepperY, extended_axis_codes[TMC_Y], parser.value_int());
  11306                  else tmc_get_sgt(stepperY, extended_axis_codes[TMC_Y]);
  11307                #endif
  11308                #if ENABLED(Y2_IS_TMC2130)
  11309                  if (parser.seen(axis_codes[Y_AXIS])) tmc_set_sgt(stepperY2, extended_axis_codes[TMC_Y2], parser.value_int());
  11310                  else tmc_get_sgt(stepperY2, extended_axis_codes[TMC_Y2]);
  11311                #endif
  11312              }
  11313            #endif // SENSORLESS_HOMING
  11314          
  11315            /**
  11316             * TMC Z axis calibration routine
  11317             */
  11318            #if ENABLED(TMC_Z_CALIBRATION) && (Z_IS_TRINAMIC || Z2_IS_TRINAMIC)
  11319              inline void gcode_M915() {
  11320                uint16_t _rms = parser.seenval('S') ? parser.value_int() : CALIBRATION_CURRENT;
  11321                uint16_t _z = parser.seenval('Z') ? parser.value_int() : CALIBRATION_EXTRA_HEIGHT;
  11322          
  11323                if (!axis_known_position[Z_AXIS]) {
  11324                  SERIAL_ECHOLNPGM("\nPlease home Z axis first");
  11325                  return;
  11326                }
  11327          
  11328                uint16_t Z_current_1 = stepperZ.getCurrent();
  11329                uint16_t Z2_current_1 = stepperZ.getCurrent();
  11330          
  11331                stepperZ.setCurrent(_rms, R_SENSE, HOLD_MULTIPLIER);
  11332                stepperZ2.setCurrent(_rms, R_SENSE, HOLD_MULTIPLIER);
  11333                SERIAL_ECHOPAIR("\nCalibration current: Z", _rms);
  11334          
  11335                soft_endstops_enabled = false;
  11336          
  11337                do_blocking_move_to_z(Z_MAX_POS+_z);
  11338          
  11339                stepperZ.setCurrent(Z_current_1, R_SENSE, HOLD_MULTIPLIER);
  11340                stepperZ2.setCurrent(Z2_current_1, R_SENSE, HOLD_MULTIPLIER);
  11341          
  11342                do_blocking_move_to_z(Z_MAX_POS);
  11343                soft_endstops_enabled = true;
  11344          
  11345                SERIAL_ECHOLNPGM("\nHoming Z because we lost steps");
  11346                home_z_safely();
  11347              }
  11348            #endif
  11349          
  11350          #endif // HAS_TRINAMIC
  11351          
  11352          /**
  11353           * M907: Set digital trimpot motor current using axis codes X, Y, Z, E, B, S
  11354           */

   \                                 In section .text, align 2
  11355          inline void gcode_M907() {
  11356            #if HAS_DIGIPOTSS
  11357          
  11358              LOOP_XYZE(i) if (parser.seen(axis_codes[i])) stepper.digipot_current(i, parser.value_int());
  11359              if (parser.seen('B')) stepper.digipot_current(4, parser.value_int());
  11360              if (parser.seen('S')) for (uint8_t i = 0; i <= 4; i++) stepper.digipot_current(i, parser.value_int());
  11361          
  11362            #elif HAS_MOTOR_CURRENT_PWM
  11363          
  11364              #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
  11365                if (parser.seen('X')) stepper.digipot_current(0, parser.value_int());
  11366              #endif
  11367              #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
  11368                if (parser.seen('Z')) stepper.digipot_current(1, parser.value_int());
  11369              #endif
  11370              #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
  11371                if (parser.seen('E')) stepper.digipot_current(2, parser.value_int());
  11372              #endif
  11373          
  11374            #endif
  11375          
  11376            #if ENABLED(DIGIPOT_I2C)
  11377              // this one uses actual amps in floating point
  11378              LOOP_XYZE(i) if (parser.seen(axis_codes[i])) digipot_i2c_set_current(i, parser.value_float());
  11379              // for each additional extruder (named B,C,D,E..., channels 4,5,6,7...)
  11380              for (uint8_t i = NUM_AXIS; i < DIGIPOT_I2C_NUM_CHANNELS; i++) if (parser.seen('B' + i - (NUM_AXIS))) digipot_i2c_set_current(i, parser.value_float());
  11381            #endif
  11382          
  11383            #if ENABLED(DAC_STEPPER_CURRENT)
  11384              if (parser.seen('S')) {
  11385                const float dac_percent = parser.value_float();
  11386                for (uint8_t i = 0; i <= 4; i++) dac_current_percent(i, dac_percent);
  11387              }
  11388              LOOP_XYZE(i) if (parser.seen(axis_codes[i])) dac_current_percent(i, parser.value_float());
  11389            #endif
  11390          }
   \                     _Z10gcode_M907v: (+1)
   \   00000000   0x4770             BX       LR               ;; return
  11391          
  11392          #if HAS_DIGIPOTSS || ENABLED(DAC_STEPPER_CURRENT)
  11393          
  11394            /**
  11395             * M908: Control digital trimpot directly (M908 P<pin> S<current>)
  11396             */
  11397            inline void gcode_M908() {
  11398              #if HAS_DIGIPOTSS
  11399                stepper.digitalPotWrite(
  11400                  parser.intval('P'),
  11401                  parser.intval('S')
  11402                );
  11403              #endif
  11404              #ifdef DAC_STEPPER_CURRENT
  11405                dac_current_raw(
  11406                  parser.byteval('P', -1),
  11407                  parser.ushortval('S', 0)
  11408                );
  11409              #endif
  11410            }
  11411          
  11412            #if ENABLED(DAC_STEPPER_CURRENT) // As with Printrbot RevF
  11413          
  11414              inline void gcode_M909() { dac_print_values(); }
  11415          
  11416              inline void gcode_M910() { dac_commit_eeprom(); }
  11417          
  11418            #endif
  11419          
  11420          #endif // HAS_DIGIPOTSS || DAC_STEPPER_CURRENT
  11421          
  11422          #if HAS_MICROSTEPS
  11423          
  11424            // M350 Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.
  11425            inline void gcode_M350() {
  11426              if (parser.seen('S')) for (int i = 0; i <= 4; i++) stepper.microstep_mode(i, parser.value_byte());
  11427              LOOP_XYZE(i) if (parser.seen(axis_codes[i])) stepper.microstep_mode(i, parser.value_byte());
  11428              if (parser.seen('B')) stepper.microstep_mode(4, parser.value_byte());
  11429              stepper.microstep_readings();
  11430            }
  11431          
  11432            /**
  11433             * M351: Toggle MS1 MS2 pins directly with axis codes X Y Z E B
  11434             *       S# determines MS1 or MS2, X# sets the pin high/low.
  11435             */
  11436            inline void gcode_M351() {
  11437              if (parser.seenval('S')) switch (parser.value_byte()) {
  11438                case 1:
  11439                  LOOP_XYZE(i) if (parser.seenval(axis_codes[i])) stepper.microstep_ms(i, parser.value_byte(), -1);
  11440                  if (parser.seenval('B')) stepper.microstep_ms(4, parser.value_byte(), -1);
  11441                  break;
  11442                case 2:
  11443                  LOOP_XYZE(i) if (parser.seenval(axis_codes[i])) stepper.microstep_ms(i, -1, parser.value_byte());
  11444                  if (parser.seenval('B')) stepper.microstep_ms(4, -1, parser.value_byte());
  11445                  break;
  11446              }
  11447              stepper.microstep_readings();
  11448            }
  11449          
  11450          #endif // HAS_MICROSTEPS
  11451          
  11452          #if HAS_CASE_LIGHT
  11453            #ifndef INVERT_CASE_LIGHT
  11454              #define INVERT_CASE_LIGHT false
  11455            #endif
  11456            uint8_t case_light_brightness;  // LCD routine wants INT
  11457            bool case_light_on;
  11458          
  11459            void update_case_light() {
  11460              pinMode(CASE_LIGHT_PIN, OUTPUT); // digitalWrite doesn't set the port mode
  11461              if (case_light_on) {
  11462                if (USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN))
  11463                  analogWrite(CASE_LIGHT_PIN, INVERT_CASE_LIGHT ? 255 - case_light_brightness : case_light_brightness);
  11464                else
  11465                  WRITE(CASE_LIGHT_PIN, INVERT_CASE_LIGHT ? LOW : HIGH);
  11466              }
  11467              else {
  11468                if (USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN))
  11469                  analogWrite(CASE_LIGHT_PIN, INVERT_CASE_LIGHT ? 255 : 0);
  11470                else
  11471                  WRITE(CASE_LIGHT_PIN, INVERT_CASE_LIGHT ? HIGH : LOW);
  11472              }
  11473            }
  11474          #endif // HAS_CASE_LIGHT
  11475          
  11476          /**
  11477           * M355: Turn case light on/off and set brightness
  11478           *
  11479           *   P<byte>  Set case light brightness (PWM pin required - ignored otherwise)
  11480           *
  11481           *   S<bool>  Set case light on/off
  11482           *
  11483           *   When S turns on the light on a PWM pin then the current brightness level is used/restored
  11484           *
  11485           *   M355 P200 S0 turns off the light & sets the brightness level
  11486           *   M355 S1 turns on the light with a brightness of 200 (assuming a PWM pin)
  11487           */

   \                                 In section .text, align 4
  11488          inline void gcode_M355() {
   \                     _Z10gcode_M355v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  11489            #if HAS_CASE_LIGHT
  11490              uint8_t args = 0;
  11491              if (parser.seenval('P')) ++args, case_light_brightness = parser.value_byte();
  11492              if (parser.seenval('S')) ++args, case_light_on = parser.value_bool();
  11493              if (args) update_case_light();
  11494          
  11495              // always report case light status
  11496              SERIAL_ECHO_START();
  11497              if (!case_light_on) {
  11498                SERIAL_ECHOLN("Case light: off");
  11499              }
  11500              else {
  11501                if (!USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN)) SERIAL_ECHOLN("Case light: on");
  11502                else SERIAL_ECHOLNPAIR("Case light: ", (int)case_light_brightness);
  11503              }
  11504          
  11505            #else
  11506              SERIAL_ERROR_START();
   \   00000002   0x4804             LDR.N    R0,??gcode_M355_0
   \   00000004   0x.... 0x....      BL       _Z14serialprintPGMPKc
  11507              SERIAL_ERRORLNPGM(MSG_ERR_M355_NONE);
   \   00000008   0x4803             LDR.N    R0,??gcode_M355_0+0x4
   \   0000000A   0xE8BD 0x4002      POP      {R1,LR}
   \   0000000E   0x.... 0x....      B.W      _Z14serialprintPGMPKc
   \   00000012   0xBF00             Nop      
   \                     ??gcode_M355_0:
   \   00000014   0x........         DC32     errormagic
   \   00000018   0x........         DC32     _ZZ10gcode_M355vEs
  11508            #endif // HAS_CASE_LIGHT
  11509          }
  11510          
  11511          #if ENABLED(MIXING_EXTRUDER)
  11512          
  11513            /**
  11514             * M163: Set a single mix factor for a mixing extruder
  11515             *       This is called "weight" by some systems.
  11516             *
  11517             *   S[index]   The channel index to set
  11518             *   P[float]   The mix value
  11519             *
  11520             */
  11521            inline void gcode_M163() {
  11522              const int mix_index = parser.intval('S');
  11523              if (mix_index < MIXING_STEPPERS) {
  11524                float mix_value = parser.floatval('P');
  11525                NOLESS(mix_value, 0.0);
  11526                mixing_factor[mix_index] = RECIPROCAL(mix_value);
  11527              }
  11528            }
  11529          
  11530            #if MIXING_VIRTUAL_TOOLS > 1
  11531          
  11532              /**
  11533               * M164: Store the current mix factors as a virtual tool.
  11534               *
  11535               *   S[index]   The virtual tool to store
  11536               *
  11537               */
  11538              inline void gcode_M164() {
  11539                const int tool_index = parser.intval('S');
  11540                if (tool_index < MIXING_VIRTUAL_TOOLS) {
  11541                  normalize_mix();
  11542                  for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
  11543                    mixing_virtual_tool_mix[tool_index][i] = mixing_factor[i];
  11544                }
  11545              }
  11546          
  11547            #endif
  11548          
  11549            #if ENABLED(DIRECT_MIXING_IN_G1)
  11550              /**
  11551               * M165: Set multiple mix factors for a mixing extruder.
  11552               *       Factors that are left out will be set to 0.
  11553               *       All factors together must add up to 1.0.
  11554               *
  11555               *   A[factor] Mix factor for extruder stepper 1
  11556               *   B[factor] Mix factor for extruder stepper 2
  11557               *   C[factor] Mix factor for extruder stepper 3
  11558               *   D[factor] Mix factor for extruder stepper 4
  11559               *   H[factor] Mix factor for extruder stepper 5
  11560               *   I[factor] Mix factor for extruder stepper 6
  11561               *
  11562               */
  11563              inline void gcode_M165() { gcode_get_mix(); }
  11564            #endif
  11565          
  11566          #endif // MIXING_EXTRUDER
  11567          
  11568          /**
  11569           * M999: Restart after being stopped
  11570           *
  11571           * Default behaviour is to flush the serial buffer and request
  11572           * a resend to the host starting on the last N line received.
  11573           *
  11574           * Sending "M999 S1" will resume printing without flushing the
  11575           * existing command buffer.
  11576           *
  11577           */

   \                                 In section .text, align 4
  11578          inline void gcode_M999() {
   \                     _Z10gcode_M999v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  11579            Running = true;
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x4906             LDR.N    R1,??gcode_M999_0
   \   00000006   0x7388             STRB     R0,[R1, #+14]
  11580            lcd_reset_alert_level();
   \   00000008   0x.... 0x....      BL       _Z21lcd_reset_alert_levelv
  11581          
  11582            if (parser.boolval('S')) return;
   \   0000000C   0x2053             MOVS     R0,#+83
   \   0000000E   0x.... 0x....      BL       _ZN11GCodeParser7boolvalEc
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD103             BNE.N    ??gcode_M999_1
  11583          
  11584            // gcode_LastN = Stopped_gcode_LastN;
  11585            FlushSerialRequestResend();
   \   00000016   0xE8BD 0x4001      POP      {R0,LR}
   \   0000001A   0x.... 0x....      B.W      _Z24FlushSerialRequestResendv
   \                     ??gcode_M999_1: (+1)
   \   0000001E   0xBD01             POP      {R0,PC}          ;; return
   \                     ??gcode_M999_0:
   \   00000020   0x........         DC32     axis_relative_modes
  11586          }
  11587          
  11588          #if ENABLED(SWITCHING_EXTRUDER)
  11589            #if EXTRUDERS > 3
  11590              #define REQ_ANGLES 4
  11591              #define _SERVO_NR (e < 2 ? SWITCHING_EXTRUDER_SERVO_NR : SWITCHING_EXTRUDER_E23_SERVO_NR)
  11592            #else
  11593              #define REQ_ANGLES 2
  11594              #define _SERVO_NR SWITCHING_EXTRUDER_SERVO_NR
  11595            #endif
  11596            inline void move_extruder_servo(const uint8_t e) {
  11597              constexpr int16_t angles[] = SWITCHING_EXTRUDER_SERVO_ANGLES;
  11598              static_assert(COUNT(angles) == REQ_ANGLES, "SWITCHING_EXTRUDER_SERVO_ANGLES needs " STRINGIFY(REQ_ANGLES) " angles.");
  11599              stepper.synchronize();
  11600              #if EXTRUDERS & 1
  11601                if (e < EXTRUDERS - 1)
  11602              #endif
  11603              {
  11604                MOVE_SERVO(_SERVO_NR, angles[e]);
  11605                safe_delay(500);
  11606              }
  11607            }
  11608          #endif // SWITCHING_EXTRUDER
  11609          
  11610          #if ENABLED(SWITCHING_NOZZLE)
  11611            inline void move_nozzle_servo(const uint8_t e) {
  11612              const int16_t angles[2] = SWITCHING_NOZZLE_SERVO_ANGLES;
  11613              stepper.synchronize();
  11614              MOVE_SERVO(SWITCHING_NOZZLE_SERVO_NR, angles[e]);
  11615              safe_delay(500);
  11616            }
  11617          #endif
  11618          

   \                                 In section .text, align 4
  11619          inline void invalid_extruder_error(const uint8_t e) {
   \                     _Z22invalid_extruder_errorh: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
  11620            SERIAL_ECHO_START();
   \   00000004   0x480D             LDR.N    R0,??invalid_extruder_error_0
   \   00000006   0x.... 0x....      BL       _Z14serialprintPGMPKc
  11621            SERIAL_CHAR('T');
   \   0000000A   0x4D0D             LDR.N    R5,??invalid_extruder_error_0+0x4
   \   0000000C   0x2154             MOVS     R1,#+84
   \   0000000E   0x4628             MOV      R0,R5
   \   00000010   0x.... 0x....      BL       _ZN10USARTClass5writeEh
  11622            SERIAL_ECHO_F(e, DEC);
   \   00000014   0x220A             MOVS     R2,#+10
   \   00000016   0x4621             MOV      R1,R4
   \   00000018   0x4628             MOV      R0,R5
   \   0000001A   0x.... 0x....      BL       _ZN5Print5printEhi
  11623            SERIAL_CHAR(' ');
   \   0000001E   0x2120             MOVS     R1,#+32
   \   00000020   0x4628             MOV      R0,R5
   \   00000022   0x.... 0x....      BL       _ZN10USARTClass5writeEh
  11624            SERIAL_ECHOLN(MSG_INVALID_EXTRUDER);
   \   00000026   0x4907             LDR.N    R1,??invalid_extruder_error_0+0x8
   \   00000028   0x4628             MOV      R0,R5
   \   0000002A   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   0000002E   0x210A             MOVS     R1,#+10
   \   00000030   0x4628             MOV      R0,R5
   \   00000032   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000036   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   \   0000003A   0xBF00             Nop      
   \                     ??invalid_extruder_error_0:
   \   0000003C   0x........         DC32     echomagic
   \   00000040   0x........         DC32     Serial6
   \   00000044   0x........         DC32     _ZZ22invalid_extruder_errorhEs
  11625          }
  11626          
  11627          #if ENABLED(PARKING_EXTRUDER)
  11628          
  11629            #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
  11630              #define PE_MAGNET_ON_STATE !PARKING_EXTRUDER_SOLENOIDS_PINS_ACTIVE
  11631            #else
  11632              #define PE_MAGNET_ON_STATE PARKING_EXTRUDER_SOLENOIDS_PINS_ACTIVE
  11633            #endif
  11634          
  11635            void pe_set_magnet(const uint8_t extruder_num, const uint8_t state) {
  11636              switch (extruder_num) {
  11637                case 1: OUT_WRITE(SOL1_PIN, state); break;
  11638                default: OUT_WRITE(SOL0_PIN, state); break;
  11639              }
  11640              #if PARKING_EXTRUDER_SOLENOIDS_DELAY > 0
  11641                dwell(PARKING_EXTRUDER_SOLENOIDS_DELAY);
  11642              #endif
  11643            }
  11644          
  11645            inline void pe_activate_magnet(const uint8_t extruder_num) { pe_set_magnet(extruder_num, PE_MAGNET_ON_STATE); }
  11646            inline void pe_deactivate_magnet(const uint8_t extruder_num) { pe_set_magnet(extruder_num, !PE_MAGNET_ON_STATE); }
  11647          
  11648          #endif // PARKING_EXTRUDER
  11649          
  11650          #if HAS_FANMUX
  11651          
  11652            void fanmux_switch(const uint8_t e) {
  11653              WRITE(FANMUX0_PIN, TEST(e, 0) ? HIGH : LOW);
  11654              #if PIN_EXISTS(FANMUX1)
  11655                WRITE(FANMUX1_PIN, TEST(e, 1) ? HIGH : LOW);
  11656                #if PIN_EXISTS(FANMUX2)
  11657                  WRITE(FANMUX2, TEST(e, 2) ? HIGH : LOW);
  11658                #endif
  11659              #endif
  11660            }
  11661          
  11662            FORCE_INLINE void fanmux_init(void) {
  11663              SET_OUTPUT(FANMUX0_PIN);
  11664              #if PIN_EXISTS(FANMUX1)
  11665                SET_OUTPUT(FANMUX1_PIN);
  11666                #if PIN_EXISTS(FANMUX2)
  11667                  SET_OUTPUT(FANMUX2_PIN);
  11668                #endif
  11669              #endif
  11670              fanmux_switch(0);
  11671            }
  11672          
  11673          #endif // HAS_FANMUX
  11674          
  11675          /**
  11676           * Perform a tool-change, which may result in moving the
  11677           * previous tool out of the way and the new tool into place.
  11678           */

   \                                 In section .text, align 2, keep-with-next
  11679          void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
   \                     _Z11tool_changehfb: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
  11680            #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
  11681          
  11682              if (tmp_extruder >= MIXING_VIRTUAL_TOOLS)
  11683                return invalid_extruder_error(tmp_extruder);
  11684          
  11685              // T0-Tnnn: Switch virtual tool by changing the mix
  11686              for (uint8_t j = 0; j < MIXING_STEPPERS; j++)
  11687                mixing_factor[j] = mixing_virtual_tool_mix[tmp_extruder][j];
  11688          
  11689            #else // !MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
  11690          
  11691              if (tmp_extruder >= EXTRUDERS)
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD003             BEQ.N    ??tool_change_0
  11692                return invalid_extruder_error(tmp_extruder);
   \   00000006   0xE8BD 0x4010      POP      {R4,LR}
   \   0000000A   0x.... 0x....      B.W      _Z22invalid_extruder_errorh
  11693          
  11694              #if HOTENDS > 1
  11695          
  11696                const float old_feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : feedrate_mm_s;
  11697          
  11698                feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
  11699          
  11700                if (tmp_extruder != active_extruder) {
  11701                  if (!no_move && axis_unhomed_error()) {
  11702                    no_move = true;
  11703                    #if ENABLED(DEBUG_LEVELING_FEATURE)
  11704                      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("No move on toolchange");
  11705                    #endif
  11706                  }
  11707          
  11708                  // Save current position to destination, for use later
  11709                  set_destination_from_current();
  11710          
  11711                  #if ENABLED(DUAL_X_CARRIAGE)
  11712          
  11713                    #if ENABLED(DEBUG_LEVELING_FEATURE)
  11714                      if (DEBUGGING(LEVELING)) {
  11715                        SERIAL_ECHOPGM("Dual X Carriage Mode ");
  11716                        switch (dual_x_carriage_mode) {
  11717                          case DXC_FULL_CONTROL_MODE: SERIAL_ECHOLNPGM("DXC_FULL_CONTROL_MODE"); break;
  11718                          case DXC_AUTO_PARK_MODE: SERIAL_ECHOLNPGM("DXC_AUTO_PARK_MODE"); break;
  11719                          case DXC_DUPLICATION_MODE: SERIAL_ECHOLNPGM("DXC_DUPLICATION_MODE"); break;
  11720                        }
  11721                      }
  11722                    #endif
  11723          
  11724                    const float xhome = x_home_pos(active_extruder);
  11725                    if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE
  11726                        && IsRunning()
  11727                        && (delayed_move_time || current_position[X_AXIS] != xhome)
  11728                    ) {
  11729                      float raised_z = current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT;
  11730                      //#if ENABLED(MAX_SOFTWARE_ENDSTOPS)
  11731                      if(mksCfg.max_software_endstops){
  11732                        NOMORE(raised_z, soft_endstop_max[Z_AXIS]);
  11733                      }
  11734                      //#endif
  11735                      #if ENABLED(DEBUG_LEVELING_FEATURE)
  11736                        if (DEBUGGING(LEVELING)) {
  11737                          SERIAL_ECHOLNPAIR("Raise to ", raised_z);
  11738                          SERIAL_ECHOLNPAIR("MoveX to ", xhome);
  11739                          SERIAL_ECHOLNPAIR("Lower to ", current_position[Z_AXIS]);
  11740                        }
  11741                      #endif
  11742                      // Park old head: 1) raise 2) move to park position 3) lower
  11743                      for (uint8_t i = 0; i < 3; i++)
  11744                        planner.buffer_line(
  11745                          i == 0 ? current_position[X_AXIS] : xhome,
  11746                          current_position[Y_AXIS],
  11747                          i == 2 ? current_position[Z_AXIS] : raised_z,
  11748                          current_position[E_AXIS],
  11749                          planner.max_feedrate_mm_s[i == 1 ? X_AXIS : Z_AXIS],
  11750                          active_extruder
  11751                        );
  11752                      stepper.synchronize();
  11753                    }
  11754          
  11755                    // Apply Y & Z extruder offset (X offset is used as home pos with Dual X)
  11756                    current_position[Y_AXIS] -= hotend_offset[Y_AXIS][active_extruder] - hotend_offset[Y_AXIS][tmp_extruder];
  11757                    current_position[Z_AXIS] -= hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
  11758          
  11759                    // Activate the new extruder ahead of calling set_axis_is_at_home!
  11760                    active_extruder = tmp_extruder;
  11761          
  11762                    // This function resets the max/min values - the current position may be overwritten below.
  11763                    set_axis_is_at_home(X_AXIS);
  11764          
  11765                    #if ENABLED(DEBUG_LEVELING_FEATURE)
  11766                      if (DEBUGGING(LEVELING)) DEBUG_POS("New Extruder", current_position);
  11767                    #endif
  11768          
  11769                    // Only when auto-parking are carriages safe to move
  11770                    if (dual_x_carriage_mode != DXC_AUTO_PARK_MODE) no_move = true;
  11771          
  11772                    switch (dual_x_carriage_mode) {
  11773                      case DXC_FULL_CONTROL_MODE:
  11774                        // New current position is the position of the activated extruder
  11775                        current_position[X_AXIS] = inactive_extruder_x_pos;
  11776                        // Save the inactive extruder's position (from the old current_position)
  11777                        inactive_extruder_x_pos = destination[X_AXIS];
  11778                        break;
  11779                      case DXC_AUTO_PARK_MODE:
  11780                        // record raised toolhead position for use by unpark
  11781                        COPY(raised_parked_position, current_position);
  11782                        raised_parked_position[Z_AXIS] += TOOLCHANGE_UNPARK_ZLIFT;
  11783                        //#if ENABLED(MAX_SOFTWARE_ENDSTOPS)
  11784                        if(mksCfg.max_software_endstops){
  11785                          NOMORE(raised_parked_position[Z_AXIS], soft_endstop_max[Z_AXIS]);
  11786                        }
  11787                        //#endif
  11788                        active_extruder_parked = true;
  11789                        delayed_move_time = 0;
  11790                        break;
  11791                      case DXC_DUPLICATION_MODE:
  11792                        // If the new extruder is the left one, set it "parked"
  11793                        // This triggers the second extruder to move into the duplication position
  11794                        active_extruder_parked = (active_extruder == 0);
  11795          
  11796                        if (active_extruder_parked)
  11797                          current_position[X_AXIS] = inactive_extruder_x_pos;
  11798                        else
  11799                          current_position[X_AXIS] = destination[X_AXIS] + duplicate_extruder_x_offset;
  11800                        inactive_extruder_x_pos = destination[X_AXIS];
  11801                        extruder_duplication_enabled = false;
  11802                        #if ENABLED(DEBUG_LEVELING_FEATURE)
  11803                          if (DEBUGGING(LEVELING)) {
  11804                            SERIAL_ECHOLNPAIR("Set inactive_extruder_x_pos=", inactive_extruder_x_pos);
  11805                            SERIAL_ECHOLNPGM("Clear extruder_duplication_enabled");
  11806                          }
  11807                        #endif
  11808                        break;
  11809                    }
  11810          
  11811                    #if ENABLED(DEBUG_LEVELING_FEATURE)
  11812                      if (DEBUGGING(LEVELING)) {
  11813                        SERIAL_ECHOLNPAIR("Active extruder parked: ", active_extruder_parked ? "yes" : "no");
  11814                        DEBUG_POS("New extruder (parked)", current_position);
  11815                      }
  11816                    #endif
  11817          
  11818                    // No extra case for HAS_ABL in DUAL_X_CARRIAGE. Does that mean they don't work together?
  11819          
  11820                  #else // !DUAL_X_CARRIAGE
  11821          
  11822                    #if ENABLED(PARKING_EXTRUDER) // Dual Parking extruder
  11823                      const float z_diff = hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
  11824                      float z_raise = PARKING_EXTRUDER_SECURITY_RAISE;
  11825                      if (!no_move) {
  11826          
  11827                        const float parkingposx[] = PARKING_EXTRUDER_PARKING_X,
  11828                                    midpos = (parkingposx[0] + parkingposx[1]) * 0.5 + hotend_offset[X_AXIS][active_extruder],
  11829                                    grabpos = parkingposx[tmp_extruder] + hotend_offset[X_AXIS][active_extruder]
  11830                                              + (tmp_extruder == 0 ? -(PARKING_EXTRUDER_GRAB_DISTANCE) : PARKING_EXTRUDER_GRAB_DISTANCE);
  11831                        /**
  11832                         *  Steps:
  11833                         *    1. Raise Z-Axis to give enough clearance
  11834                         *    2. Move to park position of old extruder
  11835                         *    3. Disengage magnetic field, wait for delay
  11836                         *    4. Move near new extruder
  11837                         *    5. Engage magnetic field for new extruder
  11838                         *    6. Move to parking incl. offset of new extruder
  11839                         *    7. Lower Z-Axis
  11840                         */
  11841          
  11842                        // STEP 1
  11843                        #if ENABLED(DEBUG_LEVELING_FEATURE)
  11844                          SERIAL_ECHOLNPGM("Starting Autopark");
  11845                          if (DEBUGGING(LEVELING)) DEBUG_POS("current position:", current_position);
  11846                        #endif
  11847                        current_position[Z_AXIS] += z_raise;
  11848                        #if ENABLED(DEBUG_LEVELING_FEATURE)
  11849                          SERIAL_ECHOLNPGM("(1) Raise Z-Axis ");
  11850                          if (DEBUGGING(LEVELING)) DEBUG_POS("Moving to Raised Z-Position", current_position);
  11851                        #endif
  11852                        planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
  11853                        stepper.synchronize();
  11854          
  11855                        // STEP 2
  11856                        current_position[X_AXIS] = parkingposx[active_extruder] + hotend_offset[X_AXIS][active_extruder];
  11857                        #if ENABLED(DEBUG_LEVELING_FEATURE)
  11858                          SERIAL_ECHOLNPAIR("(2) Park extruder ", active_extruder);
  11859                          if (DEBUGGING(LEVELING)) DEBUG_POS("Moving ParkPos", current_position);
  11860                        #endif
  11861                        planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
  11862                        stepper.synchronize();
  11863          
  11864                        // STEP 3
  11865                        #if ENABLED(DEBUG_LEVELING_FEATURE)
  11866                          SERIAL_ECHOLNPGM("(3) Disengage magnet ");
  11867                        #endif
  11868                        pe_deactivate_magnet(active_extruder);
  11869          
  11870                        // STEP 4
  11871                        #if ENABLED(DEBUG_LEVELING_FEATURE)
  11872                          SERIAL_ECHOLNPGM("(4) Move to position near new extruder");
  11873                        #endif
  11874                        current_position[X_AXIS] += (active_extruder == 0 ? 10 : -10); // move 10mm away from parked extruder
  11875          
  11876                        #if ENABLED(DEBUG_LEVELING_FEATURE)
  11877                          if (DEBUGGING(LEVELING)) DEBUG_POS("Moving away from parked extruder", current_position);
  11878                        #endif
  11879                        planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
  11880                        stepper.synchronize();
  11881          
  11882                        // STEP 5
  11883                        #if ENABLED(DEBUG_LEVELING_FEATURE)
  11884                          SERIAL_ECHOLNPGM("(5) Engage magnetic field");
  11885                        #endif
  11886          
  11887                        #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
  11888                          pe_activate_magnet(active_extruder); //just save power for inverted magnets
  11889                        #endif
  11890                        pe_activate_magnet(tmp_extruder);
  11891          
  11892                        // STEP 6
  11893                        current_position[X_AXIS] = grabpos + (tmp_extruder == 0 ? (+10) : (-10));
  11894                        planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
  11895                        current_position[X_AXIS] = grabpos;
  11896                        #if ENABLED(DEBUG_LEVELING_FEATURE)
  11897                          SERIAL_ECHOLNPAIR("(6) Unpark extruder ", tmp_extruder);
  11898                          if (DEBUGGING(LEVELING)) DEBUG_POS("Move UnparkPos", current_position);
  11899                        #endif
  11900                        planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS]/2, active_extruder);
  11901                        stepper.synchronize();
  11902          
  11903                        // Step 7
  11904                        current_position[X_AXIS] = midpos - hotend_offset[X_AXIS][tmp_extruder];
  11905                        #if ENABLED(DEBUG_LEVELING_FEATURE)
  11906                          SERIAL_ECHOLNPGM("(7) Move midway between hotends");
  11907                          if (DEBUGGING(LEVELING)) DEBUG_POS("Move midway to new extruder", current_position);
  11908                        #endif
  11909                        planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
  11910                        stepper.synchronize();
  11911                        #if ENABLED(DEBUG_LEVELING_FEATURE)
  11912                          SERIAL_ECHOLNPGM("Autopark done.");
  11913                        #endif
  11914                      }
  11915                      else { // nomove == true
  11916                        // Only engage magnetic field for new extruder
  11917                        pe_activate_magnet(tmp_extruder);
  11918                        #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
  11919                          pe_activate_magnet(active_extruder); // Just save power for inverted magnets
  11920                        #endif
  11921                      }
  11922                      current_position[Z_AXIS] -= hotend_offset[Z_AXIS][tmp_extruder] - hotend_offset[Z_AXIS][active_extruder]; // Apply Zoffset
  11923          
  11924                      #if ENABLED(DEBUG_LEVELING_FEATURE)
  11925                        if (DEBUGGING(LEVELING)) DEBUG_POS("Applying Z-offset", current_position);
  11926                      #endif
  11927          
  11928                    #endif // dualParking extruder
  11929          
  11930                    #if ENABLED(SWITCHING_NOZZLE)
  11931                      #define DONT_SWITCH (SWITCHING_EXTRUDER_SERVO_NR == SWITCHING_NOZZLE_SERVO_NR)
  11932                      // <0 if the new nozzle is higher, >0 if lower. A bigger raise when lower.
  11933                      const float z_diff = hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder],
  11934                                  z_raise = 0.3 + (z_diff > 0.0 ? z_diff : 0.0);
  11935          
  11936                      // Always raise by some amount (destination copied from current_position earlier)
  11937                      current_position[Z_AXIS] += z_raise;
  11938                      planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
  11939                      move_nozzle_servo(tmp_extruder);
  11940                    #endif
  11941          
  11942                    /**
  11943                     * Set current_position to the position of the new nozzle.
  11944                     * Offsets are based on linear distance, so we need to get
  11945                     * the resulting position in coordinate space.
  11946                     *
  11947                     * - With grid or 3-point leveling, offset XYZ by a tilted vector
  11948                     * - With mesh leveling, update Z for the new position
  11949                     * - Otherwise, just use the raw linear distance
  11950                     *
  11951                     * Software endstops are altered here too. Consider a case where:
  11952                     *   E0 at X=0 ... E1 at X=10
  11953                     * When we switch to E1 now X=10, but E1 can't move left.
  11954                     * To express this we apply the change in XY to the software endstops.
  11955                     * E1 can move farther right than E0, so the right limit is extended.
  11956                     *
  11957                     * Note that we don't adjust the Z software endstops. Why not?
  11958                     * Consider a case where Z=0 (here) and switching to E1 makes Z=1
  11959                     * because the bed is 1mm lower at the new position. As long as
  11960                     * the first nozzle is out of the way, the carriage should be
  11961                     * allowed to move 1mm lower. This technically "breaks" the
  11962                     * Z software endstop. But this is technically correct (and
  11963                     * there is no viable alternative).
  11964                     */
  11965                    #if ABL_PLANAR
  11966                      // Offset extruder, make sure to apply the bed level rotation matrix
  11967                      vector_3 tmp_offset_vec = vector_3(hotend_offset[X_AXIS][tmp_extruder],
  11968                                                         hotend_offset[Y_AXIS][tmp_extruder],
  11969                                                         0),
  11970                               act_offset_vec = vector_3(hotend_offset[X_AXIS][active_extruder],
  11971                                                         hotend_offset[Y_AXIS][active_extruder],
  11972                                                         0),
  11973                               offset_vec = tmp_offset_vec - act_offset_vec;
  11974          
  11975                      #if ENABLED(DEBUG_LEVELING_FEATURE)
  11976                        if (DEBUGGING(LEVELING)) {
  11977                          tmp_offset_vec.debug(PSTR("tmp_offset_vec"));
  11978                          act_offset_vec.debug(PSTR("act_offset_vec"));
  11979                          offset_vec.debug(PSTR("offset_vec (BEFORE)"));
  11980                        }
  11981                      #endif
  11982          
  11983                      offset_vec.apply_rotation(planner.bed_level_matrix.transpose(planner.bed_level_matrix));
  11984          
  11985                      #if ENABLED(DEBUG_LEVELING_FEATURE)
  11986                        if (DEBUGGING(LEVELING)) offset_vec.debug(PSTR("offset_vec (AFTER)"));
  11987                      #endif
  11988          
  11989                      // Adjustments to the current position
  11990                      const float xydiff[2] = { offset_vec.x, offset_vec.y };
  11991                      current_position[Z_AXIS] += offset_vec.z;
  11992          
  11993                    #else // !ABL_PLANAR
  11994          
  11995                      const float xydiff[2] = {
  11996                        hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder],
  11997                        hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder]
  11998                      };
  11999          
  12000                      #if ENABLED(MESH_BED_LEVELING)
  12001          
  12002                        if (planner.leveling_active) {
  12003                          #if ENABLED(DEBUG_LEVELING_FEATURE)
  12004                            if (DEBUGGING(LEVELING)) SERIAL_ECHOPAIR("Z before MBL: ", current_position[Z_AXIS]);
  12005                          #endif
  12006                          float x2 = current_position[X_AXIS] + xydiff[X_AXIS],
  12007                                y2 = current_position[Y_AXIS] + xydiff[Y_AXIS],
  12008                                z1 = current_position[Z_AXIS], z2 = z1;
  12009                          planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], z1);
  12010                          planner.apply_leveling(x2, y2, z2);
  12011                          current_position[Z_AXIS] += z2 - z1;
  12012                          #if ENABLED(DEBUG_LEVELING_FEATURE)
  12013                            if (DEBUGGING(LEVELING))
  12014                              SERIAL_ECHOLNPAIR(" after: ", current_position[Z_AXIS]);
  12015                          #endif
  12016                        }
  12017          
  12018                      #endif // MESH_BED_LEVELING
  12019          
  12020                    #endif // !HAS_ABL
  12021          
  12022                    #if ENABLED(DEBUG_LEVELING_FEATURE)
  12023                      if (DEBUGGING(LEVELING)) {
  12024                        SERIAL_ECHOPAIR("Offset Tool XY by { ", xydiff[X_AXIS]);
  12025                        SERIAL_ECHOPAIR(", ", xydiff[Y_AXIS]);
  12026                        SERIAL_ECHOLNPGM(" }");
  12027                      }
  12028                    #endif
  12029          
  12030                    // The newly-selected extruder XY is actually at...
  12031                    current_position[X_AXIS] += xydiff[X_AXIS];
  12032                    current_position[Y_AXIS] += xydiff[Y_AXIS];
  12033          
  12034                    // Set the new active extruder
  12035                    active_extruder = tmp_extruder;
  12036          
  12037                  #endif // !DUAL_X_CARRIAGE
  12038          
  12039                  #if ENABLED(DEBUG_LEVELING_FEATURE)
  12040                    if (DEBUGGING(LEVELING)) DEBUG_POS("Sync After Toolchange", current_position);
  12041                  #endif
  12042          
  12043                  // Tell the planner the new "current position"
  12044                  SYNC_PLAN_POSITION_KINEMATIC();
  12045          
  12046                  // Move to the "old position" (move the extruder into place)
  12047                  #if ENABLED(SWITCHING_NOZZLE)
  12048                    destination[Z_AXIS] += z_diff;  // Include the Z restore with the "move back"
  12049                  #endif
  12050                  if (!no_move && IsRunning()) {
  12051                    #if ENABLED(DEBUG_LEVELING_FEATURE)
  12052                      if (DEBUGGING(LEVELING)) DEBUG_POS("Move back", destination);
  12053                    #endif
  12054                    // Move back to the original (or tweaked) position
  12055                    do_blocking_move_to(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS]);
  12056                  }
  12057                  #if ENABLED(SWITCHING_NOZZLE)
  12058                    else {
  12059                      // Move back down. (Including when the new tool is higher.)
  12060                      do_blocking_move_to_z(destination[Z_AXIS], planner.max_feedrate_mm_s[Z_AXIS]);
  12061                    }
  12062                  #endif
  12063                } // (tmp_extruder != active_extruder)
  12064          
  12065                stepper.synchronize();
  12066          
  12067                #if ENABLED(EXT_SOLENOID) && !ENABLED(PARKING_EXTRUDER)
  12068                  disable_all_solenoids();
  12069                  enable_solenoid_on_active_extruder();
  12070                #endif // EXT_SOLENOID
  12071          
  12072                feedrate_mm_s = old_feedrate_mm_s;
  12073          
  12074              #else // HOTENDS <= 1
  12075          
  12076                UNUSED(fr_mm_s);
  12077                UNUSED(no_move);
  12078          
  12079                #if ENABLED(MK2_MULTIPLEXER)
  12080                  if (tmp_extruder >= E_STEPPERS)
  12081                    return invalid_extruder_error(tmp_extruder);
  12082          
  12083                  select_multiplexed_stepper(tmp_extruder);
  12084                #endif
  12085          
  12086                // Set the new active extruder
  12087                active_extruder = tmp_extruder;
   \                     ??tool_change_0: (+1)
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable107
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x74E0             STRB     R0,[R4, #+19]
  12088          
  12089              #endif // HOTENDS <= 1
  12090          
  12091              #if ENABLED(SWITCHING_EXTRUDER) && !DONT_SWITCH
  12092                stepper.synchronize();
  12093                move_extruder_servo(active_extruder);
  12094              #endif
  12095          
  12096              #if HAS_FANMUX
  12097                fanmux_switch(active_extruder);
  12098              #endif
  12099          
  12100              SERIAL_ECHO_START();
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable107_2
   \   0000001A   0x.... 0x....      BL       _Z14serialprintPGMPKc
  12101              SERIAL_ECHOLNPAIR(MSG_ACTIVE_EXTRUDER, (int)active_extruder);
   \   0000001E   0x7CE1             LDRB     R1,[R4, #+19]
   \   00000020   0x.... 0x....      ADR.W    R0,`?<Constant "Active Extruder: ">`
   \   00000024   0x.... 0x....      BL       _Z17serial_echopair_PPKci
   \   00000028   0x210A             MOVS     R1,#+10
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable109
   \   0000002E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000032   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
  12102          
  12103            #endif // !MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
  12104          }
  12105          
  12106          /**
  12107           * T0-T3: Switch tool, usually switching extruders
  12108           *
  12109           *   F[units/min] Set the movement feedrate
  12110           *   S1           Don't move the tool in XY after change
  12111           */

   \                                 In section .text, align 4
  12112          inline void gcode_T(const uint8_t tmp_extruder) {
  12113          
  12114            #if ENABLED(DEBUG_LEVELING_FEATURE)
  12115              if (DEBUGGING(LEVELING)) {
  12116                SERIAL_ECHOPAIR(">>> gcode_T(", tmp_extruder);
  12117                SERIAL_CHAR(')');
  12118                SERIAL_EOL();
  12119                DEBUG_POS("BEFORE", current_position);
  12120              }
  12121            #endif
  12122          
  12123            #if HOTENDS == 1 || (ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1)
  12124          
  12125              tool_change(tmp_extruder);
   \                     _Z7gcode_Th: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xED9F 0x0A02      VLDR.W   S0,??gcode_T_0   ;; 0x0
   \   00000006   0x.... 0x....      B.W      _Z11tool_changehfb
   \   0000000A   0xBF00             Nop      
   \                     ??gcode_T_0:
   \   0000000C   0x00000000         DC32     0x0
  12126          
  12127            #elif HOTENDS > 1
  12128          
  12129              tool_change(
  12130                tmp_extruder,
  12131                MMM_TO_MMS(parser.linearval('F')),
  12132                (tmp_extruder == active_extruder) || parser.boolval('S')
  12133              );
  12134          
  12135            #endif
  12136          
  12137            #if ENABLED(DEBUG_LEVELING_FEATURE)
  12138              if (DEBUGGING(LEVELING)) {
  12139                DEBUG_POS("AFTER", current_position);
  12140                SERIAL_ECHOLNPGM("<<< gcode_T");
  12141              }
  12142            #endif
  12143          }
  12144          
  12145          /**
  12146           * Process the parsed command and dispatch it to its handler
  12147           */

   \                                 In section .text, align 2, keep-with-next
  12148          void process_parsed_command() {
   \                     _Z22process_parsed_commandv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
  12149            KEEPALIVE_STATE(IN_HANDLER);
  12150          
  12151            // Handle a known G, M, or T
  12152            switch (parser.command_letter) {
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable121
   \   00000006   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   0000000A   0x2847             CMP      R0,#+71
   \   0000000C   0xD005             BEQ.N    ??process_parsed_command_0
   \   0000000E   0x284D             CMP      R0,#+77
   \   00000010   0xD03F             BEQ.N    ??process_parsed_command_1
   \   00000012   0x2854             CMP      R0,#+84
   \   00000014   0xF000 0x8218      BEQ.W    ??process_parsed_command_2
   \   00000018   0xE21D             B.N      ??process_parsed_command_3
  12153              case 'G': switch (parser.codenum) {
   \                     ??process_parsed_command_0: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable121_1
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x0001             MOVS     R1,R0
   \   00000022   0xD010             BEQ.N    ??process_parsed_command_4
   \   00000024   0x2901             CMP      R1,#+1
   \   00000026   0xD00E             BEQ.N    ??process_parsed_command_4
   \   00000028   0x2902             CMP      R1,#+2
   \   0000002A   0xD00F             BEQ.N    ??process_parsed_command_5
   \   0000002C   0x2903             CMP      R1,#+3
   \   0000002E   0xD00D             BEQ.N    ??process_parsed_command_5
   \   00000030   0x2904             CMP      R1,#+4
   \   00000032   0xD013             BEQ.N    ??process_parsed_command_6
   \   00000034   0x291C             CMP      R1,#+28
   \   00000036   0xD014             BEQ.N    ??process_parsed_command_7
   \   00000038   0x295A             CMP      R1,#+90
   \   0000003A   0xD01D             BEQ.N    ??process_parsed_command_8
   \   0000003C   0x295B             CMP      R1,#+91
   \   0000003E   0xD020             BEQ.N    ??process_parsed_command_9
   \   00000040   0x295C             CMP      R1,#+92
   \   00000042   0xD023             BEQ.N    ??process_parsed_command_10
   \   00000044   0xE20B             B.N      ??process_parsed_command_11
  12154          
  12155                // G0, G1
  12156                case 0:
  12157                case 1:
  12158                  #if IS_SCARA
  12159                    gcode_G0_G1(parser.codenum == 0);
  12160                  #else
  12161                    gcode_G0_G1();
   \                     ??process_parsed_command_4: (+1)
   \   00000046   0x.... 0x....      BL       _Z11gcode_G0_G1v
  12162                  #endif
  12163                  break;
   \   0000004A   0xE208             B.N      ??process_parsed_command_11
  12164          
  12165                // G2, G3
  12166                #if ENABLED(ARC_SUPPORT) && DISABLED(SCARA)
  12167                  case 2: // G2: CW ARC
  12168                  case 3: // G3: CCW ARC
  12169                    gcode_G2_G3(parser.codenum == 2);
   \                     ??process_parsed_command_5: (+1)
   \   0000004C   0x2802             CMP      R0,#+2
   \   0000004E   0xD101             BNE.N    ??process_parsed_command_12
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0xE000             B.N      ??process_parsed_command_13
   \                     ??process_parsed_command_12: (+1)
   \   00000054   0x2000             MOVS     R0,#+0
   \                     ??process_parsed_command_13: (+1)
   \   00000056   0x.... 0x....      BL       _Z11gcode_G2_G3b
  12170                    break;
   \   0000005A   0xE200             B.N      ??process_parsed_command_11
  12171                #endif
  12172          
  12173                // G4 Dwell
  12174                case 4:
  12175                  gcode_G4();
   \                     ??process_parsed_command_6: (+1)
   \   0000005C   0x.... 0x....      BL       _Z8gcode_G4v
  12176                  break;
   \   00000060   0xE1FD             B.N      ??process_parsed_command_11
  12177          
  12178                #if ENABLED(BEZIER_CURVE_SUPPORT)
  12179                  case 5: // G5: Cubic B_spline
  12180                    gcode_G5();
  12181                    break;
  12182                #endif // BEZIER_CURVE_SUPPORT
  12183          
  12184                #if ENABLED(FWRETRACT)
  12185                  case 10: // G10: retract
  12186                    gcode_G10();
  12187                    break;
  12188                  case 11: // G11: retract_recover
  12189                    gcode_G11();
  12190                    break;
  12191                #endif // FWRETRACT
  12192          
  12193                #if ENABLED(NOZZLE_CLEAN_FEATURE)
  12194                  case 12:
  12195                    gcode_G12(); // G12: Nozzle Clean
  12196                    break;
  12197                #endif // NOZZLE_CLEAN_FEATURE
  12198          
  12199                #if ENABLED(CNC_WORKSPACE_PLANES)
  12200                  case 17: // G17: Select Plane XY
  12201                    gcode_G17();
  12202                    break;
  12203                  case 18: // G18: Select Plane ZX
  12204                    gcode_G18();
  12205                    break;
  12206                  case 19: // G19: Select Plane YZ
  12207                    gcode_G19();
  12208                    break;
  12209                #endif // CNC_WORKSPACE_PLANES
  12210          
  12211                #if ENABLED(INCH_MODE_SUPPORT)
  12212                  case 20: // G20: Inch Mode
  12213                    gcode_G20();
  12214                    break;
  12215          
  12216                  case 21: // G21: MM Mode
  12217                    gcode_G21();
  12218                    break;
  12219                #endif // INCH_MODE_SUPPORT
  12220          
  12221                #if ENABLED(G26_MESH_VALIDATION)
  12222                  case 26: // G26: Mesh Validation Pattern generation
  12223                    gcode_G26();
  12224                    break;
  12225                #endif // G26_MESH_VALIDATION
  12226          
  12227                #if ENABLED(NOZZLE_PARK_FEATURE)
  12228                  case 27: // G27: Nozzle Park
  12229                    gcode_G27();
  12230                    break;
  12231                #endif // NOZZLE_PARK_FEATURE
  12232          
  12233                case 28: // G28: Home all axes, one at a time
  12234                  #if 1
  12235                	if (gCfgItems.breakpoint_reprint_flg == 1) break;
   \                     ??process_parsed_command_7: (+1)
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable121_2
   \   00000066   0xF890 0x0128      LDRB     R0,[R0, #+296]
   \   0000006A   0x2801             CMP      R0,#+1
   \   0000006C   0xF000 0x81F7      BEQ.W    ??process_parsed_command_11
  12236                  #endif
  12237                  gcode_G28(false);
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x.... 0x....      BL       _Z9gcode_G28b
  12238                  break;
   \   00000076   0xE1F2             B.N      ??process_parsed_command_11
  12239          
  12240                #if HAS_LEVELING
  12241                  case 29: // G29 Detailed Z probe, probes the bed at 3 or more points,
  12242                           // or provides access to the UBL System if enabled.
  12243                    gcode_G29();
  12244                    break;
  12245                #endif // HAS_LEVELING
  12246          
  12247                #if HAS_BED_PROBE
  12248          
  12249                  case 30: // G30 Single Z probe
  12250                    gcode_G30();
  12251                    break;
  12252          
  12253                  #if ENABLED(Z_PROBE_SLED)
  12254          
  12255                      case 31: // G31: dock the sled
  12256                        gcode_G31();
  12257                        break;
  12258          
  12259                      case 32: // G32: undock the sled
  12260                        gcode_G32();
  12261                        break;
  12262          
  12263                  #endif // Z_PROBE_SLED
  12264          
  12265                #endif // HAS_BED_PROBE
  12266          
  12267                #if ENABLED(DELTA_AUTO_CALIBRATION)
  12268          
  12269                  case 33: // G33: Delta Auto-Calibration
  12270                    gcode_G33();
  12271                    break;
  12272          
  12273                #endif // DELTA_AUTO_CALIBRATION
  12274          
  12275                #if ENABLED(G38_PROBE_TARGET)
  12276                  case 38: // G38.2 & G38.3
  12277                    if (parser.subcode == 2 || parser.subcode == 3)
  12278                      gcode_G38(parser.subcode == 2);
  12279                    break;
  12280                #endif
  12281          
  12282                case 90: // G90
  12283                  relative_mode = false;
   \                     ??process_parsed_command_8: (+1)
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable107
   \   0000007E   0x7508             STRB     R0,[R1, #+20]
  12284                  break;
   \   00000080   0xE1ED             B.N      ??process_parsed_command_11
  12285                case 91: // G91
  12286                  relative_mode = true;
   \                     ??process_parsed_command_9: (+1)
   \   00000082   0x2001             MOVS     R0,#+1
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable107
   \   00000088   0x7508             STRB     R0,[R1, #+20]
  12287                  break;
   \   0000008A   0xE1E8             B.N      ??process_parsed_command_11
  12288          
  12289                case 92: // G92
  12290                  gcode_G92();
   \                     ??process_parsed_command_10: (+1)
   \   0000008C   0x.... 0x....      BL       _Z9gcode_G92v
  12291                  break;
   \   00000090   0xE1E5             B.N      ??process_parsed_command_11
  12292          
  12293                #if HAS_MESH
  12294                  case 42:
  12295                    gcode_G42();
  12296                    break;
  12297                #endif
  12298          
  12299                #if ENABLED(DEBUG_GCODE_PARSER)
  12300                  case 800:
  12301                    parser.debug(); // GCode Parser Test for G
  12302                    break;
  12303                #endif
  12304              }
  12305              break;
  12306          
  12307              case 'M': switch (parser.codenum) {
   \                     ??process_parsed_command_1: (+1)
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable121_1
   \   00000096   0x6800             LDR      R0,[R0, #+0]
   \   00000098   0x3811             SUBS     R0,R0,#+17
   \   0000009A   0xF000 0x80C2      BEQ.W    ??process_parsed_command_14
   \   0000009E   0x1E40             SUBS     R0,R0,#+1
   \   000000A0   0xF000 0x8175      BEQ.W    ??process_parsed_command_15
   \   000000A4   0x1E80             SUBS     R0,R0,#+2
   \   000000A6   0xF000 0x80BF      BEQ.W    ??process_parsed_command_16
   \   000000AA   0x1E40             SUBS     R0,R0,#+1
   \   000000AC   0x2801             CMP      R0,#+1
   \   000000AE   0xF240 0x80BE      BLS.W    ??process_parsed_command_17
   \   000000B2   0x1E80             SUBS     R0,R0,#+2
   \   000000B4   0xF000 0x80BE      BEQ.W    ??process_parsed_command_18
   \   000000B8   0x1E40             SUBS     R0,R0,#+1
   \   000000BA   0xF000 0x80BE      BEQ.W    ??process_parsed_command_19
   \   000000BE   0x1E40             SUBS     R0,R0,#+1
   \   000000C0   0xF000 0x80D3      BEQ.W    ??process_parsed_command_20
   \   000000C4   0x1E40             SUBS     R0,R0,#+1
   \   000000C6   0xF000 0x80F8      BEQ.W    ??process_parsed_command_21
   \   000000CA   0x1E40             SUBS     R0,R0,#+1
   \   000000CC   0xF000 0x80F8      BEQ.W    ??process_parsed_command_22
   \   000000D0   0x1E40             SUBS     R0,R0,#+1
   \   000000D2   0xF000 0x80F8      BEQ.W    ??process_parsed_command_23
   \   000000D6   0x1E40             SUBS     R0,R0,#+1
   \   000000D8   0xF000 0x80F8      BEQ.W    ??process_parsed_command_24
   \   000000DC   0x1E40             SUBS     R0,R0,#+1
   \   000000DE   0xF000 0x80F8      BEQ.W    ??process_parsed_command_25
   \   000000E2   0x1E40             SUBS     R0,R0,#+1
   \   000000E4   0xF000 0x80FE      BEQ.W    ??process_parsed_command_26
   \   000000E8   0x1E40             SUBS     R0,R0,#+1
   \   000000EA   0xF000 0x80F5      BEQ.W    ??process_parsed_command_27
   \   000000EE   0x380A             SUBS     R0,R0,#+10
   \   000000F0   0xF000 0x80FB      BEQ.W    ??process_parsed_command_28
   \   000000F4   0x3821             SUBS     R0,R0,#+33
   \   000000F6   0xF000 0x80FB      BEQ.W    ??process_parsed_command_29
   \   000000FA   0x1E40             SUBS     R0,R0,#+1
   \   000000FC   0xF000 0x80FB      BEQ.W    ??process_parsed_command_30
   \   00000100   0x1E40             SUBS     R0,R0,#+1
   \   00000102   0xF000 0x80FB      BEQ.W    ??process_parsed_command_31
   \   00000106   0x1F00             SUBS     R0,R0,#+4
   \   00000108   0xF000 0x8138      BEQ.W    ??process_parsed_command_32
   \   0000010C   0x1E40             SUBS     R0,R0,#+1
   \   0000010E   0xF000 0x8138      BEQ.W    ??process_parsed_command_33
   \   00000112   0x1E40             SUBS     R0,R0,#+1
   \   00000114   0xF000 0x8138      BEQ.W    ??process_parsed_command_34
   \   00000118   0x1E40             SUBS     R0,R0,#+1
   \   0000011A   0xF000 0x8138      BEQ.W    ??process_parsed_command_15
   \   0000011E   0x1E40             SUBS     R0,R0,#+1
   \   00000120   0xF000 0x8138      BEQ.W    ??process_parsed_command_35
   \   00000124   0x1FC0             SUBS     R0,R0,#+7
   \   00000126   0xF000 0x8138      BEQ.W    ??process_parsed_command_36
   \   0000012A   0x380C             SUBS     R0,R0,#+12
   \   0000012C   0xF000 0x80E9      BEQ.W    ??process_parsed_command_37
   \   00000130   0x1E40             SUBS     R0,R0,#+1
   \   00000132   0xF000 0x80FB      BEQ.W    ??process_parsed_command_38
   \   00000136   0x1E40             SUBS     R0,R0,#+1
   \   00000138   0xF000 0x8107      BEQ.W    ??process_parsed_command_39
   \   0000013C   0x1E40             SUBS     R0,R0,#+1
   \   0000013E   0xF000 0x8115      BEQ.W    ??process_parsed_command_40
   \   00000142   0x1E40             SUBS     R0,R0,#+1
   \   00000144   0xF000 0x80E6      BEQ.W    ??process_parsed_command_41
   \   00000148   0x1E40             SUBS     R0,R0,#+1
   \   0000014A   0xF000 0x80FB      BEQ.W    ??process_parsed_command_42
   \   0000014E   0x1E40             SUBS     R0,R0,#+1
   \   00000150   0xF000 0x80DA      BEQ.W    ??process_parsed_command_43
   \   00000154   0x1E40             SUBS     R0,R0,#+1
   \   00000156   0xF000 0x80DA      BEQ.W    ??process_parsed_command_44
   \   0000015A   0x1E40             SUBS     R0,R0,#+1
   \   0000015C   0xF000 0x80DD      BEQ.W    ??process_parsed_command_45
   \   00000160   0x1E80             SUBS     R0,R0,#+2
   \   00000162   0xF000 0x811D      BEQ.W    ??process_parsed_command_46
   \   00000166   0x1E40             SUBS     R0,R0,#+1
   \   00000168   0xF000 0x811D      BEQ.W    ??process_parsed_command_47
   \   0000016C   0x1E80             SUBS     R0,R0,#+2
   \   0000016E   0xF000 0x811D      BEQ.W    ??process_parsed_command_48
   \   00000172   0x1E40             SUBS     R0,R0,#+1
   \   00000174   0xF000 0x811D      BEQ.W    ??process_parsed_command_49
   \   00000178   0x1E40             SUBS     R0,R0,#+1
   \   0000017A   0xF000 0x811D      BEQ.W    ??process_parsed_command_50
   \   0000017E   0x1E40             SUBS     R0,R0,#+1
   \   00000180   0xF000 0x811D      BEQ.W    ??process_parsed_command_51
   \   00000184   0x1E40             SUBS     R0,R0,#+1
   \   00000186   0xF000 0x811D      BEQ.W    ??process_parsed_command_52
   \   0000018A   0x3813             SUBS     R0,R0,#+19
   \   0000018C   0xF000 0x80CB      BEQ.W    ??process_parsed_command_53
   \   00000190   0x383C             SUBS     R0,R0,#+60
   \   00000192   0xF000 0x811A      BEQ.W    ??process_parsed_command_54
   \   00000196   0x1E40             SUBS     R0,R0,#+1
   \   00000198   0xF000 0x811A      BEQ.W    ??process_parsed_command_55
   \   0000019C   0x1E80             SUBS     R0,R0,#+2
   \   0000019E   0xF000 0x811A      BEQ.W    ??process_parsed_command_56
   \   000001A2   0x1E40             SUBS     R0,R0,#+1
   \   000001A4   0xF000 0x811A      BEQ.W    ??process_parsed_command_57
   \   000001A8   0x1E40             SUBS     R0,R0,#+1
   \   000001AA   0xF000 0x811A      BEQ.W    ??process_parsed_command_58
   \   000001AE   0x1E40             SUBS     R0,R0,#+1
   \   000001B0   0xF000 0x811A      BEQ.W    ??process_parsed_command_59
   \   000001B4   0x1F40             SUBS     R0,R0,#+5
   \   000001B6   0xF000 0x811A      BEQ.W    ??process_parsed_command_60
   \   000001BA   0x3809             SUBS     R0,R0,#+9
   \   000001BC   0xF000 0x811A      BEQ.W    ??process_parsed_command_61
   \   000001C0   0x1E40             SUBS     R0,R0,#+1
   \   000001C2   0xF000 0x811A      BEQ.W    ??process_parsed_command_62
   \   000001C6   0x1F40             SUBS     R0,R0,#+5
   \   000001C8   0xF000 0x811A      BEQ.W    ??process_parsed_command_63
   \   000001CC   0x384B             SUBS     R0,R0,#+75
   \   000001CE   0xF000 0x811A      BEQ.W    ??process_parsed_command_64
   \   000001D2   0x1E80             SUBS     R0,R0,#+2
   \   000001D4   0xF000 0x811A      BEQ.W    ??process_parsed_command_65
   \   000001D8   0x3834             SUBS     R0,R0,#+52
   \   000001DA   0xF000 0x812F      BEQ.W    ??process_parsed_command_66
   \   000001DE   0x382D             SUBS     R0,R0,#+45
   \   000001E0   0xF000 0x8117      BEQ.W    ??process_parsed_command_67
   \   000001E4   0x380A             SUBS     R0,R0,#+10
   \   000001E6   0xF000 0x809B      BEQ.W    ??process_parsed_command_68
   \   000001EA   0x3812             SUBS     R0,R0,#+18
   \   000001EC   0xF000 0x8114      BEQ.W    ??process_parsed_command_69
   \   000001F0   0x3848             SUBS     R0,R0,#+72
   \   000001F2   0xF000 0x8114      BEQ.W    ??process_parsed_command_70
   \   000001F6   0x1E40             SUBS     R0,R0,#+1
   \   000001F8   0xF000 0x8114      BEQ.W    ??process_parsed_command_71
   \   000001FC   0x1E40             SUBS     R0,R0,#+1
   \   000001FE   0xF000 0x8114      BEQ.W    ??process_parsed_command_72
   \   00000202   0x1E40             SUBS     R0,R0,#+1
   \   00000204   0xF000 0x8114      BEQ.W    ??process_parsed_command_73
   \   00000208   0xF44F 0x71CA      MOV      R1,#+404
   \   0000020C   0x1A40             SUBS     R0,R0,R1
   \   0000020E   0xF000 0x8112      BEQ.W    ??process_parsed_command_74
   \   00000212   0x3815             SUBS     R0,R0,#+21
   \   00000214   0xD063             BEQ.N    ??process_parsed_command_75
   \   00000216   0x3846             SUBS     R0,R0,#+70
   \   00000218   0xD04C             BEQ.N    ??process_parsed_command_76
   \   0000021A   0x1E40             SUBS     R0,R0,#+1
   \   0000021C   0xF000 0x8111      BEQ.W    ??process_parsed_command_77
   \   00000220   0xE11D             B.N      ??process_parsed_command_11
  12308                #if HAS_RESUME_CONTINUE
  12309                  case 0: // M0: Unconditional stop - Wait for user button press on LCD
  12310                  case 1: // M1: Conditional stop - Wait for user button press on LCD
  12311                    gcode_M0_M1();
  12312                    break;
  12313                #endif // ULTIPANEL
  12314          
  12315                #if ENABLED(SPINDLE_LASER_ENABLE)
  12316                  case 3:
  12317                    gcode_M3_M4(true);   // M3: turn spindle/laser on, set laser/spindle power/speed, set rotation direction CW
  12318                    break;               // synchronizes with movement commands
  12319                  case 4:
  12320                    gcode_M3_M4(false);  // M4: turn spindle/laser on, set laser/spindle power/speed, set rotation direction CCW
  12321                    break;               // synchronizes with movement commands
  12322                  case 5:
  12323                    gcode_M5();     // M5 - turn spindle/laser off
  12324                    break;          // synchronizes with movement commands
  12325                #endif
  12326                case 17: // M17: Enable all stepper motors
  12327                  gcode_M17();
   \                     ??process_parsed_command_14: (+1)
   \   00000222   0x.... 0x....      BL       _Z9gcode_M17v
  12328                  break;
   \   00000226   0xE11A             B.N      ??process_parsed_command_11
  12329          
  12330                #if ENABLED(SDSUPPORT)
  12331                  case 20: // M20: list SD card
  12332                    gcode_M20(); break;
   \                     ??process_parsed_command_16: (+1)
   \   00000228   0x.... 0x....      BL       _Z9gcode_M20v
   \   0000022C   0xE117             B.N      ??process_parsed_command_11
  12333                  case 21: // M21: init SD card
  12334                    //gcode_M21(); break;
  12335                  case 22: // M22: release SD card
  12336                    gcode_M22(); break;
   \                     ??process_parsed_command_17: (+1)
   \   0000022E   0x.... 0x....      BL       _Z9gcode_M22v
   \   00000232   0xE114             B.N      ??process_parsed_command_11
  12337                  case 23: // M23: Select file
  12338                    gcode_M23(); break;
   \                     ??process_parsed_command_18: (+1)
   \   00000234   0x.... 0x....      BL       _Z9gcode_M23v
   \   00000238   0xE111             B.N      ??process_parsed_command_11
  12339                  case 24: // M24: Start SD print
  12340                    gcode_M24(); 
   \                     ??process_parsed_command_19: (+1)
   \   0000023A   0x.... 0x....      BL       _Z9gcode_M24v
  12341          
  12342                    if(mksReprint.mks_printer_state == MKS_WORKING)
   \   0000023E   0x.... 0x....      LDR.W    R0,??DataTable122
   \   00000242   0xF890 0x0D10      LDRB     R0,[R0, #+3344]
   \   00000246   0x28A7             CMP      R0,#+167
   \   00000248   0xF040 0x8109      BNE.W    ??process_parsed_command_11
  12343                    {
  12344                      clear_cur_ui();
   \   0000024C   0x.... 0x....      BL       clear_cur_ui
  12345                      reset_file_info();
   \   00000250   0x.... 0x....      BL       reset_file_info
  12346                      reset_print_time();
   \   00000254   0x.... 0x....      BL       reset_print_time
  12347                      start_print_time();
   \   00000258   0x.... 0x....      BL       start_print_time
  12348                      
  12349                      preview_gcode_prehandle(curFileName);
   \   0000025C   0x.... 0x....      LDR.W    R0,??DataTable122_1
   \   00000260   0x.... 0x....      BL       preview_gcode_prehandle
  12350                      
  12351                      draw_printing();            
   \   00000264   0x.... 0x....      BL       draw_printing
   \   00000268   0xE0F9             B.N      ??process_parsed_command_11
  12352                     }
  12353                    break;
  12354                  case 25: // M25: Pause SD print
  12355                      gcode_M25(); 
   \                     ??process_parsed_command_20: (+1)
   \   0000026A   0x.... 0x....      BL       _Z9gcode_M25v
  12356                      if(mksReprint.mks_printer_state == MKS_PAUSING)
   \   0000026E   0x.... 0x....      LDR.W    R4,??DataTable122
   \   00000272   0xF894 0x0D10      LDRB     R0,[R4, #+3344]
   \   00000276   0x28A8             CMP      R0,#+168
   \   00000278   0xF040 0x80F1      BNE.W    ??process_parsed_command_11
  12357                      {
  12358                      	stop_print_time();							
   \   0000027C   0x.... 0x....      BL       stop_print_time
  12359                      	clear_cur_ui();
   \   00000280   0x.... 0x....      BL       clear_cur_ui
  12360                      
  12361                      	card.pauseSDPrint();
   \   00000284   0x4620             MOV      R0,R4
   \   00000286   0x.... 0x....      BL       _ZN10CardReader12pauseSDPrintEv
  12362                      	print_job_timer.pause();
   \   0000028A   0xF504 0x6060      ADD      R0,R4,#+3584
   \   0000028E   0x.... 0x....      BL       _ZN9Stopwatch5pauseEv
  12363          
  12364                      	if(from_flash_pic==1)
   \   00000292   0x.... 0x....      LDR.W    R0,??DataTable123
   \   00000296   0x7800             LDRB     R0,[R0, #+0]
   \   00000298   0x2801             CMP      R0,#+1
   \   0000029A   0xD104             BNE.N    ??process_parsed_command_78
  12365                      		flash_preview_begin = 1;
   \   0000029C   0x2001             MOVS     R0,#+1
   \   0000029E   0x.... 0x....      LDR.W    R1,??DataTable124
   \   000002A2   0x7008             STRB     R0,[R1, #+0]
   \   000002A4   0xE003             B.N      ??process_parsed_command_79
  12366                      	else
  12367                      		default_preview_flg = 1;							
   \                     ??process_parsed_command_78: (+1)
   \   000002A6   0x2001             MOVS     R0,#+1
   \   000002A8   0x.... 0x....      LDR.W    R1,??DataTable124_1
   \   000002AC   0x7008             STRB     R0,[R1, #+0]
  12368          
  12369                      	draw_printing();
   \                     ??process_parsed_command_79: (+1)
   \   000002AE   0x.... 0x....      BL       draw_printing
   \   000002B2   0xE0D4             B.N      ??process_parsed_command_11
  12370                      }          
  12371                    break;
  12372                  case 998:	//M998: Stop SD print
  12373                    gcode_M998(); break;			  
   \                     ??process_parsed_command_76: (+1)
   \   000002B4   0x.... 0x....      BL       _Z10gcode_M998v
   \   000002B8   0xE0D1             B.N      ??process_parsed_command_11
  12374                  case 26: // M26: Set SD index
  12375                    gcode_M26(); break;
   \                     ??process_parsed_command_21: (+1)
   \   000002BA   0x.... 0x....      BL       _Z9gcode_M26v
   \   000002BE   0xE0CE             B.N      ??process_parsed_command_11
  12376                  case 27: // M27: Get SD status
  12377                    gcode_M27(); break;
   \                     ??process_parsed_command_22: (+1)
   \   000002C0   0x.... 0x....      BL       _Z9gcode_M27v
   \   000002C4   0xE0CB             B.N      ??process_parsed_command_11
  12378                  case 28: // M28: Start SD write
  12379                    gcode_M28(); break;
   \                     ??process_parsed_command_23: (+1)
   \   000002C6   0x.... 0x....      BL       _Z9gcode_M28v
   \   000002CA   0xE0C8             B.N      ??process_parsed_command_11
  12380                  case 29: // M29: Stop SD write
  12381                    gcode_M29(); break;
   \                     ??process_parsed_command_24: (+1)
   \   000002CC   0x.... 0x....      BL       _Z9gcode_M29v
   \   000002D0   0xE0C5             B.N      ??process_parsed_command_11
  12382                  case 30: // M30 <filename> Delete File
  12383                    gcode_M30(); break;
   \                     ??process_parsed_command_25: (+1)
   \   000002D2   0x.... 0x....      BL       _Z9gcode_M30v
   \   000002D6   0xE0C2             B.N      ??process_parsed_command_11
  12384                  case 32: // M32: Select file and start SD print
  12385                    gcode_M32(); break;
   \                     ??process_parsed_command_27: (+1)
   \   000002D8   0x.... 0x....      BL       _Z9gcode_M32v
   \   000002DC   0xE0BF             B.N      ??process_parsed_command_11
  12386          
  12387                  #if ENABLED(LONG_FILENAME_HOST_SUPPORT)
  12388                    case 33: // M33: Get the long full path to a file or folder
  12389                      gcode_M33(); break;
  12390                  #endif
  12391          
  12392                  #if ENABLED(SDCARD_SORT_ALPHA) && ENABLED(SDSORT_GCODE)
  12393                    case 34: // M34: Set SD card sorting options
  12394                      gcode_M34(); break;
  12395                  #endif // SDCARD_SORT_ALPHA && SDSORT_GCODE
  12396          
  12397                  case 928: // M928: Start SD write
  12398                    gcode_M928(); break;
   \                     ??process_parsed_command_75: (+1)
   \   000002DE   0x.... 0x....      BL       _Z10gcode_M928v
   \   000002E2   0xE0BC             B.N      ??process_parsed_command_11
  12399                #endif // SDSUPPORT
  12400          
  12401                case 31: // M31: Report time since the start of SD print or last M109
  12402                  gcode_M31(); break;
   \                     ??process_parsed_command_26: (+1)
   \   000002E4   0x.... 0x....      BL       _Z9gcode_M31v
   \   000002E8   0xE0B9             B.N      ??process_parsed_command_11
  12403          
  12404                case 42: // M42: Change pin state
  12405                  gcode_M42(); break;
   \                     ??process_parsed_command_28: (+1)
   \   000002EA   0x.... 0x....      BL       _Z9gcode_M42v
   \   000002EE   0xE0B6             B.N      ??process_parsed_command_11
  12406          
  12407                #if ENABLED(PINS_DEBUGGING)
  12408                  case 43: // M43: Read pin state
  12409                    gcode_M43(); break;
  12410                #endif
  12411          
  12412          
  12413                #if ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
  12414                  case 48: // M48: Z probe repeatability test
  12415                    gcode_M48();
  12416                    break;
  12417                #endif // Z_MIN_PROBE_REPEATABILITY_TEST
  12418          
  12419                #if ENABLED(G26_MESH_VALIDATION)
  12420                  case 49: // M49: Turn on or off G26 debug flag for verbose output
  12421                    gcode_M49();
  12422                    break;
  12423                #endif // G26_MESH_VALIDATION
  12424          
  12425                #if ENABLED(ULTRA_LCD) && ENABLED(LCD_SET_PROGRESS_MANUALLY)
  12426                  case 73: // M73: Set print progress percentage
  12427                    gcode_M73(); break;
  12428                #endif
  12429          
  12430                case 75: // M75: Start print timer
  12431                  gcode_M75(); break;
   \                     ??process_parsed_command_29: (+1)
   \   000002F0   0x.... 0x....      BL       _Z9gcode_M75v
   \   000002F4   0xE0B3             B.N      ??process_parsed_command_11
  12432                case 76: // M76: Pause print timer
  12433                  gcode_M76(); break;
   \                     ??process_parsed_command_30: (+1)
   \   000002F6   0x.... 0x....      BL       _Z9gcode_M76v
   \   000002FA   0xE0B0             B.N      ??process_parsed_command_11
  12434                case 77: // M77: Stop print timer
  12435                  gcode_M77(); break;
   \                     ??process_parsed_command_31: (+1)
   \   000002FC   0x.... 0x....      BL       _Z9gcode_M77v
   \   00000300   0xE0AD             B.N      ??process_parsed_command_11
  12436          
  12437                #if ENABLED(PRINTCOUNTER)
  12438                  case 78: // M78: Show print statistics
  12439                    gcode_M78(); break;
  12440                #endif
  12441          
  12442                #if ENABLED(M100_FREE_MEMORY_WATCHER)
  12443                  case 100: // M100: Free Memory Report
  12444                    gcode_M100();
  12445                    break;
  12446                #endif
  12447          
  12448                case 104: // M104: Set hot end temperature
  12449                  gcode_M104();
   \                     ??process_parsed_command_37: (+1)
   \   00000302   0x.... 0x....      BL       _Z10gcode_M104v
  12450                  break;
   \   00000306   0xE0AA             B.N      ??process_parsed_command_11
  12451          
  12452                case 110: // M110: Set Current Line Number
  12453                  gcode_M110();
   \                     ??process_parsed_command_43: (+1)
   \   00000308   0x.... 0x....      BL       _Z10gcode_M110v
  12454                  break;
   \   0000030C   0xE0A7             B.N      ??process_parsed_command_11
  12455          
  12456                case 111: // M111: Set debug level
  12457                  gcode_M111();
   \                     ??process_parsed_command_44: (+1)
   \   0000030E   0x.... 0x....      BL       _Z10gcode_M111v
  12458                  break;
   \   00000312   0xE0A4             B.N      ??process_parsed_command_11
  12459          
  12460                #if DISABLED(EMERGENCY_PARSER)
  12461          
  12462                  case 108: // M108: Cancel Waiting
  12463                    gcode_M108();
   \                     ??process_parsed_command_41: (+1)
   \   00000314   0x.... 0x....      BL       _Z10gcode_M108v
  12464                    break;
   \   00000318   0xE0A1             B.N      ??process_parsed_command_11
  12465          
  12466                  case 112: // M112: Emergency Stop
  12467                    gcode_M112();
   \                     ??process_parsed_command_45: (+1)
   \   0000031A   0x.... 0x....      BL       _Z10gcode_M112v
  12468                    break;
   \   0000031E   0xE09E             B.N      ??process_parsed_command_11
  12469          
  12470                  case 410: // M410 quickstop - Abort all the planned moves.
  12471                    gcode_M410();
   \                     ??process_parsed_command_68: (+1)
   \   00000320   0x.... 0x....      BL       _Z10gcode_M410v
  12472                    break;
   \   00000324   0xE09B             B.N      ??process_parsed_command_11
  12473          
  12474                #endif
  12475          
  12476                #if ENABLED(HOST_KEEPALIVE_FEATURE)
  12477                  case 113: // M113: Set Host Keepalive interval
  12478                    gcode_M113();
  12479                    break;
  12480                #endif
  12481          
  12482                case 140: // M140: Set bed temperature
  12483                  gcode_M140();
   \                     ??process_parsed_command_53: (+1)
   \   00000326   0x.... 0x....      BL       _Z10gcode_M140v
  12484                  break;
   \   0000032A   0xE098             B.N      ??process_parsed_command_11
  12485          
  12486                case 105: // M105: Report current temperature
  12487                	mksdlp.buzzer_tone(500,100,2);
   \                     ??process_parsed_command_38: (+1)
   \   0000032C   0x2302             MOVS     R3,#+2
   \   0000032E   0x2264             MOVS     R2,#+100
   \   00000330   0xF44F 0x71FA      MOV      R1,#+500
   \   00000334   0x.... 0x....      LDR.W    R0,??DataTable115_1
   \   00000338   0x.... 0x....      BL       _ZN7MKS_DLP11buzzer_toneEtth
  12488                  gcode_M105();
   \   0000033C   0xE8BD 0x4010      POP      {R4,LR}
   \   00000340   0x.... 0x....      B.W      _Z10gcode_M105v
  12489                  KEEPALIVE_STATE(NOT_BUSY);
  12490                  return; // "ok" already printed
  12491          
  12492                #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
  12493                  case 155: // M155: Set temperature auto-report interval
  12494                    gcode_M155();
  12495                    break;
  12496                #endif
  12497          
  12498                case 109: // M109: Wait for hotend temperature to reach target
  12499                  gcode_M109();
   \                     ??process_parsed_command_42: (+1)
   \   00000344   0x.... 0x....      BL       _Z10gcode_M109v
  12500                  break;
   \   00000348   0xE089             B.N      ??process_parsed_command_11
  12501          
  12502                #if HAS_TEMP_BED
  12503                  case 190: // M190: Wait for bed temperature to reach target
  12504                    gcode_M190();
  12505                    break;
  12506                #endif // HAS_TEMP_BED
  12507          
  12508                #if FAN_COUNT > 0
  12509                  case 106: // M106: Fan On
  12510                  mksdlp.buzzer_enable(1);
   \                     ??process_parsed_command_39: (+1)
   \   0000034A   0x.... 0x....      LDR.W    R4,??DataTable122
   \   0000034E   0xF604 0x14C4      ADDW     R4,R4,#+2500
   \   00000352   0x2101             MOVS     R1,#+1
   \   00000354   0x4620             MOV      R0,R4
   \   00000356   0x.... 0x....      BL       _ZN7MKS_DLP13buzzer_enableEh
  12511          		//mksdlp.buzzer_tone(1000,1000,5);
  12512          		mksdlp.bank2disp_enable(CLEAN_USED_BANK,0,0);
   \   0000035A   0x2300             MOVS     R3,#+0
   \   0000035C   0x461A             MOV      R2,R3
   \   0000035E   0x2102             MOVS     R1,#+2
   \   00000360   0x4620             MOV      R0,R4
   \   00000362   0x.... 0x....      BL       _ZN7MKS_DLP16bank2disp_enableEhhh
  12513                    gcode_M106();
   \   00000366   0x.... 0x....      BL       _Z10gcode_M106v
  12514                    break;
   \   0000036A   0xE078             B.N      ??process_parsed_command_11
  12515                  case 107: // M107: Fan Off
  12516                  mksdlp.buzzer_enable(0);
   \                     ??process_parsed_command_40: (+1)
   \   0000036C   0x2100             MOVS     R1,#+0
   \   0000036E   0x.... 0x....      LDR.W    R0,??DataTable115_1
   \   00000372   0x.... 0x....      BL       _ZN7MKS_DLP13buzzer_enableEh
  12517                    gcode_M107();
   \   00000376   0x.... 0x....      BL       _Z10gcode_M107v
  12518                    break;
   \   0000037A   0xE070             B.N      ??process_parsed_command_11
  12519                #endif // FAN_COUNT > 0
  12520          
  12521                #if ENABLED(PARK_HEAD_ON_PAUSE)
  12522                  case 125: // M125: Store current position and move to filament change position
  12523                    gcode_M125(); break;
  12524                #endif
  12525          
  12526                #if ENABLED(BARICUDA)
  12527                  // PWM for HEATER_1_PIN
  12528                  #if HAS_HEATER_1
  12529                    case 126: // M126: valve open
  12530                      gcode_M126();
  12531                      break;
  12532                    case 127: // M127: valve closed
  12533                      gcode_M127();
  12534                      break;
  12535                  #endif // HAS_HEATER_1
  12536          
  12537                  // PWM for HEATER_2_PIN
  12538                  #if HAS_HEATER_2
  12539                    case 128: // M128: valve open
  12540                      gcode_M128();
  12541                      break;
  12542                    case 129: // M129: valve closed
  12543                      gcode_M129();
  12544                      break;
  12545                  #endif // HAS_HEATER_2
  12546                #endif // BARICUDA
  12547          
  12548                #if HAS_POWER_SWITCH
  12549          
  12550                  case 80: // M80: Turn on Power Supply
  12551                    gcode_M80();
  12552                    break;
  12553          
  12554                #endif // HAS_POWER_SWITCH
  12555          
  12556                case 81: // M81: Turn off Power, including Power Supply, if possible
  12557                  gcode_M81();
   \                     ??process_parsed_command_32: (+1)
   \   0000037C   0x.... 0x....      BL       _Z9gcode_M81v
  12558                  break;
   \   00000380   0xE06D             B.N      ??process_parsed_command_11
  12559          
  12560                case 82: // M82: Set E axis normal mode (same as other axes)
  12561                  gcode_M82();
   \                     ??process_parsed_command_33: (+1)
   \   00000382   0x.... 0x....      BL       _Z9gcode_M82v
  12562                  break;
   \   00000386   0xE06A             B.N      ??process_parsed_command_11
  12563                case 83: // M83: Set E axis relative mode
  12564                  gcode_M83();
   \                     ??process_parsed_command_34: (+1)
   \   00000388   0x.... 0x....      BL       _Z9gcode_M83v
  12565                  break;
   \   0000038C   0xE067             B.N      ??process_parsed_command_11
  12566                case 18: // M18 => M84
  12567                case 84: // M84: Disable all steppers or set timeout
  12568                  gcode_M18_M84();
   \                     ??process_parsed_command_15: (+1)
   \   0000038E   0x.... 0x....      BL       _Z13gcode_M18_M84v
  12569                  break;
   \   00000392   0xE064             B.N      ??process_parsed_command_11
  12570                case 85: // M85: Set inactivity stepper shutdown timeout
  12571                  gcode_M85();
   \                     ??process_parsed_command_35: (+1)
   \   00000394   0x.... 0x....      BL       _Z9gcode_M85v
  12572                  break;
   \   00000398   0xE061             B.N      ??process_parsed_command_11
  12573                case 92: // M92: Set the steps-per-unit for one or more axes
  12574                  gcode_M92();
   \                     ??process_parsed_command_36: (+1)
   \   0000039A   0x.... 0x....      BL       _Z9gcode_M92v
  12575                  break;
   \   0000039E   0xE05E             B.N      ??process_parsed_command_11
  12576                case 114: // M114: Report current position
  12577                  gcode_M114();
   \                     ??process_parsed_command_46: (+1)
   \   000003A0   0x.... 0x....      BL       _Z10gcode_M114v
  12578                  break;
   \   000003A4   0xE05B             B.N      ??process_parsed_command_11
  12579                case 115: // M115: Report capabilities
  12580                  gcode_M115();
   \                     ??process_parsed_command_47: (+1)
   \   000003A6   0x.... 0x....      BL       _Z10gcode_M115v
  12581                  break;
   \   000003AA   0xE058             B.N      ??process_parsed_command_11
  12582                case 117: // M117: Set LCD message text, if possible
  12583                  gcode_M117();
   \                     ??process_parsed_command_48: (+1)
   \   000003AC   0x.... 0x....      BL       _Z10gcode_M117v
  12584                  break;
   \   000003B0   0xE055             B.N      ??process_parsed_command_11
  12585                case 118: // M118: Display a message in the host console
  12586                  gcode_M118();
   \                     ??process_parsed_command_49: (+1)
   \   000003B2   0x.... 0x....      BL       _Z10gcode_M118v
  12587                  break;
   \   000003B6   0xE052             B.N      ??process_parsed_command_11
  12588                case 119: // M119: Report endstop states
  12589                  gcode_M119();
   \                     ??process_parsed_command_50: (+1)
   \   000003B8   0x.... 0x....      BL       _Z10gcode_M119v
  12590                  break;
   \   000003BC   0xE04F             B.N      ??process_parsed_command_11
  12591                case 120: // M120: Enable endstops
  12592                  gcode_M120();
   \                     ??process_parsed_command_51: (+1)
   \   000003BE   0x.... 0x....      BL       _Z10gcode_M120v
  12593                  break;
   \   000003C2   0xE04C             B.N      ??process_parsed_command_11
  12594                case 121: // M121: Disable endstops
  12595                  gcode_M121();
   \                     ??process_parsed_command_52: (+1)
   \   000003C4   0x.... 0x....      BL       _Z10gcode_M121v
  12596                  break;
   \   000003C8   0xE049             B.N      ??process_parsed_command_11
  12597          
  12598                #if ENABLED(ULTIPANEL)
  12599          
  12600                  case 145: // M145: Set material heatup parameters
  12601                    gcode_M145();
  12602                    break;
  12603          
  12604                #endif
  12605          
  12606                #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
  12607                  case 149: // M149: Set temperature units
  12608                    gcode_M149();
  12609                    break;
  12610                #endif
  12611          
  12612                #if HAS_COLOR_LEDS
  12613          
  12614                  case 150: // M150: Set Status LED Color
  12615                    gcode_M150();
  12616                    break;
  12617          
  12618                #endif // HAS_COLOR_LEDS
  12619          
  12620                #if ENABLED(MIXING_EXTRUDER)
  12621                  case 163: // M163: Set a component weight for mixing extruder
  12622                    gcode_M163();
  12623                    break;
  12624                  #if MIXING_VIRTUAL_TOOLS > 1
  12625                    case 164: // M164: Save current mix as a virtual extruder
  12626                      gcode_M164();
  12627                      break;
  12628                  #endif
  12629                  #if ENABLED(DIRECT_MIXING_IN_G1)
  12630                    case 165: // M165: Set multiple mix weights
  12631                      gcode_M165();
  12632                      break;
  12633                  #endif
  12634                #endif
  12635          
  12636                #if DISABLED(NO_VOLUMETRICS)
  12637                  case 200: // M200: Set filament diameter, E to cubic units
  12638                    gcode_M200();
   \                     ??process_parsed_command_54: (+1)
   \   000003CA   0x.... 0x....      BL       _Z10gcode_M200v
  12639                    break;
   \   000003CE   0xE046             B.N      ??process_parsed_command_11
  12640                #endif
  12641          
  12642                case 201: // M201: Set max acceleration for print moves (units/s^2)
  12643                  gcode_M201();
   \                     ??process_parsed_command_55: (+1)
   \   000003D0   0x.... 0x....      BL       _Z10gcode_M201v
  12644                  break;
   \   000003D4   0xE043             B.N      ??process_parsed_command_11
  12645                #if 0 // Not used for Sprinter/grbl gen6
  12646                  case 202: // M202
  12647                    gcode_M202();
  12648                    break;
  12649                #endif
  12650                case 203: // M203: Set max feedrate (units/sec)
  12651                  gcode_M203();
   \                     ??process_parsed_command_56: (+1)
   \   000003D6   0x.... 0x....      BL       _Z10gcode_M203v
  12652                  break;
   \   000003DA   0xE040             B.N      ??process_parsed_command_11
  12653                case 204: // M204: Set acceleration
  12654                  gcode_M204();
   \                     ??process_parsed_command_57: (+1)
   \   000003DC   0x.... 0x....      BL       _Z10gcode_M204v
  12655                  break;
   \   000003E0   0xE03D             B.N      ??process_parsed_command_11
  12656                case 205: // M205: Set advanced settings
  12657                  gcode_M205();
   \                     ??process_parsed_command_58: (+1)
   \   000003E2   0x.... 0x....      BL       _Z10gcode_M205v
  12658                  break;
   \   000003E6   0xE03A             B.N      ??process_parsed_command_11
  12659          
  12660                #if HAS_M206_COMMAND
  12661                  case 206: // M206: Set home offsets
  12662                    gcode_M206();
   \                     ??process_parsed_command_59: (+1)
   \   000003E8   0x.... 0x....      BL       _Z10gcode_M206v
  12663                    break;
   \   000003EC   0xE037             B.N      ??process_parsed_command_11
  12664                #endif
  12665          
  12666                #if ENABLED(DELTA)
  12667                  case 665: // M665: Set delta configurations
  12668                    gcode_M665();
  12669                    break;
  12670                #endif
  12671          
  12672                #if ENABLED(DELTA) || ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
  12673                  case 666: // M666: Set delta or dual endstop adjustment
  12674                    gcode_M666();
  12675                    break;
  12676                #endif
  12677          
  12678                #if ENABLED(FWRETRACT)
  12679                  case 207: // M207: Set Retract Length, Feedrate, and Z lift
  12680                    gcode_M207();
  12681                    break;
  12682                  case 208: // M208: Set Recover (unretract) Additional Length and Feedrate
  12683                    gcode_M208();
  12684                    break;
  12685                  case 209: // M209: Turn Automatic Retract Detection on/off
  12686                    if (MIN_AUTORETRACT <= MAX_AUTORETRACT) gcode_M209();
  12687                    break;
  12688                #endif // FWRETRACT
  12689          
  12690                case 211: // M211: Enable, Disable, and/or Report software endstops
  12691                  gcode_M211();
   \                     ??process_parsed_command_60: (+1)
   \   000003EE   0x.... 0x....      BL       _Z10gcode_M211v
  12692                  break;
   \   000003F2   0xE034             B.N      ??process_parsed_command_11
  12693          
  12694                #if HOTENDS > 1
  12695                  case 218: // M218: Set a tool offset
  12696                    gcode_M218();
  12697                    break;
  12698                #endif // HOTENDS > 1
  12699          
  12700                case 220: // M220: Set Feedrate Percentage: S<percent> ("FR" on your LCD)
  12701                  gcode_M220();
   \                     ??process_parsed_command_61: (+1)
   \   000003F4   0x.... 0x....      BL       _Z10gcode_M220v
  12702                  break;
   \   000003F8   0xE031             B.N      ??process_parsed_command_11
  12703          
  12704                case 221: // M221: Set Flow Percentage
  12705                  gcode_M221();
   \                     ??process_parsed_command_62: (+1)
   \   000003FA   0x.... 0x....      BL       _Z10gcode_M221v
  12706                  break;
   \   000003FE   0xE02E             B.N      ??process_parsed_command_11
  12707          
  12708                case 226: // M226: Wait until a pin reaches a state
  12709                  gcode_M226();
   \                     ??process_parsed_command_63: (+1)
   \   00000400   0x.... 0x....      BL       _Z10gcode_M226v
  12710                  break;
   \   00000404   0xE02B             B.N      ??process_parsed_command_11
  12711          
  12712                #if HAS_SERVOS
  12713                  case 280: // M280: Set servo position absolute
  12714                    gcode_M280();
  12715                    break;
  12716                #endif // HAS_SERVOS
  12717          
  12718                #if ENABLED(BABYSTEPPING)
  12719                  case 290: // M290: Babystepping
  12720                    gcode_M290();
  12721                    break;
  12722                #endif // BABYSTEPPING
  12723          
  12724                #if HAS_BUZZER
  12725                  case 300: // M300: Play beep tone
  12726                    gcode_M300();
  12727                    break;
  12728                #endif // HAS_BUZZER
  12729          
  12730                #if ENABLED(PIDTEMP)
  12731                  case 301: // M301: Set hotend PID parameters
  12732                    gcode_M301();
   \                     ??process_parsed_command_64: (+1)
   \   00000406   0x.... 0x....      BL       _Z10gcode_M301v
  12733                    break;
   \   0000040A   0xE028             B.N      ??process_parsed_command_11
  12734                #endif // PIDTEMP
  12735          
  12736                #if ENABLED(PIDTEMPBED)
  12737                  case 304: // M304: Set bed PID parameters
  12738                    gcode_M304();
  12739                    break;
  12740                #endif // PIDTEMPBED
  12741          
  12742                #if defined(CHDK) || HAS_PHOTOGRAPH
  12743                  case 240: // M240: Trigger a camera by emulating a Canon RC-1 : http://www.doc-diy.net/photo/rc-1_hacked/
  12744                    gcode_M240();
  12745                    break;
  12746                #endif // CHDK || PHOTOGRAPH_PIN
  12747          
  12748                #if HAS_LCD_CONTRAST
  12749                  case 250: // M250: Set LCD contrast
  12750                    gcode_M250();
  12751                    break;
  12752                #endif // HAS_LCD_CONTRAST
  12753          
  12754                #if ENABLED(EXPERIMENTAL_I2CBUS)
  12755          
  12756                  case 260: // M260: Send data to an i2c slave
  12757                    gcode_M260();
  12758                    break;
  12759          
  12760                  case 261: // M261: Request data from an i2c slave
  12761                    gcode_M261();
  12762                    break;
  12763          
  12764                #endif // EXPERIMENTAL_I2CBUS
  12765          
  12766                #if ENABLED(PREVENT_COLD_EXTRUSION)
  12767                  case 302: // M302: Allow cold extrudes (set the minimum extrude temperature)
  12768                    gcode_M302();
  12769                    break;
  12770                #endif // PREVENT_COLD_EXTRUSION
  12771          
  12772                case 303: // M303: PID autotune
  12773                  gcode_M303();
   \                     ??process_parsed_command_65: (+1)
   \   0000040C   0x.... 0x....      BL       _Z10gcode_M303v
  12774                  break;
   \   00000410   0xE025             B.N      ??process_parsed_command_11
  12775          
  12776                #if ENABLED(MORGAN_SCARA)
  12777                  case 360:  // M360: SCARA Theta pos1
  12778                    if (gcode_M360()) return;
  12779                    break;
  12780                  case 361:  // M361: SCARA Theta pos2
  12781                    if (gcode_M361()) return;
  12782                    break;
  12783                  case 362:  // M362: SCARA Psi pos1
  12784                    if (gcode_M362()) return;
  12785                    break;
  12786                  case 363:  // M363: SCARA Psi pos2
  12787                    if (gcode_M363()) return;
  12788                    break;
  12789                  case 364:  // M364: SCARA Psi pos3 (90 deg to Theta)
  12790                    if (gcode_M364()) return;
  12791                    break;
  12792                #endif // SCARA
  12793          
  12794                case 400: // M400: Finish all moves
  12795                  gcode_M400();
   \                     ??process_parsed_command_67: (+1)
   \   00000412   0x.... 0x....      BL       _Z10gcode_M400v
  12796                  break;
   \   00000416   0xE022             B.N      ??process_parsed_command_11
  12797          
  12798                #if HAS_BED_PROBE
  12799                  case 401: // M401: Deploy probe
  12800                    gcode_M401();
  12801                    break;
  12802                  case 402: // M402: Stow probe
  12803                    gcode_M402();
  12804                    break;
  12805                #endif // HAS_BED_PROBE
  12806          
  12807                #if ENABLED(FILAMENT_WIDTH_SENSOR)
  12808                  case 404:  // M404: Enter the nominal filament width (3mm, 1.75mm ) N<3.0> or display nominal filament width
  12809                    gcode_M404();
  12810                    break;
  12811                  case 405:  // M405: Turn on filament sensor for control
  12812                    gcode_M405();
  12813                    break;
  12814                  case 406:  // M406: Turn off filament sensor for control
  12815                    gcode_M406();
  12816                    break;
  12817                  case 407:   // M407: Display measured filament diameter
  12818                    gcode_M407();
  12819                    break;
  12820                #endif // FILAMENT_WIDTH_SENSOR
  12821          
  12822                #if HAS_LEVELING
  12823                  case 420: // M420: Enable/Disable Bed Leveling
  12824                    gcode_M420();
  12825                    break;
  12826                #endif
  12827          
  12828                #if HAS_MESH
  12829                  case 421: // M421: Set a Mesh Bed Leveling Z coordinate
  12830                    gcode_M421();
  12831                    break;
  12832                #endif
  12833          
  12834                #if HAS_M206_COMMAND
  12835                  case 428: // M428: Apply current_position to home_offset
  12836                    gcode_M428();
   \                     ??process_parsed_command_69: (+1)
   \   00000418   0x.... 0x....      BL       _Z10gcode_M428v
  12837                    break;
   \   0000041C   0xE01F             B.N      ??process_parsed_command_11
  12838                #endif
  12839          
  12840                case 500: // M500: Store settings in EEPROM
  12841                  gcode_M500();
   \                     ??process_parsed_command_70: (+1)
   \   0000041E   0x.... 0x....      BL       _Z10gcode_M500v
  12842                  break;
   \   00000422   0xE01C             B.N      ??process_parsed_command_11
  12843                case 501: // M501: Read settings from EEPROM
  12844                  gcode_M501();
   \                     ??process_parsed_command_71: (+1)
   \   00000424   0x.... 0x....      BL       _Z10gcode_M501v
  12845                  break;
   \   00000428   0xE019             B.N      ??process_parsed_command_11
  12846                case 502: // M502: Revert to default settings
  12847                  gcode_M502();
   \                     ??process_parsed_command_72: (+1)
   \   0000042A   0x.... 0x....      BL       _Z10gcode_M502v
  12848                  break;
   \   0000042E   0xE016             B.N      ??process_parsed_command_11
  12849          
  12850                #if DISABLED(DISABLE_M503)
  12851                  case 503: // M503: print settings currently in memory
  12852                    gcode_M503();
   \                     ??process_parsed_command_73: (+1)
   \   00000430   0x.... 0x....      BL       _Z10gcode_M503v
  12853                    break;
   \   00000434   0xE013             B.N      ??process_parsed_command_11
  12854                #endif
  12855          
  12856                #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
  12857                  case 540: // M540: Set abort on endstop hit for SD printing
  12858                    gcode_M540();
  12859                    break;
  12860                #endif
  12861          
  12862                #if HAS_BED_PROBE
  12863                  case 851: // M851: Set Z Probe Z Offset
  12864                    gcode_M851();
  12865                    break;
  12866                #endif // HAS_BED_PROBE
  12867          
  12868                #if ENABLED(SKEW_CORRECTION_GCODE)
  12869                  case 852: // M852: Set Skew factors
  12870                    gcode_M852();
  12871                    break;
  12872                #endif
  12873          
  12874                #if ENABLED(ADVANCED_PAUSE_FEATURE)
  12875                  case 600: // M600: Pause for filament change
  12876                    gcode_M600();
  12877                    break;
  12878                #endif // ADVANCED_PAUSE_FEATURE
  12879          
  12880                #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
  12881                  case 605: // M605: Set Dual X Carriage movement mode
  12882                    gcode_M605();
  12883                    break;
  12884                #endif // DUAL_X_CARRIAGE
  12885          
  12886                #if ENABLED(MK2_MULTIPLEXER)
  12887                  case 702: // M702: Unload all extruders
  12888                    gcode_M702();
  12889                    break;
  12890                #endif
  12891          
  12892                #if ENABLED(LIN_ADVANCE)
  12893                  case 900: // M900: Set advance K factor.
  12894                    gcode_M900();
  12895                    break;
  12896                #endif
  12897          
  12898                case 907: // M907: Set digital trimpot motor current using axis codes.
  12899                  gcode_M907();
   \                     ??process_parsed_command_74: (+1)
   \   00000436   0x.... 0x....      BL       _Z10gcode_M907v
  12900                  break;
   \   0000043A   0xE010             B.N      ??process_parsed_command_11
  12901          
  12902                #if HAS_DIGIPOTSS || ENABLED(DAC_STEPPER_CURRENT)
  12903          
  12904                  case 908: // M908: Control digital trimpot directly.
  12905                    gcode_M908();
  12906                    break;
  12907          
  12908                  #if ENABLED(DAC_STEPPER_CURRENT) // As with Printrbot RevF
  12909          
  12910                    case 909: // M909: Print digipot/DAC current value
  12911                      gcode_M909();
  12912                      break;
  12913          
  12914                    case 910: // M910: Commit digipot/DAC value to external EEPROM
  12915                      gcode_M910();
  12916                      break;
  12917          
  12918                  #endif
  12919          
  12920                #endif // HAS_DIGIPOTSS || DAC_STEPPER_CURRENT
  12921          
  12922                #if ENABLED(HAVE_TMC2130) || ENABLED(HAVE_TMC2208)
  12923                  case 906: // M906: Set motor current in milliamps using axis codes X, Y, Z, E
  12924                    gcode_M906();
  12925                    break;
  12926          
  12927                  case 911: // M911: Report TMC prewarn triggered flags
  12928                    gcode_M911();
  12929                    break;
  12930          
  12931                  case 912: // M911: Clear TMC prewarn triggered flags
  12932                    gcode_M912();
  12933                    break;
  12934          
  12935                  #if ENABLED(TMC_DEBUG)
  12936                    case 122:  // Debug TMC steppers
  12937                      gcode_M122();
  12938                      break;
  12939                  #endif
  12940          
  12941                  #if ENABLED(HYBRID_THRESHOLD)
  12942                    case 913: // M913: Set HYBRID_THRESHOLD speed.
  12943                      gcode_M913();
  12944                      break;
  12945                  #endif
  12946          
  12947                  #if ENABLED(SENSORLESS_HOMING)
  12948                    case 914: // M914: Set SENSORLESS_HOMING sensitivity.
  12949                      gcode_M914();
  12950                      break;
  12951                  #endif
  12952          
  12953                  #if ENABLED(TMC_Z_CALIBRATION) && (Z_IS_TRINAMIC || Z2_IS_TRINAMIC)
  12954                    case 915: // M915: TMC Z axis calibration routine
  12955                      gcode_M915();
  12956                      break;
  12957                  #endif
  12958                #endif
  12959          
  12960                #if HAS_MICROSTEPS
  12961          
  12962                  case 350: // M350: Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.
  12963                    gcode_M350();
  12964                    break;
  12965          
  12966                  case 351: // M351: Toggle MS1 MS2 pins directly, S# determines MS1 or MS2, X# sets the pin high/low.
  12967                    gcode_M351();
  12968                    break;
  12969          
  12970                #endif // HAS_MICROSTEPS
  12971          
  12972                case 355: // M355 set case light brightness
  12973                  gcode_M355();
   \                     ??process_parsed_command_66: (+1)
   \   0000043C   0x.... 0x....      BL       _Z10gcode_M355v
  12974                  break;
   \   00000440   0xE00D             B.N      ??process_parsed_command_11
  12975          
  12976                #if ENABLED(DEBUG_GCODE_PARSER)
  12977                  case 800:
  12978                    parser.debug(); // GCode Parser Test for M
  12979                    break;
  12980                #endif
  12981          
  12982                #if ENABLED(I2C_POSITION_ENCODERS)
  12983          
  12984                  case 860: // M860 Report encoder module position
  12985                    gcode_M860();
  12986                    break;
  12987          
  12988                  case 861: // M861 Report encoder module status
  12989                    gcode_M861();
  12990                    break;
  12991          
  12992                  case 862: // M862 Perform axis test
  12993                    gcode_M862();
  12994                    break;
  12995          
  12996                  case 863: // M863 Calibrate steps/mm
  12997                    gcode_M863();
  12998                    break;
  12999          
  13000                  case 864: // M864 Change module address
  13001                    gcode_M864();
  13002                    break;
  13003          
  13004                  case 865: // M865 Check module firmware version
  13005                    gcode_M865();
  13006                    break;
  13007          
  13008                  case 866: // M866 Report axis error count
  13009                    gcode_M866();
  13010                    break;
  13011          
  13012                  case 867: // M867 Toggle error correction
  13013                    gcode_M867();
  13014                    break;
  13015          
  13016                  case 868: // M868 Set error correction threshold
  13017                    gcode_M868();
  13018                    break;
  13019          
  13020                  case 869: // M869 Report axis error
  13021                    gcode_M869();
  13022                    break;
  13023          
  13024                #endif // I2C_POSITION_ENCODERS
  13025          
  13026                case 999: // M999: Restart after being Stopped
  13027                  gcode_M999();
   \                     ??process_parsed_command_77: (+1)
   \   00000442   0x.... 0x....      BL       _Z10gcode_M999v
  13028                  break;
   \   00000446   0xE00A             B.N      ??process_parsed_command_11
  13029              }
  13030              break;
  13031          
  13032              case 'T':
  13033                gcode_T(parser.codenum);
   \                     ??process_parsed_command_2: (+1)
   \   00000448   0x.... 0x....      LDR.W    R0,??DataTable121_1
   \   0000044C   0x6800             LDR      R0,[R0, #+0]
   \   0000044E   0xB2C0             UXTB     R0,R0
   \   00000450   0x.... 0x....      BL       _Z7gcode_Th
  13034                break;
   \   00000454   0xE003             B.N      ??process_parsed_command_11
  13035          
  13036              default: parser.unknown_command_error();
   \                     ??process_parsed_command_3: (+1)
   \   00000456   0x.... 0x....      LDR.W    R0,??DataTable125_1
   \   0000045A   0x.... 0x....      BL       _ZN11GCodeParser21unknown_command_errorEv
  13037            }
  13038          
  13039            KEEPALIVE_STATE(NOT_BUSY);
  13040          
  13041            ok_to_send();
   \                     ??process_parsed_command_11: (+1)
   \   0000045E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000462   0x....             B.N      _Z10ok_to_sendv
  13042          }
  13043          

   \                                 In section .text, align 2, keep-with-next
  13044          void process_next_command() {
   \                     _Z20process_next_commandv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
  13045            char * const current_command = command_queue[cmd_queue_index_r];
   \   00000002   0x....             LDR.N    R0,??DataTable107
   \   00000004   0x7C41             LDRB     R1,[R0, #+17]
   \   00000006   0xEB01 0x0241      ADD      R2,R1,R1, LSL #+1
   \   0000000A   0xEB00 0x1142      ADD      R1,R0,R2, LSL #+5
   \   0000000E   0xF101 0x048C      ADD      R4,R1,#+140
  13046          
  13047            if (DEBUGGING(ECHO)) {
   \   00000012   0x7BC0             LDRB     R0,[R0, #+15]
   \   00000014   0x07C0             LSLS     R0,R0,#+31
   \   00000016   0xD50B             BPL.N    ??process_next_command_0
  13048              SERIAL_ECHO_START();
   \   00000018   0x....             LDR.N    R0,??DataTable107_2
   \   0000001A   0x.... 0x....      BL       _Z14serialprintPGMPKc
  13049              SERIAL_ECHOLN(current_command);
   \   0000001E   0x....             LDR.N    R5,??DataTable109
   \   00000020   0x4621             MOV      R1,R4
   \   00000022   0x4628             MOV      R0,R5
   \   00000024   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   00000028   0x210A             MOVS     R1,#+10
   \   0000002A   0x4628             MOV      R0,R5
   \   0000002C   0x.... 0x....      BL       _ZN10USARTClass5writeEh
  13050              #if ENABLED(M100_FREE_MEMORY_WATCHER)
  13051                SERIAL_ECHOPAIR("slot:", cmd_queue_index_r);
  13052                M100_dump_routine("   Command Queue:", (const char*)command_queue, (const char*)(command_queue + sizeof(command_queue)));
  13053              #endif
  13054            }
  13055          
  13056            // Parse the next command in the queue
  13057            parser.parse(current_command);
   \                     ??process_next_command_0: (+1)
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
  13058            process_parsed_command();
   \   00000036   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   0000003A   0x....             B.N      _Z22process_parsed_commandv
  13059          }
  13060          
  13061          /**
  13062           * Send a "Resend: nnn" message to the host to
  13063           * indicate that a command needs to be re-sent.
  13064           */

   \                                 In section .text, align 2, keep-with-next
  13065          void FlushSerialRequestResend() {
   \                     _Z24FlushSerialRequestResendv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
  13066            //char command_queue[cmd_queue_index_r][100]="Resend:";
  13067            MYSERIAL.flush();
   \   00000002   0x....             LDR.N    R4,??DataTable109
   \   00000004   0x4620             MOV      R0,R4
   \   00000006   0x.... 0x....      BL       _ZN10USARTClass5flushEv
  13068            SERIAL_PROTOCOLPGM(MSG_RESEND);
   \   0000000A   0x.... 0x....      ADR.W    R0,`?<Constant "Resend: ">`
   \   0000000E   0x.... 0x....      BL       _Z14serialprintPGMPKc
  13069            SERIAL_PROTOCOLLN(gcode_LastN + 1);
   \   00000012   0x220A             MOVS     R2,#+10
   \   00000014   0x....             LDR.N    R0,??DataTable107
   \   00000016   0x6F00             LDR      R0,[R0, #+112]
   \   00000018   0x1C41             ADDS     R1,R0,#+1
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       _ZN5Print5printEli
   \   00000020   0x210A             MOVS     R1,#+10
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       _ZN10USARTClass5writeEh
  13070            ok_to_send();
   \   00000028   0xE8BD 0x4010      POP      {R4,LR}
   \   0000002C                      REQUIRE _Z10ok_to_sendv
   \   0000002C                      ;; // Fall through to label ok_to_send()
  13071          }
  13072          
  13073          /**
  13074           * Send an "ok" message to the host, indicating
  13075           * that a command was successfully processed.
  13076           *
  13077           * If ADVANCED_OK is enabled also include:
  13078           *   N<int>  Line number of the command, if any
  13079           *   P<int>  Planner space remaining
  13080           *   B<int>  Block queue space remaining
  13081           */

   \                                 In section .text, align 2, keep-with-next
  13082          void ok_to_send() {
   \                     _Z10ok_to_sendv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  13083            refresh_cmd_timeout();
   \   00000002   0x.... 0x....      BL       _Z19refresh_cmd_timeoutv
  13084            if (!send_ok[cmd_queue_index_r]) return;
   \   00000006   0x....             LDR.N    R0,??DataTable107
   \   00000008   0x7C41             LDRB     R1,[R0, #+17]
   \   0000000A   0x1808             ADDS     R0,R1,R0
   \   0000000C   0x7F00             LDRB     R0,[R0, #+28]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD008             BEQ.N    ??ok_to_send_0
  13085            SERIAL_PROTOCOLPGM(MSG_OK);
   \   00000012   0x....             ADR.N    R0,??DataTable111_3  ;; 0x6F, 0x6B, 0x00, 0x00
   \   00000014   0x.... 0x....      BL       _Z14serialprintPGMPKc
  13086            #if ENABLED(ADVANCED_OK)
  13087              char* p = command_queue[cmd_queue_index_r];
  13088              if (*p == 'N') {
  13089                SERIAL_PROTOCOL(' ');
  13090                SERIAL_ECHO(*p++);
  13091                while (NUMERIC_SIGNED(*p))
  13092                  SERIAL_ECHO(*p++);
  13093              }
  13094              SERIAL_PROTOCOLPGM(" P"); SERIAL_PROTOCOL(int(BLOCK_BUFFER_SIZE - planner.movesplanned() - 1));
  13095              SERIAL_PROTOCOLPGM(" B"); SERIAL_PROTOCOL(BUFSIZE - commands_in_queue);
  13096            #endif
  13097            SERIAL_EOL();
   \   00000018   0x210A             MOVS     R1,#+10
   \   0000001A   0x....             LDR.N    R0,??DataTable109
   \   0000001C   0xE8BD 0x4004      POP      {R2,LR}
   \   00000020   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   \                     ??ok_to_send_0: (+1)
   \   00000024   0xBD01             POP      {R0,PC}          ;; return
  13098          }
  13099          
  13100          #if HAS_SOFTWARE_ENDSTOPS
  13101          
  13102            /**
  13103             * Constrain the given coordinates to the software endstops.
  13104             *
  13105             * For DELTA/SCARA the XY constraint is based on the smallest
  13106             * radius within the set software endstops.
  13107             */

   \                                 In section .text, align 2, keep-with-next
  13108            void clamp_to_software_endstops(float target[XYZ]) {
  13109              if (!soft_endstops_enabled) return;
   \                     _Z26clamp_to_software_endstopsPf: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable125_2
   \   00000004   0x780A             LDRB     R2,[R1, #+0]
   \   00000006   0x2A00             CMP      R2,#+0
   \   00000008   0xD04F             BEQ.N    ??clamp_to_software_endstops_0
  13110              #if IS_KINEMATIC
  13111                const float dist_2 = HYPOT2(target[X_AXIS], target[Y_AXIS]);
  13112                if (dist_2 > soft_endstop_radius_2) {
  13113                  const float ratio = soft_endstop_radius / SQRT(dist_2); // 200 / 300 = 0.66
  13114                  target[X_AXIS] *= ratio;
  13115                  target[Y_AXIS] *= ratio;
  13116                }
  13117              #else
  13118          		if(mksCfg.min_software_endstops)
   \   0000000A   0x.... 0x....      LDR.W    R2,??DataTable126
   \   0000000E   0x7B13             LDRB     R3,[R2, #+12]
   \   00000010   0x2B00             CMP      R3,#+0
   \   00000012   0xD015             BEQ.N    ??clamp_to_software_endstops_1
  13119          		{
  13120                		//#if ENABLED(MIN_SOFTWARE_ENDSTOP_X)
  13121                 	 	NOLESS(target[X_AXIS], soft_endstop_min[X_AXIS]);
   \   00000014   0xED91 0x0A04      VLDR     S0,[R1, #+16]
   \   00000018   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   0000001C   0xEEF4 0x0A40      VCMP.F32 S1,S0
   \   00000020   0xEEF1 0xFA10      FMSTAT   
   \   00000024   0xD501             BPL.N    ??clamp_to_software_endstops_2
   \   00000026   0xED80 0x0A00      VSTR     S0,[R0, #0]
  13122                		//#endif
  13123                		//#if ENABLED(MIN_SOFTWARE_ENDSTOP_Y)
  13124                  	NOLESS(target[Y_AXIS], soft_endstop_min[Y_AXIS]);
   \                     ??clamp_to_software_endstops_2: (+1)
   \   0000002A   0xED91 0x0A05      VLDR     S0,[R1, #+20]
   \   0000002E   0xEDD0 0x0A01      VLDR     S1,[R0, #+4]
   \   00000032   0xEEF4 0x0A40      VCMP.F32 S1,S0
   \   00000036   0xEEF1 0xFA10      FMSTAT   
   \   0000003A   0xD501             BPL.N    ??clamp_to_software_endstops_1
   \   0000003C   0xED80 0x0A01      VSTR     S0,[R0, #+4]
  13125                		//#endif
  13126          		}
  13127          		if(mksCfg.max_software_endstops)
   \                     ??clamp_to_software_endstops_1: (+1)
   \   00000040   0x7B53             LDRB     R3,[R2, #+13]
   \   00000042   0x2B00             CMP      R3,#+0
   \   00000044   0xD015             BEQ.N    ??clamp_to_software_endstops_3
  13128          		{	
  13129                		//#if ENABLED(MAX_SOFTWARE_ENDSTOP_X)
  13130                  	NOMORE(target[X_AXIS], soft_endstop_max[X_AXIS]);
   \   00000046   0xED91 0x0A07      VLDR     S0,[R1, #+28]
   \   0000004A   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   0000004E   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000052   0xEEF1 0xFA10      FMSTAT   
   \   00000056   0xD501             BPL.N    ??clamp_to_software_endstops_4
   \   00000058   0xED80 0x0A00      VSTR     S0,[R0, #0]
  13131                		//#endif
  13132                		//#if ENABLED(MAX_SOFTWARE_ENDSTOP_Y)
  13133                  	NOMORE(target[Y_AXIS], soft_endstop_max[Y_AXIS]);
   \                     ??clamp_to_software_endstops_4: (+1)
   \   0000005C   0xED91 0x0A08      VLDR     S0,[R1, #+32]
   \   00000060   0xEDD0 0x0A01      VLDR     S1,[R0, #+4]
   \   00000064   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000068   0xEEF1 0xFA10      FMSTAT   
   \   0000006C   0xD501             BPL.N    ??clamp_to_software_endstops_3
   \   0000006E   0xED80 0x0A01      VSTR     S0,[R0, #+4]
  13134                		//#endif
  13135          		}
  13136              #endif
  13137          	if(mksCfg.min_software_endstops)
   \                     ??clamp_to_software_endstops_3: (+1)
   \   00000072   0x7B13             LDRB     R3,[R2, #+12]
   \   00000074   0x2B00             CMP      R3,#+0
   \   00000076   0xD00A             BEQ.N    ??clamp_to_software_endstops_5
  13138          	{
  13139              //#if ENABLED(MIN_SOFTWARE_ENDSTOP_Z)
  13140                NOLESS(target[Z_AXIS], soft_endstop_min[Z_AXIS]);
   \   00000078   0xED91 0x0A06      VLDR     S0,[R1, #+24]
   \   0000007C   0xEDD0 0x0A02      VLDR     S1,[R0, #+8]
   \   00000080   0xEEF4 0x0A40      VCMP.F32 S1,S0
   \   00000084   0xEEF1 0xFA10      FMSTAT   
   \   00000088   0xD501             BPL.N    ??clamp_to_software_endstops_5
   \   0000008A   0xED80 0x0A02      VSTR     S0,[R0, #+8]
  13141              //#endif
  13142          	}
  13143          	if(mksCfg.max_software_endstops)
   \                     ??clamp_to_software_endstops_5: (+1)
   \   0000008E   0x7B52             LDRB     R2,[R2, #+13]
   \   00000090   0x2A00             CMP      R2,#+0
   \   00000092   0xD00A             BEQ.N    ??clamp_to_software_endstops_0
  13144          	{
  13145              //#if ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
  13146                NOMORE(target[Z_AXIS], soft_endstop_max[Z_AXIS]);
   \   00000094   0xED91 0x0A09      VLDR     S0,[R1, #+36]
   \   00000098   0xEDD0 0x0A02      VLDR     S1,[R0, #+8]
   \   0000009C   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   000000A0   0xEEF1 0xFA10      FMSTAT   
   \   000000A4   0xD501             BPL.N    ??clamp_to_software_endstops_0
   \   000000A6   0xED80 0x0A02      VSTR     S0,[R0, #+8]
  13147              //#endif
  13148          	}
  13149          }  
   \                     ??clamp_to_software_endstops_0: (+1)
   \   000000AA   0x4770             BX       LR               ;; return
  13150          
  13151          #endif
  13152          
  13153          #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
  13154          
  13155            #if ENABLED(ABL_BILINEAR_SUBDIVISION)
  13156              #define ABL_BG_SPACING(A) bilinear_grid_spacing_virt[A]
  13157              #define ABL_BG_FACTOR(A)  bilinear_grid_factor_virt[A]
  13158              #define ABL_BG_POINTS_X   ABL_GRID_POINTS_VIRT_X
  13159              #define ABL_BG_POINTS_Y   ABL_GRID_POINTS_VIRT_Y
  13160              #define ABL_BG_GRID(X,Y)  z_values_virt[X][Y]
  13161            #else
  13162              #define ABL_BG_SPACING(A) bilinear_grid_spacing[A]
  13163              #define ABL_BG_FACTOR(A)  bilinear_grid_factor[A]
  13164              #define ABL_BG_POINTS_X   GRID_MAX_POINTS_X
  13165              #define ABL_BG_POINTS_Y   GRID_MAX_POINTS_Y
  13166              #define ABL_BG_GRID(X,Y)  z_values[X][Y]
  13167            #endif
  13168          
  13169            // Get the Z adjustment for non-linear bed leveling
  13170            float bilinear_z_offset(const float raw[XYZ]) {
  13171          
  13172              static float z1, d2, z3, d4, L, D, ratio_x, ratio_y,
  13173                           last_x = -999.999, last_y = -999.999;
  13174          
  13175              // Whole units for the grid line indices. Constrained within bounds.
  13176              static int8_t gridx, gridy, nextx, nexty,
  13177                            last_gridx = -99, last_gridy = -99;
  13178          
  13179              // XY relative to the probed area
  13180              const float rx = raw[X_AXIS] - bilinear_start[X_AXIS],
  13181                          ry = raw[Y_AXIS] - bilinear_start[Y_AXIS];
  13182          
  13183              #if ENABLED(EXTRAPOLATE_BEYOND_GRID)
  13184                // Keep using the last grid box
  13185                #define FAR_EDGE_OR_BOX 2
  13186              #else
  13187                // Just use the grid far edge
  13188                #define FAR_EDGE_OR_BOX 1
  13189              #endif
  13190          
  13191              if (last_x != rx) {
  13192                last_x = rx;
  13193                ratio_x = rx * ABL_BG_FACTOR(X_AXIS);
  13194                const float gx = constrain(FLOOR(ratio_x), 0, ABL_BG_POINTS_X - FAR_EDGE_OR_BOX);
  13195                ratio_x -= gx;      // Subtract whole to get the ratio within the grid box
  13196          
  13197                #if DISABLED(EXTRAPOLATE_BEYOND_GRID)
  13198                  // Beyond the grid maintain height at grid edges
  13199                  NOLESS(ratio_x, 0); // Never < 0.0. (> 1.0 is ok when nextx==gridx.)
  13200                #endif
  13201          
  13202                gridx = gx;
  13203                nextx = min(gridx + 1, ABL_BG_POINTS_X - 1);
  13204              }
  13205          
  13206              if (last_y != ry || last_gridx != gridx) {
  13207          
  13208                if (last_y != ry) {
  13209                  last_y = ry;
  13210                  ratio_y = ry * ABL_BG_FACTOR(Y_AXIS);
  13211                  const float gy = constrain(FLOOR(ratio_y), 0, ABL_BG_POINTS_Y - FAR_EDGE_OR_BOX);
  13212                  ratio_y -= gy;
  13213          
  13214                  #if DISABLED(EXTRAPOLATE_BEYOND_GRID)
  13215                    // Beyond the grid maintain height at grid edges
  13216                    NOLESS(ratio_y, 0); // Never < 0.0. (> 1.0 is ok when nexty==gridy.)
  13217                  #endif
  13218          
  13219                  gridy = gy;
  13220                  nexty = min(gridy + 1, ABL_BG_POINTS_Y - 1);
  13221                }
  13222          
  13223                if (last_gridx != gridx || last_gridy != gridy) {
  13224                  last_gridx = gridx;
  13225                  last_gridy = gridy;
  13226                  // Z at the box corners
  13227                  z1 = ABL_BG_GRID(gridx, gridy);       // left-front
  13228                  d2 = ABL_BG_GRID(gridx, nexty) - z1;  // left-back (delta)
  13229                  z3 = ABL_BG_GRID(nextx, gridy);       // right-front
  13230                  d4 = ABL_BG_GRID(nextx, nexty) - z3;  // right-back (delta)
  13231                }
  13232          
  13233                // Bilinear interpolate. Needed since ry or gridx has changed.
  13234                            L = z1 + d2 * ratio_y;   // Linear interp. LF -> LB
  13235                const float R = z3 + d4 * ratio_y;   // Linear interp. RF -> RB
  13236          
  13237                D = R - L;
  13238              }
  13239          
  13240              const float offset = L + ratio_x * D;   // the offset almost always changes
  13241          
  13242              /*
  13243              static float last_offset = 0;
  13244              if (FABS(last_offset - offset) > 0.2) {
  13245                SERIAL_ECHOPGM("Sudden Shift at ");
  13246                SERIAL_ECHOPAIR("x=", rx);
  13247                SERIAL_ECHOPAIR(" / ", bilinear_grid_spacing[X_AXIS]);
  13248                SERIAL_ECHOLNPAIR(" -> gridx=", gridx);
  13249                SERIAL_ECHOPAIR(" y=", ry);
  13250                SERIAL_ECHOPAIR(" / ", bilinear_grid_spacing[Y_AXIS]);
  13251                SERIAL_ECHOLNPAIR(" -> gridy=", gridy);
  13252                SERIAL_ECHOPAIR(" ratio_x=", ratio_x);
  13253                SERIAL_ECHOLNPAIR(" ratio_y=", ratio_y);
  13254                SERIAL_ECHOPAIR(" z1=", z1);
  13255                SERIAL_ECHOPAIR(" z2=", z2);
  13256                SERIAL_ECHOPAIR(" z3=", z3);
  13257                SERIAL_ECHOLNPAIR(" z4=", z4);
  13258                SERIAL_ECHOPAIR(" L=", L);
  13259                SERIAL_ECHOPAIR(" R=", R);
  13260                SERIAL_ECHOLNPAIR(" offset=", offset);
  13261              }
  13262              last_offset = offset;
  13263              //*/
                      ^
Warning[Pe009]: nested comment is not allowed
  13264          
  13265              return offset;
  13266            }
  13267          
  13268          #endif // AUTO_BED_LEVELING_BILINEAR
  13269          
  13270          #if ENABLED(DELTA)
  13271          
  13272            /**
  13273             * Recalculate factors used for delta kinematics whenever
  13274             * settings have been changed (e.g., by M665).
  13275             */
  13276            void recalc_delta_settings() {
  13277              const float trt[ABC] = DELTA_RADIUS_TRIM_TOWER,
  13278                          drt[ABC] = DELTA_DIAGONAL_ROD_TRIM_TOWER;
  13279              delta_tower[A_AXIS][X_AXIS] = cos(RADIANS(210 + delta_tower_angle_trim[A_AXIS])) * (delta_radius + trt[A_AXIS]); // front left tower
  13280              delta_tower[A_AXIS][Y_AXIS] = sin(RADIANS(210 + delta_tower_angle_trim[A_AXIS])) * (delta_radius + trt[A_AXIS]);
  13281              delta_tower[B_AXIS][X_AXIS] = cos(RADIANS(330 + delta_tower_angle_trim[B_AXIS])) * (delta_radius + trt[B_AXIS]); // front right tower
  13282              delta_tower[B_AXIS][Y_AXIS] = sin(RADIANS(330 + delta_tower_angle_trim[B_AXIS])) * (delta_radius + trt[B_AXIS]);
  13283              delta_tower[C_AXIS][X_AXIS] = cos(RADIANS( 90 + delta_tower_angle_trim[C_AXIS])) * (delta_radius + trt[C_AXIS]); // back middle tower
  13284              delta_tower[C_AXIS][Y_AXIS] = sin(RADIANS( 90 + delta_tower_angle_trim[C_AXIS])) * (delta_radius + trt[C_AXIS]);
  13285              delta_diagonal_rod_2_tower[A_AXIS] = sq(delta_diagonal_rod + drt[A_AXIS]);
  13286              delta_diagonal_rod_2_tower[B_AXIS] = sq(delta_diagonal_rod + drt[B_AXIS]);
  13287              delta_diagonal_rod_2_tower[C_AXIS] = sq(delta_diagonal_rod + drt[C_AXIS]);
  13288              update_software_endstops(Z_AXIS);
  13289              axis_homed[X_AXIS] = axis_homed[Y_AXIS] = axis_homed[Z_AXIS] = false;
  13290            }
  13291          
  13292            #if ENABLED(DELTA_FAST_SQRT)
  13293              /**
  13294               * Fast inverse sqrt from Quake III Arena
  13295               * See: https://en.wikipedia.org/wiki/Fast_inverse_square_root
  13296               */
  13297              float Q_rsqrt(const float number) {
  13298                long i;
  13299                float x2, y;
  13300                const float threehalfs = 1.5f;
  13301                x2 = number * 0.5f;
  13302                y  = number;
  13303                i  = * ( long * ) &y;                       // evil floating point bit level hacking
  13304                i  = 0x5F3759DF - ( i >> 1 );               // what the f***?
  13305                y  = * ( float * ) &i;
  13306                y  = y * ( threehalfs - ( x2 * y * y ) );   // 1st iteration
  13307                // y  = y * ( threehalfs - ( x2 * y * y ) );   // 2nd iteration, this can be removed
  13308                return y;
  13309              }
  13310          
  13311            #endif
  13312          
  13313            /**
  13314             * Delta Inverse Kinematics
  13315             *
  13316             * Calculate the tower positions for a given machine
  13317             * position, storing the result in the delta[] array.
  13318             *
  13319             * This is an expensive calculation, requiring 3 square
  13320             * roots per segmented linear move, and strains the limits
  13321             * of a Mega2560 with a Graphical Display.
  13322             *
  13323             * Suggested optimizations include:
  13324             *
  13325             * - Disable the home_offset (M206) and/or position_shift (G92)
  13326             *   features to remove up to 12 float additions.
  13327             *
  13328             * - Use a fast-inverse-sqrt function and add the reciprocal.
  13329             *   (see above)
  13330             */
  13331          
  13332            #define DELTA_DEBUG() do { \
  13333                SERIAL_ECHOPAIR("cartesian X:", raw[X_AXIS]); \
  13334                SERIAL_ECHOPAIR(" Y:", raw[Y_AXIS]);          \
  13335                SERIAL_ECHOLNPAIR(" Z:", raw[Z_AXIS]);        \
  13336                SERIAL_ECHOPAIR("delta A:", delta[A_AXIS]);   \
  13337                SERIAL_ECHOPAIR(" B:", delta[B_AXIS]);        \
  13338                SERIAL_ECHOLNPAIR(" C:", delta[C_AXIS]);      \
  13339              }while(0)
  13340          
  13341            void inverse_kinematics(const float raw[XYZ]) {
  13342              DELTA_IK(raw);
  13343              // DELTA_DEBUG();
  13344            }
  13345          
  13346            /**
  13347             * Calculate the highest Z position where the
  13348             * effector has the full range of XY motion.
  13349             */
  13350            float delta_safe_distance_from_top() {
  13351              float cartesian[XYZ] = { 0, 0, 0 };
  13352              inverse_kinematics(cartesian);
  13353              float distance = delta[A_AXIS];
  13354              cartesian[Y_AXIS] = DELTA_PRINTABLE_RADIUS;
  13355              inverse_kinematics(cartesian);
  13356              return FABS(distance - delta[A_AXIS]);
  13357            }
  13358          
  13359            /**
  13360             * Delta Forward Kinematics
  13361             *
  13362             * See the Wikipedia article "Trilateration"
  13363             * https://en.wikipedia.org/wiki/Trilateration
  13364             *
  13365             * Establish a new coordinate system in the plane of the
  13366             * three carriage points. This system has its origin at
  13367             * tower1, with tower2 on the X axis. Tower3 is in the X-Y
  13368             * plane with a Z component of zero.
  13369             * We will define unit vectors in this coordinate system
  13370             * in our original coordinate system. Then when we calculate
  13371             * the Xnew, Ynew and Znew values, we can translate back into
  13372             * the original system by moving along those unit vectors
  13373             * by the corresponding values.
  13374             *
  13375             * Variable names matched to Marlin, c-version, and avoid the
  13376             * use of any vector library.
  13377             *
  13378             * by Andreas Hardtung 2016-06-07
  13379             * based on a Java function from "Delta Robot Kinematics V3"
  13380             * by Steve Graves
  13381             *
  13382             * The result is stored in the cartes[] array.
  13383             */
  13384            void forward_kinematics_DELTA(float z1, float z2, float z3) {
  13385              // Create a vector in old coordinates along x axis of new coordinate
  13386              const float p12[] = {
  13387                delta_tower[B_AXIS][X_AXIS] - delta_tower[A_AXIS][X_AXIS],
  13388                delta_tower[B_AXIS][Y_AXIS] - delta_tower[A_AXIS][Y_AXIS],
  13389                z2 - z1
  13390              },
  13391          
  13392              // Get the Magnitude of vector.
  13393              d = SQRT(sq(p12[0]) + sq(p12[1]) + sq(p12[2])),
  13394          
  13395              // Create unit vector by dividing by magnitude.
  13396              ex[3] = { p12[0] / d, p12[1] / d, p12[2] / d },
  13397          
  13398              // Get the vector from the origin of the new system to the third point.
  13399              p13[3] = {
  13400                delta_tower[C_AXIS][X_AXIS] - delta_tower[A_AXIS][X_AXIS],
  13401                delta_tower[C_AXIS][Y_AXIS] - delta_tower[A_AXIS][Y_AXIS],
  13402                z3 - z1
  13403              },
  13404          
  13405              // Use the dot product to find the component of this vector on the X axis.
  13406              i = ex[0] * p13[0] + ex[1] * p13[1] + ex[2] * p13[2],
  13407          
  13408              // Create a vector along the x axis that represents the x component of p13.
  13409              iex[] = { ex[0] * i, ex[1] * i, ex[2] * i };
  13410          
  13411              // Subtract the X component from the original vector leaving only Y. We use the
  13412              // variable that will be the unit vector after we scale it.
  13413              float ey[3] = { p13[0] - iex[0], p13[1] - iex[1], p13[2] - iex[2] };
  13414          
  13415              // The magnitude of Y component
  13416              const float j = SQRT(sq(ey[0]) + sq(ey[1]) + sq(ey[2]));
  13417          
  13418              // Convert to a unit vector
  13419              ey[0] /= j; ey[1] /= j;  ey[2] /= j;
  13420          
  13421              // The cross product of the unit x and y is the unit z
  13422              // float[] ez = vectorCrossProd(ex, ey);
  13423              const float ez[3] = {
  13424                ex[1] * ey[2] - ex[2] * ey[1],
  13425                ex[2] * ey[0] - ex[0] * ey[2],
  13426                ex[0] * ey[1] - ex[1] * ey[0]
  13427              },
  13428              // We now have the d, i and j values defined in Wikipedia.
  13429              // Plug them into the equations defined in Wikipedia for Xnew, Ynew and Znew
  13430              Xnew = (delta_diagonal_rod_2_tower[A_AXIS] - delta_diagonal_rod_2_tower[B_AXIS] + sq(d)) / (d * 2),
  13431              Ynew = ((delta_diagonal_rod_2_tower[A_AXIS] - delta_diagonal_rod_2_tower[C_AXIS] + HYPOT2(i, j)) / 2 - i * Xnew) / j,
  13432              Znew = SQRT(delta_diagonal_rod_2_tower[A_AXIS] - HYPOT2(Xnew, Ynew));
  13433          
  13434              // Start from the origin of the old coordinates and add vectors in the
  13435              // old coords that represent the Xnew, Ynew and Znew to find the point
  13436              // in the old system.
  13437              cartes[X_AXIS] = delta_tower[A_AXIS][X_AXIS] + ex[0] * Xnew + ey[0] * Ynew - ez[0] * Znew;
  13438              cartes[Y_AXIS] = delta_tower[A_AXIS][Y_AXIS] + ex[1] * Xnew + ey[1] * Ynew - ez[1] * Znew;
  13439              cartes[Z_AXIS] =             z1 + ex[2] * Xnew + ey[2] * Ynew - ez[2] * Znew;
  13440            }
  13441          
  13442            void forward_kinematics_DELTA(float point[ABC]) {
  13443              forward_kinematics_DELTA(point[A_AXIS], point[B_AXIS], point[C_AXIS]);
  13444            }
  13445          
  13446          #endif // DELTA
  13447          
  13448          /**
  13449           * Get the stepper positions in the cartes[] array.
  13450           * Forward kinematics are applied for DELTA and SCARA.
  13451           *
  13452           * The result is in the current coordinate space with
  13453           * leveling applied. The coordinates need to be run through
  13454           * unapply_leveling to obtain machine coordinates suitable
  13455           * for current_position, etc.
  13456           */

   \                                 In section .text, align 2, keep-with-next
  13457          void get_cartesian_from_steppers() {
   \                     _Z27get_cartesian_from_steppersv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
  13458            #if ENABLED(DELTA)
  13459              forward_kinematics_DELTA(
  13460                stepper.get_axis_position_mm(A_AXIS),
  13461                stepper.get_axis_position_mm(B_AXIS),
  13462                stepper.get_axis_position_mm(C_AXIS)
  13463              );
  13464            #else
  13465              #if IS_SCARA
  13466                forward_kinematics_SCARA(
  13467                  stepper.get_axis_position_degrees(A_AXIS),
  13468                  stepper.get_axis_position_degrees(B_AXIS)
  13469                );
  13470              #else
  13471                cartes[X_AXIS] = stepper.get_axis_position_mm(X_AXIS);
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable126_1
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x.... 0x....      BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
   \   0000000C   0xED84 0x0A00      VSTR     S0,[R4, #0]
  13472                cartes[Y_AXIS] = stepper.get_axis_position_mm(Y_AXIS);
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x.... 0x....      BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
   \   00000016   0xED84 0x0A01      VSTR     S0,[R4, #+4]
  13473              #endif
  13474              cartes[Z_AXIS] = stepper.get_axis_position_mm(Z_AXIS);
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0x.... 0x....      BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
   \   00000020   0xED84 0x0A02      VSTR     S0,[R4, #+8]
  13475            #endif
  13476          }
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
  13477          
  13478          /**
  13479           * Set the current_position for an axis based on
  13480           * the stepper positions, removing any leveling that
  13481           * may have been applied.
  13482           *
  13483           * To prevent small shifts in axis position always call
  13484           * SYNC_PLAN_POSITION_KINEMATIC after updating axes with this.
  13485           *
  13486           * To keep hosts in sync, always call report_current_position
  13487           * after updating the current_position.
  13488           */

   \                                 In section .text, align 2, keep-with-next
  13489          void set_current_from_steppers_for_axis(const AxisEnum axis) {
   \                     _Z34set_current_from_steppers_for_axis8AxisEnum: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
  13490            get_cartesian_from_steppers();
   \   00000004   0x.... 0x....      BL       _Z27get_cartesian_from_steppersv
  13491            #if PLANNER_LEVELING
  13492              planner.unapply_leveling(cartes);
  13493            #endif
  13494            if (axis == ALL_AXES)
   \   00000008   0x....             LDR.N    R0,??DataTable111_1
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable126_1
   \   0000000E   0x2C64             CMP      R4,#+100
   \   00000010   0xD105             BNE.N    ??set_current_from_steppers_for_axis_0
  13495              COPY(current_position, cartes);
   \   00000012   0x220C             MOVS     R2,#+12
   \   00000014   0x3024             ADDS     R0,R0,#+36
   \   00000016   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001A   0x.... 0x....      B.W      memcpy
  13496            else
  13497              current_position[axis] = cartes[axis];
   \                     ??set_current_from_steppers_for_axis_0: (+1)
   \   0000001E   0xEB00 0x0084      ADD      R0,R0,R4, LSL #+2
   \   00000022   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   00000026   0x6241             STR      R1,[R0, #+36]
  13498          }
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
  13499          
  13500          #if IS_CARTESIAN
  13501          #if ENABLED(SEGMENT_LEVELED_MOVES)
  13502          
  13503            /**
  13504             * Prepare a segmented move on a CARTESIAN setup.
  13505             *
  13506             * This calls planner.buffer_line several times, adding
  13507             * small incremental moves. This allows the planner to
  13508             * apply more detailed bed leveling to the full move.
  13509             */
  13510            inline void segmented_line_to_destination(const float &fr_mm_s, const float segment_size=LEVELED_SEGMENT_LENGTH) {
  13511          
  13512              const float xdiff = destination[X_AXIS] - current_position[X_AXIS],
  13513                          ydiff = destination[Y_AXIS] - current_position[Y_AXIS];
  13514          
  13515              // If the move is only in Z/E don't split up the move
  13516              if (!xdiff && !ydiff) {
  13517                planner.buffer_line_kinematic(destination, fr_mm_s, active_extruder);
  13518                return;
  13519              }
  13520          
  13521              // Remaining cartesian distances
  13522              const float zdiff = destination[Z_AXIS] - current_position[Z_AXIS],
  13523                          ediff = destination[E_AXIS] - current_position[E_AXIS];
  13524          
  13525              // Get the linear distance in XYZ
  13526              // If the move is very short, check the E move distance
  13527              // No E move either? Game over.
  13528              float cartesian_mm = SQRT(sq(xdiff) + sq(ydiff) + sq(zdiff));
  13529              if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = FABS(ediff);
  13530              if (UNEAR_ZERO(cartesian_mm)) return;
  13531          
  13532              // The length divided by the segment size
  13533              // At least one segment is required
  13534              uint16_t segments = cartesian_mm / segment_size;
  13535              NOLESS(segments, 1);
  13536          
  13537              // The approximate length of each segment
  13538              const float inv_segments = 1.0 / float(segments),
  13539                          segment_distance[XYZE] = {
  13540                            xdiff * inv_segments,
  13541                            ydiff * inv_segments,
  13542                            zdiff * inv_segments,
  13543                            ediff * inv_segments
  13544                          };
  13545          
  13546              // SERIAL_ECHOPAIR("mm=", cartesian_mm);
  13547              // SERIAL_ECHOLNPAIR(" segments=", segments);
  13548          
  13549              // Get the raw current position as starting point
  13550              float raw[XYZE];
  13551              COPY(raw, current_position);
  13552          
  13553              // Calculate and execute the segments
  13554              while (--segments) {
  13555                static millis_t next_idle_ms = millis() + 200UL;
  13556                thermalManager.manage_heater();  // This returns immediately if not really needed.
  13557                if (ELAPSED(millis(), next_idle_ms)) {
  13558                  next_idle_ms = millis() + 200UL;
  13559                  idle();
  13560                }
  13561                LOOP_XYZE(i) raw[i] += segment_distance[i];
  13562                planner.buffer_line_kinematic(raw, fr_mm_s, active_extruder);
  13563              }
  13564          
  13565              // Since segment_distance is only approximate,
  13566              // the final move must be to the exact destination.
  13567              planner.buffer_line_kinematic(destination, fr_mm_s, active_extruder);
  13568            }
  13569          
  13570          #elif ENABLED(MESH_BED_LEVELING)
  13571          
  13572            /**
  13573             * Prepare a mesh-leveled linear move in a Cartesian setup,
  13574             * splitting the move where it crosses mesh borders.
  13575             */
  13576            void mesh_line_to_destination(const float fr_mm_s, uint8_t x_splits=0xFF, uint8_t y_splits=0xFF) {
  13577              // Get current and destination cells for this line
  13578              int cx1 = mbl.cell_index_x(current_position[X_AXIS]),
  13579                  cy1 = mbl.cell_index_y(current_position[Y_AXIS]),
  13580                  cx2 = mbl.cell_index_x(destination[X_AXIS]),
  13581                  cy2 = mbl.cell_index_y(destination[Y_AXIS]);
  13582              NOMORE(cx1, GRID_MAX_POINTS_X - 2);
  13583              NOMORE(cy1, GRID_MAX_POINTS_Y - 2);
  13584              NOMORE(cx2, GRID_MAX_POINTS_X - 2);
  13585              NOMORE(cy2, GRID_MAX_POINTS_Y - 2);
  13586          
  13587              // Start and end in the same cell? No split needed.
  13588              if (cx1 == cx2 && cy1 == cy2) {
  13589                buffer_line_to_destination(fr_mm_s);
  13590                set_current_from_destination();
  13591                return;
  13592              }
  13593          
  13594              #define MBL_SEGMENT_END(A) (current_position[A ##_AXIS] + (destination[A ##_AXIS] - current_position[A ##_AXIS]) * normalized_dist)
  13595          
  13596              float normalized_dist, end[XYZE];
  13597              const int8_t gcx = max(cx1, cx2), gcy = max(cy1, cy2);
  13598          
  13599              // Crosses on the X and not already split on this X?
  13600              // The x_splits flags are insurance against rounding errors.
  13601              if (cx2 != cx1 && TEST(x_splits, gcx)) {
  13602                // Split on the X grid line
  13603                CBI(x_splits, gcx);
  13604                COPY(end, destination);
  13605                destination[X_AXIS] = mbl.index_to_xpos[gcx];
  13606                normalized_dist = (destination[X_AXIS] - current_position[X_AXIS]) / (end[X_AXIS] - current_position[X_AXIS]);
  13607                destination[Y_AXIS] = MBL_SEGMENT_END(Y);
  13608              }
  13609              // Crosses on the Y and not already split on this Y?
  13610              else if (cy2 != cy1 && TEST(y_splits, gcy)) {
  13611                // Split on the Y grid line
  13612                CBI(y_splits, gcy);
  13613                COPY(end, destination);
  13614                destination[Y_AXIS] = mbl.index_to_ypos[gcy];
  13615                normalized_dist = (destination[Y_AXIS] - current_position[Y_AXIS]) / (end[Y_AXIS] - current_position[Y_AXIS]);
  13616                destination[X_AXIS] = MBL_SEGMENT_END(X);
  13617              }
  13618              else {
  13619                // Must already have been split on these border(s)
  13620                buffer_line_to_destination(fr_mm_s);
  13621                set_current_from_destination();
  13622                return;
  13623              }
  13624          
  13625              destination[Z_AXIS] = MBL_SEGMENT_END(Z);
  13626              destination[E_AXIS] = MBL_SEGMENT_END(E);
  13627          
  13628              // Do the split and look for more borders
  13629              mesh_line_to_destination(fr_mm_s, x_splits, y_splits);
  13630          
  13631              // Restore destination from stack
  13632              COPY(destination, end);
  13633              mesh_line_to_destination(fr_mm_s, x_splits, y_splits);
  13634            }
  13635          
  13636          #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
  13637          
  13638            #define CELL_INDEX(A,V) ((V - bilinear_start[A##_AXIS]) * ABL_BG_FACTOR(A##_AXIS))
  13639          
  13640            /**
  13641             * Prepare a bilinear-leveled linear move on Cartesian,
  13642             * splitting the move where it crosses grid borders.
  13643             */
  13644            void bilinear_line_to_destination(const float fr_mm_s, uint16_t x_splits=0xFFFF, uint16_t y_splits=0xFFFF) {
  13645              // Get current and destination cells for this line
  13646              int cx1 = CELL_INDEX(X, current_position[X_AXIS]),
  13647                  cy1 = CELL_INDEX(Y, current_position[Y_AXIS]),
  13648                  cx2 = CELL_INDEX(X, destination[X_AXIS]),
  13649                  cy2 = CELL_INDEX(Y, destination[Y_AXIS]);
  13650              cx1 = constrain(cx1, 0, ABL_BG_POINTS_X - 2);
  13651              cy1 = constrain(cy1, 0, ABL_BG_POINTS_Y - 2);
  13652              cx2 = constrain(cx2, 0, ABL_BG_POINTS_X - 2);
  13653              cy2 = constrain(cy2, 0, ABL_BG_POINTS_Y - 2);
  13654          
  13655              // Start and end in the same cell? No split needed.
  13656              if (cx1 == cx2 && cy1 == cy2) {
  13657                buffer_line_to_destination(fr_mm_s);
  13658                set_current_from_destination();
  13659                return;
  13660              }
  13661          
  13662              #define LINE_SEGMENT_END(A) (current_position[A ##_AXIS] + (destination[A ##_AXIS] - current_position[A ##_AXIS]) * normalized_dist)
  13663          
  13664              float normalized_dist, end[XYZE];
  13665              const int8_t gcx = max(cx1, cx2), gcy = max(cy1, cy2);
  13666          
  13667              // Crosses on the X and not already split on this X?
  13668              // The x_splits flags are insurance against rounding errors.
  13669              if (cx2 != cx1 && TEST(x_splits, gcx)) {
  13670                // Split on the X grid line
  13671                CBI(x_splits, gcx);
  13672                COPY(end, destination);
  13673                destination[X_AXIS] = bilinear_start[X_AXIS] + ABL_BG_SPACING(X_AXIS) * gcx;
  13674                normalized_dist = (destination[X_AXIS] - current_position[X_AXIS]) / (end[X_AXIS] - current_position[X_AXIS]);
  13675                destination[Y_AXIS] = LINE_SEGMENT_END(Y);
  13676              }
  13677              // Crosses on the Y and not already split on this Y?
  13678              else if (cy2 != cy1 && TEST(y_splits, gcy)) {
  13679                // Split on the Y grid line
  13680                CBI(y_splits, gcy);
  13681                COPY(end, destination);
  13682                destination[Y_AXIS] = bilinear_start[Y_AXIS] + ABL_BG_SPACING(Y_AXIS) * gcy;
  13683                normalized_dist = (destination[Y_AXIS] - current_position[Y_AXIS]) / (end[Y_AXIS] - current_position[Y_AXIS]);
  13684                destination[X_AXIS] = LINE_SEGMENT_END(X);
  13685              }
  13686              else {
  13687                // Must already have been split on these border(s)
  13688                buffer_line_to_destination(fr_mm_s);
  13689                set_current_from_destination();
  13690                return;
  13691              }
  13692          
  13693              destination[Z_AXIS] = LINE_SEGMENT_END(Z);
  13694              destination[E_AXIS] = LINE_SEGMENT_END(E);
  13695          
  13696              // Do the split and look for more borders
  13697              bilinear_line_to_destination(fr_mm_s, x_splits, y_splits);
  13698          
  13699              // Restore destination from stack
  13700              COPY(destination, end);
  13701              bilinear_line_to_destination(fr_mm_s, x_splits, y_splits);
  13702            }
  13703          
  13704          #endif // AUTO_BED_LEVELING_BILINEAR
  13705          #endif // IS_CARTESIAN
  13706          
  13707          #if !UBL_SEGMENTED
  13708          #if IS_KINEMATIC
  13709          
  13710            /**
  13711             * Prepare a linear move in a DELTA or SCARA setup.
  13712             *
  13713             * This calls planner.buffer_line several times, adding
  13714             * small incremental moves for DELTA or SCARA.
  13715             *
  13716             * For Unified Bed Leveling (Delta or Segmented Cartesian)
  13717             * the ubl.prepare_segmented_line_to method replaces this.
  13718             */
  13719            inline bool prepare_kinematic_move_to(const float (&rtarget)[XYZE]) {
  13720          
  13721              // Get the top feedrate of the move in the XY plane
  13722              const float _feedrate_mm_s = MMS_SCALED(feedrate_mm_s);
  13723          
  13724              const float xdiff = rtarget[X_AXIS] - current_position[X_AXIS],
  13725                          ydiff = rtarget[Y_AXIS] - current_position[Y_AXIS];
  13726          
  13727              // If the move is only in Z/E don't split up the move
  13728              if (!xdiff && !ydiff) {
  13729                planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder);
  13730                return false; // caller will update current_position
  13731              }
  13732          
  13733              // Fail if attempting move outside printable radius
  13734              if (!position_is_reachable(rtarget[X_AXIS], rtarget[Y_AXIS])) return true;
  13735          
  13736              // Remaining cartesian distances
  13737              const float zdiff = rtarget[Z_AXIS] - current_position[Z_AXIS],
  13738                          ediff = rtarget[E_AXIS] - current_position[E_AXIS];
  13739          
  13740              // Get the linear distance in XYZ
  13741              // If the move is very short, check the E move distance
  13742              // No E move either? Game over.
  13743              float cartesian_mm = SQRT(sq(xdiff) + sq(ydiff) + sq(zdiff));
  13744              if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = FABS(ediff);
  13745              if (UNEAR_ZERO(cartesian_mm)) return true;
  13746          
  13747              // Minimum number of seconds to move the given distance
  13748              const float seconds = cartesian_mm / _feedrate_mm_s;
  13749          
  13750              // The number of segments-per-second times the duration
  13751              // gives the number of segments
  13752              uint16_t segments = delta_segments_per_second * seconds;
  13753          
  13754              // For SCARA minimum segment size is 0.25mm
  13755              #if IS_SCARA
  13756                NOMORE(segments, cartesian_mm * 4);
  13757              #endif
  13758          
  13759              // At least one segment is required
  13760              NOLESS(segments, 1);
  13761          
  13762              // The approximate length of each segment
  13763              const float inv_segments = 1.0 / float(segments),
  13764                          segment_distance[XYZE] = {
  13765                            xdiff * inv_segments,
  13766                            ydiff * inv_segments,
  13767                            zdiff * inv_segments,
  13768                            ediff * inv_segments
  13769                          };
  13770          
  13771              // SERIAL_ECHOPAIR("mm=", cartesian_mm);
  13772              // SERIAL_ECHOPAIR(" seconds=", seconds);
  13773              // SERIAL_ECHOLNPAIR(" segments=", segments);
  13774          
  13775              #if ENABLED(SCARA_FEEDRATE_SCALING)
  13776                // SCARA needs to scale the feed rate from mm/s to degrees/s
  13777                // i.e., Complete the angular vector in the given time.
  13778                const float inv_segment_length = min(10.0, float(segments) / cartesian_mm), // 1/mm/segs
  13779                            inverse_secs = inv_segment_length * _feedrate_mm_s;
  13780                float oldA = stepper.get_axis_position_degrees(A_AXIS),
  13781                      oldB = stepper.get_axis_position_degrees(B_AXIS);
  13782              #endif
  13783          
  13784              // Get the current position as starting point
  13785              float raw[XYZE];
  13786              COPY(raw, current_position);
  13787          
  13788          
  13789              // Calculate and execute the segments
  13790              while (--segments) {
  13791          
  13792                static millis_t next_idle_ms = millis() + 200UL;
  13793                thermalManager.manage_heater();  // This returns immediately if not really needed.
  13794                if (ELAPSED(millis(), next_idle_ms)) {
  13795                  next_idle_ms = millis() + 200UL;
  13796                  idle();
  13797                }
  13798          
  13799                LOOP_XYZE(i) raw[i] += segment_distance[i];
  13800                #if ENABLED(DELTA)
  13801                  DELTA_IK(raw); // Delta can inline its kinematics
  13802                #else
  13803                  inverse_kinematics(raw);
  13804                #endif
  13805          
  13806                ADJUST_DELTA(raw); // Adjust Z if bed leveling is enabled
  13807          
  13808                #if ENABLED(SCARA_FEEDRATE_SCALING)
  13809                  // For SCARA scale the feed rate from mm/s to degrees/s
  13810                  // i.e., Complete the angular vector in the given time.
  13811                  planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
  13812                  oldA = delta[A_AXIS]; oldB = delta[B_AXIS];
  13813                #else
  13814                    if (gCfgItems.breakpoint_reprint_flg == 1) 
  13815                    {
  13816                        if (rtarget[Z_AXIS] < gCfgItems.breakpoint_z_pos) 
  13817                        {
  13818                            current_position[Z_AXIS] = rtarget[Z_AXIS];
  13819                            current_position[E_AXIS] = destination[E_AXIS];
  13820                            return;
  13821                        }
  13822                    }
  13823                  //gCfgItems.breakpoint_reprint_flg = 0;
  13824                  planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], _feedrate_mm_s, active_extruder);
  13825                #endif
  13826              }
  13827          
  13828              // Ensure last segment arrives at target location.
  13829              #if ENABLED(SCARA_FEEDRATE_SCALING)
  13830                inverse_kinematics(rtarget);
  13831                ADJUST_DELTA(rtarget);
  13832                planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], rtarget[Z_AXIS], rtarget[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
  13833              #else
  13834                planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder);
  13835              #endif
  13836          
  13837              return false; // caller will update current_position
  13838            }
  13839          
  13840          #else // !IS_KINEMATIC
  13841          
  13842            /**
  13843             * Prepare a linear move in a Cartesian setup.
  13844             *
  13845             * When a mesh-based leveling system is active, moves are segmented
  13846             * according to the configuration of the leveling system.
  13847             *
  13848             * Returns true if current_position[] was set to destination[]
  13849             */

   \                                 In section .text, align 4
  13850            inline bool prepare_move_to_destination_cartesian() {
   \                     _Z37prepare_move_to_destination_cartesianv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  13851              #if HAS_MESH
  13852                if (planner.leveling_active && planner.leveling_active_at_z(destination[Z_AXIS])) {
  13853                  #if ENABLED(AUTO_BED_LEVELING_UBL)
  13854                    ubl.line_to_destination_cartesian(MMS_SCALED(feedrate_mm_s), active_extruder);  // UBL's motion routine needs to know about
  13855                    return true;                                                                    // all moves, including Z-only moves.
  13856                  #elif ENABLED(SEGMENT_LEVELED_MOVES)
  13857                    segmented_line_to_destination(MMS_SCALED(feedrate_mm_s));
  13858                    return false; // caller will update current_position
  13859                  #else
  13860                    /**
  13861                     * For MBL and ABL-BILINEAR only segment moves when X or Y are involved.
  13862                     * Otherwise fall through to do a direct single move.
  13863                     */
  13864                    if (current_position[X_AXIS] != destination[X_AXIS] || current_position[Y_AXIS] != destination[Y_AXIS]) {
  13865                      #if ENABLED(MESH_BED_LEVELING)
  13866                        mesh_line_to_destination(MMS_SCALED(feedrate_mm_s));
  13867                      #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
  13868                        bilinear_line_to_destination(MMS_SCALED(feedrate_mm_s));
  13869                      #endif
  13870                      return true;
  13871                    }
  13872                  #endif
  13873                }
  13874              #endif // HAS_MESH
  13875          
  13876              buffer_line_to_destination(MMS_SCALED(feedrate_mm_s));
   \   00000002   0x480D             LDR.N    R0,??prepare_move_to_destination_cartesian_0
   \   00000004   0xF9B0 0x1020      LDRSH    R1,[R0, #+32]
   \   00000008   0xEE00 0x1A10      VMOV     S0,R1
   \   0000000C   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000010   0xEDD0 0x0A1E      VLDR     S1,[R0, #+120]
   \   00000014   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000018   0xEE10 0x0A10      VMOV     R0,S0
   \   0000001C   0x.... 0x....      BL       __aeabi_f2d
   \   00000020   0x4A06             LDR.N    R2,??prepare_move_to_destination_cartesian_0+0x4  ;; 0x47ae147b
   \   00000022   0x4B07             LDR.N    R3,??prepare_move_to_destination_cartesian_0+0x8  ;; 0x3f847ae1
   \   00000024   0x.... 0x....      BL       __aeabi_dmul
   \   00000028   0x.... 0x....      BL       __aeabi_d2f
   \   0000002C   0xEE00 0x0A10      VMOV     S0,R0
   \   00000030   0x.... 0x....      BL       _Z26buffer_line_to_destinationf
  13877              return false; // caller will update current_position
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xBD02             POP      {R1,PC}          ;; return
   \                     ??prepare_move_to_destination_cartesian_0:
   \   00000038   0x........         DC32     axis_relative_modes
   \   0000003C   0x47AE147B         DC32     0x47ae147b
   \   00000040   0x3F847AE1         DC32     0x3f847ae1
  13878            }
  13879          
  13880          #endif // !IS_KINEMATIC
  13881          #endif // !UBL_SEGMENTED
  13882          
  13883          #if ENABLED(DUAL_X_CARRIAGE)
  13884          
  13885            /**
  13886             * Unpark the carriage, if needed
  13887             */
  13888            inline bool dual_x_carriage_unpark() {
  13889              if (active_extruder_parked)
  13890                switch (dual_x_carriage_mode) {
  13891          
  13892                  case DXC_FULL_CONTROL_MODE: break;
  13893          
  13894                  case DXC_AUTO_PARK_MODE:
  13895                    if (current_position[E_AXIS] == destination[E_AXIS]) {
  13896                      // This is a travel move (with no extrusion)
  13897                      // Skip it, but keep track of the current position
  13898                      // (so it can be used as the start of the next non-travel move)
  13899                      if (delayed_move_time != 0xFFFFFFFFUL) {
  13900                        set_current_from_destination();
  13901                        NOLESS(raised_parked_position[Z_AXIS], destination[Z_AXIS]);
  13902                        delayed_move_time = millis();
  13903                        return true;
  13904                      }
  13905                    }
  13906                    // unpark extruder: 1) raise, 2) move into starting XY position, 3) lower
  13907                    for (uint8_t i = 0; i < 3; i++)
  13908                      planner.buffer_line(
  13909                        i == 0 ? raised_parked_position[X_AXIS] : current_position[X_AXIS],
  13910                        i == 0 ? raised_parked_position[Y_AXIS] : current_position[Y_AXIS],
  13911                        i == 2 ? current_position[Z_AXIS] : raised_parked_position[Z_AXIS],
  13912                        current_position[E_AXIS],
  13913                        i == 1 ? PLANNER_XY_FEEDRATE() : planner.max_feedrate_mm_s[Z_AXIS],
  13914                        active_extruder
  13915                      );
  13916                    delayed_move_time = 0;
  13917                    active_extruder_parked = false;
  13918                    #if ENABLED(DEBUG_LEVELING_FEATURE)
  13919                      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Clear active_extruder_parked");
  13920                    #endif
  13921                    break;
  13922          
  13923                  case DXC_DUPLICATION_MODE:
  13924                    if (active_extruder == 0) {
  13925                      #if ENABLED(DEBUG_LEVELING_FEATURE)
  13926                        if (DEBUGGING(LEVELING)) {
  13927                          SERIAL_ECHOPAIR("Set planner X", inactive_extruder_x_pos);
  13928                          SERIAL_ECHOLNPAIR(" ... Line to X", current_position[X_AXIS] + duplicate_extruder_x_offset);
  13929                        }
  13930                      #endif
  13931                      // move duplicate extruder into correct duplication position.
  13932                      planner.set_position_mm(
  13933                        inactive_extruder_x_pos,
  13934                        current_position[Y_AXIS],
  13935                        current_position[Z_AXIS],
  13936                        current_position[E_AXIS]
  13937                      );
  13938                      planner.buffer_line(
  13939                        current_position[X_AXIS] + duplicate_extruder_x_offset,
  13940                        current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS],
  13941                        planner.max_feedrate_mm_s[X_AXIS], 1
  13942                      );
  13943                      SYNC_PLAN_POSITION_KINEMATIC();
  13944                      stepper.synchronize();
  13945                      extruder_duplication_enabled = true;
  13946                      active_extruder_parked = false;
  13947                      #if ENABLED(DEBUG_LEVELING_FEATURE)
  13948                        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Set extruder_duplication_enabled\nClear active_extruder_parked");
  13949                      #endif
  13950                    }
  13951                    else {
  13952                      #if ENABLED(DEBUG_LEVELING_FEATURE)
  13953                        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Active extruder not 0");
  13954                      #endif
  13955                    }
  13956                    break;
  13957                }
  13958              return false;
  13959            }
  13960          
  13961          #endif // DUAL_X_CARRIAGE
  13962          
  13963          /**
  13964           * Prepare a single move and get ready for the next one
  13965           *
  13966           * This may result in several calls to planner.buffer_line to
  13967           * do smaller moves for DELTA, SCARA, mesh moves, etc.
  13968           *
  13969           * Make sure current_position[E] and destination[E] are good
  13970           * before calling or cold/lengthy extrusion may get missed.
  13971           */

   \                                 In section .text, align 4, keep-with-next
  13972          void prepare_move_to_destination() {
   \                     _Z27prepare_move_to_destinationv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
  13973            clamp_to_software_endstops(destination);
   \   00000002   0x....             LDR.N    R4,??DataTable111_1
   \   00000004   0xF104 0x0034      ADD      R0,R4,#+52
   \   00000008   0x.... 0x....      BL       _Z26clamp_to_software_endstopsPf
  13974            refresh_cmd_timeout();
   \   0000000C   0x.... 0x....      BL       _Z19refresh_cmd_timeoutv
  13975          
  13976            #if ENABLED(PREVENT_COLD_EXTRUSION) || ENABLED(PREVENT_LENGTHY_EXTRUDE)
  13977          
  13978              if (!DEBUGGING(DRYRUN)) {
   \   00000010   0x7BE0             LDRB     R0,[R4, #+15]
   \   00000012   0x0700             LSLS     R0,R0,#+28
   \   00000014   0xD426             BMI.N    ??prepare_move_to_destination_0
  13979                if (destination[E_AXIS] != current_position[E_AXIS]) {
   \   00000016   0xED94 0x0A0C      VLDR     S0,[R4, #+48]
   \   0000001A   0xEDD4 0x0A10      VLDR     S1,[R4, #+64]
   \   0000001E   0xEEF4 0x0A40      VCMP.F32 S1,S0
   \   00000022   0xEEF1 0xFA10      FMSTAT   
   \   00000026   0xD01D             BEQ.N    ??prepare_move_to_destination_0
  13980                  #if ENABLED(PREVENT_COLD_EXTRUSION)
  13981                    if (thermalManager.tooColdToExtrude(active_extruder)) {
  13982                      current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
  13983                      SERIAL_ECHO_START();
  13984                      SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
  13985                    }
  13986                  #endif // PREVENT_COLD_EXTRUSION
  13987                  #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
  13988                    if (FABS(destination[E_AXIS] - current_position[E_AXIS]) * planner.e_factor[active_extruder] > (EXTRUDE_MAXLENGTH)) {
   \   00000028   0xEE30 0x0AC0      VSUB.F32 S0,S1,S0
   \   0000002C   0xEEB0 0x0AC0      VABS.F32 S0,S0
   \   00000030   0x7CE0             LDRB     R0,[R4, #+19]
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable126_2
   \   00000036   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   0000003A   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   0000003E   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000042   0xEDDF 0x....      VLDR.W   S1,??DataTable111_5  ;; 0x43480001
   \   00000046   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   0000004A   0xEEF1 0xFA10      FMSTAT   
   \   0000004E   0xDB09             BLT.N    ??prepare_move_to_destination_0
  13989                      current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
   \   00000050   0x6C20             LDR      R0,[R4, #+64]
   \   00000052   0x6320             STR      R0,[R4, #+48]
  13990                      SERIAL_ECHO_START();
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable127
   \   00000058   0x.... 0x....      BL       _Z14serialprintPGMPKc
  13991                      SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
   \   0000005C   0x.... 0x....      ADR.W    R0,`?<Constant " too long extrusion p...">`
   \   00000060   0x.... 0x....      BL       _Z14serialprintPGMPKc
  13992                    }
  13993                  #endif // PREVENT_LENGTHY_EXTRUDE
  13994                }
  13995              }
  13996          
  13997            #endif
  13998          
  13999            #if ENABLED(DUAL_X_CARRIAGE)
  14000              if (dual_x_carriage_unpark()) return;
  14001            #endif
  14002          
  14003            if (
  14004              #if UBL_SEGMENTED
  14005                ubl.prepare_segmented_line_to(destination, MMS_SCALED(feedrate_mm_s))
  14006              #elif IS_KINEMATIC
  14007                prepare_kinematic_move_to(destination)
  14008              #else
  14009                prepare_move_to_destination_cartesian()
  14010              #endif
  14011            ) return;
   \                     ??prepare_move_to_destination_0: (+1)
   \   00000064   0x.... 0x....      BL       _Z37prepare_move_to_destination_cartesianv
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD103             BNE.N    ??prepare_move_to_destination_1
  14012          
  14013            set_current_from_destination();
   \   0000006C   0xE8BD 0x4010      POP      {R4,LR}
   \   00000070   0x.... 0x....      B.W      _Z28set_current_from_destinationv
   \                     ??prepare_move_to_destination_1: (+1)
   \   00000074   0xBD10             POP      {R4,PC}          ;; return
  14014          }
  14015          
  14016          #if ENABLED(ARC_SUPPORT)
  14017          
  14018            #if N_ARC_CORRECTION < 1
  14019              #undef N_ARC_CORRECTION
  14020              #define N_ARC_CORRECTION 1
  14021            #endif
  14022          
  14023            /**
  14024             * Plan an arc in 2 dimensions
  14025             *
  14026             * The arc is approximated by generating many small linear segments.
  14027             * The length of each segment is configured in MM_PER_ARC_SEGMENT (Default 1mm)
  14028             * Arcs should only be made relatively large (over 5mm), as larger arcs with
  14029             * larger segments will tend to be more efficient. Your slicer should have
  14030             * options for G2/G3 arc generation. In future these options may be GCode tunable.
  14031             */

   \                                 In section .text, align 4, keep-with-next
  14032            void plan_arc(
  14033              const float (&cart)[XYZE], // Destination position
  14034              const float (&offset)[2], // Center of rotation relative to current_position
  14035              const bool clockwise      // Clockwise?
  14036            ) {
   \                     _Z8plan_arcRA4_KfRA2_S_b: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0xED2D 0x8B0A      VPUSH    {D8-D12}
   \   00000008   0xB086             SUB      SP,SP,#+24
   \   0000000A   0x4604             MOV      R4,R0
   \   0000000C   0x4688             MOV      R8,R1
   \   0000000E   0x4616             MOV      R6,R2
  14037              #if ENABLED(CNC_WORKSPACE_PLANES)
  14038                AxisEnum p_axis, q_axis, l_axis;
  14039                switch (workspace_plane) {
  14040                  default:
  14041                  case PLANE_XY: p_axis = X_AXIS; q_axis = Y_AXIS; l_axis = Z_AXIS; break;
  14042                  case PLANE_ZX: p_axis = Z_AXIS; q_axis = X_AXIS; l_axis = Y_AXIS; break;
  14043                  case PLANE_YZ: p_axis = Y_AXIS; q_axis = Z_AXIS; l_axis = X_AXIS; break;
  14044                }
  14045              #else
  14046                constexpr AxisEnum p_axis = X_AXIS, q_axis = Y_AXIS, l_axis = Z_AXIS;
  14047              #endif
  14048          
  14049              // Radius vector from center to current location
  14050              float r_P = -offset[0], r_Q = -offset[1];
   \   00000010   0xED98 0x0A00      VLDR     S0,[R8, #0]
   \   00000014   0xEEB1 0x8A40      VNEG.F32 S16,S0
   \   00000018   0xED98 0x0A01      VLDR     S0,[R8, #+4]
   \   0000001C   0xEEF1 0x8A40      VNEG.F32 S17,S0
  14051          
  14052              const float radius = HYPOT(r_P, r_Q),
   \   00000020   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0xEEB7 0x9A00      VMOV.F32 S18,#1.0
   \   0000002A   0xEEF0 0x0A49      VMOV.F32 S1,S18
   \   0000002E   0xE001             B.N      ??plan_arc_0
   \                     ??plan_arc_1: (+1)
   \   00000030   0xEE20 0x0A00      VMUL.F32 S0,S0,S0
   \                     ??plan_arc_0: (+1)
   \   00000034   0x07C1             LSLS     R1,R0,#+31
   \   00000036   0xD501             BPL.N    ??plan_arc_2
   \   00000038   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \                     ??plan_arc_2: (+1)
   \   0000003C   0x0840             LSRS     R0,R0,#+1
   \   0000003E   0xD1F7             BNE.N    ??plan_arc_1
   \   00000040   0xEEB0 0x0A68      VMOV.F32 S0,S17
   \   00000044   0x2002             MOVS     R0,#+2
   \   00000046   0xEEB0 0x1A49      VMOV.F32 S2,S18
   \   0000004A   0xE001             B.N      ??plan_arc_3
   \                     ??plan_arc_4: (+1)
   \   0000004C   0xEE20 0x0A00      VMUL.F32 S0,S0,S0
   \                     ??plan_arc_3: (+1)
   \   00000050   0x07C1             LSLS     R1,R0,#+31
   \   00000052   0xD501             BPL.N    ??plan_arc_5
   \   00000054   0xEE21 0x1A00      VMUL.F32 S2,S2,S0
   \                     ??plan_arc_5: (+1)
   \   00000058   0x0840             LSRS     R0,R0,#+1
   \   0000005A   0xD1F7             BNE.N    ??plan_arc_4
   \   0000005C   0xEE30 0x0A81      VADD.F32 S0,S1,S2
   \   00000060   0x.... 0x....      BL       sqrtf
   \   00000064   0xEEF0 0xBA40      VMOV.F32 S23,S0
  14053                          center_P = current_position[p_axis] - r_P,
   \   00000068   0x.... 0x....      LDR.W    R5,??DataTable127_1
   \   0000006C   0xED95 0x0A09      VLDR     S0,[R5, #+36]
   \   00000070   0xEE70 0x9A48      VSUB.F32 S19,S0,S16
  14054                          center_Q = current_position[q_axis] - r_Q,
   \   00000074   0xED95 0x0A0A      VLDR     S0,[R5, #+40]
   \   00000078   0xEE30 0xAA68      VSUB.F32 S20,S0,S17
  14055                          rt_X = cart[p_axis] - center_P,
   \   0000007C   0xED94 0x0A00      VLDR     S0,[R4, #0]
   \   00000080   0xEE30 0x1A69      VSUB.F32 S2,S0,S19
  14056                          rt_Y = cart[q_axis] - center_Q,
   \   00000084   0xED94 0x0A01      VLDR     S0,[R4, #+4]
   \   00000088   0xEE30 0x0A4A      VSUB.F32 S0,S0,S20
  14057                          linear_travel = cart[l_axis] - current_position[l_axis],
   \   0000008C   0xEDD4 0x0A02      VLDR     S1,[R4, #+8]
   \   00000090   0xEDD5 0x1A0B      VLDR     S3,[R5, #+44]
   \   00000094   0xEE30 0xBAE1      VSUB.F32 S22,S1,S3
  14058                          extruder_travel = cart[E_AXIS] - current_position[E_AXIS];
   \   00000098   0xEDD4 0x0A03      VLDR     S1,[R4, #+12]
   \   0000009C   0xEDD5 0x1A0C      VLDR     S3,[R5, #+48]
   \   000000A0   0xEE70 0xAAE1      VSUB.F32 S21,S1,S3
  14059          
  14060              // CCW angle of rotation between position and target from the circle center. Only one atan2() trig computation required.
  14061              float angular_travel = ATAN2(r_P * rt_Y - r_Q * rt_X, r_P * rt_X + r_Q * rt_Y);
   \   000000A4   0xEE68 0x0A01      VMUL.F32 S1,S16,S2
   \   000000A8   0xEE48 0x0A80      VMLA.F32 S1,S17,S0
   \   000000AC   0xEE28 0x0A00      VMUL.F32 S0,S16,S0
   \   000000B0   0xEE08 0x0AC1      VMLS.F32 S0,S17,S2
   \   000000B4   0x.... 0x....      BL       atan2f
   \   000000B8   0xEEB0 0xCA40      VMOV.F32 S24,S0
  14062              if (angular_travel < 0) angular_travel += RADIANS(360);
   \   000000BC   0xEEB5 0xCA40      VCMP.F32 S24,#0.0
   \   000000C0   0xEEF1 0xFA10      FMSTAT   
   \   000000C4   0xD50D             BPL.N    ??plan_arc_6
   \   000000C6   0xEE1C 0x0A10      VMOV     R0,S24
   \   000000CA   0x.... 0x....      BL       __aeabi_f2d
   \   000000CE   0x.... 0x....      LDR.W    R2,??DataTable127_2  ;; 0x54442d18
   \   000000D2   0x.... 0x....      LDR.W    R3,??DataTable127_3  ;; 0x401921fb
   \   000000D6   0x.... 0x....      BL       __aeabi_dadd
   \   000000DA   0x.... 0x....      BL       __aeabi_d2f
   \   000000DE   0xEE0C 0x0A10      VMOV     S24,R0
  14063              if (clockwise) angular_travel -= RADIANS(360);
   \                     ??plan_arc_6: (+1)
   \   000000E2   0x2E00             CMP      R6,#+0
   \   000000E4   0xD00D             BEQ.N    ??plan_arc_7
   \   000000E6   0xEE1C 0x0A10      VMOV     R0,S24
   \   000000EA   0x.... 0x....      BL       __aeabi_f2d
   \   000000EE   0x.... 0x....      LDR.W    R2,??DataTable127_2  ;; 0x54442d18
   \   000000F2   0x.... 0x....      LDR.W    R3,??DataTable127_4  ;; 0xc01921fb
   \   000000F6   0x.... 0x....      BL       __aeabi_dadd
   \   000000FA   0x.... 0x....      BL       __aeabi_d2f
   \   000000FE   0xEE0C 0x0A10      VMOV     S24,R0
  14064          
  14065              // Make a circle if the angular rotation is 0 and the target is current position
  14066              if (angular_travel == 0 && current_position[p_axis] == cart[p_axis] && current_position[q_axis] == cart[q_axis])
   \                     ??plan_arc_7: (+1)
   \   00000102   0xEEB5 0xCA40      VCMP.F32 S24,#0.0
   \   00000106   0xEEF1 0xFA10      FMSTAT   
   \   0000010A   0xD113             BNE.N    ??plan_arc_8
   \   0000010C   0xED95 0x0A09      VLDR     S0,[R5, #+36]
   \   00000110   0xEDD4 0x0A00      VLDR     S1,[R4, #0]
   \   00000114   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000118   0xEEF1 0xFA10      FMSTAT   
   \   0000011C   0xD10A             BNE.N    ??plan_arc_8
   \   0000011E   0xED95 0x0A0A      VLDR     S0,[R5, #+40]
   \   00000122   0xEDD4 0x0A01      VLDR     S1,[R4, #+4]
   \   00000126   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   0000012A   0xEEF1 0xFA10      FMSTAT   
   \   0000012E   0xD101             BNE.N    ??plan_arc_8
  14067                angular_travel = RADIANS(360);
   \   00000130   0xED9F 0x....      VLDR.W   S24,??DataTable115  ;; 0x40c90fdb
  14068          
  14069              const float mm_of_travel = HYPOT(angular_travel * radius, FABS(linear_travel));
   \                     ??plan_arc_8: (+1)
   \   00000134   0xEE2C 0x0A2B      VMUL.F32 S0,S24,S23
   \   00000138   0x2002             MOVS     R0,#+2
   \   0000013A   0xEEF0 0x0A49      VMOV.F32 S1,S18
   \   0000013E   0xE001             B.N      ??plan_arc_9
   \                     ??plan_arc_10: (+1)
   \   00000140   0xEE20 0x0A00      VMUL.F32 S0,S0,S0
   \                     ??plan_arc_9: (+1)
   \   00000144   0x07C1             LSLS     R1,R0,#+31
   \   00000146   0xD501             BPL.N    ??plan_arc_11
   \   00000148   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \                     ??plan_arc_11: (+1)
   \   0000014C   0x0840             LSRS     R0,R0,#+1
   \   0000014E   0xD1F7             BNE.N    ??plan_arc_10
   \   00000150   0xEEB0 0x0ACB      VABS.F32 S0,S22
   \   00000154   0x2002             MOVS     R0,#+2
   \   00000156   0xEEB0 0x1A49      VMOV.F32 S2,S18
   \   0000015A   0xE001             B.N      ??plan_arc_12
   \                     ??plan_arc_13: (+1)
   \   0000015C   0xEE20 0x0A00      VMUL.F32 S0,S0,S0
   \                     ??plan_arc_12: (+1)
   \   00000160   0x07C1             LSLS     R1,R0,#+31
   \   00000162   0xD501             BPL.N    ??plan_arc_14
   \   00000164   0xEE21 0x1A00      VMUL.F32 S2,S2,S0
   \                     ??plan_arc_14: (+1)
   \   00000168   0x0840             LSRS     R0,R0,#+1
   \   0000016A   0xD1F7             BNE.N    ??plan_arc_13
   \   0000016C   0xEE30 0x0A81      VADD.F32 S0,S1,S2
   \   00000170   0x.... 0x....      BL       sqrtf
  14070              if (mm_of_travel < 0.001) return;
   \   00000174   0xEDDF 0x....      VLDR.W   S1,??DataTable116  ;; 0x3a83126f
   \   00000178   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   0000017C   0xEEF1 0xFA10      FMSTAT   
   \   00000180   0xF100 0x80C1      BMI.W    ??plan_arc_15
  14071          
  14072              uint16_t segments = FLOOR(mm_of_travel / (MM_PER_ARC_SEGMENT));
                                         ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   00000184   0x.... 0x....      BL       floorf
   \   00000188   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   0000018C   0xEE10 0x6A10      VMOV     R6,S0
   \   00000190   0xB2B6             UXTH     R6,R6
  14073              NOLESS(segments, 1);
   \   00000192   0x2E00             CMP      R6,#+0
   \   00000194   0xD100             BNE.N    ??plan_arc_16
   \   00000196   0x2601             MOVS     R6,#+1
  14074          
  14075              /**
  14076               * Vector rotation by transformation matrix: r is the original vector, r_T is the rotated vector,
  14077               * and phi is the angle of rotation. Based on the solution approach by Jens Geisler.
  14078               *     r_T = [cos(phi) -sin(phi);
  14079               *            sin(phi)  cos(phi)] * r ;
  14080               *
  14081               * For arc generation, the center of the circle is the axis of rotation and the radius vector is
  14082               * defined from the circle center to the initial position. Each line segment is formed by successive
  14083               * vector rotations. This requires only two cos() and sin() computations to form the rotation
  14084               * matrix for the duration of the entire arc. Error may accumulate from numerical round-off, since
  14085               * all double numbers are single precision on the Arduino. (True double precision will not have
  14086               * round off issues for CNC applications.) Single precision error can accumulate to be greater than
  14087               * tool precision in some cases. Therefore, arc path correction is implemented.
  14088               *
  14089               * Small angle approximation may be used to reduce computation overhead further. This approximation
  14090               * holds for everything, but very small circles and large MM_PER_ARC_SEGMENT values. In other words,
  14091               * theta_per_segment would need to be greater than 0.1 rad and N_ARC_CORRECTION would need to be large
  14092               * to cause an appreciable drift error. N_ARC_CORRECTION~=25 is more than small enough to correct for
  14093               * numerical drift error. N_ARC_CORRECTION may be on the order a hundred(s) before error becomes an
  14094               * issue for CNC machines with the single precision Arduino calculations.
  14095               *
  14096               * This approximation also allows plan_arc to immediately insert a line segment into the planner
  14097               * without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
  14098               * a correction, the planner should have caught up to the lag caused by the initial plan_arc overhead.
  14099               * This is important when there are successive arc motions.
  14100               */
  14101              // Vector rotation matrix values
  14102              float raw[XYZE];
  14103              const float theta_per_segment = angular_travel / segments,
   \                     ??plan_arc_16: (+1)
   \   00000198   0x4630             MOV      R0,R6
   \   0000019A   0xEE00 0x0A10      VMOV     S0,R0
   \   0000019E   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   000001A2   0xEECC 0xBA00      VDIV.F32 S23,S24,S0
  14104                          linear_per_segment = linear_travel / segments,
   \   000001A6   0xEE8B 0xBA00      VDIV.F32 S22,S22,S0
  14105                          extruder_per_segment = extruder_travel / segments,
   \   000001AA   0xEECA 0xAA80      VDIV.F32 S21,S21,S0
  14106                          sin_T = theta_per_segment,
  14107                          cos_T = 1 - 0.5 * sq(theta_per_segment); // Small angle approximation
   \   000001AE   0xEEB0 0x0A6B      VMOV.F32 S0,S23
   \   000001B2   0x2002             MOVS     R0,#+2
   \   000001B4   0xE001             B.N      ??plan_arc_17
   \                     ??plan_arc_18: (+1)
   \   000001B6   0xEE20 0x0A00      VMUL.F32 S0,S0,S0
   \                     ??plan_arc_17: (+1)
   \   000001BA   0x07C1             LSLS     R1,R0,#+31
   \   000001BC   0xD501             BPL.N    ??plan_arc_19
   \   000001BE   0xEE29 0x9A00      VMUL.F32 S18,S18,S0
   \                     ??plan_arc_19: (+1)
   \   000001C2   0x0840             LSRS     R0,R0,#+1
   \   000001C4   0xD1F7             BNE.N    ??plan_arc_18
   \   000001C6   0xEE19 0x0A10      VMOV     R0,S18
   \   000001CA   0x.... 0x....      BL       __aeabi_f2d
   \   000001CE   0x2200             MOVS     R2,#+0
   \   000001D0   0x.... 0x....      LDR.W    R3,??DataTable127_5  ;; 0x3fe00000
   \   000001D4   0x.... 0x....      BL       __aeabi_dmul
   \   000001D8   0x4602             MOV      R2,R0
   \   000001DA   0x460B             MOV      R3,R1
   \   000001DC   0x2000             MOVS     R0,#+0
   \   000001DE   0x.... 0x....      LDR.W    R1,??DataTable127_6  ;; 0x3ff00000
   \   000001E2   0x.... 0x....      BL       __aeabi_dsub
   \   000001E6   0x.... 0x....      BL       __aeabi_d2f
   \   000001EA   0xEE09 0x0A10      VMOV     S18,R0
  14108          
  14109              // Initialize the linear axis
  14110              raw[l_axis] = current_position[l_axis];
   \   000001EE   0xAF01             ADD      R7,SP,#+4
   \   000001F0   0x6AE8             LDR      R0,[R5, #+44]
   \   000001F2   0x60B8             STR      R0,[R7, #+8]
  14111          
  14112              // Initialize the extruder axis
  14113              raw[E_AXIS] = current_position[E_AXIS];
   \   000001F4   0x6B28             LDR      R0,[R5, #+48]
   \   000001F6   0x60F8             STR      R0,[R7, #+12]
  14114          
  14115              const float fr_mm_s = MMS_SCALED(feedrate_mm_s);
   \   000001F8   0xF9B5 0x0020      LDRSH    R0,[R5, #+32]
   \   000001FC   0xEE00 0x0A10      VMOV     S0,R0
   \   00000200   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000204   0xEDD5 0x0A1E      VLDR     S1,[R5, #+120]
   \   00000208   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   0000020C   0xEE10 0x0A10      VMOV     R0,S0
   \   00000210   0x.... 0x....      BL       __aeabi_f2d
   \   00000214   0x.... 0x....      LDR.W    R2,??DataTable127_7  ;; 0x47ae147b
   \   00000218   0x.... 0x....      LDR.W    R3,??DataTable131  ;; 0x3f847ae1
   \   0000021C   0x.... 0x....      BL       __aeabi_dmul
   \   00000220   0x.... 0x....      BL       __aeabi_d2f
   \   00000224   0x9000             STR      R0,[SP, #+0]
  14116          
  14117              millis_t next_idle_ms = millis() + 200UL;
   \   00000226   0x.... 0x....      BL       HAL_GetTick
   \   0000022A   0xF100 0x09C8      ADD      R9,R0,#+200
  14118          
  14119              #if N_ARC_CORRECTION > 1
  14120                int8_t arc_recalc_count = N_ARC_CORRECTION;
   \   0000022E   0xF04F 0x0A19      MOV      R10,#+25
  14121              #endif
  14122          
  14123              #if ENABLED(SCARA_FEEDRATE_SCALING)
  14124                // SCARA needs to scale the feed rate from mm/s to degrees/s
  14125                const float inv_segment_length = 1.0 / (MM_PER_ARC_SEGMENT),
  14126                            inverse_secs = inv_segment_length * fr_mm_s;
  14127                float oldA = stepper.get_axis_position_degrees(A_AXIS),
  14128                      oldB = stepper.get_axis_position_degrees(B_AXIS);
  14129              #endif
  14130          
  14131              for (uint16_t i = 1; i < segments; i++) { // Iterate (segments-1) times
   \   00000232   0xF04F 0x0B01      MOV      R11,#+1
   \   00000236   0xE03E             B.N      ??plan_arc_20
  14132          
  14133                thermalManager.manage_heater();
  14134                if (ELAPSED(millis(), next_idle_ms)) {
  14135                  next_idle_ms = millis() + 200UL;
  14136                  idle();
  14137                }
  14138          
  14139                #if N_ARC_CORRECTION > 1
  14140                  if (--arc_recalc_count) {
  14141                    // Apply vector rotation matrix to previous r_P / 1
  14142                    const float r_new_Y = r_P * sin_T + r_Q * cos_T;
  14143                    r_P = r_P * cos_T - r_Q * sin_T;
  14144                    r_Q = r_new_Y;
  14145                  }
  14146                  else
  14147                #endif
  14148                {
  14149                  #if N_ARC_CORRECTION > 1
  14150                    arc_recalc_count = N_ARC_CORRECTION;
   \                     ??plan_arc_21: (+1)
   \   00000238   0xF04F 0x0A19      MOV      R10,#+25
  14151                  #endif
  14152          
  14153                  // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments.
  14154                  // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
  14155                  // To reduce stuttering, the sin and cos could be computed at different times.
  14156                  // For now, compute both at the same time.
  14157                  const float cos_Ti = cos(i * theta_per_segment), sin_Ti = sin(i * theta_per_segment);
   \   0000023C   0x4658             MOV      R0,R11
   \   0000023E   0xEE00 0x0A10      VMOV     S0,R0
   \   00000242   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   00000246   0xEE20 0x8A2B      VMUL.F32 S16,S0,S23
   \   0000024A   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   0000024E   0x.... 0x....      BL       cosf
   \   00000252   0xEEB0 0xCA40      VMOV.F32 S24,S0
   \   00000256   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   0000025A   0x.... 0x....      BL       sinf
  14158                  r_P = -offset[0] * cos_Ti + offset[1] * sin_Ti;
   \   0000025E   0xEDD8 0x0A01      VLDR     S1,[R8, #+4]
   \   00000262   0xED98 0x1A00      VLDR     S2,[R8, #0]
   \   00000266   0xEE20 0x8A80      VMUL.F32 S16,S1,S0
   \   0000026A   0xEE01 0x8A4C      VMLS.F32 S16,S2,S24
  14159                  r_Q = -offset[0] * sin_Ti - offset[1] * cos_Ti;
   \   0000026E   0xEE61 0x8A40      VNMUL.F32 S17,S2,S0
   \   00000272   0xEE40 0x8ACC      VMLS.F32 S17,S1,S24
  14160                }
  14161          
  14162                // Update raw location
  14163                raw[p_axis] = center_P + r_P;
   \                     ??plan_arc_22: (+1)
   \   00000276   0xEE39 0x0A88      VADD.F32 S0,S19,S16
   \   0000027A   0xED8D 0x0A01      VSTR     S0,[SP, #+4]
  14164                raw[q_axis] = center_Q + r_Q;
   \   0000027E   0xEE3A 0x0A28      VADD.F32 S0,S20,S17
   \   00000282   0xED87 0x0A01      VSTR     S0,[R7, #+4]
  14165                raw[l_axis] += linear_per_segment;
   \   00000286   0xED97 0x0A02      VLDR     S0,[R7, #+8]
   \   0000028A   0xEE30 0x0A0B      VADD.F32 S0,S0,S22
   \   0000028E   0xED87 0x0A02      VSTR     S0,[R7, #+8]
  14166                raw[E_AXIS] += extruder_per_segment;
   \   00000292   0xED97 0x0A03      VLDR     S0,[R7, #+12]
   \   00000296   0xEE30 0x0A2A      VADD.F32 S0,S0,S21
   \   0000029A   0xED87 0x0A03      VSTR     S0,[R7, #+12]
  14167          
  14168                clamp_to_software_endstops(raw);
   \   0000029E   0xA801             ADD      R0,SP,#+4
   \   000002A0   0x.... 0x....      BL       _Z26clamp_to_software_endstopsPf
  14169          
  14170                #if ENABLED(SCARA_FEEDRATE_SCALING)
  14171                  // For SCARA scale the feed rate from mm/s to degrees/s
  14172                  // i.e., Complete the angular vector in the given time.
  14173                  inverse_kinematics(raw);
  14174                  ADJUST_DELTA(raw);
  14175                  planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
  14176                  oldA = delta[A_AXIS]; oldB = delta[B_AXIS];
  14177                #else
  14178                  planner.buffer_line_kinematic(raw, fr_mm_s, active_extruder);
   \   000002A4   0x7CEA             LDRB     R2,[R5, #+19]
   \   000002A6   0xA900             ADD      R1,SP,#+0
   \   000002A8   0xA801             ADD      R0,SP,#+4
   \   000002AA   0x.... 0x....      BL       _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
   \   000002AE   0xF10B 0x0B01      ADD      R11,R11,#+1
   \   000002B2   0xFA1F 0xFB8B      UXTH     R11,R11
   \                     ??plan_arc_20: (+1)
   \   000002B6   0x45B3             CMP      R11,R6
   \   000002B8   0xDA1E             BGE.N    ??plan_arc_23
   \   000002BA   0x.... 0x....      BL       _ZN11Temperature13manage_heaterEv
   \   000002BE   0x.... 0x....      BL       HAL_GetTick
   \   000002C2   0xEBB0 0x0009      SUBS     R0,R0,R9
   \   000002C6   0xD405             BMI.N    ??plan_arc_24
   \   000002C8   0x.... 0x....      BL       HAL_GetTick
   \   000002CC   0xF100 0x09C8      ADD      R9,R0,#+200
   \   000002D0   0x.... 0x....      BL       _Z4idlev
   \                     ??plan_arc_24: (+1)
   \   000002D4   0xF1AA 0x0A01      SUB      R10,R10,#+1
   \   000002D8   0xFA4F 0xFA8A      SXTB     R10,R10
   \   000002DC   0xF1BA 0x0F00      CMP      R10,#+0
   \   000002E0   0xD0AA             BEQ.N    ??plan_arc_21
   \   000002E2   0xEE28 0x0A2B      VMUL.F32 S0,S16,S23
   \   000002E6   0xEE08 0x0A89      VMLA.F32 S0,S17,S18
   \   000002EA   0xEE28 0x8A09      VMUL.F32 S16,S16,S18
   \   000002EE   0xEE08 0x8AEB      VMLS.F32 S16,S17,S23
   \   000002F2   0xEEF0 0x8A40      VMOV.F32 S17,S0
   \   000002F6   0xE7BE             B.N      ??plan_arc_22
  14179                #endif
  14180              }
  14181          
  14182              // Ensure last segment arrives at target location.
  14183              #if ENABLED(SCARA_FEEDRATE_SCALING)
  14184                inverse_kinematics(cart);
  14185                ADJUST_DELTA(cart);
  14186                planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], cart[Z_AXIS], cart[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
  14187              #else
  14188                planner.buffer_line_kinematic(cart, fr_mm_s, active_extruder);
   \                     ??plan_arc_23: (+1)
   \   000002F8   0x7CEA             LDRB     R2,[R5, #+19]
   \   000002FA   0xA900             ADD      R1,SP,#+0
   \   000002FC   0x4620             MOV      R0,R4
   \   000002FE   0x.... 0x....      BL       _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
  14189              #endif
  14190          
  14191              // As far as the parser is concerned, the position is now == target. In reality the
  14192              // motion control system might still be processing the action and the real tool position
  14193              // in any intermediate location.
  14194              set_current_from_destination();
   \   00000302   0x.... 0x....      BL       _Z28set_current_from_destinationv
  14195            } // plan_arc
   \                     ??plan_arc_15: (+1)
   \   00000306   0xB006             ADD      SP,SP,#+24
   \   00000308   0xECBD 0x8B0A      VPOP     {D8-D12}
   \   0000030C   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
  14196          
  14197          #endif // ARC_SUPPORT
  14198          
  14199          #if ENABLED(BEZIER_CURVE_SUPPORT)
  14200          
  14201            void plan_cubic_move(const float (&offset)[4]) {
  14202              cubic_b_spline(current_position, destination, offset, MMS_SCALED(feedrate_mm_s), active_extruder);
  14203          
  14204              // As far as the parser is concerned, the position is now == destination. In reality the
  14205              // motion control system might still be processing the action and the real tool position
  14206              // in any intermediate location.
  14207              set_current_from_destination();
  14208            }
  14209          
  14210          #endif // BEZIER_CURVE_SUPPORT
  14211          
  14212          #if ENABLED(USE_CONTROLLER_FAN)
  14213          
  14214            void controllerFan() {
  14215              static millis_t lastMotorOn = 0, // Last time a motor was turned on
  14216                              nextMotorCheck = 0; // Last time the state was checked
  14217              const millis_t ms = millis();
  14218              if (ELAPSED(ms, nextMotorCheck)) {
  14219                nextMotorCheck = ms + 2500UL; // Not a time critical function, so only check every 2.5s
  14220                if (X_ENABLE_READ == X_ENABLE_ON || Y_ENABLE_READ == Y_ENABLE_ON || Z_ENABLE_READ == Z_ENABLE_ON || thermalManager.soft_pwm_amount_bed > 0
  14221                    || E0_ENABLE_READ == E_ENABLE_ON // If any of the drivers are enabled...
  14222                    #if E_STEPPERS > 1
  14223                      || E1_ENABLE_READ == E_ENABLE_ON
  14224                      #if HAS_X2_ENABLE
  14225                        || X2_ENABLE_READ == X_ENABLE_ON
  14226                      #endif
  14227                      #if E_STEPPERS > 2
  14228                        || E2_ENABLE_READ == E_ENABLE_ON
  14229                        #if E_STEPPERS > 3
  14230                          || E3_ENABLE_READ == E_ENABLE_ON
  14231                          #if E_STEPPERS > 4
  14232                            || E4_ENABLE_READ == E_ENABLE_ON
  14233                          #endif // E_STEPPERS > 4
  14234                        #endif // E_STEPPERS > 3
  14235                      #endif // E_STEPPERS > 2
  14236                    #endif // E_STEPPERS > 1
  14237                ) {
  14238                  lastMotorOn = ms; //... set time to NOW so the fan will turn on
  14239                }
  14240          
  14241                // Fan off if no steppers have been enabled for CONTROLLERFAN_SECS seconds
  14242                uint8_t speed = (!lastMotorOn || ELAPSED(ms, lastMotorOn + (CONTROLLERFAN_SECS) * 1000UL)) ? 0 : CONTROLLERFAN_SPEED;
  14243          
  14244                // allows digital or PWM fan output to be used (see M42 handling)
  14245                WRITE(CONTROLLER_FAN_PIN, speed);
  14246                analogWrite(CONTROLLER_FAN_PIN, speed);
  14247              }
  14248            }
  14249          
  14250          #endif // USE_CONTROLLER_FAN
  14251          
  14252          #if ENABLED(MORGAN_SCARA)
  14253          
  14254            /**
  14255             * Morgan SCARA Forward Kinematics. Results in cartes[].
  14256             * Maths and first version by QHARLEY.
  14257             * Integrated into Marlin and slightly restructured by Joachim Cerny.
  14258             */
  14259            void forward_kinematics_SCARA(const float &a, const float &b) {
  14260          
  14261              float a_sin = sin(RADIANS(a)) * L1,
  14262                    a_cos = cos(RADIANS(a)) * L1,
  14263                    b_sin = sin(RADIANS(b)) * L2,
  14264                    b_cos = cos(RADIANS(b)) * L2;
  14265          
  14266              cartes[X_AXIS] = a_cos + b_cos + SCARA_OFFSET_X;  //theta
  14267              cartes[Y_AXIS] = a_sin + b_sin + SCARA_OFFSET_Y;  //theta+phi
  14268          
  14269              /*
  14270                SERIAL_ECHOPAIR("SCARA FK Angle a=", a);
  14271                SERIAL_ECHOPAIR(" b=", b);
  14272                SERIAL_ECHOPAIR(" a_sin=", a_sin);
  14273                SERIAL_ECHOPAIR(" a_cos=", a_cos);
  14274                SERIAL_ECHOPAIR(" b_sin=", b_sin);
  14275                SERIAL_ECHOLNPAIR(" b_cos=", b_cos);
  14276                SERIAL_ECHOPAIR(" cartes[X_AXIS]=", cartes[X_AXIS]);
  14277                SERIAL_ECHOLNPAIR(" cartes[Y_AXIS]=", cartes[Y_AXIS]);
  14278              //*/
                      ^
Warning[Pe009]: nested comment is not allowed
  14279            }
  14280          
  14281            /**
  14282             * Morgan SCARA Inverse Kinematics. Results in delta[].
  14283             *
  14284             * See http://forums.reprap.org/read.php?185,283327
  14285             *
  14286             * Maths and first version by QHARLEY.
  14287             * Integrated into Marlin and slightly restructured by Joachim Cerny.
  14288             */
  14289            void inverse_kinematics(const float raw[XYZ]) {
  14290          
  14291              static float C2, S2, SK1, SK2, THETA, PSI;
  14292          
  14293              float sx = raw[X_AXIS] - SCARA_OFFSET_X,  // Translate SCARA to standard X Y
  14294                    sy = raw[Y_AXIS] - SCARA_OFFSET_Y;  // With scaling factor.
  14295          
  14296              if (L1 == L2)
  14297                C2 = HYPOT2(sx, sy) / L1_2_2 - 1;
  14298              else
  14299                C2 = (HYPOT2(sx, sy) - (L1_2 + L2_2)) / (2.0 * L1 * L2);
  14300          
  14301              S2 = SQRT(1 - sq(C2));
  14302          
  14303              // Unrotated Arm1 plus rotated Arm2 gives the distance from Center to End
  14304              SK1 = L1 + L2 * C2;
  14305          
  14306              // Rotated Arm2 gives the distance from Arm1 to Arm2
  14307              SK2 = L2 * S2;
  14308          
  14309              // Angle of Arm1 is the difference between Center-to-End angle and the Center-to-Elbow
  14310              THETA = ATAN2(SK1, SK2) - ATAN2(sx, sy);
  14311          
  14312              // Angle of Arm2
  14313              PSI = ATAN2(S2, C2);
  14314          
  14315              delta[A_AXIS] = DEGREES(THETA);        // theta is support arm angle
  14316              delta[B_AXIS] = DEGREES(THETA + PSI);  // equal to sub arm angle (inverted motor)
  14317              delta[C_AXIS] = raw[Z_AXIS];
  14318          
  14319              /*
  14320                DEBUG_POS("SCARA IK", raw);
  14321                DEBUG_POS("SCARA IK", delta);
  14322                SERIAL_ECHOPAIR("  SCARA (x,y) ", sx);
  14323                SERIAL_ECHOPAIR(",", sy);
  14324                SERIAL_ECHOPAIR(" C2=", C2);
  14325                SERIAL_ECHOPAIR(" S2=", S2);
  14326                SERIAL_ECHOPAIR(" Theta=", THETA);
  14327                SERIAL_ECHOLNPAIR(" Phi=", PHI);
  14328              //*/
                      ^
Warning[Pe009]: nested comment is not allowed
  14329            }
  14330          
  14331          #endif // MORGAN_SCARA
  14332          
  14333          #if ENABLED(TEMP_STAT_LEDS)
  14334          
  14335            static bool red_led = false;
  14336            static millis_t next_status_led_update_ms = 0;
  14337          
  14338            void handle_status_leds(void) {
  14339              if (ELAPSED(millis(), next_status_led_update_ms)) {
  14340                next_status_led_update_ms += 500; // Update every 0.5s
  14341                float max_temp = 0.0;
  14342                #if HAS_TEMP_BED
  14343                  max_temp = MAX3(max_temp, thermalManager.degTargetBed(), thermalManager.degBed());
  14344                #endif
  14345                HOTEND_LOOP()
  14346                  max_temp = MAX3(max_temp, thermalManager.degHotend(e), thermalManager.degTargetHotend(e));
  14347                const bool new_led = (max_temp > 55.0) ? true : (max_temp < 54.0) ? false : red_led;
  14348                if (new_led != red_led) {
  14349                  red_led = new_led;
  14350                  #if PIN_EXISTS(STAT_LED_RED)
  14351                    WRITE(STAT_LED_RED_PIN, new_led ? HIGH : LOW);
  14352                    #if PIN_EXISTS(STAT_LED_BLUE)
  14353                      WRITE(STAT_LED_BLUE_PIN, new_led ? LOW : HIGH);
  14354                    #endif
  14355                  #else
  14356                    WRITE(STAT_LED_BLUE_PIN, new_led ? HIGH : LOW);
  14357                  #endif
  14358                }
  14359              }
  14360            }
  14361          
  14362          #endif
  14363          
  14364          #if ENABLED(FILAMENT_RUNOUT_SENSOR)
  14365          
  14366            void handle_filament_runout() {
  14367              if (!filament_ran_out) {
  14368                filament_ran_out = true;
  14369                enqueue_and_echo_commands_P(PSTR(FILAMENT_RUNOUT_SCRIPT));
  14370                stepper.synchronize();
  14371              }
  14372            }
  14373          
  14374          #endif // FILAMENT_RUNOUT_SENSOR
  14375          
  14376          #if ENABLED(FAST_PWM_FAN)
  14377          
  14378            void setPwmFrequency(uint8_t pin, int val) {
  14379              val &= 0x07;
  14380              switch (digitalPinToTimer(pin)) {
  14381                #ifdef TCCR0A
  14382                  #if !AVR_AT90USB1286_FAMILY
  14383                    case TIMER0A:
  14384                  #endif
  14385                  case TIMER0B:                           //_SET_CS(0, val);
  14386                                                            break;
  14387                #endif
  14388                #ifdef TCCR1A
  14389                  case TIMER1A: case TIMER1B:             //_SET_CS(1, val);
  14390                                                            break;
  14391                #endif
  14392                #if defined(TCCR2) || defined(TCCR2A)
  14393                  #ifdef TCCR2
  14394                    case TIMER2:
  14395                  #endif
  14396                  #ifdef TCCR2A
  14397                    case TIMER2A: case TIMER2B:
  14398                  #endif
  14399                                                            _SET_CS(2, val); break;
  14400                #endif
  14401                #ifdef TCCR3A
  14402                  case TIMER3A: case TIMER3B: case TIMER3C: _SET_CS(3, val); break;
  14403                #endif
  14404                #ifdef TCCR4A
  14405                  case TIMER4A: case TIMER4B: case TIMER4C: _SET_CS(4, val); break;
  14406                #endif
  14407                #ifdef TCCR5A
  14408                  case TIMER5A: case TIMER5B: case TIMER5C: _SET_CS(5, val); break;
  14409                #endif
  14410              }
  14411            }
  14412          
  14413          #endif // FAST_PWM_FAN
  14414          

   \                                 In section .text, align 2, keep-with-next
  14415          void enable_all_steppers() {
  14416            enable_X();
  14417            enable_Y();
  14418            enable_Z();
   \                     _Z19enable_all_steppersv: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable128
   \   00000006   0x8881             LDRH     R1,[R0, #+4]
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable128_1
   \   0000000C   0x6880             LDR      R0,[R0, #+8]
   \   0000000E   0x.... 0x....      B.W      HAL_GPIO_WritePin
  14419            enable_E0();
  14420            enable_E1();
  14421            enable_E2();
  14422            enable_E3();
  14423            enable_E4();
  14424          }
  14425          

   \                                 In section .text, align 2, keep-with-next
  14426          void disable_e_steppers() {
  14427            disable_E0();
  14428            disable_E1();
  14429            disable_E2();
  14430            disable_E3();
  14431            disable_E4();
  14432          }
   \                     _Z18disable_e_steppersv: (+1)
   \   00000000   0x4770             BX       LR               ;; return
  14433          

   \                                 In section .text, align 2, keep-with-next
  14434          void disable_all_steppers() {
   \                     _Z20disable_all_steppersv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  14435            disable_X();
  14436            disable_Y();
  14437            disable_Z();
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable128
   \   00000008   0x8881             LDRH     R1,[R0, #+4]
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable128_1
   \   0000000E   0x6880             LDR      R0,[R0, #+8]
   \   00000010   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable127_1
   \   0000001A   0x7288             STRB     R0,[R1, #+10]
  14438            disable_e_steppers();
   \   0000001C   0xE8BD 0x4001      POP      {R0,LR}
   \   00000020   0x....             B.N      _Z18disable_e_steppersv
  14439          }
  14440          
  14441          #if ENABLED(MONITOR_DRIVER_STATUS)
  14442            /*
  14443             * Check for over temperature or short to ground error flags.
  14444             * Report and log warning of overtemperature condition.
  14445             * Reduce driver current in a persistent otpw condition.
  14446             * Keep track of otpw counter so we don't reduce current on a single instance,
  14447             * and so we don't repeatedly report warning before the condition is cleared.
  14448             */
  14449          
  14450            struct TMC_driver_data {
  14451              uint32_t drv_status;
  14452              bool is_otpw;
  14453              bool is_ot;
  14454              bool is_error;
  14455            };
  14456            #if ENABLED(HAVE_TMC2130)
  14457              static uint32_t get_pwm_scale(TMC2130Stepper &st) { return st.PWM_SCALE(); }
  14458              static uint8_t get_status_response(TMC2130Stepper &st) { return st.status_response&0xF; }
  14459              static TMC_driver_data get_driver_data(TMC2130Stepper &st) {
  14460                constexpr uint32_t OTPW_bm = 0x4000000UL;
  14461                constexpr uint8_t OTPW_bp = 26;
  14462                constexpr uint32_t OT_bm = 0x2000000UL;
  14463                constexpr uint8_t OT_bp = 25;
  14464                constexpr uint8_t DRIVER_ERROR_bm = 0x2UL;
  14465                constexpr uint8_t DRIVER_ERROR_bp = 1;
  14466                TMC_driver_data data;
  14467                data.drv_status = st.DRV_STATUS();
  14468                data.is_otpw = (data.drv_status & OTPW_bm)>>OTPW_bp;
  14469                data.is_ot = (data.drv_status & OT_bm)>>OT_bp;
  14470                data.is_error = (st.status_response & DRIVER_ERROR_bm)>>DRIVER_ERROR_bp;
  14471                return data;
  14472              }
  14473            #endif
  14474            #if ENABLED(HAVE_TMC2208)
  14475              static uint32_t get_pwm_scale(TMC2208Stepper &st) { return st.pwm_scale_sum(); }
  14476              static uint8_t get_status_response(TMC2208Stepper &st) {
  14477                uint32_t drv_status = st.DRV_STATUS();
  14478                uint8_t gstat = st.GSTAT();
  14479                uint8_t response = 0;
  14480                response |= (drv_status >> (31-3)) & 0b1000;
  14481                response |= gstat & 0b11;
  14482                return response;
  14483              }
  14484              static TMC_driver_data get_driver_data(TMC2208Stepper &st) {
  14485                constexpr uint32_t OTPW_bm = 0b1ul;
  14486                constexpr uint8_t OTPW_bp = 0;
  14487                constexpr uint32_t OT_bm = 0b10ul;
  14488                constexpr uint8_t OT_bp = 1;
  14489                TMC_driver_data data;
  14490                data.drv_status = st.DRV_STATUS();
  14491                data.is_otpw = (data.drv_status & OTPW_bm)>>OTPW_bp;
  14492                data.is_ot = (data.drv_status & OT_bm)>>OT_bp;
  14493                data.is_error = st.drv_err();
  14494                return data;
  14495              }
  14496            #endif
  14497          
  14498            template<typename TMC>
  14499            uint8_t monitor_tmc_driver(TMC &st, const char axisID, uint8_t otpw_cnt) {
  14500              TMC_driver_data data = get_driver_data(st);
  14501          
  14502              #if ENABLED(STOP_ON_ERROR)
  14503                if (data.is_error) {
  14504                  SERIAL_EOL();
  14505                  SERIAL_ECHO(axisID);
  14506                  SERIAL_ECHO(" driver error detected:");
  14507                  if (data.is_ot) SERIAL_ECHO("\novertemperature");
  14508                  if (st.s2ga()) SERIAL_ECHO("\nshort to ground (coil A)");
  14509                  if (st.s2gb()) SERIAL_ECHO("\nshort to ground (coil B)");
  14510                  SERIAL_EOL();
  14511                  #if ENABLED(TMC_DEBUG)
  14512                    gcode_M122();
  14513                  #endif
  14514                  kill(PSTR("Driver error"));
  14515                }
  14516              #endif
  14517          
  14518              // Report if a warning was triggered
  14519              if (data.is_otpw && otpw_cnt==0) {
  14520                char timestamp[10];
  14521                duration_t elapsed = print_job_timer.duration();
  14522                const bool has_days = (elapsed.value > 60*60*24L);
  14523                (void)elapsed.toDigital(timestamp, has_days);
  14524                SERIAL_EOL();
  14525                SERIAL_ECHO(timestamp);
  14526                SERIAL_ECHOPGM(": ");
  14527                SERIAL_ECHO(axisID);
  14528                SERIAL_ECHOPGM(" driver overtemperature warning! (");
  14529                SERIAL_ECHO(st.getCurrent());
  14530                SERIAL_ECHOLN("mA)");
  14531              }
  14532              #if CURRENT_STEP_DOWN > 0
  14533                // Decrease current if is_otpw is true and driver is enabled and there's been more then 4 warnings
  14534                if (data.is_otpw && !st.isEnabled() && otpw_cnt > 4) {
  14535                  st.setCurrent(st.getCurrent() - CURRENT_STEP_DOWN, R_SENSE, HOLD_MULTIPLIER);
  14536                  #if ENABLED(REPORT_CURRENT_CHANGE)
  14537                    SERIAL_ECHO(axisID);
  14538                    SERIAL_ECHOLNPAIR(" current decreased to ", st.getCurrent());
  14539                  #endif
  14540                }
  14541              #endif
  14542          
  14543              if (data.is_otpw) {
  14544                otpw_cnt++;
  14545                st.flag_otpw = true;
  14546              }
  14547              else if (otpw_cnt>0) otpw_cnt--;
  14548          
  14549              if (report_tmc_status) {
  14550                const uint32_t pwm_scale = get_pwm_scale(st);
  14551                SERIAL_ECHO(axisID);
  14552                SERIAL_ECHOPAIR(":", pwm_scale);
  14553                SERIAL_ECHO(" |0b"); MYSERIAL.print(get_status_response(st), BIN);
  14554                SERIAL_ECHO("| ");
  14555                if (data.is_error) SERIAL_ECHO('E');
  14556                else if (data.is_ot) SERIAL_ECHO('O');
  14557                else if (data.is_otpw) SERIAL_ECHO('W');
  14558                else if (otpw_cnt>0) MYSERIAL.print(otpw_cnt, DEC);
  14559                else if (st.flag_otpw) SERIAL_ECHO('F');
  14560                SERIAL_ECHO("\t");
  14561              }
  14562          
  14563              return otpw_cnt;
  14564            }
  14565          
  14566            void monitor_tmc_driver() {
  14567              static millis_t next_cOT = 0;
  14568              if (ELAPSED(millis(), next_cOT)) {
  14569                next_cOT = millis() + 500;
  14570                #if ENABLED(X_IS_TMC2130)|| (ENABLED(X_IS_TMC2208) && defined(X_HARDWARE_SERIAL)) || ENABLED(IS_TRAMS)
  14571                  static uint8_t x_otpw_cnt = 0;
  14572                  x_otpw_cnt = monitor_tmc_driver(stepperX, axis_codes[X_AXIS], x_otpw_cnt);
  14573                #endif
  14574                #if ENABLED(Y_IS_TMC2130)|| (ENABLED(Y_IS_TMC2208) && defined(Y_HARDWARE_SERIAL)) || ENABLED(IS_TRAMS)
  14575                  static uint8_t y_otpw_cnt = 0;
  14576                  y_otpw_cnt = monitor_tmc_driver(stepperY, axis_codes[Y_AXIS], y_otpw_cnt);
  14577                #endif
  14578                #if ENABLED(Z_IS_TMC2130)|| (ENABLED(Z_IS_TMC2208) && defined(Z_HARDWARE_SERIAL)) || ENABLED(IS_TRAMS)
  14579                  static uint8_t z_otpw_cnt = 0;
  14580                  z_otpw_cnt = monitor_tmc_driver(stepperZ, axis_codes[Z_AXIS], z_otpw_cnt);
  14581                #endif
  14582                #if ENABLED(X2_IS_TMC2130) || (ENABLED(X2_IS_TMC2208) && defined(X2_HARDWARE_SERIAL))
  14583                  static uint8_t x2_otpw_cnt = 0;
  14584                  x2_otpw_cnt = monitor_tmc_driver(stepperX2, axis_codes[X_AXIS], x2_otpw_cnt);
  14585                #endif
  14586                #if ENABLED(Y2_IS_TMC2130) || (ENABLED(Y2_IS_TMC2208) && defined(Y2_HARDWARE_SERIAL))
  14587                  static uint8_t y2_otpw_cnt = 0;
  14588                  y2_otpw_cnt = monitor_tmc_driver(stepperY2, axis_codes[Y_AXIS], y2_otpw_cnt);
  14589                #endif
  14590                #if ENABLED(Z2_IS_TMC2130) || (ENABLED(Z2_IS_TMC2208) && defined(Z2_HARDWARE_SERIAL))
  14591                  static uint8_t z2_otpw_cnt = 0;
  14592                  z2_otpw_cnt = monitor_tmc_driver(stepperZ2, axis_codes[Z_AXIS], z2_otpw_cnt);
  14593                #endif
  14594                #if ENABLED(E0_IS_TMC2130)|| (ENABLED(E0_IS_TMC2208) && defined(E0_HARDWARE_SERIAL)) || ENABLED(IS_TRAMS)
  14595                  static uint8_t e0_otpw_cnt = 0;
  14596                  e0_otpw_cnt = monitor_tmc_driver(stepperE0, axis_codes[E_AXIS], e0_otpw_cnt);
  14597                #endif
  14598                #if ENABLED(E1_IS_TMC2130) || (ENABLED(E1_IS_TMC2208) && defined(E1_HARDWARE_SERIAL))
  14599                  static uint8_t e1_otpw_cnt = 0;
  14600                  e1_otpw_cnt = monitor_tmc_driver(stepperE1, axis_codes[E_AXIS], e1_otpw_cnt);
  14601                #endif
  14602                #if ENABLED(E2_IS_TMC2130) || (ENABLED(E2_IS_TMC2208) && defined(E2_HARDWARE_SERIAL))
  14603                  static uint8_t e2_otpw_cnt = 0;
  14604                  e2_otpw_cnt = monitor_tmc_driver(stepperE2, axis_codes[E_AXIS], e2_otpw_cnt);
  14605                #endif
  14606                #if ENABLED(E3_IS_TMC2130) || (ENABLED(E3_IS_TMC2208) && defined(E3_HARDWARE_SERIAL))
  14607                  static uint8_t e3_otpw_cnt = 0;
  14608                  e3_otpw_cnt = monitor_tmc_driver(stepperE3, axis_codes[E_AXIS], e3_otpw_cnt);
  14609                #endif
  14610                #if ENABLED(E4_IS_TMC2130) || (ENABLED(E4_IS_TMC2208) && defined(E4_HARDWARE_SERIAL))
  14611                  static uint8_t e4_otpw_cnt = 0;
  14612                  e4_otpw_cnt = monitor_tmc_driver(stepperE4, axis_codes[E_AXIS], e4_otpw_cnt);
  14613                #endif
  14614          
  14615                if (report_tmc_status) SERIAL_EOL();
  14616              }
  14617            }
  14618          
  14619          #endif // MONITOR_DRIVER_STATUS
  14620          
  14621          /**
  14622           * Manage several activities:
  14623           *  - Check for Filament Runout
  14624           *  - Keep the command buffer full
  14625           *  - Check for maximum inactive time between commands
  14626           *  - Check for maximum inactive time between stepper commands
  14627           *  - Check if pin CHDK needs to go LOW
  14628           *  - Check for KILL button held down
  14629           *  - Check for HOME button held down
  14630           *  - Check if cooling fan needs to be switched on
  14631           *  - Check if an idle but hot extruder needs filament extruded (EXTRUDER_RUNOUT_PREVENT)
  14632           */

   \                                 In section .text, align 2, keep-with-next
  14633          void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
   \                     _Z17manage_inactivityb: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
  14634          
  14635            #if ENABLED(FILAMENT_RUNOUT_SENSOR)
  14636              if ((IS_SD_PRINTING || print_job_timer.isRunning()) && (READ(FIL_RUNOUT_PIN) == FIL_RUNOUT_INVERTING))
  14637                handle_filament_runout();
  14638            #endif
  14639          
  14640            if (commands_in_queue < BUFSIZE) get_available_commands();
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable127_1
   \   00000008   0x7C28             LDRB     R0,[R5, #+16]
   \   0000000A   0x2804             CMP      R0,#+4
   \   0000000C   0xDA01             BGE.N    ??manage_inactivity_0
   \   0000000E   0x.... 0x....      BL       _Z22get_available_commandsv
  14641          
  14642            const millis_t ms = millis();
   \                     ??manage_inactivity_0: (+1)
   \   00000012   0x.... 0x....      BL       HAL_GetTick
   \   00000016   0x4606             MOV      R6,R0
  14643          
  14644            if (max_inactive_time && ELAPSED(ms, previous_cmd_ms + max_inactive_time)) {
   \   00000018   0x....             LDR.N    R7,??DataTable118
   \   0000001A   0x6878             LDR      R0,[R7, #+4]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD017             BEQ.N    ??manage_inactivity_1
   \   00000020   0x6839             LDR      R1,[R7, #+0]
   \   00000022   0x1A71             SUBS     R1,R6,R1
   \   00000024   0x1A08             SUBS     R0,R1,R0
   \   00000026   0xD413             BMI.N    ??manage_inactivity_1
  14645              SERIAL_ERROR_START();
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable132
   \   0000002C   0x.... 0x....      BL       _Z14serialprintPGMPKc
  14646              SERIAL_ECHOLNPAIR(MSG_KILL_INACTIVE_TIME, parser.command_ptr);
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable130
   \   00000034   0x6801             LDR      R1,[R0, #+0]
   \   00000036   0x.... 0x....      ADR.W    R0,`?<Constant "KILL caused by too mu...">`
   \   0000003A   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
   \   0000003E   0x210A             MOVS     R1,#+10
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable130_1
   \   00000044   0x.... 0x....      BL       _ZN10USARTClass5writeEh
  14647              kill(PSTR(MSG_KILLED));
   \   00000048   0x.... 0x....      ADR.W    R0,`?<Constant "KILLED. ">`
   \   0000004C   0x.... 0x....      BL       _Z4killPKc
  14648            }
  14649          
  14650            // Prevent steppers timing-out in the middle of M600
  14651            #if ENABLED(ADVANCED_PAUSE_FEATURE) && ENABLED(PAUSE_PARK_NO_STEPPER_TIMEOUT)
  14652              #define MOVE_AWAY_TEST !move_away_flag
  14653            #else
  14654              #define MOVE_AWAY_TEST true
  14655            #endif
  14656          
  14657            if (MOVE_AWAY_TEST && stepper_inactive_time && ELAPSED(ms, previous_cmd_ms + stepper_inactive_time)
  14658                && !ignore_stepper_queue && !planner.blocks_queued()) {
   \                     ??manage_inactivity_1: (+1)
   \   00000050   0x68B8             LDR      R0,[R7, #+8]
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD016             BEQ.N    ??manage_inactivity_2
   \   00000056   0x6839             LDR      R1,[R7, #+0]
   \   00000058   0x1A71             SUBS     R1,R6,R1
   \   0000005A   0x1A08             SUBS     R0,R1,R0
   \   0000005C   0xD412             BMI.N    ??manage_inactivity_2
   \   0000005E   0x2C00             CMP      R4,#+0
   \   00000060   0xD110             BNE.N    ??manage_inactivity_2
   \   00000062   0x.... 0x....      BL       _ZN7Planner13blocks_queuedEv
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD10C             BNE.N    ??manage_inactivity_2
  14659              #if ENABLED(DISABLE_INACTIVE_X)
  14660                disable_X();
  14661              #endif
  14662              #if ENABLED(DISABLE_INACTIVE_Y)
  14663                disable_Y();
  14664              #endif
  14665              #if ENABLED(DISABLE_INACTIVE_Z)
  14666                disable_Z();
   \   0000006A   0x2201             MOVS     R2,#+1
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable128
   \   00000070   0x8881             LDRH     R1,[R0, #+4]
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable128_1
   \   00000076   0x6880             LDR      R0,[R0, #+8]
   \   00000078   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x72A8             STRB     R0,[R5, #+10]
  14667              #endif
  14668              #if ENABLED(DISABLE_INACTIVE_E)
  14669                disable_e_steppers();
   \   00000080   0x.... 0x....      BL       _Z18disable_e_steppersv
  14670              #endif
  14671              #if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(ULTIPANEL)  // Only needed with an LCD
  14672                ubl.lcd_map_control = defer_return_to_status = false;
  14673              #endif
  14674            }
  14675          
  14676            #ifdef CHDK // Check if pin should be set to LOW after M240 set it to HIGH
  14677              if (chdkActive && ELAPSED(ms, chdkHigh + CHDK_DELAY)) {
  14678                chdkActive = false;
  14679                WRITE(CHDK, LOW);
  14680              }
  14681            #endif
  14682          
  14683            #if HAS_KILL
  14684          
  14685              // Check if the kill button was pressed and wait just in case it was an accidental
  14686              // key kill key press
  14687              // -------------------------------------------------------------------------------
  14688              static int killCount = 0;   // make the inactivity button a bit less responsive
  14689              const int KILL_DELAY = 750;
  14690              if (!READ(KILL_PIN))
  14691                killCount++;
  14692              else if (killCount > 0)
  14693                killCount--;
  14694          
  14695              // Exceeded threshold and we can confirm that it was not accidental
  14696              // KILL the machine
  14697              // ----------------------------------------------------------------
  14698              if (killCount >= KILL_DELAY) {
  14699                SERIAL_ERROR_START();
  14700                SERIAL_ERRORLNPGM(MSG_KILL_BUTTON);
  14701                kill(PSTR(MSG_KILLED));
  14702              }
  14703            #endif
  14704          
  14705            #if HAS_HOME
  14706              // Check to see if we have to home, use poor man's debouncer
  14707              // ---------------------------------------------------------
  14708              static int homeDebounceCount = 0;   // poor man's debouncing count
  14709              const int HOME_DEBOUNCE_DELAY = 2500;
  14710              if (!IS_SD_PRINTING && !READ(HOME_PIN)) {
  14711                if (!homeDebounceCount) {
  14712                  enqueue_and_echo_commands_P(PSTR("G28"));
  14713                  LCD_MESSAGEPGM(MSG_AUTO_HOME);
  14714                }
  14715                if (homeDebounceCount < HOME_DEBOUNCE_DELAY)
  14716                  homeDebounceCount++;
  14717                else
  14718                  homeDebounceCount = 0;
  14719              }
  14720            #endif
  14721          
  14722            #if ENABLED(USE_CONTROLLER_FAN)
  14723              controllerFan(); // Check if fan should be turned on to cool stepper drivers down
  14724            #endif
  14725          
  14726            #if ENABLED(EXTRUDER_RUNOUT_PREVENT)
  14727              if (ELAPSED(ms, previous_cmd_ms + (EXTRUDER_RUNOUT_SECONDS) * 1000UL)
  14728                && thermalManager.degHotend(active_extruder) > EXTRUDER_RUNOUT_MINTEMP) {
  14729                #if ENABLED(SWITCHING_EXTRUDER)
  14730                  const bool oldstatus = E0_ENABLE_READ;
  14731                  enable_E0();
  14732                #else // !SWITCHING_EXTRUDER
  14733                  bool oldstatus;
  14734                  switch (active_extruder) {
  14735                    default: oldstatus = E0_ENABLE_READ; enable_E0(); break;
  14736                    #if E_STEPPERS > 1
  14737                      case 1: oldstatus = E1_ENABLE_READ; enable_E1(); break;
  14738                      #if E_STEPPERS > 2
  14739                        case 2: oldstatus = E2_ENABLE_READ; enable_E2(); break;
  14740                        #if E_STEPPERS > 3
  14741                          case 3: oldstatus = E3_ENABLE_READ; enable_E3(); break;
  14742                          #if E_STEPPERS > 4
  14743                            case 4: oldstatus = E4_ENABLE_READ; enable_E4(); break;
  14744                          #endif // E_STEPPERS > 4
  14745                        #endif // E_STEPPERS > 3
  14746                      #endif // E_STEPPERS > 2
  14747                    #endif // E_STEPPERS > 1
  14748                  }
  14749                #endif // !SWITCHING_EXTRUDER
  14750          
  14751                previous_cmd_ms = ms; // refresh_cmd_timeout()
  14752          
  14753                const float olde = current_position[E_AXIS];
  14754                current_position[E_AXIS] += EXTRUDER_RUNOUT_EXTRUDE;
  14755                planner.buffer_line_kinematic(current_position, MMM_TO_MMS(EXTRUDER_RUNOUT_SPEED), active_extruder);
  14756                current_position[E_AXIS] = olde;
  14757                planner.set_e_position_mm(olde);
  14758                stepper.synchronize();
  14759                #if ENABLED(SWITCHING_EXTRUDER)
  14760                  E0_ENABLE_WRITE(oldstatus);
  14761                #else
  14762                  switch (active_extruder) {
  14763                    case 0: E0_ENABLE_WRITE(oldstatus); break;
  14764                    #if E_STEPPERS > 1
  14765                      case 1: E1_ENABLE_WRITE(oldstatus); break;
  14766                      #if E_STEPPERS > 2
  14767                        case 2: E2_ENABLE_WRITE(oldstatus); break;
  14768                        #if E_STEPPERS > 3
  14769                          case 3: E3_ENABLE_WRITE(oldstatus); break;
  14770                          #if E_STEPPERS > 4
  14771                            case 4: E4_ENABLE_WRITE(oldstatus); break;
  14772                          #endif // E_STEPPERS > 4
  14773                        #endif // E_STEPPERS > 3
  14774                      #endif // E_STEPPERS > 2
  14775                    #endif // E_STEPPERS > 1
  14776                  }
  14777                #endif // !SWITCHING_EXTRUDER
  14778              }
  14779            #endif // EXTRUDER_RUNOUT_PREVENT
  14780          
  14781            #if ENABLED(DUAL_X_CARRIAGE)
  14782              // handle delayed move timeout
  14783              if (delayed_move_time && ELAPSED(ms, delayed_move_time + 1000UL) && IsRunning()) {
  14784                // travel moves have been received so enact them
  14785                delayed_move_time = 0xFFFFFFFFUL; // force moves to be done
  14786                set_destination_from_current();
  14787                prepare_move_to_destination();
  14788              }
  14789            #endif
  14790          
  14791            #if ENABLED(TEMP_STAT_LEDS)
  14792              handle_status_leds();
  14793            #endif
  14794          
  14795            #if ENABLED(MONITOR_DRIVER_STATUS)
  14796              monitor_tmc_driver();
  14797            #endif
  14798          
  14799            planner.check_axes_activity();
   \                     ??manage_inactivity_2: (+1)
   \   00000084   0xE8BD 0x40F1      POP      {R0,R4-R7,LR}
   \   00000088   0x.... 0x....      B.W      _ZN7Planner19check_axes_activityEv
  14800          }
  14801          
  14802          /**
  14803           * Standard idle routine keeps the machine alive
  14804           */

   \                                 In section .text, align 2, keep-with-next
  14805          void idle(
  14806            #if ENABLED(ADVANCED_PAUSE_FEATURE)
  14807              bool no_stepper_sleep/*=false*/
  14808            #endif
  14809          ) {
   \                     _Z4idlev: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  14810            #if ENABLED(MAX7219_DEBUG)
  14811              Max7219_idle_tasks();
  14812            #endif  // MAX7219_DEBUG
  14813          
  14814          #if  DISABLED(MKS_DLP_BOARD)
  14815            lcd_update();
  14816          #endif
  14817          
  14818            host_keepalive();
  14819          
  14820            #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
  14821              thermalManager.auto_report_temperatures();
  14822            no use
  14823            #endif
  14824          
  14825            manage_inactivity(
  14826              #if ENABLED(ADVANCED_PAUSE_FEATURE)
  14827                no_stepper_sleep
  14828              #endif
  14829            );
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      BL       _Z17manage_inactivityb
  14830          
  14831          #if  DISABLED(MKS_DLP_BOARD)
  14832            thermalManager.manage_heater();
  14833          #endif
  14834          
  14835            #if ENABLED(PRINTCOUNTER)
  14836              print_job_timer.tick();
  14837            #endif
  14838          
  14839            #if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
  14840              buzzer.tick();
  14841            no use
  14842            #endif
  14843            
  14844          #if  DISABLED(MKS_DLP_BOARD)
  14845            display_temper_error();
  14846          #endif
  14847          
  14848            wifi_looping();
   \   00000008   0x.... 0x....      BL       _Z12wifi_loopingv
  14849            
  14850            if(wifi_link_state != WIFI_TRANS_FILE)
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable132_1
   \   00000010   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000014   0x2810             CMP      R0,#+16
   \   00000016   0xD001             BEQ.N    ??idle_0
  14851            {
  14852          	  GUI_RefreshPage();
   \   00000018   0x.... 0x....      BL       GUI_RefreshPage
  14853            }
  14854            #if defined(TFT70)
  14855            disp_pre_gcode(3,40);
  14856            #elif defined(TFT35)
  14857            if(preview_no_display != 1)
   \                     ??idle_0: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable132_2
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD003             BEQ.N    ??idle_1
  14858            {
  14859          	  disp_pre_gcode(25,15);
   \   00000026   0x210F             MOVS     R1,#+15
   \   00000028   0x2019             MOVS     R0,#+25
   \   0000002A   0x.... 0x....      BL       disp_pre_gcode
  14860            }
  14861            #endif
  14862            
  14863            GUI_TOUCH_Exec(); 	  
   \                     ??idle_1: (+1)
   \   0000002E   0x.... 0x....      BL       GUI_TOUCH_Exec
  14864            GUI_Exec(); 
   \   00000032   0x.... 0x....      BL       GUI_Exec
  14865            //mksdlp.buzzer_polling();
  14866            mksdlp.PrintStatePolling();
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable135
   \   0000003A   0xE8BD 0x4002      POP      {R1,LR}
   \   0000003E   0x.... 0x....      B.W      _ZN7MKS_DLP17PrintStatePollingEv
  14867            #if ENABLED(I2C_POSITION_ENCODERS)
  14868              if (planner.blocks_queued() &&
  14869                  ( (blockBufferIndexRef != planner.block_buffer_head) ||
  14870                    ((lastUpdateMillis + I2CPE_MIN_UPD_TIME_MS) < millis())) ) {
  14871                blockBufferIndexRef = planner.block_buffer_head;
  14872                I2CPEM.update();
  14873                lastUpdateMillis = millis();
  14874              }
  14875            #endif
  14876          }
  14877          
  14878          extern "C" void kill_c(const char* lcd_msg);

   \                                 In section .text, align 4, keep-with-next
  14879          void kill_c(const char* lcd_msg) {
   \                     kill_c: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  14880            SERIAL_ERROR_START();
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable132
   \   00000006   0x.... 0x....      BL       _Z14serialprintPGMPKc
  14881            SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
   \   0000000A   0x.... 0x....      ADR.W    R0,`?<Constant "Printer halted. kill(...">`
   \   0000000E   0x.... 0x....      BL       _Z14serialprintPGMPKc
  14882          
  14883            thermalManager.disable_all_heaters();
   \   00000012   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
  14884            disable_all_steppers();
   \   00000016   0x.... 0x....      BL       _Z20disable_all_steppersv
  14885          
  14886            #if ENABLED(ULTRA_LCD)
  14887              kill_screen(lcd_msg);
  14888            #else
  14889              UNUSED(lcd_msg);
  14890            #endif
  14891          
  14892            _delay_ms(600); // Wait a short time (allows messages to get out before shutting down.
   \   0000001A   0xF44F 0x7016      MOV      R0,#+600
   \   0000001E   0x.... 0x....      BL       HAL_Delay
  14893            cli(); // Stop interrupts
   \   00000022   0xB672             cpsid i
  14894          
  14895            _delay_ms(250); //Wait to ensure all interrupts routines stopped
   \   00000024   0x20FA             MOVS     R0,#+250
   \   00000026   0x.... 0x....      BL       HAL_Delay
  14896            thermalManager.disable_all_heaters(); //turn off heaters again
   \   0000002A   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
  14897          
  14898            #if HAS_POWER_SWITCH
  14899              SET_INPUT(PS_ON_PIN);
  14900            #endif
  14901          
  14902            suicide();
   \   0000002E   0x.... 0x....      BL       _Z7suicidev
  14903            while (1) {
   \                     ??kill_c_0: (+1)
   \   00000032   0xE7FE             B.N      ??kill_c_0
  14904              #if ENABLED(USE_WATCHDOG)
  14905                watchdog_reset();
  14906              #endif
  14907            } // Wait for reset
  14908          }
  14909          #if 1

   \                                 In section .text, align 2, keep-with-next
  14910          void temper_error_kill()
  14911          {
   \                     _Z17temper_error_killv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  14912            SERIAL_ERROR_START();
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable132
   \   00000006   0x.... 0x....      BL       _Z14serialprintPGMPKc
  14913            SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
   \   0000000A   0x.... 0x....      ADR.W    R0,`?<Constant "Printer halted. kill(...">`
   \   0000000E   0x.... 0x....      BL       _Z14serialprintPGMPKc
  14914          
  14915            thermalManager.disable_all_heaters();
   \   00000012   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
  14916            disable_all_steppers();	
   \   00000016   0x.... 0x....      BL       _Z20disable_all_steppersv
  14917          
  14918            _delay_ms(600);
   \   0000001A   0xF44F 0x7016      MOV      R0,#+600
   \   0000001E   0x.... 0x....      BL       HAL_Delay
  14919          
  14920            temper_error_flg = 1;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable128_2
   \   00000028   0x7308             STRB     R0,[R1, #+12]
  14921          }
   \   0000002A   0xBD01             POP      {R0,PC}          ;; return
  14922          

   \                                 In section .text, align 2, keep-with-next
  14923          void display_temper_error()
  14924          {
   \                     _Z20display_temper_errorv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
  14925          	if(temper_error_flg == 1)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable127_1
   \   00000006   0x7B01             LDRB     R1,[R0, #+12]
   \   00000008   0x2901             CMP      R1,#+1
   \   0000000A   0xD11C             BNE.N    ??display_temper_error_0
  14926          	{
  14927          		card.sdprinting = false;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x....             LDR.N    R2,??DataTable122
   \   00000010   0xF882 0x19B8      STRB     R1,[R2, #+2488]
  14928          		wait_for_heatup = false;
   \   00000014   0x7541             STRB     R1,[R0, #+21]
  14929          		
  14930          		GUI_SetBkColor(gCfgItems.background_color);
   \   00000016   0x....             LDR.N    R4,??DataTable121_2
   \   00000018   0x6860             LDR      R0,[R4, #+4]
   \   0000001A   0x.... 0x....      BL       GUI_SetBkColor
  14931          		GUI_SetColor(0X0000ff);//	o¨¬¨¦?¡Á?¨¬?
   \   0000001E   0x20FF             MOVS     R0,#+255
   \   00000020   0x.... 0x....      BL       GUI_SetColor
  14932          		GUI_DispStringAt("Error",380, TITLE_YPOS);
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable136
   \   00000028   0x89C2             LDRH     R2,[R0, #+14]
   \   0000002A   0xF44F 0x71BE      MOV      R1,#+380
   \   0000002E   0x.... 0x....      ADR.W    R0,`?<Constant "Error">`
   \   00000032   0x.... 0x....      BL       GUI_DispStringAt
  14933          		GUI_SetBkColor(gCfgItems.background_color);
   \   00000036   0x6860             LDR      R0,[R4, #+4]
   \   00000038   0x.... 0x....      BL       GUI_SetBkColor
  14934          		GUI_SetColor(gCfgItems.title_color);			
   \   0000003C   0x6DA0             LDR      R0,[R4, #+88]
   \   0000003E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000042   0x.... 0x....      B.W      GUI_SetColor
  14935          	}
  14936          }
   \                     ??display_temper_error_0: (+1)
   \   00000046   0xBD10             POP      {R4,PC}          ;; return
  14937          
  14938          #endif
  14939          
  14940          /**
  14941           * Kill all activity and lock the machine.
  14942           * After this the machine will need to be reset.
  14943           */

   \                                 In section .text, align 4, keep-with-next
  14944          void kill(const char* lcd_msg) {
   \                     _Z4killPKc: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  14945            SERIAL_ERROR_START();
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable132
   \   00000006   0x.... 0x....      BL       _Z14serialprintPGMPKc
  14946            SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
   \   0000000A   0x.... 0x....      ADR.W    R0,`?<Constant "Printer halted. kill(...">`
   \   0000000E   0x.... 0x....      BL       _Z14serialprintPGMPKc
  14947          
  14948            thermalManager.disable_all_heaters();
   \   00000012   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
  14949            disable_all_steppers();
   \   00000016   0x.... 0x....      BL       _Z20disable_all_steppersv
  14950          
  14951            #if ENABLED(ULTRA_LCD)
  14952              kill_screen(lcd_msg);
  14953            #else
  14954              UNUSED(lcd_msg);
  14955            #endif
  14956          
  14957            _delay_ms(600); // Wait a short time (allows messages to get out before shutting down.
   \   0000001A   0xF44F 0x7016      MOV      R0,#+600
   \   0000001E   0x.... 0x....      BL       HAL_Delay
  14958           
  14959          
  14960            _delay_ms(250); //Wait to ensure all interrupts routines stopped
   \   00000022   0x20FA             MOVS     R0,#+250
   \   00000024   0x.... 0x....      BL       HAL_Delay
  14961             cli(); // Stop interrupts
   \   00000028   0xB672             cpsid i
  14962            thermalManager.disable_all_heaters(); //turn off heaters again
   \   0000002A   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
  14963          
  14964            #ifdef ACTION_ON_KILL
  14965              SERIAL_ECHOLNPGM("//action:" ACTION_ON_KILL);
  14966            #endif
  14967          
  14968            #if HAS_POWER_SWITCH
  14969              SET_INPUT(PS_ON_PIN);
  14970            #endif
  14971          
  14972            suicide();
   \   0000002E   0x.... 0x....      BL       _Z7suicidev
  14973            while (1) {
   \                     ??kill_0: (+1)
   \   00000032   0xE7FE             B.N      ??kill_0
  14974              #if ENABLED(USE_WATCHDOG)
  14975                watchdog_reset();
  14976              #endif
  14977            } // Wait for reset
  14978          }
  14979          
  14980          /**
  14981           * Turn off heaters and stop the print in progress
  14982           * After a stop the machine may be resumed with M999
  14983           */

   \                                 In section .text, align 2, keep-with-next
  14984          void stop() {
   \                     _Z4stopv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
  14985            thermalManager.disable_all_heaters(); // 'unpause' taken care of in here
   \   00000002   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
  14986          
  14987            #if ENABLED(PROBING_FANS_OFF)
  14988              if (fans_paused) fans_pause(false); // put things back the way they were
  14989            #endif
  14990          
  14991            if (IsRunning()) {
   \   00000006   0x.... 0x....      BL       _Z9IsRunningv
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD016             BEQ.N    ??stop_0
  14992              Stopped_gcode_LastN = gcode_LastN; // Save last g_code for restart
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable127_1
   \   00000012   0x6F20             LDR      R0,[R4, #+112]
   \   00000014   0x6760             STR      R0,[R4, #+116]
  14993              SERIAL_ERROR_START();
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable132
   \   0000001A   0x.... 0x....      BL       _Z14serialprintPGMPKc
  14994              SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
   \   0000001E   0x.... 0x....      ADR.W    R0,`?<Constant "Printer stopped due t...">`
   \   00000022   0x.... 0x....      BL       _Z14serialprintPGMPKc
  14995              LCD_MESSAGEPGM(MSG_STOPPED);
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x.... 0x....      ADR.W    R0,`?<Constant "STOPPED. ">`
   \   0000002C   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
  14996              safe_delay(350);       // allow enough time for messages to get out before stopping
   \   00000030   0xF44F 0x70AF      MOV      R0,#+350
   \   00000034   0x.... 0x....      BL       _Z10safe_delaym
  14997              Running = false;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x73A0             STRB     R0,[R4, #+14]
  14998            }
  14999          }
   \                     ??stop_0: (+1)
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
  15000          
  15001          /**
  15002           * Marlin entry-point: Set up before the program loop
  15003           *  - Set up the kill pin, filament runout, power hold
  15004           *  - Start the serial port
  15005           *  - Print startup messages and diagnostics
  15006           *  - Get EEPROM or default settings
  15007           *  - Initialize managers for:
  15008           *    â¢ temperature
  15009           *    â¢ planner
  15010           *    â¢ watchdog
  15011           *    â¢ stepper
  15012           *    â¢ photo pin
  15013           *    â¢ servos
  15014           *    â¢ LCD controller
  15015           *    â¢ Digipot I2C
  15016           *    â¢ Z probe sled
  15017           *    â¢ status LEDs
  15018           */

   \                                 In section .text, align 2, keep-with-next
  15019          void setup() {
   \                     setup: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
  15020          
  15021            #if ENABLED(MAX7219_DEBUG)
  15022              Max7219_init();
  15023            #endif
  15024          /*
  15025            #if ENABLED(DISABLE_JTAG)
  15026              // Disable JTAG on AT90USB chips to free up pins for IO
  15027              MCUCR = 0x80;
  15028              MCUCR = 0x80;
  15029            #endif
  15030            */
  15031          
  15032            #if ENABLED(FILAMENT_RUNOUT_SENSOR)
  15033              setup_filrunoutpin();
  15034            #endif
  15035          
  15036            setup_killpin();
   \   00000002   0x.... 0x....      BL       _Z13setup_killpinv
  15037          
  15038            //setup_powerhold();
  15039          
  15040            #if HAS_STEPPER_RESET
  15041              disableStepperDrivers();
  15042            #endif
  15043          
  15044            //MYSERIAL.begin(BAUDRATE);
  15045            //SERIAL_PROTOCOLLNPGM("start");
  15046            //SERIAL_ECHO_START();
  15047          
  15048            #if ENABLED(HAVE_TMC2208)
  15049              tmc2208_serial_begin();
  15050            #endif
  15051          
  15052            // Check startup - does nothing if bootloader sets MCUSR to 0
  15053            byte mcu = MCUSR;
  15054            if (mcu &  1) SERIAL_ECHOLNPGM(MSG_POWERUP);
  15055            if (mcu &  2) SERIAL_ECHOLNPGM(MSG_EXTERNAL_RESET);
  15056            if (mcu &  4) SERIAL_ECHOLNPGM(MSG_BROWNOUT_RESET);
  15057            if (mcu &  8) SERIAL_ECHOLNPGM(MSG_WATCHDOG_RESET);
  15058            if (mcu & 32) SERIAL_ECHOLNPGM(MSG_SOFTWARE_RESET);
  15059            //MCUSR = 0;
  15060          
  15061            SERIAL_ECHOPGM(MSG_MARLIN);
   \   00000006   0x.... 0x....      ADR.W    R0,`?<Constant "MKS DLP">`
   \   0000000A   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15062            SERIAL_CHAR(' ');
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable130_1
   \   00000012   0x2120             MOVS     R1,#+32
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       _ZN10USARTClass5writeEh
  15063            SERIAL_ECHOLNPGM(SHORT_BUILD_VERSION);
   \   0000001A   0x.... 0x....      ADR.W    R0,`?<Constant "1.0.0\\n">`
   \   0000001E   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15064            SERIAL_EOL();
   \   00000022   0x210A             MOVS     R1,#+10
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       _ZN10USARTClass5writeEh
  15065          
  15066            #if defined(STRING_DISTRIBUTION_DATE) && defined(STRING_CONFIG_H_AUTHOR)
  15067              SERIAL_ECHO_START();
   \   0000002A   0x.... 0x....      LDR.W    R5,??DataTable127
   \   0000002E   0x4628             MOV      R0,R5
   \   00000030   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15068              SERIAL_ECHOPGM(MSG_CONFIGURATION_VER);
   \   00000034   0x.... 0x....      ADR.W    R0,`?<Constant " Last Updated: ">`
   \   00000038   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15069              SERIAL_ECHOPGM(STRING_DISTRIBUTION_DATE);
   \   0000003C   0x.... 0x....      ADR.W    R0,`?<Constant "2017-12-25 12:00">`
   \   00000040   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15070              SERIAL_ECHOLNPGM(MSG_AUTHOR STRING_CONFIG_H_AUTHOR);
   \   00000044   0x.... 0x....      ADR.W    R0,`?<Constant " | Author: (none, def...">`
   \   00000048   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15071              SERIAL_ECHO_START();
   \   0000004C   0x4628             MOV      R0,R5
   \   0000004E   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15072              SERIAL_ECHOLNPGM("Compiled: " __DATE__);
   \   00000052   0x.... 0x....      ADR.W    R0,`?<Constant "Compiled: Apr 16 2020\\n">`
   \   00000056   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15073            #endif
  15074          
  15075            SERIAL_ECHO_START();
   \   0000005A   0x4628             MOV      R0,R5
   \   0000005C   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15076            SERIAL_ECHOPAIR(MSG_FREE_MEMORY, freeMemory());
   \   00000060   0x.... 0x....      BL       _Z10freeMemoryv
   \   00000064   0x4601             MOV      R1,R0
   \   00000066   0x.... 0x....      ADR.W    R0,`?<Constant " Free Memory: ">`
   \   0000006A   0x.... 0x....      BL       _Z17serial_echopair_PPKci
  15077            SERIAL_ECHOLNPAIR(MSG_PLANNER_BUFFER_BYTES, (int)sizeof(block_t)*BLOCK_BUFFER_SIZE);
   \   0000006E   0xF44F 0x61A8      MOV      R1,#+1344
   \   00000072   0x.... 0x....      ADR.W    R0,`?<Constant "  PlannerBufferBytes: ">`
   \   00000076   0x.... 0x....      BL       _Z17serial_echopair_PPKci
   \   0000007A   0x210A             MOVS     R1,#+10
   \   0000007C   0x4620             MOV      R0,R4
   \   0000007E   0x.... 0x....      BL       _ZN10USARTClass5writeEh
  15078          
  15079            // Send "ok" after commands by default
  15080            for (int8_t i = 0; i < BUFSIZE; i++) send_ok[i] = true;
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x2201             MOVS     R2,#+1
   \   00000086   0x.... 0x....      LDR.W    R4,??DataTable127_1
   \   0000008A   0xE002             B.N      ??setup_0
   \                     ??setup_1: (+1)
   \   0000008C   0x1909             ADDS     R1,R1,R4
   \   0000008E   0x770A             STRB     R2,[R1, #+28]
   \   00000090   0x1C40             ADDS     R0,R0,#+1
   \                     ??setup_0: (+1)
   \   00000092   0xB240             SXTB     R0,R0
   \   00000094   0x4601             MOV      R1,R0
   \   00000096   0x2904             CMP      R1,#+4
   \   00000098   0xDBF8             BLT.N    ??setup_1
  15081          
  15082            // Load data from EEPROM if available (or use defaults)
  15083            // This also updates variables in the planner, elsewhere
  15084            (void)settings.load();
   \   0000009A   0x.... 0x....      BL       _ZN14MarlinSettings4loadEv
  15085          
  15086            #if HAS_M206_COMMAND
  15087              // Initialize current position based on home_offset
  15088              COPY(current_position, home_offset);
   \   0000009E   0x220C             MOVS     R2,#+12
   \   000000A0   0xF104 0x0154      ADD      R1,R4,#+84
   \   000000A4   0xF104 0x0024      ADD      R0,R4,#+36
   \   000000A8   0x.... 0x....      BL       memcpy
  15089            #else
  15090              ZERO(current_position);
  15091            #endif
  15092          
  15093            // Vital to init stepper/planner equivalent for current_position
  15094            SYNC_PLAN_POSITION_KINEMATIC();
   \   000000AC   0x.... 0x....      BL       _Z18sync_plan_positionv
  15095          
  15096            thermalManager.init();    // Initialize temperature loop
   \   000000B0   0x.... 0x....      LDR.W    R0,??DataTable142
   \   000000B4   0x.... 0x....      BL       _ZN11Temperature4initEv
  15097          
  15098            #if ENABLED(USE_WATCHDOG)
  15099              watchdog_init();
  15100            #endif
  15101            //tan add
  15102            soft_endstop_min_init();
   \   000000B8   0x.... 0x....      BL       _Z21soft_endstop_min_initv
  15103          
  15104            stepper.init();    // Initialize stepper, this enables interrupts!
   \   000000BC   0x.... 0x....      BL       _ZN7Stepper4initEv
  15105            servo_init();
   \   000000C0   0x.... 0x....      BL       _Z10servo_initv
  15106          
  15107            #if HAS_PHOTOGRAPH
  15108              OUT_WRITE(PHOTOGRAPH_PIN, LOW);
  15109            #endif
  15110          
  15111            #if HAS_CASE_LIGHT
  15112              case_light_on = CASE_LIGHT_DEFAULT_ON;
  15113              case_light_brightness = CASE_LIGHT_DEFAULT_BRIGHTNESS;
  15114              update_case_light();
  15115            #endif
  15116          
  15117            #if ENABLED(SPINDLE_LASER_ENABLE)
  15118              OUT_WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);  // init spindle to off
  15119              #if SPINDLE_DIR_CHANGE
  15120                OUT_WRITE(SPINDLE_DIR_PIN, SPINDLE_INVERT_DIR ? 255 : 0);  // init rotation to clockwise (M3)
  15121              #endif
  15122              #if ENABLED(SPINDLE_LASER_PWM)
  15123                SET_OUTPUT(SPINDLE_LASER_PWM_PIN);
  15124                analogWrite(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);  // set to lowest speed
  15125              #endif
  15126            #endif
  15127          
  15128            #if HAS_BED_PROBE
  15129              endstops.enable_z_probe(false);
  15130            #endif
  15131          
  15132            #if ENABLED(USE_CONTROLLER_FAN)
  15133              SET_OUTPUT(CONTROLLER_FAN_PIN); //Set pin used for driver cooling fan
  15134            #endif
  15135          
  15136            #if HAS_STEPPER_RESET
  15137              enableStepperDrivers();
  15138            #endif
  15139          
  15140            #if ENABLED(DIGIPOT_I2C)
  15141              digipot_i2c_init();
  15142            #endif
  15143          
  15144            #if ENABLED(DAC_STEPPER_CURRENT)
  15145              dac_init();
  15146            #endif
  15147          
  15148            #if (ENABLED(Z_PROBE_SLED) || ENABLED(SOLENOID_PROBE)) && HAS_SOLENOID_1
  15149              OUT_WRITE(SOL1_PIN, LOW); // turn it off
  15150            #endif
  15151          
  15152            #if HAS_HOME
  15153              SET_INPUT_PULLUP(HOME_PIN);
  15154            #endif
  15155          
  15156            #if PIN_EXISTS(STAT_LED_RED)
  15157              OUT_WRITE(STAT_LED_RED_PIN, LOW); // turn it off
  15158            #endif
  15159          
  15160            #if PIN_EXISTS(STAT_LED_BLUE)
  15161              OUT_WRITE(STAT_LED_BLUE_PIN, LOW); // turn it off
  15162            #endif
  15163          
  15164            #if HAS_COLOR_LEDS
  15165              leds.setup();
  15166            #endif
  15167          
  15168            #if ENABLED(RGB_LED) || ENABLED(RGBW_LED)
  15169              SET_OUTPUT(RGB_LED_R_PIN);
  15170              SET_OUTPUT(RGB_LED_G_PIN);
  15171              SET_OUTPUT(RGB_LED_B_PIN);
  15172              #if ENABLED(RGBW_LED)
  15173                SET_OUTPUT(RGB_LED_W_PIN);
  15174              #endif
  15175            #endif
  15176          
  15177            #if ENABLED(MK2_MULTIPLEXER)
  15178              SET_OUTPUT(E_MUX0_PIN);
  15179              SET_OUTPUT(E_MUX1_PIN);
  15180              SET_OUTPUT(E_MUX2_PIN);
  15181            #endif
  15182          
  15183            #if HAS_FANMUX
  15184              fanmux_init();
  15185            #endif
  15186          
  15187            lcd_init();
   \   000000C4   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   000000C8   0x.... 0x....      B.W      _Z8lcd_initv
  15188          
  15189            #if ENABLED(SHOW_BOOTSCREEN)
  15190              lcd_bootscreen();
  15191            #endif
  15192          
  15193            #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
  15194              // Virtual Tools 0, 1, 2, 3 = Filament 1, 2, 3, 4, etc.
  15195              for (uint8_t t = 0; t < MIXING_VIRTUAL_TOOLS && t < MIXING_STEPPERS; t++)
  15196                for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
  15197                  mixing_virtual_tool_mix[t][i] = (t == i) ? 1.0 : 0.0;
  15198          
  15199              // Remaining virtual tools are 100% filament 1
  15200              #if MIXING_STEPPERS < MIXING_VIRTUAL_TOOLS
  15201                for (uint8_t t = MIXING_STEPPERS; t < MIXING_VIRTUAL_TOOLS; t++)
  15202                  for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
  15203                    mixing_virtual_tool_mix[t][i] = (i == 0) ? 1.0 : 0.0;
  15204              #endif
  15205          
  15206              // Initialize mixing to tool 0 color
  15207              for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
  15208                mixing_factor[i] = mixing_virtual_tool_mix[0][i];
  15209            #endif
  15210          
  15211            #if ENABLED(BLTOUCH)
  15212              // Make sure any BLTouch error condition is cleared
  15213              bltouch_command(BLTOUCH_RESET);
  15214              set_bltouch_deployed(true);
  15215              set_bltouch_deployed(false);
  15216            #endif
  15217          
  15218            #if ENABLED(I2C_POSITION_ENCODERS)
  15219              I2CPEM.init();
  15220            #endif
  15221          
  15222            #if ENABLED(EXPERIMENTAL_I2CBUS) && I2C_SLAVE_ADDRESS > 0
  15223              i2c.onReceive(i2c_on_receive);
  15224              i2c.onRequest(i2c_on_request);
  15225            #endif
  15226          
  15227            #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
  15228              setup_endstop_interrupts();
  15229            #endif
  15230          
  15231            #if ENABLED(SWITCHING_EXTRUDER) && !DONT_SWITCH
  15232              move_extruder_servo(0);  // Initialize extruder servo
  15233            #endif
  15234          
  15235            #if ENABLED(SWITCHING_NOZZLE)
  15236              move_nozzle_servo(0);  // Initialize nozzle servo
  15237            #endif
  15238          
  15239            #if ENABLED(PARKING_EXTRUDER)
  15240              #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
  15241                pe_activate_magnet(0);
  15242                pe_activate_magnet(1);
  15243              #else
  15244                pe_deactivate_magnet(0);
  15245                pe_deactivate_magnet(1);
  15246              #endif
  15247            #endif
  15248            #if ENABLED(MKS_12864OLED) || ENABLED(MKS_12864OLED_SSD1306)
  15249              SET_OUTPUT(LCD_PINS_DC);
  15250              OUT_WRITE(LCD_PINS_RS, LOW);
  15251              delay(1000);
  15252              WRITE(LCD_PINS_RS, HIGH);
  15253            #endif
  15254          }
  15255          
  15256          /**
  15257           * The main Marlin program loop
  15258           *
  15259           *  - Save or log commands to SD
  15260           *  - Process available commands (if not saving)
  15261           *  - Call heater manager
  15262           *  - Call inactivity manager
  15263           *  - Call endstop manager
  15264           *  - Call LCD update
  15265           */
  15266          
  15267          
  15268          

   \                                 In section .text, align 2, keep-with-next
  15269          void loop() {
   \                     loop: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
  15270          #if 0
  15271          	display_temper_error();
  15272          	
  15273          	PowerOff_Filament_Check();
  15274          	
  15275          	MYSERIAL.MoremenuCmd();
  15276          
  15277          #endif
  15278            if (commands_in_queue < BUFSIZE) get_available_commands();
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable127_1
   \   00000006   0x7C20             LDRB     R0,[R4, #+16]
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xDA01             BGE.N    ??loop_0
   \   0000000C   0x.... 0x....      BL       _Z22get_available_commandsv
  15279          
  15280            mksdlp.get_available_bmps();
   \                     ??loop_0: (+1)
   \   00000010   0x.... 0x....      LDR.W    R5,??DataTable142_2
   \   00000014   0xF605 0x10C4      ADDW     R0,R5,#+2500
   \   00000018   0x.... 0x....      BL       _ZN7MKS_DLP18get_available_bmpsEv
  15281          
  15282          	
  15283            #if 0//ENABLED(SDSUPPORT)
  15284              card.checkautostart(false);
  15285            #endif
  15286            card.checkFilesys(gCfgItems.fileSysType);
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable138
   \   00000020   0xF890 0x10DA      LDRB     R1,[R0, #+218]
   \   00000024   0x4628             MOV      R0,R5
   \   00000026   0x.... 0x....      BL       _ZN10CardReader12checkFilesysEh
  15287          
  15288            if (commands_in_queue) {
   \   0000002A   0x7C20             LDRB     R0,[R4, #+16]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD038             BEQ.N    ??loop_1
  15289          
  15290              #if ENABLED(SDSUPPORT)
  15291          
  15292                if (card.saving) {
   \   00000030   0xF895 0x09B9      LDRB     R0,[R5, #+2489]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD025             BEQ.N    ??loop_2
  15293                  char* command = command_queue[cmd_queue_index_r];
   \   00000038   0x7C60             LDRB     R0,[R4, #+17]
   \   0000003A   0xEB00 0x0140      ADD      R1,R0,R0, LSL #+1
   \   0000003E   0xEB04 0x1041      ADD      R0,R4,R1, LSL #+5
   \   00000042   0xF100 0x068C      ADD      R6,R0,#+140
  15294                  if (strstr_P(command, PSTR("M29"))) {
   \   00000046   0x....             ADR.N    R1,??DataTable125  ;; "M29"
   \   00000048   0x4630             MOV      R0,R6
   \   0000004A   0x.... 0x....      BL       _Z6strstrPcPKc
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD00A             BEQ.N    ??loop_3
  15295                    // M29 closes the file
  15296                    card.closefile();
   \   00000052   0x2100             MOVS     R1,#+0
   \   00000054   0x4628             MOV      R0,R5
   \   00000056   0x.... 0x....      BL       _ZN10CardReader9closefileEb
  15297                    SERIAL_PROTOCOLLNPGM(MSG_FILE_SAVED);
   \   0000005A   0x.... 0x....      ADR.W    R0,`?<Constant "Done saving file.\\n">`
   \   0000005E   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15298          
  15299                    #if ENABLED(SERIAL_STATS_DROPPED_RX)
  15300                      SERIAL_ECHOLNPAIR("Dropped bytes: ", customizedSerial.dropped());
  15301                    #endif
  15302          
  15303                    #if ENABLED(SERIAL_STATS_MAX_RX_QUEUED)
  15304                      SERIAL_ECHOLNPAIR("Max RX Queue Size: ", customizedSerial.rxMaxEnqueued());
  15305                    #endif
  15306          
  15307                    ok_to_send();
   \   00000062   0x.... 0x....      BL       _Z10ok_to_sendv
   \   00000066   0xE00F             B.N      ??loop_4
  15308                  }
  15309                  else {
  15310                    // Write the string from the read buffer to SD
  15311                    card.write_command(command);
   \                     ??loop_3: (+1)
   \   00000068   0x4631             MOV      R1,R6
   \   0000006A   0x4628             MOV      R0,R5
   \   0000006C   0x.... 0x....      BL       _ZN10CardReader13write_commandEPc
  15312                    if (card.logging)
   \   00000070   0xF895 0x09BA      LDRB     R0,[R5, #+2490]
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD002             BEQ.N    ??loop_5
  15313                      process_next_command(); // The card is saving because it's logging
   \   00000078   0x.... 0x....      BL       _Z20process_next_commandv
   \   0000007C   0xE004             B.N      ??loop_4
  15314                    else
  15315                      ok_to_send();
   \                     ??loop_5: (+1)
   \   0000007E   0x.... 0x....      BL       _Z10ok_to_sendv
   \   00000082   0xE001             B.N      ??loop_4
  15316                  }
  15317                }
  15318                else
  15319                  process_next_command();
   \                     ??loop_2: (+1)
   \   00000084   0x.... 0x....      BL       _Z20process_next_commandv
  15320          
  15321              #else
  15322          
  15323                process_next_command();
  15324          
  15325              #endif // SDSUPPORT
  15326          
  15327              // The queue may be reset by a command handler or by code invoked by idle() within a handler
  15328              if (commands_in_queue) {
   \                     ??loop_4: (+1)
   \   00000088   0x7C20             LDRB     R0,[R4, #+16]
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xD009             BEQ.N    ??loop_1
  15329                --commands_in_queue;
   \   0000008E   0x1E40             SUBS     R0,R0,#+1
   \   00000090   0x7420             STRB     R0,[R4, #+16]
  15330                if (++cmd_queue_index_r >= BUFSIZE) cmd_queue_index_r = 0;
   \   00000092   0x7C60             LDRB     R0,[R4, #+17]
   \   00000094   0x1C40             ADDS     R0,R0,#+1
   \   00000096   0x7460             STRB     R0,[R4, #+17]
   \   00000098   0xB2C0             UXTB     R0,R0
   \   0000009A   0x2804             CMP      R0,#+4
   \   0000009C   0xDB01             BLT.N    ??loop_1
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x7460             STRB     R0,[R4, #+17]
  15331              }
  15332            }
  15333            endstops.report_state();
   \                     ??loop_1: (+1)
   \   000000A2   0x.... 0x....      BL       _ZN8Endstops12report_stateEv
  15334            idle();
   \   000000A6   0x.... 0x....      BL       _Z4idlev
  15335          
  15336            
  15337            mks_PrintStatePolling();
   \   000000AA   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   000000AE   0x.... 0x....      B.W      mks_PrintStatePolling
  15338          }

   \                                 In section .bss, align 4
   \                     printing_rate_update_flag:
   \   00000000                      DS8 1
  15339          #if 1
  15340          uint16_t z_high_count;
  15341          
  15342          extern uint8_t poweroff_det_flg;
  15343          extern uint32_t poweroff_det_cnt;
  15344          extern uint8_t poweroff_det_low_flg;
  15345          extern uint32_t poweroff_det_low_cnt;
  15346          extern uint8_t poweroff_det_high_flg;
  15347          extern uint32_t poweroff_det_high_cnt;
  15348          
  15349          extern uint8_t filament_det1_flg;
  15350          extern uint32_t filament_det1_cnt;
  15351          extern uint8_t filament_det1_low_flg;
  15352          extern uint32_t filament_det1_low_cnt;
  15353          extern uint8_t filament_det1_high_flg;
  15354          extern uint32_t filament_det1_high_cnt;
  15355          extern uint8_t filament_det1_check;
  15356          
  15357          extern uint8_t filament_det2_flg;
  15358          extern uint32_t filament_det2_cnt;
  15359          extern uint8_t filament_det2_low_flg;
  15360          extern uint32_t filament_det2_low_cnt;
  15361          extern uint8_t filament_det2_high_flg;
  15362          extern uint32_t filament_det2_high_cnt;
  15363          extern uint8_t filament_det2_check;
  15364          
  15365          uint32_t wifi_loop_cycle = 500;
  15366          extern char wifi_check_time;
  15367          uint8_t wifi_init_flg = 0;
   \                     wifi_init_flg:
   \   00000001                      DS8 1
  15368          uint8_t wifi_init_state = 0;
  15369          uint8_t wifi_refresh_flg = 0, cloud_refresh_flg = 0;
   \                     wifi_refresh_flg:
   \   00000002                      DS8 1
   \                     cloud_refresh_flg:
   \   00000003                      DS8 1
  15370          uint8_t waiting_wifi_time = 0;
   \                     waiting_wifi_time:
   \   00000004                      DS8 1
  15371          
  15372          uint8_t btn_flg;
   \                     btn_flg:
   \   00000005                      DS8 1
   \                     z_high_count:
   \   00000006                      DS8 2
   \   00000008                      DS8 4
   \                     TimeIncrease:
   \   0000000C                      DS8 4
  15373          uint32_t btn_beep_cnt;
   \                     btn_beep_cnt:
   \   00000010                      DS8 4

   \                                 In section .bss, align 1
   \                     preview_no_display:
   \   00000000                      DS8 1
  15374          
  15375          extern void mksBeeperAlarm(void);
  15376          
  15377          extern uint8_t clean_time_flg;
  15378          extern uint8_t time_1s_flg;
  15379          
  15380          #if defined(__cplusplus)
  15381          extern "C" {     /* Make sure we have C-declarations in C++ programs */
  15382          #endif

   \                                 In section .text, align 2, keep-with-next
  15383          void btn_beeper(uint32_t beeper)
  15384          {
  15385              btn_flg = 1;
   \                     btn_beeper: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable141
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x714A             STRB     R2,[R1, #+5]
  15386              btn_beep_cnt = beeper;
   \   00000008   0x6108             STR      R0,[R1, #+16]
  15387              BEEPER_OP=1;
   \   0000000A   0x4610             MOV      R0,R2
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable143_1  ;; 0x424082b4
   \   00000010   0x6008             STR      R0,[R1, #+0]
  15388          }
   \   00000012   0x4770             BX       LR               ;; return
  15389          #if defined(__cplusplus)
  15390          }     /* Make sure we have C-declarations in C++ programs */
  15391          #endif
  15392          

   \                                 In section .text, align 2, keep-with-next
  15393          void SysTick_Handler_User()
  15394          {
   \                     _Z20SysTick_Handler_Userv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
  15395          		TimeIncrease++;
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable141
   \   00000006   0x68E0             LDR      R0,[R4, #+12]
   \   00000008   0x1C40             ADDS     R0,R0,#+1
   \   0000000A   0x60E0             STR      R0,[R4, #+12]
  15396          
  15397                  if(clean_time_flg==1)
   \   0000000C   0xF44F 0x707A      MOV      R0,#+1000
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable142_3
   \   00000014   0x780A             LDRB     R2,[R1, #+0]
   \   00000016   0x2A01             CMP      R2,#+1
   \   00000018   0xD118             BNE.N    ??SysTick_Handler_User_0
  15398                  {
  15399              		if(!(TimeIncrease * TICK_CYCLE % 1000))	// 1s
   \   0000001A   0x68E2             LDR      R2,[R4, #+12]
   \   0000001C   0x4603             MOV      R3,R0
   \   0000001E   0xFBB2 0xF3F3      UDIV     R3,R2,R3
   \   00000022   0xFB00 0x2213      MLS      R2,R0,R3,R2
   \   00000026   0x2A00             CMP      R2,#+0
   \   00000028   0xD110             BNE.N    ??SysTick_Handler_User_0
  15400              		{		
  15401              			time_1s_flg = 1;
   \   0000002A   0x2201             MOVS     R2,#+1
   \   0000002C   0x.... 0x....      LDR.W    R3,??DataTable142_4
   \   00000030   0x701A             STRB     R2,[R3, #+0]
  15402                          gCfgItems.clean_time_bak--;
   \   00000032   0x.... 0x....      LDR.W    R2,??DataTable138
   \   00000036   0xF8B2 0x327C      LDRH     R3,[R2, #+636]
   \   0000003A   0x1E5B             SUBS     R3,R3,#+1
   \   0000003C   0xF8A2 0x327C      STRH     R3,[R2, #+636]
  15403                          if(gCfgItems.clean_time_bak == 0)
   \   00000040   0xF8B2 0x227C      LDRH     R2,[R2, #+636]
   \   00000044   0x2A00             CMP      R2,#+0
   \   00000046   0xD101             BNE.N    ??SysTick_Handler_User_0
  15404                             clean_time_flg = 0; 
   \   00000048   0x2200             MOVS     R2,#+0
   \   0000004A   0x700A             STRB     R2,[R1, #+0]
  15405              		}            
  15406                  }
  15407          	
  15408          		temperature_change_frequency_cnt++;
   \                     ??SysTick_Handler_User_0: (+1)
   \   0000004C   0x68A1             LDR      R1,[R4, #+8]
   \   0000004E   0x1C49             ADDS     R1,R1,#+1
   \   00000050   0x60A1             STR      R1,[R4, #+8]
  15409          		if((temperature_change_frequency_cnt>=2000)&&(temperature_change_frequency!=1))
   \   00000052   0xF5B1 0x6FFA      CMP      R1,#+2000
   \   00000056   0xD308             BCC.N    ??SysTick_Handler_User_1
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable142_5
   \   0000005C   0x780A             LDRB     R2,[R1, #+0]
   \   0000005E   0x2A01             CMP      R2,#+1
   \   00000060   0xD003             BEQ.N    ??SysTick_Handler_User_1
  15410          		{
  15411          			temperature_change_frequency_cnt = 0;
   \   00000062   0x2200             MOVS     R2,#+0
   \   00000064   0x60A2             STR      R2,[R4, #+8]
  15412          			temperature_change_frequency = 1;
   \   00000066   0x2201             MOVS     R2,#+1
   \   00000068   0x700A             STRB     R2,[R1, #+0]
  15413          		}
  15414          		
  15415          		if(!(TimeIncrease * TICK_CYCLE % 3000))	// 3s
   \                     ??SysTick_Handler_User_1: (+1)
   \   0000006A   0x68E1             LDR      R1,[R4, #+12]
   \   0000006C   0xF640 0x32B8      MOVW     R2,#+3000
   \   00000070   0xFBB1 0xF2F2      UDIV     R2,R1,R2
   \   00000074   0xF640 0x33B8      MOVW     R3,#+3000
   \   00000078   0xFB03 0x1112      MLS      R1,R3,R2,R1
   \   0000007C   0x2900             CMP      R1,#+0
   \   0000007E   0xD101             BNE.N    ??SysTick_Handler_User_2
  15416          		{		
  15417          			printing_rate_update_flag = 1;
   \   00000080   0x2101             MOVS     R1,#+1
   \   00000082   0x7021             STRB     R1,[R4, #+0]
  15418          		}	
  15419          
  15420          		if((TimeIncrease * TICK_CYCLE % 1000) == 0) 
   \                     ??SysTick_Handler_User_2: (+1)
   \   00000084   0x68E1             LDR      R1,[R4, #+12]
   \   00000086   0x4602             MOV      R2,R0
   \   00000088   0xFBB1 0xF2F2      UDIV     R2,R1,R2
   \   0000008C   0xFB00 0x1112      MLS      R1,R0,R2,R1
   \   00000090   0x2900             CMP      R1,#+0
   \   00000092   0xD108             BNE.N    ??SysTick_Handler_User_3
  15421          		{		
  15422          			if(print_time.start == 1)
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable142_6
   \   00000098   0xF991 0x2007      LDRSB    R2,[R1, #+7]
   \   0000009C   0x2A01             CMP      R2,#+1
   \   0000009E   0xD102             BNE.N    ??SysTick_Handler_User_3
  15423          			{
  15424          				print_time.seconds++;
   \   000000A0   0x794A             LDRB     R2,[R1, #+5]
   \   000000A2   0x1C52             ADDS     R2,R2,#+1
   \   000000A4   0x714A             STRB     R2,[R1, #+5]
  15425          			}
  15426          		}
  15427          		if((TimeIncrease * TICK_CYCLE % 1000) == 0)
   \                     ??SysTick_Handler_User_3: (+1)
   \   000000A6   0x68E1             LDR      R1,[R4, #+12]
   \   000000A8   0x4602             MOV      R2,R0
   \   000000AA   0xFBB1 0xF2F2      UDIV     R2,R1,R2
   \   000000AE   0xFB00 0x1012      MLS      R0,R0,R2,R1
   \   000000B2   0x2800             CMP      R0,#+0
   \   000000B4   0xD101             BNE.N    ??SysTick_Handler_User_4
  15428          		{
  15429          			z_high_count=1;
   \   000000B6   0x2001             MOVS     R0,#+1
   \   000000B8   0x80E0             STRH     R0,[R4, #+6]
  15430          		}
  15431          
  15432          	if(poweroff_det_flg==1)
   \                     ??SysTick_Handler_User_4: (+1)
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable142_7
   \   000000BE   0x7800             LDRB     R0,[R0, #+0]
   \   000000C0   0x2801             CMP      R0,#+1
   \   000000C2   0xD104             BNE.N    ??SysTick_Handler_User_5
  15433          	{
  15434          		poweroff_det_cnt++;
   \   000000C4   0x.... 0x....      LDR.W    R0,??DataTable142_8
   \   000000C8   0x6801             LDR      R1,[R0, #+0]
   \   000000CA   0x1C49             ADDS     R1,R1,#+1
   \   000000CC   0x6001             STR      R1,[R0, #+0]
  15435          	}
  15436          		
  15437          	if(filament_det1_flg==1)
   \                     ??SysTick_Handler_User_5: (+1)
   \   000000CE   0x.... 0x....      LDR.W    R0,??DataTable142_9
   \   000000D2   0x7800             LDRB     R0,[R0, #+0]
   \   000000D4   0x2801             CMP      R0,#+1
   \   000000D6   0xD104             BNE.N    ??SysTick_Handler_User_6
  15438          	{
  15439          		filament_det1_cnt++;
   \   000000D8   0x.... 0x....      LDR.W    R0,??DataTable142_10
   \   000000DC   0x6801             LDR      R1,[R0, #+0]
   \   000000DE   0x1C49             ADDS     R1,R1,#+1
   \   000000E0   0x6001             STR      R1,[R0, #+0]
  15440          	}
  15441          
  15442          	if(filament_det1_low_flg==1)
   \                     ??SysTick_Handler_User_6: (+1)
   \   000000E2   0x.... 0x....      LDR.W    R0,??DataTable143_2
   \   000000E6   0x7800             LDRB     R0,[R0, #+0]
   \   000000E8   0x2801             CMP      R0,#+1
   \   000000EA   0xD104             BNE.N    ??SysTick_Handler_User_7
  15443          	{
  15444          		filament_det1_low_cnt++;
   \   000000EC   0x.... 0x....      LDR.W    R0,??DataTable143_3
   \   000000F0   0x6801             LDR      R1,[R0, #+0]
   \   000000F2   0x1C49             ADDS     R1,R1,#+1
   \   000000F4   0x6001             STR      R1,[R0, #+0]
  15445          	}
  15446          
  15447          	if(filament_det1_high_flg==1)
   \                     ??SysTick_Handler_User_7: (+1)
   \   000000F6   0x.... 0x....      LDR.W    R0,??DataTable143_4
   \   000000FA   0x7800             LDRB     R0,[R0, #+0]
   \   000000FC   0x2801             CMP      R0,#+1
   \   000000FE   0xD104             BNE.N    ??SysTick_Handler_User_8
  15448          	{
  15449          		filament_det1_high_cnt++;
   \   00000100   0x.... 0x....      LDR.W    R0,??DataTable143_5
   \   00000104   0x6801             LDR      R1,[R0, #+0]
   \   00000106   0x1C49             ADDS     R1,R1,#+1
   \   00000108   0x6001             STR      R1,[R0, #+0]
  15450          	}
  15451          	if(filament_det2_flg==1)
   \                     ??SysTick_Handler_User_8: (+1)
   \   0000010A   0x.... 0x....      LDR.W    R0,??DataTable143_6
   \   0000010E   0x7800             LDRB     R0,[R0, #+0]
   \   00000110   0x2801             CMP      R0,#+1
   \   00000112   0xD104             BNE.N    ??SysTick_Handler_User_9
  15452          	{
  15453          		filament_det2_cnt++;
   \   00000114   0x.... 0x....      LDR.W    R0,??DataTable143_7
   \   00000118   0x6801             LDR      R1,[R0, #+0]
   \   0000011A   0x1C49             ADDS     R1,R1,#+1
   \   0000011C   0x6001             STR      R1,[R0, #+0]
  15454          	}
  15455          
  15456          	if(filament_det2_low_flg==1)
   \                     ??SysTick_Handler_User_9: (+1)
   \   0000011E   0x.... 0x....      LDR.W    R0,??DataTable143_8
   \   00000122   0x7800             LDRB     R0,[R0, #+0]
   \   00000124   0x2801             CMP      R0,#+1
   \   00000126   0xD104             BNE.N    ??SysTick_Handler_User_10
  15457          	{
  15458          		filament_det2_low_cnt++;
   \   00000128   0x.... 0x....      LDR.W    R0,??DataTable143_9
   \   0000012C   0x6801             LDR      R1,[R0, #+0]
   \   0000012E   0x1C49             ADDS     R1,R1,#+1
   \   00000130   0x6001             STR      R1,[R0, #+0]
  15459          	}
  15460          
  15461          	if(filament_det2_high_flg==1)
   \                     ??SysTick_Handler_User_10: (+1)
   \   00000132   0x.... 0x....      LDR.W    R0,??DataTable143_10
   \   00000136   0x7800             LDRB     R0,[R0, #+0]
   \   00000138   0x2801             CMP      R0,#+1
   \   0000013A   0xD104             BNE.N    ??SysTick_Handler_User_11
  15462          	{
  15463          		filament_det2_high_cnt++;
   \   0000013C   0x.... 0x....      LDR.W    R0,??DataTable143_11
   \   00000140   0x6801             LDR      R1,[R0, #+0]
   \   00000142   0x1C49             ADDS     R1,R1,#+1
   \   00000144   0x6001             STR      R1,[R0, #+0]
  15464          	}
  15465          
  15466          	if(poweroff_det_low_flg==1)
   \                     ??SysTick_Handler_User_11: (+1)
   \   00000146   0x.... 0x....      LDR.W    R0,??DataTable143_12
   \   0000014A   0x7800             LDRB     R0,[R0, #+0]
   \   0000014C   0x2801             CMP      R0,#+1
   \   0000014E   0xD104             BNE.N    ??SysTick_Handler_User_12
  15467          	{
  15468          		poweroff_det_low_cnt++;
   \   00000150   0x.... 0x....      LDR.W    R0,??DataTable143_13
   \   00000154   0x6801             LDR      R1,[R0, #+0]
   \   00000156   0x1C49             ADDS     R1,R1,#+1
   \   00000158   0x6001             STR      R1,[R0, #+0]
  15469          	}
  15470          	
  15471          	if(poweroff_det_high_flg==1)
   \                     ??SysTick_Handler_User_12: (+1)
   \   0000015A   0x.... 0x....      LDR.W    R0,??DataTable143_14
   \   0000015E   0x7800             LDRB     R0,[R0, #+0]
   \   00000160   0x2801             CMP      R0,#+1
   \   00000162   0xD104             BNE.N    ??SysTick_Handler_User_13
  15472          	{
  15473          		poweroff_det_high_cnt++;
   \   00000164   0x.... 0x....      LDR.W    R0,??DataTable143_15
   \   00000168   0x6801             LDR      R1,[R0, #+0]
   \   0000016A   0x1C49             ADDS     R1,R1,#+1
   \   0000016C   0x6001             STR      R1,[R0, #+0]
  15474          	}		
  15475          
  15476          	if(!(TimeIncrease * TICK_CYCLE % 5000))	//5s
   \                     ??SysTick_Handler_User_13: (+1)
   \   0000016E   0x68E0             LDR      R0,[R4, #+12]
   \   00000170   0xF241 0x3188      MOVW     R1,#+5000
   \   00000174   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   00000178   0xF241 0x3288      MOVW     R2,#+5000
   \   0000017C   0xFB02 0x0011      MLS      R0,R2,R1,R0
   \   00000180   0x2800             CMP      R0,#+0
   \   00000182   0xD11E             BNE.N    ??SysTick_Handler_User_14
  15477          	{
  15478          		wifi_check_time = 1;
   \   00000184   0x2001             MOVS     R0,#+1
   \   00000186   0x.... 0x....      LDR.W    R1,??DataTable144_1
   \   0000018A   0x7008             STRB     R0,[R1, #+0]
  15479          		waiting_wifi_time ++;
   \   0000018C   0x7920             LDRB     R0,[R4, #+4]
   \   0000018E   0x1C40             ADDS     R0,R0,#+1
   \   00000190   0x7120             STRB     R0,[R4, #+4]
  15480          		if((waiting_wifi_time == 8) || (gCfgItems.wifi_type == ESP_WIFI))//40s
   \   00000192   0xB2C0             UXTB     R0,R0
   \   00000194   0x2808             CMP      R0,#+8
   \   00000196   0xD005             BEQ.N    ??SysTick_Handler_User_15
   \   00000198   0x.... 0x....      LDR.W    R0,??DataTable138
   \   0000019C   0xF890 0x0208      LDRB     R0,[R0, #+520]
   \   000001A0   0x2802             CMP      R0,#+2
   \   000001A2   0xD104             BNE.N    ??SysTick_Handler_User_16
  15481          		{
  15482          			if(wifi_init_flg == 0)
   \                     ??SysTick_Handler_User_15: (+1)
   \   000001A4   0x7860             LDRB     R0,[R4, #+1]
   \   000001A6   0x2800             CMP      R0,#+0
   \   000001A8   0xD101             BNE.N    ??SysTick_Handler_User_16
  15483          			{
  15484          				wifi_init_flg = 1;
   \   000001AA   0x2001             MOVS     R0,#+1
   \   000001AC   0x7060             STRB     R0,[R4, #+1]
  15485          			}
  15486          			
  15487          		}
  15488          		if(wifi_refresh_flg == 0)
   \                     ??SysTick_Handler_User_16: (+1)
   \   000001AE   0x78A0             LDRB     R0,[R4, #+2]
   \   000001B0   0x2800             CMP      R0,#+0
   \   000001B2   0xD101             BNE.N    ??SysTick_Handler_User_17
  15489          			wifi_refresh_flg = 1;
   \   000001B4   0x2001             MOVS     R0,#+1
   \   000001B6   0x70A0             STRB     R0,[R4, #+2]
  15490          		
  15491          		if(cloud_refresh_flg == 0)
   \                     ??SysTick_Handler_User_17: (+1)
   \   000001B8   0x78E0             LDRB     R0,[R4, #+3]
   \   000001BA   0x2800             CMP      R0,#+0
   \   000001BC   0xD101             BNE.N    ??SysTick_Handler_User_14
  15492          			cloud_refresh_flg = 1;
   \   000001BE   0x2001             MOVS     R0,#+1
   \   000001C0   0x70E0             STRB     R0,[R4, #+3]
  15493          
  15494          	}
  15495          	
  15496          
  15497          	mksBeeperAlarm();
   \                     ??SysTick_Handler_User_14: (+1)
   \   000001C2   0x.... 0x....      BL       _Z14mksBeeperAlarmv
  15498          
  15499              if(btn_flg==1)
   \   000001C6   0x7960             LDRB     R0,[R4, #+5]
   \   000001C8   0x2801             CMP      R0,#+1
   \   000001CA   0xD107             BNE.N    ??SysTick_Handler_User_18
  15500              {
  15501                  btn_beep_cnt--;
   \   000001CC   0x6920             LDR      R0,[R4, #+16]
   \   000001CE   0x1E40             SUBS     R0,R0,#+1
   \   000001D0   0x6120             STR      R0,[R4, #+16]
  15502                  if(btn_beep_cnt==0)
   \   000001D2   0xD103             BNE.N    ??SysTick_Handler_User_18
  15503                  {
  15504                      btn_beep_cnt=0;
  15505                      BEEPER_OP=0;
   \   000001D4   0x2000             MOVS     R0,#+0
   \   000001D6   0x.... 0x....      LDR.W    R1,??DataTable143_1  ;; 0x424082b4
   \   000001DA   0x6008             STR      R0,[R1, #+0]
  15506                  }
  15507              }
  15508          }
   \                     ??SysTick_Handler_User_18: (+1)
   \   000001DC   0xBD10             POP      {R4,PC}          ;; return
  15509          #endif
  15510          
  15511          #include "mks_reprint.cpp"

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mkstft_ui_load()
   \                     mkstft_ui_load: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable138
   \   00000006   0x2204             MOVS     R2,#+4
   \   00000008   0x1D21             ADDS     R1,R4,#+4
   \   0000000A   0xF240 0x50C7      MOVW     R0,#+1479
   \   0000000E   0x.... 0x....      BL       epr_read_data
   \   00000012   0x2204             MOVS     R2,#+4
   \   00000014   0xF104 0x0108      ADD      R1,R4,#+8
   \   00000018   0xF240 0x50DF      MOVW     R0,#+1503
   \   0000001C   0x.... 0x....      BL       epr_read_data
   \   00000020   0x2204             MOVS     R2,#+4
   \   00000022   0xF104 0x010C      ADD      R1,R4,#+12
   \   00000026   0xF240 0x603B      MOVW     R0,#+1595
   \   0000002A   0x.... 0x....      BL       epr_read_data
   \   0000002E   0x2204             MOVS     R2,#+4
   \   00000030   0xF104 0x0110      ADD      R1,R4,#+16
   \   00000034   0xF240 0x50E3      MOVW     R0,#+1507
   \   00000038   0x.... 0x....      BL       epr_read_data
   \   0000003C   0x2204             MOVS     R2,#+4
   \   0000003E   0xF104 0x0168      ADD      R1,R4,#+104
   \   00000042   0xF240 0x50D7      MOVW     R0,#+1495
   \   00000046   0x.... 0x....      BL       epr_read_data
   \   0000004A   0x2204             MOVS     R2,#+4
   \   0000004C   0xF104 0x0164      ADD      R1,R4,#+100
   \   00000050   0xF240 0x50DB      MOVW     R0,#+1499
   \   00000054   0x.... 0x....      BL       epr_read_data
   \   00000058   0x2204             MOVS     R2,#+4
   \   0000005A   0xF104 0x0114      ADD      R1,R4,#+20
   \   0000005E   0xF240 0x603F      MOVW     R0,#+1599
   \   00000062   0x.... 0x....      BL       epr_read_data
   \   00000066   0x2204             MOVS     R2,#+4
   \   00000068   0xF104 0x0118      ADD      R1,R4,#+24
   \   0000006C   0xF240 0x6043      MOVW     R0,#+1603
   \   00000070   0x.... 0x....      BL       epr_read_data
   \   00000074   0x2204             MOVS     R2,#+4
   \   00000076   0xF104 0x011C      ADD      R1,R4,#+28
   \   0000007A   0xF240 0x6047      MOVW     R0,#+1607
   \   0000007E   0x.... 0x....      BL       epr_read_data
   \   00000082   0x2204             MOVS     R2,#+4
   \   00000084   0xF104 0x0120      ADD      R1,R4,#+32
   \   00000088   0xF240 0x50F7      MOVW     R0,#+1527
   \   0000008C   0x.... 0x....      BL       epr_read_data
   \   00000090   0x2204             MOVS     R2,#+4
   \   00000092   0xF104 0x0124      ADD      R1,R4,#+36
   \   00000096   0xF240 0x604B      MOVW     R0,#+1611
   \   0000009A   0x.... 0x....      BL       epr_read_data
   \   0000009E   0x2204             MOVS     R2,#+4
   \   000000A0   0xF104 0x0128      ADD      R1,R4,#+40
   \   000000A4   0xF240 0x50FB      MOVW     R0,#+1531
   \   000000A8   0x.... 0x....      BL       epr_read_data
   \   000000AC   0x2204             MOVS     R2,#+4
   \   000000AE   0xF104 0x013C      ADD      R1,R4,#+60
   \   000000B2   0xF240 0x604F      MOVW     R0,#+1615
   \   000000B6   0x.... 0x....      BL       epr_read_data
   \   000000BA   0x2204             MOVS     R2,#+4
   \   000000BC   0xF104 0x0140      ADD      R1,R4,#+64
   \   000000C0   0xF240 0x6053      MOVW     R0,#+1619
   \   000000C4   0x.... 0x....      BL       epr_read_data
   \   000000C8   0x2204             MOVS     R2,#+4
   \   000000CA   0xF104 0x0144      ADD      R1,R4,#+68
   \   000000CE   0xF240 0x50FF      MOVW     R0,#+1535
   \   000000D2   0x.... 0x....      BL       epr_read_data
   \   000000D6   0x2204             MOVS     R2,#+4
   \   000000D8   0xF104 0x0148      ADD      R1,R4,#+72
   \   000000DC   0xF240 0x6003      MOVW     R0,#+1539
   \   000000E0   0x.... 0x....      BL       epr_read_data
   \   000000E4   0x2204             MOVS     R2,#+4
   \   000000E6   0xF104 0x014C      ADD      R1,R4,#+76
   \   000000EA   0xF240 0x6057      MOVW     R0,#+1623
   \   000000EE   0x.... 0x....      BL       epr_write_data
   \   000000F2   0x2204             MOVS     R2,#+4
   \   000000F4   0xF104 0x0150      ADD      R1,R4,#+80
   \   000000F8   0xF240 0x605B      MOVW     R0,#+1627
   \   000000FC   0x.... 0x....      BL       epr_write_data
   \   00000100   0x2204             MOVS     R2,#+4
   \   00000102   0xF104 0x0154      ADD      R1,R4,#+84
   \   00000106   0xF240 0x605F      MOVW     R0,#+1631
   \   0000010A   0x.... 0x....      BL       epr_write_data
   \   0000010E   0x2201             MOVS     R2,#+1
   \   00000110   0xF204 0x119B      ADDW     R1,R4,#+411
   \   00000114   0xF240 0x6007      MOVW     R0,#+1543
   \   00000118   0x.... 0x....      BL       epr_read_data
   \   0000011C   0x2201             MOVS     R2,#+1
   \   0000011E   0xF104 0x01D8      ADD      R1,R4,#+216
   \   00000122   0xF44F 0x60C1      MOV      R0,#+1544
   \   00000126   0x.... 0x....      BL       epr_read_data
   \   0000012A   0xF994 0x00D8      LDRSB    R0,[R4, #+216]
   \   0000012E   0x2801             CMP      R0,#+1
   \   00000130   0xD01A             BEQ.N    ??mkstft_ui_load_0
   \   00000132   0xF994 0x00D8      LDRSB    R0,[R4, #+216]
   \   00000136   0x2802             CMP      R0,#+2
   \   00000138   0xD016             BEQ.N    ??mkstft_ui_load_0
   \   0000013A   0xF994 0x00D8      LDRSB    R0,[R4, #+216]
   \   0000013E   0x2803             CMP      R0,#+3
   \   00000140   0xD012             BEQ.N    ??mkstft_ui_load_0
   \   00000142   0xF994 0x00D8      LDRSB    R0,[R4, #+216]
   \   00000146   0x2806             CMP      R0,#+6
   \   00000148   0xD00E             BEQ.N    ??mkstft_ui_load_0
   \   0000014A   0xF994 0x00D8      LDRSB    R0,[R4, #+216]
   \   0000014E   0x2807             CMP      R0,#+7
   \   00000150   0xD00A             BEQ.N    ??mkstft_ui_load_0
   \   00000152   0xF994 0x00D8      LDRSB    R0,[R4, #+216]
   \   00000156   0x280A             CMP      R0,#+10
   \   00000158   0xD006             BEQ.N    ??mkstft_ui_load_0
   \   0000015A   0xF994 0x00D8      LDRSB    R0,[R4, #+216]
   \   0000015E   0x280C             CMP      R0,#+12
   \   00000160   0xD002             BEQ.N    ??mkstft_ui_load_0
   \   00000162   0x2003             MOVS     R0,#+3
   \   00000164   0xF884 0x00D8      STRB     R0,[R4, #+216]
   \                     ??mkstft_ui_load_0: (+1)
   \   00000168   0x2201             MOVS     R2,#+1
   \   0000016A   0xF204 0x217E      ADDW     R1,R4,#+638
   \   0000016E   0xF240 0x6067      MOVW     R0,#+1639
   \   00000172   0xE8BD 0x4010      POP      {R4,LR}
   \   00000176   0x.... 0x....      B.W      epr_read_data

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mkstft_ui_set_epr()
   \                     _Z17mkstft_ui_set_eprv: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0xF240 0x54AA      MOVW     R4,#+1450
   \   00000008   0x2204             MOVS     R2,#+4
   \   0000000A   0xA900             ADD      R1,SP,#+0
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       epr_read_data
   \   00000012   0x.... 0x....      LDR.W    R5,??DataTable147  ;; 0x76313030
   \   00000016   0x9800             LDR      R0,[SP, #+0]
   \   00000018   0x42A8             CMP      R0,R5
   \   0000001A   0xF000 0x80A1      BEQ.W    ??mkstft_ui_set_epr_0
   \   0000001E   0x.... 0x....      LDR.W    R6,??DataTable138
   \   00000022   0x2204             MOVS     R2,#+4
   \   00000024   0x1D31             ADDS     R1,R6,#+4
   \   00000026   0xF240 0x50C7      MOVW     R0,#+1479
   \   0000002A   0x.... 0x....      BL       epr_write_data
   \   0000002E   0x2204             MOVS     R2,#+4
   \   00000030   0xF106 0x0108      ADD      R1,R6,#+8
   \   00000034   0xF240 0x50DF      MOVW     R0,#+1503
   \   00000038   0x.... 0x....      BL       epr_write_data
   \   0000003C   0x2204             MOVS     R2,#+4
   \   0000003E   0xF106 0x0110      ADD      R1,R6,#+16
   \   00000042   0xF240 0x603B      MOVW     R0,#+1595
   \   00000046   0x.... 0x....      BL       epr_write_data
   \   0000004A   0x2204             MOVS     R2,#+4
   \   0000004C   0xF106 0x0110      ADD      R1,R6,#+16
   \   00000050   0xF240 0x50E3      MOVW     R0,#+1507
   \   00000054   0x.... 0x....      BL       epr_write_data
   \   00000058   0x2204             MOVS     R2,#+4
   \   0000005A   0xF106 0x0168      ADD      R1,R6,#+104
   \   0000005E   0xF240 0x50D7      MOVW     R0,#+1495
   \   00000062   0x.... 0x....      BL       epr_write_data
   \   00000066   0x2204             MOVS     R2,#+4
   \   00000068   0xF106 0x0164      ADD      R1,R6,#+100
   \   0000006C   0xF240 0x50DB      MOVW     R0,#+1499
   \   00000070   0x.... 0x....      BL       epr_write_data
   \   00000074   0x2204             MOVS     R2,#+4
   \   00000076   0xF106 0x0114      ADD      R1,R6,#+20
   \   0000007A   0xF240 0x603F      MOVW     R0,#+1599
   \   0000007E   0x.... 0x....      BL       epr_write_data
   \   00000082   0x2204             MOVS     R2,#+4
   \   00000084   0xF106 0x0118      ADD      R1,R6,#+24
   \   00000088   0xF240 0x6043      MOVW     R0,#+1603
   \   0000008C   0x.... 0x....      BL       epr_write_data
   \   00000090   0x2204             MOVS     R2,#+4
   \   00000092   0xF106 0x011C      ADD      R1,R6,#+28
   \   00000096   0xF240 0x6047      MOVW     R0,#+1607
   \   0000009A   0x.... 0x....      BL       epr_write_data
   \   0000009E   0x2204             MOVS     R2,#+4
   \   000000A0   0xF106 0x0120      ADD      R1,R6,#+32
   \   000000A4   0xF240 0x50F7      MOVW     R0,#+1527
   \   000000A8   0x.... 0x....      BL       epr_write_data
   \   000000AC   0x2204             MOVS     R2,#+4
   \   000000AE   0xF106 0x0124      ADD      R1,R6,#+36
   \   000000B2   0xF240 0x604B      MOVW     R0,#+1611
   \   000000B6   0x.... 0x....      BL       epr_write_data
   \   000000BA   0x2204             MOVS     R2,#+4
   \   000000BC   0xF106 0x0128      ADD      R1,R6,#+40
   \   000000C0   0xF240 0x50FB      MOVW     R0,#+1531
   \   000000C4   0x.... 0x....      BL       epr_write_data
   \   000000C8   0x2204             MOVS     R2,#+4
   \   000000CA   0xF106 0x013C      ADD      R1,R6,#+60
   \   000000CE   0xF240 0x604F      MOVW     R0,#+1615
   \   000000D2   0x.... 0x....      BL       epr_write_data
   \   000000D6   0x2204             MOVS     R2,#+4
   \   000000D8   0xF106 0x0140      ADD      R1,R6,#+64
   \   000000DC   0xF240 0x6053      MOVW     R0,#+1619
   \   000000E0   0x.... 0x....      BL       epr_write_data
   \   000000E4   0x2204             MOVS     R2,#+4
   \   000000E6   0xF106 0x0144      ADD      R1,R6,#+68
   \   000000EA   0xF240 0x50FF      MOVW     R0,#+1535
   \   000000EE   0x.... 0x....      BL       epr_write_data
   \   000000F2   0x2204             MOVS     R2,#+4
   \   000000F4   0xF106 0x0148      ADD      R1,R6,#+72
   \   000000F8   0xF240 0x6003      MOVW     R0,#+1539
   \   000000FC   0x.... 0x....      BL       epr_write_data
   \   00000100   0x2204             MOVS     R2,#+4
   \   00000102   0xF106 0x014C      ADD      R1,R6,#+76
   \   00000106   0xF240 0x6057      MOVW     R0,#+1623
   \   0000010A   0x.... 0x....      BL       epr_write_data
   \   0000010E   0x2204             MOVS     R2,#+4
   \   00000110   0xF106 0x0150      ADD      R1,R6,#+80
   \   00000114   0xF240 0x605B      MOVW     R0,#+1627
   \   00000118   0x.... 0x....      BL       epr_write_data
   \   0000011C   0x2204             MOVS     R2,#+4
   \   0000011E   0xF106 0x0154      ADD      R1,R6,#+84
   \   00000122   0xF240 0x605F      MOVW     R0,#+1631
   \   00000126   0x.... 0x....      BL       epr_write_data
   \   0000012A   0x2201             MOVS     R2,#+1
   \   0000012C   0xF206 0x119B      ADDW     R1,R6,#+411
   \   00000130   0xF240 0x6007      MOVW     R0,#+1543
   \   00000134   0x.... 0x....      BL       epr_write_data
   \   00000138   0x2201             MOVS     R2,#+1
   \   0000013A   0xF106 0x01D8      ADD      R1,R6,#+216
   \   0000013E   0xF44F 0x60C1      MOV      R0,#+1544
   \   00000142   0x.... 0x....      BL       epr_write_data
   \   00000146   0x2201             MOVS     R2,#+1
   \   00000148   0xF206 0x217E      ADDW     R1,R6,#+638
   \   0000014C   0xF240 0x6067      MOVW     R0,#+1639
   \   00000150   0x.... 0x....      BL       epr_write_data
   \   00000154   0x9500             STR      R5,[SP, #+0]
   \   00000156   0x2204             MOVS     R2,#+4
   \   00000158   0xA900             ADD      R1,SP,#+0
   \   0000015A   0x4620             MOV      R0,R4
   \   0000015C   0x.... 0x....      BL       epr_write_data
   \                     ??mkstft_ui_set_epr_0: (+1)
   \   00000160   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mkstft_ui_init()
   \                     mkstft_ui_init: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable138
   \   00000008   0x1D20             ADDS     R0,R4,#+4
   \   0000000A   0xF06F 0x417F      MVN      R1,#-16777216
   \   0000000E   0x6541             STR      R1,[R0, #+84]
   \   00000010   0x6061             STR      R1,[R4, #+4]
   \   00000012   0x.... 0x....      LDR.W    R2,??DataTable150  ;; 0x8db937
   \   00000016   0x6042             STR      R2,[R0, #+4]
   \   00000018   0x2300             MOVS     R3,#+0
   \   0000001A   0x6083             STR      R3,[R0, #+8]
   \   0000001C   0x60C2             STR      R2,[R0, #+12]
   \   0000001E   0x6643             STR      R3,[R0, #+100]
   \   00000020   0x6601             STR      R1,[R0, #+96]
   \   00000022   0x6102             STR      R2,[R0, #+16]
   \   00000024   0x6141             STR      R1,[R0, #+20]
   \   00000026   0x6182             STR      R2,[R0, #+24]
   \   00000028   0x61C1             STR      R1,[R0, #+28]
   \   0000002A   0x6201             STR      R1,[R0, #+32]
   \   0000002C   0x.... 0x....      LDR.W    R3,??DataTable150_1  ;; 0x43cdff
   \   00000030   0x6243             STR      R3,[R0, #+36]
   \   00000032   0xF44F 0x437F      MOV      R3,#+65280
   \   00000036   0x6283             STR      R3,[R0, #+40]
   \   00000038   0x.... 0x....      LDR.W    R3,??DataTable150_2  ;; 0xaaaaaa
   \   0000003C   0x62C3             STR      R3,[R0, #+44]
   \   0000003E   0x2300             MOVS     R3,#+0
   \   00000040   0x6303             STR      R3,[R0, #+48]
   \   00000042   0x6343             STR      R3,[R0, #+52]
   \   00000044   0x6383             STR      R3,[R0, #+56]
   \   00000046   0x63C1             STR      R1,[R0, #+60]
   \   00000048   0xF44F 0x037F      MOV      R3,#+16711680
   \   0000004C   0x6403             STR      R3,[R0, #+64]
   \   0000004E   0x6441             STR      R1,[R0, #+68]
   \   00000050   0x6482             STR      R2,[R0, #+72]
   \   00000052   0x64C1             STR      R1,[R0, #+76]
   \   00000054   0x6502             STR      R2,[R0, #+80]
   \   00000056   0x2001             MOVS     R0,#+1
   \   00000058   0xF884 0x019B      STRB     R0,[R4, #+411]
   \   0000005C   0xF104 0x00BC      ADD      R0,R4,#+188
   \   00000060   0x2103             MOVS     R1,#+3
   \   00000062   0x7701             STRB     R1,[R0, #+28]
   \   00000064   0xF640 0x714F      MOVW     R1,#+3919
   \   00000068   0x6201             STR      R1,[R0, #+32]
   \   0000006A   0x21C9             MOVS     R1,#+201
   \   0000006C   0x6241             STR      R1,[R0, #+36]
   \   0000006E   0x21A4             MOVS     R1,#+164
   \   00000070   0x6281             STR      R1,[R0, #+40]
   \   00000072   0xF44F 0x616C      MOV      R1,#+3776
   \   00000076   0x62C1             STR      R1,[R0, #+44]
   \   00000078   0x2101             MOVS     R1,#+1
   \   0000007A   0x7781             STRB     R1,[R0, #+30]
   \   0000007C   0x2105             MOVS     R1,#+5
   \   0000007E   0x70C1             STRB     R1,[R0, #+3]
   \   00000080   0x2100             MOVS     R1,#+0
   \   00000082   0xF884 0x10BC      STRB     R1,[R4, #+188]
   \   00000086   0xF04F 0x517E      MOV      R1,#+1065353216
   \   0000008A   0x6181             STR      R1,[R0, #+24]
   \   0000008C   0xF640 0x31B8      MOVW     R1,#+3000
   \   00000090   0x8241             STRH     R1,[R0, #+18]
   \   00000092   0x2101             MOVS     R1,#+1
   \   00000094   0x7401             STRB     R1,[R0, #+16]
   \   00000096   0x2105             MOVS     R1,#+5
   \   00000098   0x73C1             STRB     R1,[R0, #+15]
   \   0000009A   0x7381             STRB     R1,[R0, #+14]
   \   0000009C   0x2164             MOVS     R1,#+100
   \   0000009E   0x8101             STRH     R1,[R0, #+8]
   \   000000A0   0x8141             STRH     R1,[R0, #+10]
   \   000000A2   0xF204 0x107B      ADDW     R0,R4,#+379
   \   000000A6   0x2100             MOVS     R1,#+0
   \   000000A8   0x7741             STRB     R1,[R0, #+29]
   \   000000AA   0xF884 0x10ED      STRB     R1,[R4, #+237]
   \   000000AE   0x7781             STRB     R1,[R0, #+30]
   \   000000B0   0x77C1             STRB     R1,[R0, #+31]
   \   000000B2   0x4608             MOV      R0,R1
   \   000000B4   0xF884 0x01A6      STRB     R0,[R4, #+422]
   \   000000B8   0xF204 0x05ED      ADDW     R5,R4,#+237
   \   000000BC   0x7328             STRB     R0,[R5, #+12]
   \   000000BE   0x2206             MOVS     R2,#+6
   \   000000C0   0x.... 0x....      ADR.W    R1,`?<Constant "0.000">`
   \   000000C4   0xF504 0x709E      ADD      R0,R4,#+316
   \   000000C8   0x.... 0x....      BL       __aeabi_memcpy
   \   000000CC   0x2001             MOVS     R0,#+1
   \   000000CE   0x76A8             STRB     R0,[R5, #+26]
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0x71E8             STRB     R0,[R5, #+7]
   \   000000D4   0x2001             MOVS     R0,#+1
   \   000000D6   0x7228             STRB     R0,[R5, #+8]
   \   000000D8   0xF884 0x0207      STRB     R0,[R4, #+519]
   \   000000DC   0x.... 0x....      LDR.W    R7,??DataTable151
   \   000000E0   0x226C             MOVS     R2,#+108
   \   000000E2   0x2100             MOVS     R1,#+0
   \   000000E4   0x4638             MOV      R0,R7
   \   000000E6   0x.... 0x....      BL       memset
   \   000000EA   0x.... 0x....      LDR.W    R5,??DataTable151_1
   \   000000EE   0x22A2             MOVS     R2,#+162
   \   000000F0   0x2100             MOVS     R1,#+0
   \   000000F2   0x4628             MOV      R0,R5
   \   000000F4   0x.... 0x....      BL       memset
   \   000000F8   0x260C             MOVS     R6,#+12
   \   000000FA   0x4632             MOV      R2,R6
   \   000000FC   0x.... 0x....      ADR.W    R1,`?<Constant "TP-LINK_MKS">`
   \   00000100   0x4638             MOV      R0,R7
   \   00000102   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000106   0x220A             MOVS     R2,#+10
   \   00000108   0x.... 0x....      ADR.W    R1,`?<Constant "makerbase">`
   \   0000010C   0xF107 0x0020      ADD      R0,R7,#+32
   \   00000110   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000114   0x.... 0x....      ADR.W    R7,`?<Constant "192.168.3.100">`
   \   00000118   0xF04F 0x080E      MOV      R8,#+14
   \   0000011C   0x4642             MOV      R2,R8
   \   0000011E   0x4639             MOV      R1,R7
   \   00000120   0x1C68             ADDS     R0,R5,#+1
   \   00000122   0x.... 0x....      BL       __aeabi_memcpy
   \   00000126   0x.... 0x....      ADR.W    R9,`?<Constant "255.255.255.0">`
   \   0000012A   0x4642             MOV      R2,R8
   \   0000012C   0x4649             MOV      R1,R9
   \   0000012E   0xF105 0x0011      ADD      R0,R5,#+17
   \   00000132   0x.... 0x....      BL       __aeabi_memcpy
   \   00000136   0x.... 0x....      ADR.W    R10,`?<Constant "192.168.3.1">`
   \   0000013A   0x4632             MOV      R2,R6
   \   0000013C   0x4651             MOV      R1,R10
   \   0000013E   0xF105 0x0021      ADD      R0,R5,#+33
   \   00000142   0x.... 0x....      BL       __aeabi_memcpy
   \   00000146   0x4632             MOV      R2,R6
   \   00000148   0x4651             MOV      R1,R10
   \   0000014A   0xF105 0x0031      ADD      R0,R5,#+49
   \   0000014E   0x.... 0x....      BL       __aeabi_memcpy
   \   00000152   0x2001             MOVS     R0,#+1
   \   00000154   0x7028             STRB     R0,[R5, #+0]
   \   00000156   0x4642             MOV      R2,R8
   \   00000158   0x4639             MOV      R1,R7
   \   0000015A   0xF105 0x0042      ADD      R0,R5,#+66
   \   0000015E   0x.... 0x....      BL       __aeabi_memcpy
   \   00000162   0x4642             MOV      R2,R8
   \   00000164   0x4649             MOV      R1,R9
   \   00000166   0xF105 0x0052      ADD      R0,R5,#+82
   \   0000016A   0x.... 0x....      BL       __aeabi_memcpy
   \   0000016E   0x4632             MOV      R2,R6
   \   00000170   0x4651             MOV      R1,R10
   \   00000172   0xF105 0x0062      ADD      R0,R5,#+98
   \   00000176   0x.... 0x....      BL       __aeabi_memcpy
   \   0000017A   0x4632             MOV      R2,R6
   \   0000017C   0x4651             MOV      R1,R10
   \   0000017E   0xF105 0x0072      ADD      R0,R5,#+114
   \   00000182   0x.... 0x....      BL       __aeabi_memcpy
   \   00000186   0x4632             MOV      R2,R6
   \   00000188   0x4651             MOV      R1,R10
   \   0000018A   0xF105 0x0082      ADD      R0,R5,#+130
   \   0000018E   0x.... 0x....      BL       __aeabi_memcpy
   \   00000192   0x4642             MOV      R2,R8
   \   00000194   0x.... 0x....      ADR.W    R1,`?<Constant "192.168.3.255">`
   \   00000198   0xF105 0x0092      ADD      R0,R5,#+146
   \   0000019C   0x.... 0x....      BL       __aeabi_memcpy
   \   000001A0   0x2001             MOVS     R0,#+1
   \   000001A2   0xF885 0x0041      STRB     R0,[R5, #+65]
   \   000001A6   0xF204 0x2507      ADDW     R5,R4,#+519
   \   000001AA   0x2002             MOVS     R0,#+2
   \   000001AC   0x7068             STRB     R0,[R5, #+1]
   \   000001AE   0x220F             MOVS     R2,#+15
   \   000001B0   0x.... 0x....      ADR.W    R1,`?<Constant "baizhongyun.cn">`
   \   000001B4   0xF204 0x200A      ADDW     R0,R4,#+522
   \   000001B8   0x.... 0x....      BL       __aeabi_memcpy
   \   000001BC   0xF242 0x7066      MOVW     R0,#+10086
   \   000001C0   0xF8C4 0x026C      STR      R0,[R4, #+620]
   \   000001C4   0x2001             MOVS     R0,#+1
   \   000001C6   0x70A8             STRB     R0,[R5, #+2]
   \   000001C8   0xF504 0x751B      ADD      R5,R4,#+620
   \   000001CC   0x2017             MOVS     R0,#+23
   \   000001CE   0x7128             STRB     R0,[R5, #+4]
   \   000001D0   0x2001             MOVS     R0,#+1
   \   000001D2   0x7168             STRB     R0,[R5, #+5]
   \   000001D4   0x2000             MOVS     R0,#+0
   \   000001D6   0xF884 0x017B      STRB     R0,[R4, #+379]
   \   000001DA   0xF884 0x0128      STRB     R0,[R4, #+296]
   \   000001DE   0x2064             MOVS     R0,#+100
   \   000001E0   0x81E8             STRH     R0,[R5, #+14]
   \   000001E2   0x2000             MOVS     R0,#+0
   \   000001E4   0x74A8             STRB     R0,[R5, #+18]
   \   000001E6   0x.... 0x....      BL       _Z17mkstft_ui_set_eprv
   \   000001EA   0x2000             MOVS     R0,#+0
   \   000001EC   0x.... 0x....      LDR.W    R1,??DataTable152
   \   000001F0   0x7008             STRB     R0,[R1, #+0]
   \   000001F2   0x.... 0x....      LDR.W    R1,??DataTable153_1
   \   000001F6   0x7008             STRB     R0,[R1, #+0]
   \   000001F8   0x7128             STRB     R0,[R5, #+4]
   \   000001FA   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_initPrint()
   \                     mks_initPrint: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable142_2
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable153_2
   \   0000000A   0x6980             LDR      R0,[R0, #+24]
   \   0000000C   0xF8C4 0x0CEC      STR      R0,[R4, #+3308]
   \   00000010   0x20A6             MOVS     R0,#+166
   \   00000012   0xF884 0x0D10      STRB     R0,[R4, #+3344]
   \   00000016   0xF604 0x5510      ADDW     R5,R4,#+3344
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x6068             STR      R0,[R5, #+4]
   \   0000001E   0x2214             MOVS     R2,#+20
   \   00000020   0x4601             MOV      R1,R0
   \   00000022   0xF604 0x40B8      ADDW     R0,R4,#+3256
   \   00000026   0x.... 0x....      BL       memset
   \   0000002A   0x221E             MOVS     R2,#+30
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0xF604 0x40CC      ADDW     R0,R4,#+3276
   \   00000032   0x.... 0x....      BL       memset
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x8368             STRH     R0,[R5, #+26]
   \   0000003A   0xF884 0x0D8C      STRB     R0,[R4, #+3468]
   \   0000003E   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_WriteToEpr()
   \                     _Z14mks_WriteToEprv: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_ReadFromEpr()
   \                     mks_ReadFromEpr: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable142_2
   \   00000006   0x221E             MOVS     R2,#+30
   \   00000008   0xF604 0x41CC      ADDW     R1,R4,#+3276
   \   0000000C   0xF240 0x30E9      MOVW     R0,#+1001
   \   00000010   0x.... 0x....      BL       epr_read_data
   \   00000014   0x2204             MOVS     R2,#+4
   \   00000016   0xF604 0x5114      ADDW     R1,R4,#+3348
   \   0000001A   0xF240 0x401D      MOVW     R0,#+1053
   \   0000001E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000022   0x.... 0x....      B.W      epr_read_data

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_resumePrint()
   \                     mks_resumePrint: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable142_2
   \   00000006   0xF894 0x0D10      LDRB     R0,[R4, #+3344]
   \   0000000A   0x28A9             CMP      R0,#+169
   \   0000000C   0xD10B             BNE.N    ??mks_resumePrint_0
   \   0000000E   0x20A7             MOVS     R0,#+167
   \   00000010   0xF884 0x0D10      STRB     R0,[R4, #+3344]
   \   00000014   0xF604 0x10C4      ADDW     R0,R4,#+2500
   \   00000018   0x.... 0x....      BL       _ZN7MKS_DLP11resumePrintEv
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0xF604 0x40CC      ADDW     R0,R4,#+3276
   \   00000022   0x.... 0x....      BL       _Z13lcd_setstatusPKcb
   \                     ??mks_resumePrint_0: (+1)
   \   00000026   0xF894 0x0D10      LDRB     R0,[R4, #+3344]
   \   0000002A   0x28AA             CMP      R0,#+170
   \   0000002C   0xD102             BNE.N    ??mks_resumePrint_1
   \   0000002E   0x20AB             MOVS     R0,#+171
   \   00000030   0xF884 0x0D10      STRB     R0,[R4, #+3344]
   \                     ??mks_resumePrint_1: (+1)
   \   00000034   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \   __interwork __softfp void mks_pausePrint()
   \                     mks_pausePrint: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   \   00000006   0x20A6             MOVS     R0,#+166
   \   00000008   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000000C   0xF240 0x4423      MOVW     R4,#+1059
   \   00000010   0x2201             MOVS     R2,#+1
   \   00000012   0xA900             ADD      R1,SP,#+0
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       epr_write_data
   \   0000001A   0x.... 0x....      LDR.W    R5,??DataTable142_2
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable153_2
   \   00000022   0xED90 0x0A04      VLDR     S0,[R0, #+16]
   \   00000026   0xEDDF 0x....      VLDR.W   S1,??DataTable136_1  ;; 0x42f00000
   \   0000002A   0xEEC0 0x0A20      VDIV.F32 S1,S0,S1
   \   0000002E   0xF8D5 0x0CEC      LDR      R0,[R5, #+3308]
   \   00000032   0xEE00 0x0A10      VMOV     S0,R0
   \   00000036   0xF605 0x10C4      ADDW     R0,R5,#+2500
   \   0000003A   0x.... 0x....      BL       _ZN7MKS_DLP14moveRelative_ZEff
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable157
   \   00000042   0x6AC0             LDR      R0,[R0, #+44]
   \   00000044   0xF8C5 0x0CF8      STR      R0,[R5, #+3320]
   \   00000048   0x20A7             MOVS     R0,#+167
   \   0000004A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000004E   0x2201             MOVS     R2,#+1
   \   00000050   0xA900             ADD      R1,SP,#+0
   \   00000052   0x4620             MOV      R0,R4
   \   00000054   0x.... 0x....      BL       epr_write_data
   \   00000058   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \   __interwork __softfp void mks_PrintStatePolling()
   \                     mks_PrintStatePolling: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable142_2
   \   00000006   0xF894 0x0D10      LDRB     R0,[R4, #+3344]
   \   0000000A   0x28A8             CMP      R0,#+168
   \   0000000C   0xD122             BNE.N    ??mks_PrintStatePolling_0
   \   0000000E   0xF604 0x15C4      ADDW     R5,R4,#+2500
   \   00000012   0x4628             MOV      R0,R5
   \   00000014   0x.... 0x....      BL       _ZN7MKS_DLP10pausePrintEv
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD11B             BNE.N    ??mks_PrintStatePolling_0
   \   0000001C   0x.... 0x....      ADR.W    R0,`?<Constant "paused:">`
   \   00000020   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   00000024   0x.... 0x....      BL       _Z23report_current_positionv
   \   00000028   0x20A9             MOVS     R0,#+169
   \   0000002A   0xF884 0x0D10      STRB     R0,[R4, #+3344]
   \   0000002E   0x2201             MOVS     R2,#+1
   \   00000030   0xF504 0x6151      ADD      R1,R4,#+3344
   \   00000034   0xF44F 0x707A      MOV      R0,#+1000
   \   00000038   0x.... 0x....      BL       epr_write_data
   \   0000003C   0x.... 0x....      BL       mks_pausePrint
   \   00000040   0x4628             MOV      R0,R5
   \   00000042   0x.... 0x....      BL       _ZN7MKS_DLP24write_Information_pausedEv
   \   00000046   0x2302             MOVS     R3,#+2
   \   00000048   0xF44F 0x727A      MOV      R2,#+1000
   \   0000004C   0x4611             MOV      R1,R2
   \   0000004E   0x4628             MOV      R0,R5
   \   00000050   0x.... 0x....      BL       _ZN7MKS_DLP11buzzer_toneEtth
   \                     ??mks_PrintStatePolling_0: (+1)
   \   00000054   0xF894 0x0D10      LDRB     R0,[R4, #+3344]
   \   00000058   0x28A7             CMP      R0,#+167
   \   0000005A   0xD12A             BNE.N    ??mks_PrintStatePolling_1
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable156
   \   00000060   0x7801             LDRB     R1,[R0, #+0]
   \   00000062   0x2901             CMP      R1,#+1
   \   00000064   0xD10C             BNE.N    ??mks_PrintStatePolling_2
   \   00000066   0x2100             MOVS     R1,#+0
   \   00000068   0x7001             STRB     R1,[R0, #+0]
   \   0000006A   0xF604 0x10C4      ADDW     R0,R4,#+2500
   \   0000006E   0x.... 0x....      BL       _ZN7MKS_DLP11resumePrintEv
   \   00000072   0x4620             MOV      R0,R4
   \   00000074   0x.... 0x....      BL       _ZN10CardReader14startFileprintEv
   \   00000078   0xF504 0x6060      ADD      R0,R4,#+3584
   \   0000007C   0x.... 0x....      BL       _ZN9Stopwatch5startEv
   \                     ??mks_PrintStatePolling_2: (+1)
   \   00000080   0xF604 0x5110      ADDW     R1,R4,#+3344
   \   00000084   0xF894 0x09B8      LDRB     R0,[R4, #+2488]
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD103             BNE.N    ??mks_PrintStatePolling_3
   \   0000008C   0x8B48             LDRH     R0,[R1, #+26]
   \   0000008E   0x1C40             ADDS     R0,R0,#+1
   \   00000090   0x8348             STRH     R0,[R1, #+26]
   \   00000092   0xE001             B.N      ??mks_PrintStatePolling_4
   \                     ??mks_PrintStatePolling_3: (+1)
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0x8348             STRH     R0,[R1, #+26]
   \                     ??mks_PrintStatePolling_4: (+1)
   \   00000098   0x8B48             LDRH     R0,[R1, #+26]
   \   0000009A   0x2815             CMP      R0,#+21
   \   0000009C   0xDB09             BLT.N    ??mks_PrintStatePolling_1
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x8348             STRH     R0,[R1, #+26]
   \   000000A2   0x20A6             MOVS     R0,#+166
   \   000000A4   0xF884 0x0D10      STRB     R0,[R4, #+3344]
   \   000000A8   0x2201             MOVS     R2,#+1
   \   000000AA   0xF44F 0x707A      MOV      R0,#+1000
   \   000000AE   0x.... 0x....      BL       epr_write_data
   \                     ??mks_PrintStatePolling_1: (+1)
   \   000000B2   0xF894 0x0D10      LDRB     R0,[R4, #+3344]
   \   000000B6   0x28AC             CMP      R0,#+172
   \   000000B8   0xD137             BNE.N    ??mks_PrintStatePolling_5
   \   000000BA   0x20A6             MOVS     R0,#+166
   \   000000BC   0xF884 0x0D10      STRB     R0,[R4, #+3344]
   \   000000C0   0x2201             MOVS     R2,#+1
   \   000000C2   0xF504 0x6151      ADD      R1,R4,#+3344
   \   000000C6   0xF44F 0x707A      MOV      R0,#+1000
   \   000000CA   0x.... 0x....      BL       epr_write_data
   \   000000CE   0x.... 0x....      BL       _Z19clear_command_queuev
   \   000000D2   0xF604 0x15C4      ADDW     R5,R4,#+2500
   \   000000D6   0x4628             MOV      R0,R5
   \   000000D8   0x.... 0x....      BL       _ZN7MKS_DLP9stopPrintEv
   \   000000DC   0x.... 0x....      LDR.W    R0,??DataTable153_2
   \   000000E0   0xED90 0x0A04      VLDR     S0,[R0, #+16]
   \   000000E4   0xEDDF 0x....      VLDR.W   S1,??DataTable136_1  ;; 0x42f00000
   \   000000E8   0xEEC0 0x0A20      VDIV.F32 S1,S0,S1
   \   000000EC   0xF8D4 0x0CEC      LDR      R0,[R4, #+3308]
   \   000000F0   0xEE00 0x0A10      VMOV     S0,R0
   \   000000F4   0x4628             MOV      R0,R5
   \   000000F6   0x.... 0x....      BL       _ZN7MKS_DLP14moveRelative_ZEff
   \   000000FA   0x2201             MOVS     R2,#+1
   \   000000FC   0x.... 0x....      LDR.W    R0,??DataTable157_1
   \   00000100   0x8881             LDRH     R1,[R0, #+4]
   \   00000102   0x.... 0x....      LDR.W    R0,??DataTable157_2
   \   00000106   0x6880             LDR      R0,[R0, #+8]
   \   00000108   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   0000010C   0x2000             MOVS     R0,#+0
   \   0000010E   0x.... 0x....      LDR.W    R1,??DataTable157
   \   00000112   0x7288             STRB     R0,[R1, #+10]
   \   00000114   0x2302             MOVS     R3,#+2
   \   00000116   0xF44F 0x727A      MOV      R2,#+1000
   \   0000011A   0x4611             MOV      R1,R2
   \   0000011C   0x4628             MOV      R0,R5
   \   0000011E   0x.... 0x....      BL       _ZN7MKS_DLP11buzzer_toneEtth
   \   00000122   0xF504 0x6060      ADD      R0,R4,#+3584
   \   00000126   0x.... 0x....      BL       _ZN9Stopwatch4stopEv
   \                     ??mks_PrintStatePolling_5: (+1)
   \   0000012A   0xF894 0x0D10      LDRB     R0,[R4, #+3344]
   \   0000012E   0x28AB             CMP      R0,#+171
   \   00000130   0xD111             BNE.N    ??mks_PrintStatePolling_6
   \   00000132   0xF994 0x0D8C      LDRSB    R0,[R4, #+3468]
   \   00000136   0x2801             CMP      R0,#+1
   \   00000138   0xD105             BNE.N    ??mks_PrintStatePolling_7
   \   0000013A   0xF604 0x10C4      ADDW     R0,R4,#+2500
   \   0000013E   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000142   0x.... 0x....      B.W      _ZN7MKS_DLP19contiuePrint_pausedEv
   \                     ??mks_PrintStatePolling_7: (+1)
   \   00000146   0x2802             CMP      R0,#+2
   \   00000148   0xD105             BNE.N    ??mks_PrintStatePolling_6
   \   0000014A   0xF604 0x10C4      ADDW     R0,R4,#+2500
   \   0000014E   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000152   0x.... 0x....      B.W      _ZN7MKS_DLP18contiuePrint_PwdwnEv
   \                     ??mks_PrintStatePolling_6: (+1)
   \   00000156   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_setTemperature()
   \                     _Z18mks_setTemperaturev: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_setPositionZ()
   \                     mks_setPositionZ: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x....             LDR.N    R4,??DataTable142_2
   \   00000006   0x2260             MOVS     R2,#+96
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0xF604 0x502C      ADDW     R0,R4,#+3372
   \   0000000E   0x.... 0x....      BL       memset
   \   00000012   0xF604 0x552C      ADDW     R5,R4,#+3372
   \   00000016   0x2206             MOVS     R2,#+6
   \   00000018   0x.... 0x....      ADR.W    R1,`?<Constant "G92 Z">`
   \   0000001C   0x4628             MOV      R0,R5
   \   0000001E   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000022   0x2214             MOVS     R2,#+20
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0xA800             ADD      R0,SP,#+0
   \   00000028   0x.... 0x....      BL       memset
   \   0000002C   0xF8D4 0x0CF8      LDR      R0,[R4, #+3320]
   \   00000030   0x.... 0x....      BL       __aeabi_f2d
   \   00000034   0x4602             MOV      R2,R0
   \   00000036   0x460B             MOV      R3,R1
   \   00000038   0x....             ADR.N    R1,??DataTable142_1  ;; 0x25, 0x66, 0x00, 0x00
   \   0000003A   0xA800             ADD      R0,SP,#+0
   \   0000003C   0x.... 0x....      BL       sprintf
   \   00000040   0xA900             ADD      R1,SP,#+0
   \   00000042   0x4628             MOV      R0,R5
   \   00000044   0x.... 0x....      BL       strcat
   \   00000048   0x4628             MOV      R0,R5
   \   0000004A   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   0000004E   0x.... 0x....      BL       _Z9gcode_G92v
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable159
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0x6181             STR      R1,[R0, #+24]
   \   0000005A   0xB005             ADD      SP,SP,#+20
   \   0000005C   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_setFeedrate()
   \                     _Z15mks_setFeedratev: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable157
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable152_1
   \   00000008   0xF8D1 0x1D24      LDR      R1,[R1, #+3364]
   \   0000000C   0x6781             STR      R1,[R0, #+120]
   \   0000000E   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __vfp void mks_preExtrude(float)
   \                     mks_preExtrude: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __vfp void mks_moveXY(float, float)
   \                     mks_moveXY: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0xB086             SUB      SP,SP,#+24
   \   00000008   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   0000000C   0xEEF0 0x8A60      VMOV.F32 S17,S1
   \   00000010   0x....             LDR.N    R4,??DataTable142_2
   \   00000012   0x2260             MOVS     R2,#+96
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0xF604 0x502C      ADDW     R0,R4,#+3372
   \   0000001A   0x.... 0x....      BL       memset
   \   0000001E   0xF604 0x542C      ADDW     R4,R4,#+3372
   \   00000022   0x2205             MOVS     R2,#+5
   \   00000024   0x.... 0x....      ADR.W    R1,`?<Constant "G1 X">`
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000002E   0x2214             MOVS     R2,#+20
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0xA800             ADD      R0,SP,#+0
   \   00000034   0x.... 0x....      BL       memset
   \   00000038   0x....             ADR.N    R5,??DataTable142_1  ;; 0x25, 0x66, 0x00, 0x00
   \   0000003A   0xEE18 0x0A10      VMOV     R0,S16
   \   0000003E   0x.... 0x....      BL       __aeabi_f2d
   \   00000042   0x4602             MOV      R2,R0
   \   00000044   0x460B             MOV      R3,R1
   \   00000046   0x4629             MOV      R1,R5
   \   00000048   0xA800             ADD      R0,SP,#+0
   \   0000004A   0x.... 0x....      BL       sprintf
   \   0000004E   0xA900             ADD      R1,SP,#+0
   \   00000050   0x4620             MOV      R0,R4
   \   00000052   0x.... 0x....      BL       strcat
   \   00000056   0x....             ADR.N    R1,??DataTable143  ;; 0x20, 0x59, 0x00, 0x00
   \   00000058   0x4620             MOV      R0,R4
   \   0000005A   0x.... 0x....      BL       strcat
   \   0000005E   0x2214             MOVS     R2,#+20
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0xA800             ADD      R0,SP,#+0
   \   00000064   0x.... 0x....      BL       memset
   \   00000068   0xEE18 0x0A90      VMOV     R0,S17
   \   0000006C   0x.... 0x....      BL       __aeabi_f2d
   \   00000070   0x4602             MOV      R2,R0
   \   00000072   0x460B             MOV      R3,R1
   \   00000074   0x4629             MOV      R1,R5
   \   00000076   0xA800             ADD      R0,SP,#+0
   \   00000078   0x.... 0x....      BL       sprintf
   \   0000007C   0xA900             ADD      R1,SP,#+0
   \   0000007E   0x4620             MOV      R0,R4
   \   00000080   0x.... 0x....      BL       strcat
   \   00000084   0x4620             MOV      R0,R4
   \   00000086   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   0000008A   0x.... 0x....      BL       _Z11gcode_G0_G1v
   \   0000008E   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   \   00000092   0xB006             ADD      SP,SP,#+24
   \   00000094   0xECBD 0x8B02      VPOP     {D8}
   \   00000098   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __vfp void mks_moveZ(float)
   \                     mks_moveZ: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0xB086             SUB      SP,SP,#+24
   \   00000008   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   0000000C   0x....             LDR.N    R4,??DataTable142_2
   \   0000000E   0x2260             MOVS     R2,#+96
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0xF604 0x502C      ADDW     R0,R4,#+3372
   \   00000016   0x.... 0x....      BL       memset
   \   0000001A   0xF604 0x552C      ADDW     R5,R4,#+3372
   \   0000001E   0x2205             MOVS     R2,#+5
   \   00000020   0x.... 0x....      ADR.W    R1,`?<Constant "G1 Z">`
   \   00000024   0x4628             MOV      R0,R5
   \   00000026   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000002A   0x2214             MOVS     R2,#+20
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0xA800             ADD      R0,SP,#+0
   \   00000030   0x.... 0x....      BL       memset
   \   00000034   0xF8D4 0x0D08      LDR      R0,[R4, #+3336]
   \   00000038   0xEE00 0x0A10      VMOV     S0,R0
   \   0000003C   0xEE30 0x0A08      VADD.F32 S0,S0,S16
   \   00000040   0xEE10 0x0A10      VMOV     R0,S0
   \   00000044   0x.... 0x....      BL       __aeabi_f2d
   \   00000048   0x4602             MOV      R2,R0
   \   0000004A   0x460B             MOV      R3,R1
   \   0000004C   0x....             ADR.N    R1,??DataTable142_1  ;; 0x25, 0x66, 0x00, 0x00
   \   0000004E   0xA800             ADD      R0,SP,#+0
   \   00000050   0x.... 0x....      BL       sprintf
   \   00000054   0xA900             ADD      R1,SP,#+0
   \   00000056   0x4628             MOV      R0,R5
   \   00000058   0x.... 0x....      BL       strcat
   \   0000005C   0x4628             MOV      R0,R5
   \   0000005E   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   00000062   0x.... 0x....      BL       _Z11gcode_G0_G1v
   \   00000066   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   \   0000006A   0xB006             ADD      SP,SP,#+24
   \   0000006C   0xECBD 0x8B02      VPOP     {D8}
   \   00000070   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_G28(char *)
   \                     _Z7mks_G28Pc: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable152_1
   \   00000008   0x2260             MOVS     R2,#+96
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0xF605 0x502C      ADDW     R0,R5,#+3372
   \   00000010   0x.... 0x....      BL       memset
   \   00000014   0xF605 0x552C      ADDW     R5,R5,#+3372
   \   00000018   0x4621             MOV      R1,R4
   \   0000001A   0x4628             MOV      R0,R5
   \   0000001C   0x.... 0x....      BL       strcpy
   \   00000020   0x4628             MOV      R0,R5
   \   00000022   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000002C   0x.... 0x....      B.W      _Z9gcode_G28b

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_manual_leveling(int16_t, int16_t)
   \                     mks_manual_leveling: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1

      char string[20];
           ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_reprint.cpp",934  Warning[Pe177]: 
          variable "string" was declared but never referenced
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable160
   \   0000000A   0x7801             LDRB     R1,[R0, #+0]
   \   0000000C   0x2901             CMP      R1,#+1
   \   0000000E   0xD104             BNE.N    ??mks_manual_leveling_0
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x7001             STRB     R1,[R0, #+0]
   \   00000014   0x....             ADR.N    R0,??DataTable144  ;; "G28"
   \   00000016   0x.... 0x....      BL       _Z7mks_G28Pc
   \                     ??mks_manual_leveling_0: (+1)
   \   0000001A   0x....             LDR.N    R0,??DataTable142_2
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable157
   \   00000020   0x6AC9             LDR      R1,[R1, #+44]
   \   00000022   0xF8C0 0x1D08      STR      R1,[R0, #+3336]
   \   00000026   0xEEB2 0x0A04      VMOV.F32 S0,#10.0
   \   0000002A   0x.... 0x....      BL       mks_moveZ
   \   0000002E   0xEE00 0x5A10      VMOV     S0,R5
   \   00000032   0xEEF8 0x0AC0      VCVT.F32.S32 S1,S0
   \   00000036   0xEE00 0x4A10      VMOV     S0,R4
   \   0000003A   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000003E   0x.... 0x....      BL       mks_moveXY
   \   00000042   0x.... 0x....      ADR.W    R0,`?<Constant "G1 Z0">`
   \   00000046   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000004A   0x.... 0x....      B.W      _Z27enqueue_and_echo_commands_PPKc

   \                                 In section .text, align 4, keep-with-next
   \   __interwork __softfp void mks_contiuePrintPause()
   \                     mks_contiuePrintPause: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}

  	char string[20];
  	     ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_reprint.cpp",950  Warning[Pe177]: 
          variable "string" was declared but never referenced
   \   00000002   0x....             LDR.N    R4,??DataTable142_2
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0xF884 0x09B8      STRB     R0,[R4, #+2488]
   \   0000000A   0x.... 0x....      BL       mks_setPositionZ
   \   0000000E   0xED9F 0x....      VLDR.W   S0,??DataTable145  ;; 0x0
   \   00000012   0x.... 0x....      BL       mks_moveZ
   \   00000016   0x20A7             MOVS     R0,#+167
   \   00000018   0xF884 0x0D10      STRB     R0,[R4, #+3344]
   \   0000001C   0xE8BD 0x4010      POP      {R4,LR}
   \   00000020   0x.... 0x....      B.W      _Z9gcode_M24v

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_contiuePrintPwdwn()
   \                     mks_contiuePrintPwdwn: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \   __interwork __softfp void mks_contiuePrintDelta()
   \                     mks_contiuePrintDelta: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}

  	char string[20];
  	     ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_reprint.cpp",1036  Warning[Pe177]: 
          variable "string" was declared but never referenced
   \   00000002   0x....             LDR.N    R4,??DataTable142_2
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0xF884 0x09B8      STRB     R0,[R4, #+2488]
   \   0000000A   0xF8D4 0x0CEC      LDR      R0,[R4, #+3308]
   \   0000000E   0xEE00 0x0A10      VMOV     S0,R0
   \   00000012   0x.... 0x....      BL       mks_moveZ
   \   00000016   0xED9F 0x....      VLDR.W   S0,??DataTable145  ;; 0x0
   \   0000001A   0x.... 0x....      BL       mks_moveZ
   \   0000001E   0x20A7             MOVS     R0,#+167
   \   00000020   0xF884 0x0D10      STRB     R0,[R4, #+3344]
   \   00000024   0xE8BD 0x4010      POP      {R4,LR}
   \   00000028   0x.... 0x....      B.W      _Z9gcode_M24v

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_getPositionXYZE()
   \                     mks_getPositionXYZE: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4

      volatile char *ZPOS_TEMP;
                     ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_reprint.cpp",1079  Warning[Pe177]: 
          variable "ZPOS_TEMP" was declared but never referenced
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000008   0xB001             ADD      SP,SP,#+4
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_clearDir()
   \                     mks_clearDir: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable161
   \   00000008   0xE007             B.N      ??mks_clearDir_0
   \                     ??mks_clearDir_1: (+1)
   \   0000000A   0x1C41             ADDS     R1,R0,#+1
   \   0000000C   0xA800             ADD      R0,SP,#+0
   \   0000000E   0x.... 0x....      BL       strcpy
   \   00000012   0xA900             ADD      R1,SP,#+0
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       strcpy
   \                     ??mks_clearDir_0: (+1)
   \   0000001A   0x....             ADR.N    R1,??DataTable146  ;; "/"
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       _Z6strstrPcPKc
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD1F1             BNE.N    ??mks_clearDir_1
   \   00000026   0xB008             ADD      SP,SP,#+32
   \   00000028   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_contiuePrint_UI()
   \                     mks_contiuePrint_UI: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x.... 0x....      ADR.W    R0,`?<Constant "Resume print?">`
   \   00000008   0x.... 0x....      BL       _Z13lcd_setstatusPKcb
   \   0000000C   0x.... 0x....      LDR.W    R4,??DataTable152_1
   \   00000010   0xF604 0x45CC      ADDW     R5,R4,#+3276
   \   00000014   0x2301             MOVS     R3,#+1
   \   00000016   0x461A             MOV      R2,R3
   \   00000018   0x4629             MOV      R1,R5
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       _ZN10CardReader8openFileEPcbb
   \   00000020   0x.... 0x....      LDR.W    R6,??DataTable162
   \   00000024   0x4629             MOV      R1,R5
   \   00000026   0x4630             MOV      R0,R6
   \   00000028   0x.... 0x....      BL       strcpy
   \   0000002C   0x.... 0x....      ADR.W    R1,`?<Constant ".cbddlp">`
   \   00000030   0x.... 0x....      BL       _Z6strstrPcPKc
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD114             BNE.N    ??mks_contiuePrint_UI_0
   \   00000038   0x.... 0x....      ADR.W    R1,`?<Constant ".CBDDLP">`
   \   0000003C   0x4630             MOV      R0,R6
   \   0000003E   0x.... 0x....      BL       _Z6strstrPcPKc
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD10D             BNE.N    ??mks_contiuePrint_UI_0
   \   00000046   0x.... 0x....      ADR.W    R1,`?<Constant ".photon">`
   \   0000004A   0x4630             MOV      R0,R6
   \   0000004C   0x.... 0x....      BL       _Z6strstrPcPKc
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD106             BNE.N    ??mks_contiuePrint_UI_0
   \   00000054   0x.... 0x....      ADR.W    R1,`?<Constant ".PHOTON">`
   \   00000058   0x4630             MOV      R0,R6
   \   0000005A   0x.... 0x....      BL       _Z6strstrPcPKc
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD003             BEQ.N    ??mks_contiuePrint_UI_1
   \                     ??mks_contiuePrint_UI_0: (+1)
   \   00000062   0x2002             MOVS     R0,#+2
   \   00000064   0xF884 0x0CB7      STRB     R0,[R4, #+3255]
   \   00000068   0xE002             B.N      ??mks_contiuePrint_UI_2
   \                     ??mks_contiuePrint_UI_1: (+1)
   \   0000006A   0x2001             MOVS     R0,#+1
   \   0000006C   0xF884 0x0CB7      STRB     R0,[R4, #+3255]
   \                     ??mks_contiuePrint_UI_2: (+1)
   \   00000070   0x4620             MOV      R0,R4
   \   00000072   0x.... 0x....      BL       _ZN10CardReader10isFileOpenEv
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD104             BNE.N    ??mks_contiuePrint_UI_3
   \   0000007A   0x2002             MOVS     R0,#+2
   \   0000007C   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000080   0x.... 0x....      B.W      draw_dialog
   \                     ??mks_contiuePrint_UI_3: (+1)
   \   00000084   0x221E             MOVS     R2,#+30
   \   00000086   0xF604 0x41CC      ADDW     R1,R4,#+3276
   \   0000008A   0xF240 0x30E9      MOVW     R0,#+1001
   \   0000008E   0x.... 0x....      BL       epr_write_data
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0xF884 0x09B8      STRB     R0,[R4, #+2488]
   \   00000098   0x.... 0x....      BL       mks_clearDir
   \                     ??mks_contiuePrint_UI_4: (+1)
   \   0000009C   0x.... 0x....      BL       getTick
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable163
   \   000000A4   0x6008             STR      R0,[R1, #+0]
   \   000000A6   0x.... 0x....      LDR.W    R1,??DataTable163_1
   \   000000AA   0x6809             LDR      R1,[R1, #+0]
   \   000000AC   0x.... 0x....      BL       getTickDiff
   \   000000B0   0xF640 0x31B8      MOVW     R1,#+3000
   \   000000B4   0x4288             CMP      R0,R1
   \   000000B6   0xD205             BCS.N    ??mks_contiuePrint_UI_5
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable163_2
   \   000000BC   0xF990 0x00DA      LDRSB    R0,[R0, #+218]
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD1EB             BNE.N    ??mks_contiuePrint_UI_4
   \                     ??mks_contiuePrint_UI_5: (+1)
   \   000000C4   0x.... 0x....      LDR.W    R5,??DataTable163_3
   \   000000C8   0x2201             MOVS     R2,#+1
   \   000000CA   0x4629             MOV      R1,R5
   \   000000CC   0xF240 0x6029      MOVW     R0,#+1577
   \   000000D0   0x.... 0x....      BL       AT24CXX_Read
   \   000000D4   0x7828             LDRB     R0,[R5, #+0]
   \   000000D6   0x2800             CMP      R0,#+0
   \   000000D8   0xD004             BEQ.N    ??mks_contiuePrint_UI_6
   \   000000DA   0x2001             MOVS     R0,#+1
   \   000000DC   0x.... 0x....      LDR.W    R1,??DataTable163_4
   \   000000E0   0x7008             STRB     R0,[R1, #+0]
   \   000000E2   0xE003             B.N      ??mks_contiuePrint_UI_7
   \                     ??mks_contiuePrint_UI_6: (+1)
   \   000000E4   0x2001             MOVS     R0,#+1
   \   000000E6   0x.... 0x....      LDR.W    R1,??DataTable163_5
   \   000000EA   0x7008             STRB     R0,[R1, #+0]
   \                     ??mks_contiuePrint_UI_7: (+1)
   \   000000EC   0x.... 0x....      BL       draw_printing
   \   000000F0   0xF604 0x10C4      ADDW     R0,R4,#+2500
   \   000000F4   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   000000F8   0x.... 0x....      B.W      _ZN7MKS_DLP13draw_printingEv

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_rePrintCheck()
   \                     mks_rePrintCheck: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x.... 0x....      LDR.W    R5,??DataTable152_1
   \   00000006   0xF605 0x5610      ADDW     R6,R5,#+3344
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0x4631             MOV      R1,R6
   \   0000000E   0xF44F 0x707A      MOV      R0,#+1000
   \   00000012   0x.... 0x....      BL       epr_read_data
   \   00000016   0x.... 0x....      LDR.W    R4,??DataTable163_6
   \   0000001A   0xF895 0x0D10      LDRB     R0,[R5, #+3344]
   \   0000001E   0x7060             STRB     R0,[R4, #+1]
   \   00000020   0x28A9             CMP      R0,#+169
   \   00000022   0xD112             BNE.N    ??mks_rePrintCheck_0
   \   00000024   0xF605 0x17C4      ADDW     R7,R5,#+2500
   \   00000028   0x4638             MOV      R0,R7
   \   0000002A   0x.... 0x....      BL       _ZN7MKS_DLP18Is_Paused_FinishedEv
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD00B             BEQ.N    ??mks_rePrintCheck_0
   \   00000032   0x20AA             MOVS     R0,#+170
   \   00000034   0xF885 0x0D10      STRB     R0,[R5, #+3344]
   \   00000038   0x4638             MOV      R0,R7
   \   0000003A   0x.... 0x....      BL       _ZN7MKS_DLP23read_Information_pausedEv
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0xF885 0x0D8C      STRB     R0,[R5, #+3468]
   \   00000044   0x.... 0x....      BL       mks_contiuePrint_UI
   \   00000048   0xE01D             B.N      ??mks_rePrintCheck_1
   \                     ??mks_rePrintCheck_0: (+1)
   \   0000004A   0xF895 0x0D10      LDRB     R0,[R5, #+3344]
   \   0000004E   0x28A7             CMP      R0,#+167
   \   00000050   0xD10E             BNE.N    ??mks_rePrintCheck_2
   \   00000052   0xF605 0x10C4      ADDW     R0,R5,#+2500
   \   00000056   0x.... 0x....      BL       _ZN7MKS_DLP22read_Information_layerEv
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD008             BEQ.N    ??mks_rePrintCheck_2
   \   0000005E   0x20AA             MOVS     R0,#+170
   \   00000060   0xF885 0x0D10      STRB     R0,[R5, #+3344]
   \   00000064   0x2002             MOVS     R0,#+2
   \   00000066   0xF885 0x0D8C      STRB     R0,[R5, #+3468]
   \   0000006A   0x.... 0x....      BL       mks_contiuePrint_UI
   \   0000006E   0xE00A             B.N      ??mks_rePrintCheck_1
   \                     ??mks_rePrintCheck_2: (+1)
   \   00000070   0x20A6             MOVS     R0,#+166
   \   00000072   0xF885 0x0D10      STRB     R0,[R5, #+3344]
   \   00000076   0x2201             MOVS     R2,#+1
   \   00000078   0x4631             MOV      R1,R6
   \   0000007A   0xF44F 0x707A      MOV      R0,#+1000
   \   0000007E   0x.... 0x....      BL       epr_write_data
   \   00000082   0x2001             MOVS     R0,#+1
   \   00000084   0x7020             STRB     R0,[R4, #+0]
   \                     ??mks_rePrintCheck_1: (+1)
   \   00000086   0x7820             LDRB     R0,[R4, #+0]
   \   00000088   0x2801             CMP      R0,#+1
   \   0000008A   0xD113             BNE.N    ??mks_rePrintCheck_3
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0x7020             STRB     R0,[R4, #+0]
   \                     ??mks_rePrintCheck_4: (+1)
   \   00000090   0x.... 0x....      BL       getTick
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable163
   \   00000098   0x6008             STR      R0,[R1, #+0]
   \   0000009A   0x.... 0x....      LDR.W    R1,??DataTable163_1
   \   0000009E   0x6809             LDR      R1,[R1, #+0]
   \   000000A0   0x.... 0x....      BL       getTickDiff
   \   000000A4   0xF640 0x31B8      MOVW     R1,#+3000
   \   000000A8   0x4288             CMP      R0,R1
   \   000000AA   0xD3F1             BCC.N    ??mks_rePrintCheck_4
   \   000000AC   0xE8BD 0x40F1      POP      {R0,R4-R7,LR}
   \   000000B0   0x.... 0x....      B.W      draw_ready_print
   \                     ??mks_rePrintCheck_3: (+1)
   \   000000B4   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next

  	char string[20];
  	     ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_reprint.cpp",1437  Warning[Pe177]: 
          variable "string" was declared but never referenced

  	char name[30]={0};
  	     ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_reprint.cpp",1440  Warning[Pe177]: 
          variable "name" was declared but never referenced
   \   __interwork __softfp void mks_WriteToFile()
   \                     mks_WriteToFile: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_WriteToEpr_pwroff()
   \                     _Z21mks_WriteToEpr_pwroffv: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_ReadFromEpr_pwroff()
   \                     _Z22mks_ReadFromEpr_pwroffv: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next

  }
  ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_reprint.cpp",1680  Warning[Pe940]: 
          missing return statement at end of non-void function "pft_get"
   \   __interwork __softfp int16_t pft_get()
   \                     _Z7pft_getv: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next

  	char string[20];
  	     ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_reprint.cpp",1685  Warning[Pe177]: 
          variable "string" was declared but never referenced

  	char commands_count = 0;
  	     ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_reprint.cpp",1686  Warning[Pe177]: 
          variable "commands_count" was declared but never referenced

    uint16_t sd_count = 0;
             ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_reprint.cpp",1687  Warning[Pe177]: 
          variable "sd_count" was declared but never referenced
   \   __interwork __softfp bool mks_get_commands()
   \                     _Z16mks_get_commandsv: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next

  }
  ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_reprint.cpp",1801  Warning[Pe940]: 
          missing return statement at end of non-void function
          "mks_ReadFromFile"

  	bool get_ok = false;
  	     ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_reprint.cpp",1777  Warning[Pe177]: 
          variable "get_ok" was declared but never referenced

         	char name[30]={0};
         	     ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_reprint.cpp",1780  Warning[Pe177]: 
          variable "name" was declared but never referenced
   \   __interwork __softfp bool mks_ReadFromFile()
   \                     mks_ReadFromFile: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next

  	char string[20]="clear";
  	     ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_reprint.cpp",1805  Warning[Pe177]: 
          variable "string" was declared but never referenced

  	char name[30]={0};
  	     ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_reprint.cpp",1806  Warning[Pe177]: 
          variable "name" was declared but never referenced
   \   __interwork __softfp void mks_clearFile()
   \                     mks_clearFile: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_saveFileName(char *)
   \                     mks_saveFileName: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable152_1
   \   00000008   0x221E             MOVS     R2,#+30
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0xF605 0x40CC      ADDW     R0,R5,#+3276
   \   00000010   0x.... 0x....      BL       memset
   \   00000014   0x4621             MOV      R1,R4
   \   00000016   0xF605 0x40CC      ADDW     R0,R5,#+3276
   \   0000001A   0x.... 0x....      BL       strcpy
   \   0000001E   0x221E             MOVS     R2,#+30
   \   00000020   0xF605 0x41CC      ADDW     R1,R5,#+3276
   \   00000024   0xF240 0x30E9      MOVW     R0,#+1001
   \   00000028   0xE8BD 0x4038      POP      {R3-R5,LR}
   \   0000002C   0x.... 0x....      B.W      epr_write_data

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void EXTI9_5_IRQHandler()
   \                     EXTI9_5_IRQHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
  15512          #include "mks_dlp_main.cpp"

   \                                 In section .text, align 4, keep-with-next
   \   static __absolute unsigned short const exposure_bmp_data_square[800][3]
   \                     exposure_bmp_data_square:
   \   00000000   0x0140 0x045F      DC16 320, 1119, 880, 320, 1119, 881, 320, 1119, 882, 320, 1119, 883
   \              0x0370 0x0140
   \              0x045F 0x0371
   \              0x0140 0x045F
   \              0x0372 0x0140
   \              0x045F 0x0373
   \   00000018   0x0140 0x045F      DC16 320, 1119, 884, 320, 1119, 885, 320, 1119, 886, 320, 1119, 887
   \              0x0374 0x0140
   \              0x045F 0x0375
   \              0x0140 0x045F
   \              0x0376 0x0140
   \              0x045F 0x0377
   \   00000030   0x0140 0x045F      DC16 320, 1119, 888, 320, 1119, 889, 320, 1119, 890, 320, 1119, 891
   \              0x0378 0x0140
   \              0x045F 0x0379
   \              0x0140 0x045F
   \              0x037A 0x0140
   \              0x045F 0x037B
   \   00000048   0x0140 0x045F      DC16 320, 1119, 892, 320, 1119, 893, 320, 1119, 894, 320, 1119, 895
   \              0x037C 0x0140
   \              0x045F 0x037D
   \              0x0140 0x045F
   \              0x037E 0x0140
   \              0x045F 0x037F
   \   00000060   0x0140 0x045F      DC16 320, 1119, 896, 320, 1119, 897, 320, 1119, 898, 320, 1119, 899
   \              0x0380 0x0140
   \              0x045F 0x0381
   \              0x0140 0x045F
   \              0x0382 0x0140
   \              0x045F 0x0383
   \   00000078   0x0140 0x045F      DC16 320, 1119, 900, 320, 1119, 901, 320, 1119, 902, 320, 1119, 903
   \              0x0384 0x0140
   \              0x045F 0x0385
   \              0x0140 0x045F
   \              0x0386 0x0140
   \              0x045F 0x0387
   \   00000090   0x0140 0x045F      DC16 320, 1119, 904, 320, 1119, 905, 320, 1119, 906, 320, 1119, 907
   \              0x0388 0x0140
   \              0x045F 0x0389
   \              0x0140 0x045F
   \              0x038A 0x0140
   \              0x045F 0x038B
   \   000000A8   0x0140 0x045F      DC16 320, 1119, 908, 320, 1119, 909, 320, 1119, 910, 320, 1119, 911
   \              0x038C 0x0140
   \              0x045F 0x038D
   \              0x0140 0x045F
   \              0x038E 0x0140
   \              0x045F 0x038F
   \   000000C0   0x0140 0x045F      DC16 320, 1119, 912, 320, 1119, 913, 320, 1119, 914, 320, 1119, 915
   \              0x0390 0x0140
   \              0x045F 0x0391
   \              0x0140 0x045F
   \              0x0392 0x0140
   \              0x045F 0x0393
   \   000000D8   0x0140 0x045F      DC16 320, 1119, 916, 320, 1119, 917, 320, 1119, 918, 320, 1119, 919
   \              0x0394 0x0140
   \              0x045F 0x0395
   \              0x0140 0x045F
   \              0x0396 0x0140
   \              0x045F 0x0397
   \   000000F0   0x0140 0x045F      DC16 320, 1119, 920, 320, 1119, 921, 320, 1119, 922, 320, 1119, 923
   \              0x0398 0x0140
   \              0x045F 0x0399
   \              0x0140 0x045F
   \              0x039A 0x0140
   \              0x045F 0x039B
   \   00000108   0x0140 0x045F      DC16 320, 1119, 924, 320, 1119, 925, 320, 1119, 926, 320, 1119, 927
   \              0x039C 0x0140
   \              0x045F 0x039D
   \              0x0140 0x045F
   \              0x039E 0x0140
   \              0x045F 0x039F
   \   00000120   0x0140 0x045F      DC16 320, 1119, 928, 320, 1119, 929, 320, 1119, 930, 320, 1119, 931
   \              0x03A0 0x0140
   \              0x045F 0x03A1
   \              0x0140 0x045F
   \              0x03A2 0x0140
   \              0x045F 0x03A3
   \   00000138   0x0140 0x045F      DC16 320, 1119, 932, 320, 1119, 933, 320, 1119, 934, 320, 1119, 935
   \              0x03A4 0x0140
   \              0x045F 0x03A5
   \              0x0140 0x045F
   \              0x03A6 0x0140
   \              0x045F 0x03A7
   \   00000150   0x0140 0x045F      DC16 320, 1119, 936, 320, 1119, 937, 320, 1119, 938, 320, 1119, 939
   \              0x03A8 0x0140
   \              0x045F 0x03A9
   \              0x0140 0x045F
   \              0x03AA 0x0140
   \              0x045F 0x03AB
   \   00000168   0x0140 0x045F      DC16 320, 1119, 940, 320, 1119, 941, 320, 1119, 942, 320, 1119, 943
   \              0x03AC 0x0140
   \              0x045F 0x03AD
   \              0x0140 0x045F
   \              0x03AE 0x0140
   \              0x045F 0x03AF
   \   00000180   0x0140 0x045F      DC16 320, 1119, 944, 320, 1119, 945, 320, 1119, 946, 320, 1119, 947
   \              0x03B0 0x0140
   \              0x045F 0x03B1
   \              0x0140 0x045F
   \              0x03B2 0x0140
   \              0x045F 0x03B3
   \   00000198   0x0140 0x045F      DC16 320, 1119, 948, 320, 1119, 949, 320, 1119, 950, 320, 1119, 951
   \              0x03B4 0x0140
   \              0x045F 0x03B5
   \              0x0140 0x045F
   \              0x03B6 0x0140
   \              0x045F 0x03B7
   \   000001B0   0x0140 0x045F      DC16 320, 1119, 952, 320, 1119, 953, 320, 1119, 954, 320, 1119, 955
   \              0x03B8 0x0140
   \              0x045F 0x03B9
   \              0x0140 0x045F
   \              0x03BA 0x0140
   \              0x045F 0x03BB
   \   000001C8   0x0140 0x045F      DC16 320, 1119, 956, 320, 1119, 957, 320, 1119, 958, 320, 1119, 959
   \              0x03BC 0x0140
   \              0x045F 0x03BD
   \              0x0140 0x045F
   \              0x03BE 0x0140
   \              0x045F 0x03BF
   \   000001E0   0x0140 0x045F      DC16 320, 1119, 960, 320, 1119, 961, 320, 1119, 962, 320, 1119, 963
   \              0x03C0 0x0140
   \              0x045F 0x03C1
   \              0x0140 0x045F
   \              0x03C2 0x0140
   \              0x045F 0x03C3
   \   000001F8   0x0140 0x045F      DC16 320, 1119, 964, 320, 1119, 965, 320, 1119, 966, 320, 1119, 967
   \              0x03C4 0x0140
   \              0x045F 0x03C5
   \              0x0140 0x045F
   \              0x03C6 0x0140
   \              0x045F 0x03C7
   \   00000210   0x0140 0x045F      DC16 320, 1119, 968, 320, 1119, 969, 320, 1119, 970, 320, 1119, 971
   \              0x03C8 0x0140
   \              0x045F 0x03C9
   \              0x0140 0x045F
   \              0x03CA 0x0140
   \              0x045F 0x03CB
   \   00000228   0x0140 0x045F      DC16 320, 1119, 972, 320, 1119, 973, 320, 1119, 974, 320, 1119, 975
   \              0x03CC 0x0140
   \              0x045F 0x03CD
   \              0x0140 0x045F
   \              0x03CE 0x0140
   \              0x045F 0x03CF
   \   00000240   0x0140 0x045F      DC16 320, 1119, 976, 320, 1119, 977, 320, 1119, 978, 320, 1119, 979
   \              0x03D0 0x0140
   \              0x045F 0x03D1
   \              0x0140 0x045F
   \              0x03D2 0x0140
   \              0x045F 0x03D3
   \   00000258   0x0140 0x045F      DC16 320, 1119, 980, 320, 1119, 981, 320, 1119, 982, 320, 1119, 983
   \              0x03D4 0x0140
   \              0x045F 0x03D5
   \              0x0140 0x045F
   \              0x03D6 0x0140
   \              0x045F 0x03D7
   \   00000270   0x0140 0x045F      DC16 320, 1119, 984, 320, 1119, 985, 320, 1119, 986, 320, 1119, 987
   \              0x03D8 0x0140
   \              0x045F 0x03D9
   \              0x0140 0x045F
   \              0x03DA 0x0140
   \              0x045F 0x03DB
   \   00000288   0x0140 0x045F      DC16 320, 1119, 988, 320, 1119, 989, 320, 1119, 990, 320, 1119, 991
   \              0x03DC 0x0140
   \              0x045F 0x03DD
   \              0x0140 0x045F
   \              0x03DE 0x0140
   \              0x045F 0x03DF
   \   000002A0   0x0140 0x045F      DC16 320, 1119, 992, 320, 1119, 993, 320, 1119, 994, 320, 1119, 995
   \              0x03E0 0x0140
   \              0x045F 0x03E1
   \              0x0140 0x045F
   \              0x03E2 0x0140
   \              0x045F 0x03E3
   \   000002B8   0x0140 0x045F      DC16 320, 1119, 996, 320, 1119, 997, 320, 1119, 998, 320, 1119, 999
   \              0x03E4 0x0140
   \              0x045F 0x03E5
   \              0x0140 0x045F
   \              0x03E6 0x0140
   \              0x045F 0x03E7
   \   000002D0   0x0140 0x045F      DC16 320, 1119, 1000, 320, 1119, 1001, 320, 1119, 1002, 320, 1119, 1003
   \              0x03E8 0x0140
   \              0x045F 0x03E9
   \              0x0140 0x045F
   \              0x03EA 0x0140
   \              0x045F 0x03EB
   \   000002E8   0x0140 0x045F      DC16 320, 1119, 1004, 320, 1119, 1005, 320, 1119, 1006, 320, 1119, 1007
   \              0x03EC 0x0140
   \              0x045F 0x03ED
   \              0x0140 0x045F
   \              0x03EE 0x0140
   \              0x045F 0x03EF
   \   00000300   0x0140 0x045F      DC16 320, 1119, 1008, 320, 1119, 1009, 320, 1119, 1010, 320, 1119, 1011
   \              0x03F0 0x0140
   \              0x045F 0x03F1
   \              0x0140 0x045F
   \              0x03F2 0x0140
   \              0x045F 0x03F3
   \   00000318   0x0140 0x045F      DC16 320, 1119, 1012, 320, 1119, 1013, 320, 1119, 1014, 320, 1119, 1015
   \              0x03F4 0x0140
   \              0x045F 0x03F5
   \              0x0140 0x045F
   \              0x03F6 0x0140
   \              0x045F 0x03F7
   \   00000330   0x0140 0x045F      DC16 320, 1119, 1016, 320, 1119, 1017, 320, 1119, 1018, 320, 1119, 1019
   \              0x03F8 0x0140
   \              0x045F 0x03F9
   \              0x0140 0x045F
   \              0x03FA 0x0140
   \              0x045F 0x03FB
   \   00000348   0x0140 0x045F      DC16 320, 1119, 1020, 320, 1119, 1021, 320, 1119, 1022, 320, 1119, 1023
   \              0x03FC 0x0140
   \              0x045F 0x03FD
   \              0x0140 0x045F
   \              0x03FE 0x0140
   \              0x045F 0x03FF
   \   00000360   0x0140 0x045F      DC16 320, 1119, 1024, 320, 1119, 1025, 320, 1119, 1026, 320, 1119, 1027
   \              0x0400 0x0140
   \              0x045F 0x0401
   \              0x0140 0x045F
   \              0x0402 0x0140
   \              0x045F 0x0403
   \   00000378   0x0140 0x045F      DC16 320, 1119, 1028, 320, 1119, 1029, 320, 1119, 1030, 320, 1119, 1031
   \              0x0404 0x0140
   \              0x045F 0x0405
   \              0x0140 0x045F
   \              0x0406 0x0140
   \              0x045F 0x0407
   \   00000390   0x0140 0x045F      DC16 320, 1119, 1032, 320, 1119, 1033, 320, 1119, 1034, 320, 1119, 1035
   \              0x0408 0x0140
   \              0x045F 0x0409
   \              0x0140 0x045F
   \              0x040A 0x0140
   \              0x045F 0x040B
   \   000003A8   0x0140 0x045F      DC16 320, 1119, 1036, 320, 1119, 1037, 320, 1119, 1038, 320, 1119, 1039
   \              0x040C 0x0140
   \              0x045F 0x040D
   \              0x0140 0x045F
   \              0x040E 0x0140
   \              0x045F 0x040F
   \   000003C0   0x0140 0x045F      DC16 320, 1119, 1040, 320, 1119, 1041, 320, 1119, 1042, 320, 1119, 1043
   \              0x0410 0x0140
   \              0x045F 0x0411
   \              0x0140 0x045F
   \              0x0412 0x0140
   \              0x045F 0x0413
   \   000003D8   0x0140 0x045F      DC16 320, 1119, 1044, 320, 1119, 1045, 320, 1119, 1046, 320, 1119, 1047
   \              0x0414 0x0140
   \              0x045F 0x0415
   \              0x0140 0x045F
   \              0x0416 0x0140
   \              0x045F 0x0417
   \   000003F0   0x0140 0x045F      DC16 320, 1119, 1048, 320, 1119, 1049, 320, 1119, 1050, 320, 1119, 1051
   \              0x0418 0x0140
   \              0x045F 0x0419
   \              0x0140 0x045F
   \              0x041A 0x0140
   \              0x045F 0x041B
   \   00000408   0x0140 0x045F      DC16 320, 1119, 1052, 320, 1119, 1053, 320, 1119, 1054, 320, 1119, 1055
   \              0x041C 0x0140
   \              0x045F 0x041D
   \              0x0140 0x045F
   \              0x041E 0x0140
   \              0x045F 0x041F
   \   00000420   0x0140 0x045F      DC16 320, 1119, 1056, 320, 1119, 1057, 320, 1119, 1058, 320, 1119, 1059
   \              0x0420 0x0140
   \              0x045F 0x0421
   \              0x0140 0x045F
   \              0x0422 0x0140
   \              0x045F 0x0423
   \   00000438   0x0140 0x045F      DC16 320, 1119, 1060, 320, 1119, 1061, 320, 1119, 1062, 320, 1119, 1063
   \              0x0424 0x0140
   \              0x045F 0x0425
   \              0x0140 0x045F
   \              0x0426 0x0140
   \              0x045F 0x0427
   \   00000450   0x0140 0x045F      DC16 320, 1119, 1064, 320, 1119, 1065, 320, 1119, 1066, 320, 1119, 1067
   \              0x0428 0x0140
   \              0x045F 0x0429
   \              0x0140 0x045F
   \              0x042A 0x0140
   \              0x045F 0x042B
   \   00000468   0x0140 0x045F      DC16 320, 1119, 1068, 320, 1119, 1069, 320, 1119, 1070, 320, 1119, 1071
   \              0x042C 0x0140
   \              0x045F 0x042D
   \              0x0140 0x045F
   \              0x042E 0x0140
   \              0x045F 0x042F
   \   00000480   0x0140 0x045F      DC16 320, 1119, 1072, 320, 1119, 1073, 320, 1119, 1074, 320, 1119, 1075
   \              0x0430 0x0140
   \              0x045F 0x0431
   \              0x0140 0x045F
   \              0x0432 0x0140
   \              0x045F 0x0433
   \   00000498   0x0140 0x045F      DC16 320, 1119, 1076, 320, 1119, 1077, 320, 1119, 1078, 320, 1119, 1079
   \              0x0434 0x0140
   \              0x045F 0x0435
   \              0x0140 0x045F
   \              0x0436 0x0140
   \              0x045F 0x0437
   \   000004B0   0x0140 0x045F      DC16 320, 1119, 1080, 320, 1119, 1081, 320, 1119, 1082, 320, 1119, 1083
   \              0x0438 0x0140
   \              0x045F 0x0439
   \              0x0140 0x045F
   \              0x043A 0x0140
   \              0x045F 0x043B
   \   000004C8   0x0140 0x045F      DC16 320, 1119, 1084, 320, 1119, 1085, 320, 1119, 1086, 320, 1119, 1087
   \              0x043C 0x0140
   \              0x045F 0x043D
   \              0x0140 0x045F
   \              0x043E 0x0140
   \              0x045F 0x043F
   \   000004E0   0x0140 0x045F      DC16 320, 1119, 1088, 320, 1119, 1089, 320, 1119, 1090, 320, 1119, 1091
   \              0x0440 0x0140
   \              0x045F 0x0441
   \              0x0140 0x045F
   \              0x0442 0x0140
   \              0x045F 0x0443
   \   000004F8   0x0140 0x045F      DC16 320, 1119, 1092, 320, 1119, 1093, 320, 1119, 1094, 320, 1119, 1095
   \              0x0444 0x0140
   \              0x045F 0x0445
   \              0x0140 0x045F
   \              0x0446 0x0140
   \              0x045F 0x0447
   \   00000510   0x0140 0x045F      DC16 320, 1119, 1096, 320, 1119, 1097, 320, 1119, 1098, 320, 1119, 1099
   \              0x0448 0x0140
   \              0x045F 0x0449
   \              0x0140 0x045F
   \              0x044A 0x0140
   \              0x045F 0x044B
   \   00000528   0x0140 0x045F      DC16 320, 1119, 1100, 320, 1119, 1101, 320, 1119, 1102, 320, 1119, 1103
   \              0x044C 0x0140
   \              0x045F 0x044D
   \              0x0140 0x045F
   \              0x044E 0x0140
   \              0x045F 0x044F
   \   00000540   0x0140 0x045F      DC16 320, 1119, 1104, 320, 1119, 1105, 320, 1119, 1106, 320, 1119, 1107
   \              0x0450 0x0140
   \              0x045F 0x0451
   \              0x0140 0x045F
   \              0x0452 0x0140
   \              0x045F 0x0453
   \   00000558   0x0140 0x045F      DC16 320, 1119, 1108, 320, 1119, 1109, 320, 1119, 1110, 320, 1119, 1111
   \              0x0454 0x0140
   \              0x045F 0x0455
   \              0x0140 0x045F
   \              0x0456 0x0140
   \              0x045F 0x0457
   \   00000570   0x0140 0x045F      DC16 320, 1119, 1112, 320, 1119, 1113, 320, 1119, 1114, 320, 1119, 1115
   \              0x0458 0x0140
   \              0x045F 0x0459
   \              0x0140 0x045F
   \              0x045A 0x0140
   \              0x045F 0x045B
   \   00000588   0x0140 0x045F      DC16 320, 1119, 1116, 320, 1119, 1117, 320, 1119, 1118, 320, 1119, 1119
   \              0x045C 0x0140
   \              0x045F 0x045D
   \              0x0140 0x045F
   \              0x045E 0x0140
   \              0x045F 0x045F
   \   000005A0   0x0140 0x045F      DC16 320, 1119, 1120, 320, 1119, 1121, 320, 1119, 1122, 320, 1119, 1123
   \              0x0460 0x0140
   \              0x045F 0x0461
   \              0x0140 0x045F
   \              0x0462 0x0140
   \              0x045F 0x0463
   \   000005B8   0x0140 0x045F      DC16 320, 1119, 1124, 320, 1119, 1125, 320, 1119, 1126, 320, 1119, 1127
   \              0x0464 0x0140
   \              0x045F 0x0465
   \              0x0140 0x045F
   \              0x0466 0x0140
   \              0x045F 0x0467
   \   000005D0   0x0140 0x045F      DC16 320, 1119, 1128, 320, 1119, 1129, 320, 1119, 1130, 320, 1119, 1131
   \              0x0468 0x0140
   \              0x045F 0x0469
   \              0x0140 0x045F
   \              0x046A 0x0140
   \              0x045F 0x046B
   \   000005E8   0x0140 0x045F      DC16 320, 1119, 1132, 320, 1119, 1133, 320, 1119, 1134, 320, 1119, 1135
   \              0x046C 0x0140
   \              0x045F 0x046D
   \              0x0140 0x045F
   \              0x046E 0x0140
   \              0x045F 0x046F
   \   00000600   0x0140 0x045F      DC16 320, 1119, 1136, 320, 1119, 1137, 320, 1119, 1138, 320, 1119, 1139
   \              0x0470 0x0140
   \              0x045F 0x0471
   \              0x0140 0x045F
   \              0x0472 0x0140
   \              0x045F 0x0473
   \   00000618   0x0140 0x045F      DC16 320, 1119, 1140, 320, 1119, 1141, 320, 1119, 1142, 320, 1119, 1143
   \              0x0474 0x0140
   \              0x045F 0x0475
   \              0x0140 0x045F
   \              0x0476 0x0140
   \              0x045F 0x0477
   \   00000630   0x0140 0x045F      DC16 320, 1119, 1144, 320, 1119, 1145, 320, 1119, 1146, 320, 1120, 1147
   \              0x0478 0x0140
   \              0x045F 0x0479
   \              0x0140 0x045F
   \              0x047A 0x0140
   \              0x0460 0x047B
   \   00000648   0x0140 0x045F      DC16 320, 1119, 1148, 320, 1119, 1149, 320, 1119, 1150, 320, 1119, 1151
   \              0x047C 0x0140
   \              0x045F 0x047D
   \              0x0140 0x045F
   \              0x047E 0x0140
   \              0x045F 0x047F
   \   00000660   0x0140 0x045F      DC16 320, 1119, 1152, 320, 1119, 1153, 320, 1119, 1154, 320, 1119, 1155
   \              0x0480 0x0140
   \              0x045F 0x0481
   \              0x0140 0x045F
   \              0x0482 0x0140
   \              0x045F 0x0483
   \   00000678   0x0140 0x045F      DC16 320, 1119, 1156, 320, 1119, 1157, 320, 1119, 1158, 320, 1119, 1159
   \              0x0484 0x0140
   \              0x045F 0x0485
   \              0x0140 0x045F
   \              0x0486 0x0140
   \              0x045F 0x0487
   \   00000690   0x0140 0x045F      DC16 320, 1119, 1160, 320, 1119, 1161, 320, 1119, 1162, 320, 1119, 1163
   \              0x0488 0x0140
   \              0x045F 0x0489
   \              0x0140 0x045F
   \              0x048A 0x0140
   \              0x045F 0x048B
   \   000006A8   0x0140 0x045F      DC16 320, 1119, 1164, 320, 1119, 1165, 320, 1119, 1166, 320, 1119, 1167
   \              0x048C 0x0140
   \              0x045F 0x048D
   \              0x0140 0x045F
   \              0x048E 0x0140
   \              0x045F 0x048F
   \   000006C0   0x0140 0x045F      DC16 320, 1119, 1168, 320, 1119, 1169, 320, 1119, 1170, 320, 1119, 1171
   \              0x0490 0x0140
   \              0x045F 0x0491
   \              0x0140 0x045F
   \              0x0492 0x0140
   \              0x045F 0x0493
   \   000006D8   0x0140 0x045F      DC16 320, 1119, 1172, 320, 1119, 1173, 320, 1119, 1174, 320, 1119, 1175
   \              0x0494 0x0140
   \              0x045F 0x0495
   \              0x0140 0x045F
   \              0x0496 0x0140
   \              0x045F 0x0497
   \   000006F0   0x0140 0x045F      DC16 320, 1119, 1176, 320, 1119, 1177, 320, 1119, 1178, 320, 1119, 1179
   \              0x0498 0x0140
   \              0x045F 0x0499
   \              0x0140 0x045F
   \              0x049A 0x0140
   \              0x045F 0x049B
   \   00000708   0x0140 0x045F      DC16 320, 1119, 1180, 320, 1119, 1181, 320, 1119, 1182, 320, 1119, 1183
   \              0x049C 0x0140
   \              0x045F 0x049D
   \              0x0140 0x045F
   \              0x049E 0x0140
   \              0x045F 0x049F
   \   00000720   0x0140 0x045F      DC16 320, 1119, 1184, 320, 1119, 1185, 320, 1119, 1186, 320, 1119, 1187
   \              0x04A0 0x0140
   \              0x045F 0x04A1
   \              0x0140 0x045F
   \              0x04A2 0x0140
   \              0x045F 0x04A3
   \   00000738   0x0140 0x045F      DC16 320, 1119, 1188, 320, 1119, 1189, 320, 1119, 1190, 320, 1119, 1191
   \              0x04A4 0x0140
   \              0x045F 0x04A5
   \              0x0140 0x045F
   \              0x04A6 0x0140
   \              0x045F 0x04A7
   \   00000750   0x0140 0x045F      DC16 320, 1119, 1192, 320, 1119, 1193, 320, 1119, 1194, 320, 1119, 1195
   \              0x04A8 0x0140
   \              0x045F 0x04A9
   \              0x0140 0x045F
   \              0x04AA 0x0140
   \              0x045F 0x04AB
   \   00000768   0x0140 0x045F      DC16 320, 1119, 1196, 320, 1119, 1197, 320, 1119, 1198, 320, 1119, 1199
   \              0x04AC 0x0140
   \              0x045F 0x04AD
   \              0x0140 0x045F
   \              0x04AE 0x0140
   \              0x045F 0x04AF
   \   00000780   0x0140 0x045F      DC16 320, 1119, 1200, 320, 1119, 1201, 320, 1119, 1202, 320, 1119, 1203
   \              0x04B0 0x0140
   \              0x045F 0x04B1
   \              0x0140 0x045F
   \              0x04B2 0x0140
   \              0x045F 0x04B3
   \   00000798   0x0140 0x045F      DC16 320, 1119, 1204, 320, 1119, 1205, 320, 1119, 1206, 320, 1119, 1207
   \              0x04B4 0x0140
   \              0x045F 0x04B5
   \              0x0140 0x045F
   \              0x04B6 0x0140
   \              0x045F 0x04B7
   \   000007B0   0x0140 0x045F      DC16 320, 1119, 1208, 320, 1119, 1209, 320, 1119, 1210, 320, 1119, 1211
   \              0x04B8 0x0140
   \              0x045F 0x04B9
   \              0x0140 0x045F
   \              0x04BA 0x0140
   \              0x045F 0x04BB
   \   000007C8   0x0140 0x045F      DC16 320, 1119, 1212, 320, 1119, 1213, 320, 1119, 1214, 320, 1119, 1215
   \              0x04BC 0x0140
   \              0x045F 0x04BD
   \              0x0140 0x045F
   \              0x04BE 0x0140
   \              0x045F 0x04BF
   \   000007E0   0x0140 0x045F      DC16 320, 1119, 1216, 320, 1119, 1217, 320, 1119, 1218, 320, 1119, 1219
   \              0x04C0 0x0140
   \              0x045F 0x04C1
   \              0x0140 0x045F
   \              0x04C2 0x0140
   \              0x045F 0x04C3
   \   000007F8   0x0140 0x045F      DC16 320, 1119, 1220, 320, 1119, 1221, 320, 1119, 1222, 320, 1119, 1223
   \              0x04C4 0x0140
   \              0x045F 0x04C5
   \              0x0140 0x045F
   \              0x04C6 0x0140
   \              0x045F 0x04C7
   \   00000810   0x0140 0x045F      DC16 320, 1119, 1224, 320, 1119, 1225, 320, 1119, 1226, 320, 1119, 1227
   \              0x04C8 0x0140
   \              0x045F 0x04C9
   \              0x0140 0x045F
   \              0x04CA 0x0140
   \              0x045F 0x04CB
   \   00000828   0x0140 0x045F      DC16 320, 1119, 1228, 320, 1119, 1229, 320, 1119, 1230, 320, 1119, 1231
   \              0x04CC 0x0140
   \              0x045F 0x04CD
   \              0x0140 0x045F
   \              0x04CE 0x0140
   \              0x045F 0x04CF
   \   00000840   0x0140 0x045F      DC16 320, 1119, 1232, 320, 1119, 1233, 320, 1119, 1234, 320, 1119, 1235
   \              0x04D0 0x0140
   \              0x045F 0x04D1
   \              0x0140 0x045F
   \              0x04D2 0x0140
   \              0x045F 0x04D3
   \   00000858   0x0140 0x045F      DC16 320, 1119, 1236, 320, 1119, 1237, 320, 1119, 1238, 320, 1119, 1239
   \              0x04D4 0x0140
   \              0x045F 0x04D5
   \              0x0140 0x045F
   \              0x04D6 0x0140
   \              0x045F 0x04D7
   \   00000870   0x0140 0x045F      DC16 320, 1119, 1240, 320, 1119, 1241, 320, 1119, 1242, 320, 1119, 1243
   \              0x04D8 0x0140
   \              0x045F 0x04D9
   \              0x0140 0x045F
   \              0x04DA 0x0140
   \              0x045F 0x04DB
   \   00000888   0x0140 0x045F      DC16 320, 1119, 1244, 320, 1119, 1245, 320, 1119, 1246, 320, 1119, 1247
   \              0x04DC 0x0140
   \              0x045F 0x04DD
   \              0x0140 0x045F
   \              0x04DE 0x0140
   \              0x045F 0x04DF
   \   000008A0   0x0140 0x045F      DC16 320, 1119, 1248, 320, 1119, 1249, 320, 1119, 1250, 320, 1119, 1251
   \              0x04E0 0x0140
   \              0x045F 0x04E1
   \              0x0140 0x045F
   \              0x04E2 0x0140
   \              0x045F 0x04E3
   \   000008B8   0x0140 0x045F      DC16 320, 1119, 1252, 320, 1119, 1253, 320, 1119, 1254, 320, 1119, 1255
   \              0x04E4 0x0140
   \              0x045F 0x04E5
   \              0x0140 0x045F
   \              0x04E6 0x0140
   \              0x045F 0x04E7
   \   000008D0   0x0140 0x045F      DC16 320, 1119, 1256, 320, 1119, 1257, 320, 1119, 1258, 320, 1119, 1259
   \              0x04E8 0x0140
   \              0x045F 0x04E9
   \              0x0140 0x045F
   \              0x04EA 0x0140
   \              0x045F 0x04EB
   \   000008E8   0x0140 0x045F      DC16 320, 1119, 1260, 320, 1119, 1261, 320, 1119, 1262, 320, 1119, 1263
   \              0x04EC 0x0140
   \              0x045F 0x04ED
   \              0x0140 0x045F
   \              0x04EE 0x0140
   \              0x045F 0x04EF
   \   00000900   0x0140 0x045F      DC16 320, 1119, 1264, 320, 1119, 1265, 320, 1119, 1266, 320, 1119, 1267
   \              0x04F0 0x0140
   \              0x045F 0x04F1
   \              0x0140 0x045F
   \              0x04F2 0x0140
   \              0x045F 0x04F3
   \   00000918   0x0140 0x045F      DC16 320, 1119, 1268, 320, 1119, 1269, 320, 1119, 1270, 320, 1119, 1271
   \              0x04F4 0x0140
   \              0x045F 0x04F5
   \              0x0140 0x045F
   \              0x04F6 0x0140
   \              0x045F 0x04F7
   \   00000930   0x0140 0x045F      DC16 320, 1119, 1272, 320, 1119, 1273, 320, 1119, 1274, 320, 1119, 1275
   \              0x04F8 0x0140
   \              0x045F 0x04F9
   \              0x0140 0x045F
   \              0x04FA 0x0140
   \              0x045F 0x04FB
   \   00000948   0x0140 0x045F      DC16 320, 1119, 1276, 320, 1119, 1277, 320, 1119, 1278, 320, 1119, 1279
   \              0x04FC 0x0140
   \              0x045F 0x04FD
   \              0x0140 0x045F
   \              0x04FE 0x0140
   \              0x045F 0x04FF
   \   00000960   0x0140 0x045F      DC16 320, 1119, 1280, 320, 1119, 1281, 320, 1119, 1282, 320, 1119, 1283
   \              0x0500 0x0140
   \              0x045F 0x0501
   \              0x0140 0x045F
   \              0x0502 0x0140
   \              0x045F 0x0503
   \   00000978   0x0140 0x045F      DC16 320, 1119, 1284, 320, 1119, 1285, 320, 1119, 1286, 320, 1119, 1287
   \              0x0504 0x0140
   \              0x045F 0x0505
   \              0x0140 0x045F
   \              0x0506 0x0140
   \              0x045F 0x0507
   \   00000990   0x0140 0x045F      DC16 320, 1119, 1288, 320, 1119, 1289, 320, 1119, 1290, 320, 1119, 1291
   \              0x0508 0x0140
   \              0x045F 0x0509
   \              0x0140 0x045F
   \              0x050A 0x0140
   \              0x045F 0x050B
   \   000009A8   0x0140 0x045F      DC16 320, 1119, 1292, 320, 1119, 1293, 320, 1119, 1294, 320, 1119, 1295
   \              0x050C 0x0140
   \              0x045F 0x050D
   \              0x0140 0x045F
   \              0x050E 0x0140
   \              0x045F 0x050F
   \   000009C0   0x0140 0x045F      DC16 320, 1119, 1296, 320, 1119, 1297, 320, 1119, 1298, 320, 1119, 1299
   \              0x0510 0x0140
   \              0x045F 0x0511
   \              0x0140 0x045F
   \              0x0512 0x0140
   \              0x045F 0x0513
   \   000009D8   0x0140 0x045F      DC16 320, 1119, 1300, 320, 1119, 1301, 320, 1119, 1302, 320, 1119, 1303
   \              0x0514 0x0140
   \              0x045F 0x0515
   \              0x0140 0x045F
   \              0x0516 0x0140
   \              0x045F 0x0517
   \   000009F0   0x0140 0x045F      DC16 320, 1119, 1304, 320, 1119, 1305, 320, 1119, 1306, 320, 1119, 1307
   \              0x0518 0x0140
   \              0x045F 0x0519
   \              0x0140 0x045F
   \              0x051A 0x0140
   \              0x045F 0x051B
   \   00000A08   0x0140 0x045F      DC16 320, 1119, 1308, 320, 1119, 1309, 320, 1119, 1310, 320, 1119, 1311
   \              0x051C 0x0140
   \              0x045F 0x051D
   \              0x0140 0x045F
   \              0x051E 0x0140
   \              0x045F 0x051F
   \   00000A20   0x0140 0x045F      DC16 320, 1119, 1312, 320, 1119, 1313, 320, 1119, 1314, 320, 1119, 1315
   \              0x0520 0x0140
   \              0x045F 0x0521
   \              0x0140 0x045F
   \              0x0522 0x0140
   \              0x045F 0x0523
   \   00000A38   0x0140 0x045F      DC16 320, 1119, 1316, 320, 1119, 1317, 320, 1119, 1318, 320, 1119, 1319
   \              0x0524 0x0140
   \              0x045F 0x0525
   \              0x0140 0x045F
   \              0x0526 0x0140
   \              0x045F 0x0527
   \   00000A50   0x0140 0x045F      DC16 320, 1119, 1320, 320, 1119, 1321, 320, 1119, 1322, 320, 1119, 1323
   \              0x0528 0x0140
   \              0x045F 0x0529
   \              0x0140 0x045F
   \              0x052A 0x0140
   \              0x045F 0x052B
   \   00000A68   0x0140 0x045F      DC16 320, 1119, 1324, 320, 1119, 1325, 320, 1119, 1326, 320, 1119, 1327
   \              0x052C 0x0140
   \              0x045F 0x052D
   \              0x0140 0x045F
   \              0x052E 0x0140
   \              0x045F 0x052F
   \   00000A80   0x0140 0x045F      DC16 320, 1119, 1328, 320, 1119, 1329, 320, 1119, 1330, 320, 1119, 1331
   \              0x0530 0x0140
   \              0x045F 0x0531
   \              0x0140 0x045F
   \              0x0532 0x0140
   \              0x045F 0x0533
   \   00000A98   0x0140 0x045F      DC16 320, 1119, 1332, 320, 1119, 1333, 320, 1119, 1334, 320, 1119, 1335
   \              0x0534 0x0140
   \              0x045F 0x0535
   \              0x0140 0x045F
   \              0x0536 0x0140
   \              0x045F 0x0537
   \   00000AB0   0x0140 0x045F      DC16 320, 1119, 1336, 320, 1119, 1337, 320, 1119, 1338, 320, 1119, 1339
   \              0x0538 0x0140
   \              0x045F 0x0539
   \              0x0140 0x045F
   \              0x053A 0x0140
   \              0x045F 0x053B
   \   00000AC8   0x0140 0x045F      DC16 320, 1119, 1340, 320, 1119, 1341, 320, 1119, 1342, 320, 1119, 1343
   \              0x053C 0x0140
   \              0x045F 0x053D
   \              0x0140 0x045F
   \              0x053E 0x0140
   \              0x045F 0x053F
   \   00000AE0   0x0140 0x045F      DC16 320, 1119, 1344, 320, 1119, 1345, 320, 1119, 1346, 320, 1119, 1347
   \              0x0540 0x0140
   \              0x045F 0x0541
   \              0x0140 0x045F
   \              0x0542 0x0140
   \              0x045F 0x0543
   \   00000AF8   0x0140 0x045F      DC16 320, 1119, 1348, 320, 1119, 1349, 320, 1119, 1350, 320, 1119, 1351
   \              0x0544 0x0140
   \              0x045F 0x0545
   \              0x0140 0x045F
   \              0x0546 0x0140
   \              0x045F 0x0547
   \   00000B10   0x0140 0x045F      DC16 320, 1119, 1352, 320, 1119, 1353, 320, 1119, 1354, 320, 1119, 1355
   \              0x0548 0x0140
   \              0x045F 0x0549
   \              0x0140 0x045F
   \              0x054A 0x0140
   \              0x045F 0x054B
   \   00000B28   0x0140 0x045F      DC16 320, 1119, 1356, 320, 1119, 1357, 320, 1119, 1358, 320, 1119, 1359
   \              0x054C 0x0140
   \              0x045F 0x054D
   \              0x0140 0x045F
   \              0x054E 0x0140
   \              0x045F 0x054F
   \   00000B40   0x0140 0x045F      DC16 320, 1119, 1360, 320, 1119, 1361, 320, 1119, 1362, 320, 1119, 1363
   \              0x0550 0x0140
   \              0x045F 0x0551
   \              0x0140 0x045F
   \              0x0552 0x0140
   \              0x045F 0x0553
   \   00000B58   0x0140 0x045F      DC16 320, 1119, 1364, 320, 1119, 1365, 320, 1119, 1366, 320, 1119, 1367
   \              0x0554 0x0140
   \              0x045F 0x0555
   \              0x0140 0x045F
   \              0x0556 0x0140
   \              0x045F 0x0557
   \   00000B70   0x0140 0x045F      DC16 320, 1119, 1368, 320, 1119, 1369, 320, 1119, 1370, 320, 1119, 1371
   \              0x0558 0x0140
   \              0x045F 0x0559
   \              0x0140 0x045F
   \              0x055A 0x0140
   \              0x045F 0x055B
   \   00000B88   0x0140 0x045F      DC16 320, 1119, 1372, 320, 1119, 1373, 320, 1119, 1374, 320, 1119, 1375
   \              0x055C 0x0140
   \              0x045F 0x055D
   \              0x0140 0x045F
   \              0x055E 0x0140
   \              0x045F 0x055F
   \   00000BA0   0x0140 0x045F      DC16 320, 1119, 1376, 320, 1119, 1377, 320, 1119, 1378, 320, 1119, 1379
   \              0x0560 0x0140
   \              0x045F 0x0561
   \              0x0140 0x045F
   \              0x0562 0x0140
   \              0x045F 0x0563
   \   00000BB8   0x0140 0x045F      DC16 320, 1119, 1380, 320, 1119, 1381, 320, 1119, 1382, 320, 1119, 1383
   \              0x0564 0x0140
   \              0x045F 0x0565
   \              0x0140 0x045F
   \              0x0566 0x0140
   \              0x045F 0x0567
   \   00000BD0   0x0140 0x045F      DC16 320, 1119, 1384, 320, 1119, 1385, 320, 1119, 1386, 320, 1119, 1387
   \              0x0568 0x0140
   \              0x045F 0x0569
   \              0x0140 0x045F
   \              0x056A 0x0140
   \              0x045F 0x056B
   \   00000BE8   0x0140 0x045F      DC16 320, 1119, 1388, 320, 1119, 1389, 320, 1119, 1390, 320, 1119, 1391
   \              0x056C 0x0140
   \              0x045F 0x056D
   \              0x0140 0x045F
   \              0x056E 0x0140
   \              0x045F 0x056F
   \   00000C00   0x0140 0x045F      DC16 320, 1119, 1392, 320, 1119, 1393, 320, 1119, 1394, 320, 1119, 1395
   \              0x0570 0x0140
   \              0x045F 0x0571
   \              0x0140 0x045F
   \              0x0572 0x0140
   \              0x045F 0x0573
   \   00000C18   0x0140 0x045F      DC16 320, 1119, 1396, 320, 1119, 1397, 320, 1119, 1398, 320, 1119, 1399
   \              0x0574 0x0140
   \              0x045F 0x0575
   \              0x0140 0x045F
   \              0x0576 0x0140
   \              0x045F 0x0577
   \   00000C30   0x0140 0x045F      DC16 320, 1119, 1400, 320, 1119, 1401, 320, 1119, 1402, 320, 1119, 1403
   \              0x0578 0x0140
   \              0x045F 0x0579
   \              0x0140 0x045F
   \              0x057A 0x0140
   \              0x045F 0x057B
   \   00000C48   0x0140 0x045F      DC16 320, 1119, 1404, 320, 1119, 1405, 320, 1119, 1406, 320, 1119, 1407
   \              0x057C 0x0140
   \              0x045F 0x057D
   \              0x0140 0x045F
   \              0x057E 0x0140
   \              0x045F 0x057F
   \   00000C60   0x0140 0x045F      DC16 320, 1119, 1408, 320, 1119, 1409, 320, 1119, 1410, 320, 1119, 1411
   \              0x0580 0x0140
   \              0x045F 0x0581
   \              0x0140 0x045F
   \              0x0582 0x0140
   \              0x045F 0x0583
   \   00000C78   0x0140 0x045F      DC16 320, 1119, 1412, 320, 1120, 1413, 320, 1119, 1414, 320, 1119, 1415
   \              0x0584 0x0140
   \              0x0460 0x0585
   \              0x0140 0x045F
   \              0x0586 0x0140
   \              0x045F 0x0587
   \   00000C90   0x0140 0x045F      DC16 320, 1119, 1416, 320, 1119, 1417, 320, 1119, 1418, 320, 1119, 1419
   \              0x0588 0x0140
   \              0x045F 0x0589
   \              0x0140 0x045F
   \              0x058A 0x0140
   \              0x045F 0x058B
   \   00000CA8   0x0140 0x045F      DC16 320, 1119, 1420, 320, 1119, 1421, 320, 1119, 1422, 320, 1119, 1423
   \              0x058C 0x0140
   \              0x045F 0x058D
   \              0x0140 0x045F
   \              0x058E 0x0140
   \              0x045F 0x058F
   \   00000CC0   0x0140 0x045F      DC16 320, 1119, 1424, 320, 1119, 1425, 320, 1119, 1426, 320, 1119, 1427
   \              0x0590 0x0140
   \              0x045F 0x0591
   \              0x0140 0x045F
   \              0x0592 0x0140
   \              0x045F 0x0593
   \   00000CD8   0x0140 0x045F      DC16 320, 1119, 1428, 320, 1119, 1429, 320, 1119, 1430, 320, 1119, 1431
   \              0x0594 0x0140
   \              0x045F 0x0595
   \              0x0140 0x045F
   \              0x0596 0x0140
   \              0x045F 0x0597
   \   00000CF0   0x0140 0x045F      DC16 320, 1119, 1432, 320, 1119, 1433, 320, 1119, 1434, 320, 1119, 1435
   \              0x0598 0x0140
   \              0x045F 0x0599
   \              0x0140 0x045F
   \              0x059A 0x0140
   \              0x045F 0x059B
   \   00000D08   0x0140 0x045F      DC16 320, 1119, 1436, 320, 1119, 1437, 320, 1119, 1438, 320, 1119, 1439
   \              0x059C 0x0140
   \              0x045F 0x059D
   \              0x0140 0x045F
   \              0x059E 0x0140
   \              0x045F 0x059F
   \   00000D20   0x0140 0x045F      DC16 320, 1119, 1440, 320, 1119, 1441, 320, 1119, 1442, 320, 1119, 1443
   \              0x05A0 0x0140
   \              0x045F 0x05A1
   \              0x0140 0x045F
   \              0x05A2 0x0140
   \              0x045F 0x05A3
   \   00000D38   0x0140 0x045F      DC16 320, 1119, 1444, 320, 1119, 1445, 320, 1119, 1446, 320, 1119, 1447
   \              0x05A4 0x0140
   \              0x045F 0x05A5
   \              0x0140 0x045F
   \              0x05A6 0x0140
   \              0x045F 0x05A7
   \   00000D50   0x0140 0x045F      DC16 320, 1119, 1448, 320, 1119, 1449, 320, 1119, 1450, 320, 1119, 1451
   \              0x05A8 0x0140
   \              0x045F 0x05A9
   \              0x0140 0x045F
   \              0x05AA 0x0140
   \              0x045F 0x05AB
   \   00000D68   0x0140 0x045F      DC16 320, 1119, 1452, 320, 1119, 1453, 320, 1119, 1454, 320, 1119, 1455
   \              0x05AC 0x0140
   \              0x045F 0x05AD
   \              0x0140 0x045F
   \              0x05AE 0x0140
   \              0x045F 0x05AF
   \   00000D80   0x0140 0x045F      DC16 320, 1119, 1456, 320, 1119, 1457, 320, 1119, 1458, 320, 1119, 1459
   \              0x05B0 0x0140
   \              0x045F 0x05B1
   \              0x0140 0x045F
   \              0x05B2 0x0140
   \              0x045F 0x05B3
   \   00000D98   0x0140 0x045F      DC16 320, 1119, 1460, 320, 1119, 1461, 320, 1119, 1462, 320, 1119, 1463
   \              0x05B4 0x0140
   \              0x045F 0x05B5
   \              0x0140 0x045F
   \              0x05B6 0x0140
   \              0x045F 0x05B7
   \   00000DB0   0x0140 0x045F      DC16 320, 1119, 1464, 320, 1119, 1465, 320, 1119, 1466, 320, 1119, 1467
   \              0x05B8 0x0140
   \              0x045F 0x05B9
   \              0x0140 0x045F
   \              0x05BA 0x0140
   \              0x045F 0x05BB
   \   00000DC8   0x0140 0x045F      DC16 320, 1119, 1468, 320, 1119, 1469, 320, 1119, 1470, 320, 1119, 1471
   \              0x05BC 0x0140
   \              0x045F 0x05BD
   \              0x0140 0x045F
   \              0x05BE 0x0140
   \              0x045F 0x05BF
   \   00000DE0   0x0140 0x045F      DC16 320, 1119, 1472, 320, 1119, 1473, 320, 1119, 1474, 320, 1119, 1475
   \              0x05C0 0x0140
   \              0x045F 0x05C1
   \              0x0140 0x045F
   \              0x05C2 0x0140
   \              0x045F 0x05C3
   \   00000DF8   0x0140 0x045F      DC16 320, 1119, 1476, 320, 1119, 1477, 320, 1119, 1478, 320, 1119, 1479
   \              0x05C4 0x0140
   \              0x045F 0x05C5
   \              0x0140 0x045F
   \              0x05C6 0x0140
   \              0x045F 0x05C7
   \   00000E10   0x0140 0x045F      DC16 320, 1119, 1480, 320, 1119, 1481, 320, 1119, 1482, 320, 1119, 1483
   \              0x05C8 0x0140
   \              0x045F 0x05C9
   \              0x0140 0x045F
   \              0x05CA 0x0140
   \              0x045F 0x05CB
   \   00000E28   0x0140 0x045F      DC16 320, 1119, 1484, 320, 1119, 1485, 320, 1119, 1486, 320, 1119, 1487
   \              0x05CC 0x0140
   \              0x045F 0x05CD
   \              0x0140 0x045F
   \              0x05CE 0x0140
   \              0x045F 0x05CF
   \   00000E40   0x0140 0x045F      DC16 320, 1119, 1488, 320, 1119, 1489, 320, 1119, 1490, 320, 1119, 1491
   \              0x05D0 0x0140
   \              0x045F 0x05D1
   \              0x0140 0x045F
   \              0x05D2 0x0140
   \              0x045F 0x05D3
   \   00000E58   0x0140 0x045F      DC16 320, 1119, 1492, 320, 1119, 1493, 320, 1119, 1494, 320, 1119, 1495
   \              0x05D4 0x0140
   \              0x045F 0x05D5
   \              0x0140 0x045F
   \              0x05D6 0x0140
   \              0x045F 0x05D7
   \   00000E70   0x0140 0x045F      DC16 320, 1119, 1496, 320, 1119, 1497, 320, 1119, 1498, 320, 1119, 1499
   \              0x05D8 0x0140
   \              0x045F 0x05D9
   \              0x0140 0x045F
   \              0x05DA 0x0140
   \              0x045F 0x05DB
   \   00000E88   0x0140 0x045F      DC16 320, 1119, 1500, 320, 1119, 1501, 320, 1119, 1502, 320, 1119, 1503
   \              0x05DC 0x0140
   \              0x045F 0x05DD
   \              0x0140 0x045F
   \              0x05DE 0x0140
   \              0x045F 0x05DF
   \   00000EA0   0x0140 0x045F      DC16 320, 1119, 1504, 320, 1119, 1505, 320, 1119, 1506, 320, 1119, 1507
   \              0x05E0 0x0140
   \              0x045F 0x05E1
   \              0x0140 0x045F
   \              0x05E2 0x0140
   \              0x045F 0x05E3
   \   00000EB8   0x0140 0x045F      DC16 320, 1119, 1508, 320, 1119, 1509, 320, 1119, 1510, 320, 1119, 1511
   \              0x05E4 0x0140
   \              0x045F 0x05E5
   \              0x0140 0x045F
   \              0x05E6 0x0140
   \              0x045F 0x05E7
   \   00000ED0   0x0140 0x045F      DC16 320, 1119, 1512, 320, 1119, 1513, 320, 1119, 1514, 320, 1119, 1515
   \              0x05E8 0x0140
   \              0x045F 0x05E9
   \              0x0140 0x045F
   \              0x05EA 0x0140
   \              0x045F 0x05EB
   \   00000EE8   0x0140 0x045F      DC16 320, 1119, 1516, 320, 1119, 1517, 320, 1119, 1518, 320, 1119, 1519
   \              0x05EC 0x0140
   \              0x045F 0x05ED
   \              0x0140 0x045F
   \              0x05EE 0x0140
   \              0x045F 0x05EF
   \   00000F00   0x0140 0x045F      DC16 320, 1119, 1520, 320, 1119, 1521, 320, 1119, 1522, 320, 1119, 1523
   \              0x05F0 0x0140
   \              0x045F 0x05F1
   \              0x0140 0x045F
   \              0x05F2 0x0140
   \              0x045F 0x05F3
   \   00000F18   0x0140 0x045F      DC16 320, 1119, 1524, 320, 1119, 1525, 320, 1119, 1526, 320, 1119, 1527
   \              0x05F4 0x0140
   \              0x045F 0x05F5
   \              0x0140 0x045F
   \              0x05F6 0x0140
   \              0x045F 0x05F7
   \   00000F30   0x0140 0x045F      DC16 320, 1119, 1528, 320, 1119, 1529, 320, 1119, 1530, 320, 1119, 1531
   \              0x05F8 0x0140
   \              0x045F 0x05F9
   \              0x0140 0x045F
   \              0x05FA 0x0140
   \              0x045F 0x05FB
   \   00000F48   0x0140 0x045F      DC16 320, 1119, 1532, 320, 1119, 1533, 320, 1119, 1534, 320, 1119, 1535
   \              0x05FC 0x0140
   \              0x045F 0x05FD
   \              0x0140 0x045F
   \              0x05FE 0x0140
   \              0x045F 0x05FF
   \   00000F60   0x0140 0x045F      DC16 320, 1119, 1536, 320, 1119, 1537, 320, 1119, 1538, 320, 1119, 1539
   \              0x0600 0x0140
   \              0x045F 0x0601
   \              0x0140 0x045F
   \              0x0602 0x0140
   \              0x045F 0x0603
   \   00000F78   0x0140 0x045F      DC16 320, 1119, 1540, 320, 1119, 1541, 320, 1119, 1542, 320, 1119, 1543
   \              0x0604 0x0140
   \              0x045F 0x0605
   \              0x0140 0x045F
   \              0x0606 0x0140
   \              0x045F 0x0607
   \   00000F90   0x0140 0x045F      DC16 320, 1119, 1544, 320, 1119, 1545, 320, 1119, 1546, 320, 1119, 1547
   \              0x0608 0x0140
   \              0x045F 0x0609
   \              0x0140 0x045F
   \              0x060A 0x0140
   \              0x045F 0x060B
   \   00000FA8   0x0140 0x045F      DC16 320, 1119, 1548, 320, 1119, 1549, 320, 1119, 1550, 320, 1119, 1551
   \              0x060C 0x0140
   \              0x045F 0x060D
   \              0x0140 0x045F
   \              0x060E 0x0140
   \              0x045F 0x060F
   \   00000FC0   0x0140 0x045F      DC16 320, 1119, 1552, 320, 1119, 1553, 320, 1119, 1554, 320, 1119, 1555
   \              0x0610 0x0140
   \              0x045F 0x0611
   \              0x0140 0x045F
   \              0x0612 0x0140
   \              0x045F 0x0613
   \   00000FD8   0x0140 0x045F      DC16 320, 1119, 1556, 320, 1119, 1557, 320, 1119, 1558, 320, 1119, 1559
   \              0x0614 0x0140
   \              0x045F 0x0615
   \              0x0140 0x045F
   \              0x0616 0x0140
   \              0x045F 0x0617
   \   00000FF0   0x0140 0x045F      DC16 320, 1119, 1560, 320, 1119, 1561, 320, 1119, 1562, 320, 1119, 1563
   \              0x0618 0x0140
   \              0x045F 0x0619
   \              0x0140 0x045F
   \              0x061A 0x0140
   \              0x045F 0x061B
   \   00001008   0x0140 0x045F      DC16 320, 1119, 1564, 320, 1119, 1565, 320, 1119, 1566, 320, 1119, 1567
   \              0x061C 0x0140
   \              0x045F 0x061D
   \              0x0140 0x045F
   \              0x061E 0x0140
   \              0x045F 0x061F
   \   00001020   0x0140 0x045F      DC16 320, 1119, 1568, 320, 1119, 1569, 320, 1119, 1570, 320, 1119, 1571
   \              0x0620 0x0140
   \              0x045F 0x0621
   \              0x0140 0x045F
   \              0x0622 0x0140
   \              0x045F 0x0623
   \   00001038   0x0140 0x045F      DC16 320, 1119, 1572, 320, 1119, 1573, 320, 1119, 1574, 320, 1119, 1575
   \              0x0624 0x0140
   \              0x045F 0x0625
   \              0x0140 0x045F
   \              0x0626 0x0140
   \              0x045F 0x0627
   \   00001050   0x0140 0x045F      DC16 320, 1119, 1576, 320, 1119, 1577, 320, 1119, 1578, 320, 1119, 1579
   \              0x0628 0x0140
   \              0x045F 0x0629
   \              0x0140 0x045F
   \              0x062A 0x0140
   \              0x045F 0x062B
   \   00001068   0x0140 0x045F      DC16 320, 1119, 1580, 320, 1119, 1581, 320, 1119, 1582, 320, 1119, 1583
   \              0x062C 0x0140
   \              0x045F 0x062D
   \              0x0140 0x045F
   \              0x062E 0x0140
   \              0x045F 0x062F
   \   00001080   0x0140 0x045F      DC16 320, 1119, 1584, 320, 1119, 1585, 320, 1119, 1586, 320, 1119, 1587
   \              0x0630 0x0140
   \              0x045F 0x0631
   \              0x0140 0x045F
   \              0x0632 0x0140
   \              0x045F 0x0633
   \   00001098   0x0140 0x045F      DC16 320, 1119, 1588, 320, 1119, 1589, 320, 1119, 1590, 320, 1119, 1591
   \              0x0634 0x0140
   \              0x045F 0x0635
   \              0x0140 0x045F
   \              0x0636 0x0140
   \              0x045F 0x0637
   \   000010B0   0x0140 0x045F      DC16 320, 1119, 1592, 320, 1119, 1593, 320, 1119, 1594, 320, 1119, 1595
   \              0x0638 0x0140
   \              0x045F 0x0639
   \              0x0140 0x045F
   \              0x063A 0x0140
   \              0x045F 0x063B
   \   000010C8   0x0140 0x045F      DC16 320, 1119, 1596, 320, 1119, 1597, 320, 1119, 1598, 320, 1119, 1599
   \              0x063C 0x0140
   \              0x045F 0x063D
   \              0x0140 0x045F
   \              0x063E 0x0140
   \              0x045F 0x063F
   \   000010E0   0x0140 0x045F      DC16 320, 1119, 1600, 320, 1119, 1601, 320, 1119, 1602, 320, 1119, 1603
   \              0x0640 0x0140
   \              0x045F 0x0641
   \              0x0140 0x045F
   \              0x0642 0x0140
   \              0x045F 0x0643
   \   000010F8   0x0140 0x045F      DC16 320, 1119, 1604, 320, 1119, 1605, 320, 1119, 1606, 320, 1119, 1607
   \              0x0644 0x0140
   \              0x045F 0x0645
   \              0x0140 0x045F
   \              0x0646 0x0140
   \              0x045F 0x0647
   \   00001110   0x0140 0x045F      DC16 320, 1119, 1608, 320, 1119, 1609, 320, 1119, 1610, 320, 1119, 1611
   \              0x0648 0x0140
   \              0x045F 0x0649
   \              0x0140 0x045F
   \              0x064A 0x0140
   \              0x045F 0x064B
   \   00001128   0x0140 0x045F      DC16 320, 1119, 1612, 320, 1119, 1613, 320, 1119, 1614, 320, 1119, 1615
   \              0x064C 0x0140
   \              0x045F 0x064D
   \              0x0140 0x045F
   \              0x064E 0x0140
   \              0x045F 0x064F
   \   00001140   0x0140 0x045F      DC16 320, 1119, 1616, 320, 1119, 1617, 320, 1119, 1618, 320, 1119, 1619
   \              0x0650 0x0140
   \              0x045F 0x0651
   \              0x0140 0x045F
   \              0x0652 0x0140
   \              0x045F 0x0653
   \   00001158   0x0140 0x045F      DC16 320, 1119, 1620, 320, 1119, 1621, 320, 1119, 1622, 320, 1119, 1623
   \              0x0654 0x0140
   \              0x045F 0x0655
   \              0x0140 0x045F
   \              0x0656 0x0140
   \              0x045F 0x0657
   \   00001170   0x0140 0x045F      DC16 320, 1119, 1624, 320, 1119, 1625, 320, 1119, 1626, 320, 1119, 1627
   \              0x0658 0x0140
   \              0x045F 0x0659
   \              0x0140 0x045F
   \              0x065A 0x0140
   \              0x045F 0x065B
   \   00001188   0x0140 0x045F      DC16 320, 1119, 1628, 320, 1119, 1629, 320, 1119, 1630, 320, 1119, 1631
   \              0x065C 0x0140
   \              0x045F 0x065D
   \              0x0140 0x045F
   \              0x065E 0x0140
   \              0x045F 0x065F
   \   000011A0   0x0140 0x045F      DC16 320, 1119, 1632, 320, 1119, 1633, 320, 1119, 1634, 320, 1119, 1635
   \              0x0660 0x0140
   \              0x045F 0x0661
   \              0x0140 0x045F
   \              0x0662 0x0140
   \              0x045F 0x0663
   \   000011B8   0x0140 0x045F      DC16 320, 1119, 1636, 320, 1119, 1637, 320, 1119, 1638, 320, 1119, 1639
   \              0x0664 0x0140
   \              0x045F 0x0665
   \              0x0140 0x045F
   \              0x0666 0x0140
   \              0x045F 0x0667
   \   000011D0   0x0140 0x045F      DC16 320, 1119, 1640, 320, 1119, 1641, 320, 1119, 1642, 320, 1119, 1643
   \              0x0668 0x0140
   \              0x045F 0x0669
   \              0x0140 0x045F
   \              0x066A 0x0140
   \              0x045F 0x066B
   \   000011E8   0x0140 0x045F      DC16 320, 1119, 1644, 320, 1119, 1645, 320, 1119, 1646, 320, 1119, 1647
   \              0x066C 0x0140
   \              0x045F 0x066D
   \              0x0140 0x045F
   \              0x066E 0x0140
   \              0x045F 0x066F
   \   00001200   0x0140 0x045F      DC16 320, 1119, 1648, 320, 1119, 1649, 320, 1119, 1650, 320, 1119, 1651
   \              0x0670 0x0140
   \              0x045F 0x0671
   \              0x0140 0x045F
   \              0x0672 0x0140
   \              0x045F 0x0673
   \   00001218   0x0140 0x045F      DC16 320, 1119, 1652, 320, 1119, 1653, 320, 1119, 1654, 320, 1119, 1655
   \              0x0674 0x0140
   \              0x045F 0x0675
   \              0x0140 0x045F
   \              0x0676 0x0140
   \              0x045F 0x0677
   \   00001230   0x0140 0x045F      DC16 320, 1119, 1656, 320, 1119, 1657, 320, 1119, 1658, 320, 1119, 1659
   \              0x0678 0x0140
   \              0x045F 0x0679
   \              0x0140 0x045F
   \              0x067A 0x0140
   \              0x045F 0x067B
   \   00001248   0x0140 0x045F      DC16 320, 1119, 1660, 320, 1119, 1661, 320, 1119, 1662, 320, 1119, 1663
   \              0x067C 0x0140
   \              0x045F 0x067D
   \              0x0140 0x045F
   \              0x067E 0x0140
   \              0x045F 0x067F
   \   00001260   0x0140 0x045F      DC16 320, 1119, 1664, 320, 1119, 1665, 320, 1119, 1666, 320, 1119, 1667
   \              0x0680 0x0140
   \              0x045F 0x0681
   \              0x0140 0x045F
   \              0x0682 0x0140
   \              0x045F 0x0683
   \   00001278   0x0140 0x045F      DC16 320, 1119, 1668, 320, 1119, 1669, 320, 1119, 1670, 320, 1119, 1671
   \              0x0684 0x0140
   \              0x045F 0x0685
   \              0x0140 0x045F
   \              0x0686 0x0140
   \              0x045F 0x0687
   \   00001290   0x0140 0x045F      DC16 320, 1119, 1672, 320, 1119, 1673, 320, 1119, 1674, 320, 1119, 1675
   \              0x0688 0x0140
   \              0x045F 0x0689
   \              0x0140 0x045F
   \              0x068A 0x0140
   \              0x045F 0x068B
   \   000012A8   0x0140 0x045F      DC16 320, 1119, 1676, 320, 1119, 1677, 320, 1119, 1678, 320, 1119, 1679
   \              0x068C 0x0140
   \              0x045F 0x068D
   \              0x0140 0x045F
   \              0x068E 0x0140
   \              0x045F 0x068F

   \                                 In section .text, align 4, keep-with-next
   \   static __absolute unsigned short const exposure_bmp_data_circle[1000][3]
   \                     exposure_bmp_data_circle:
   \   00000000   0x02D0 0x02D0      DC16 720, 720, 780, 690, 750, 781, 681, 759, 782, 673, 767, 783, 665
   \              0x030C 0x02B2
   \              0x02EE 0x030D
   \              0x02A9 0x02F7
   \              0x030E 0x02A1
   \              0x02FF 0x030F
   \              0x0299       
   \   0000001A   0x0307 0x0310      DC16 775, 784, 656, 784, 785, 648, 792, 786, 639, 801, 787, 632, 808
   \              0x0290 0x0310
   \              0x0311 0x0288
   \              0x0318 0x0312
   \              0x027F 0x0321
   \              0x0313 0x0278
   \              0x0328       
   \   00000034   0x0314 0x0273      DC16 788, 627, 813, 789, 623, 817, 790, 619, 821, 791, 615, 825, 792
   \              0x032D 0x0315
   \              0x026F 0x0331
   \              0x0316 0x026B
   \              0x0335 0x0317
   \              0x0267 0x0339
   \              0x0318       
   \   0000004E   0x0263 0x033D      DC16 611, 829, 793, 607, 833, 794, 603, 837, 795, 598, 842, 796, 594
   \              0x0319 0x025F
   \              0x0341 0x031A
   \              0x025B 0x0345
   \              0x031B 0x0256
   \              0x034A 0x031C
   \              0x0252       
   \   00000068   0x034E 0x031D      DC16 846, 797, 590, 850, 798, 586, 854, 799, 582, 858, 800, 578, 862
   \              0x024E 0x0352
   \              0x031E 0x024A
   \              0x0356 0x031F
   \              0x0246 0x035A
   \              0x0320 0x0242
   \              0x035E       
   \   00000082   0x0321 0x023E      DC16 801, 574, 866, 802, 571, 869, 803, 569, 871, 804, 566, 874, 805
   \              0x0362 0x0322
   \              0x023B 0x0365
   \              0x0323 0x0239
   \              0x0367 0x0324
   \              0x0236 0x036A
   \              0x0325       
   \   0000009C   0x0233 0x036D      DC16 563, 877, 806, 560, 880, 807, 558, 882, 808, 555, 885, 809, 552
   \              0x0326 0x0230
   \              0x0370 0x0327
   \              0x022E 0x0372
   \              0x0328 0x022B
   \              0x0375 0x0329
   \              0x0228       
   \   000000B6   0x0378 0x032A      DC16 888, 810, 550, 890, 811, 547, 893, 812, 544, 896, 813, 542, 898
   \              0x0226 0x037A
   \              0x032B 0x0223
   \              0x037D 0x032C
   \              0x0220 0x0380
   \              0x032D 0x021E
   \              0x0382       
   \   000000D0   0x032E 0x021B      DC16 814, 539, 901, 815, 536, 904, 816, 534, 906, 817, 531, 909, 818
   \              0x0385 0x032F
   \              0x0218 0x0388
   \              0x0330 0x0216
   \              0x038A 0x0331
   \              0x0213 0x038D
   \              0x0332       
   \   000000EA   0x0210 0x0390      DC16 528, 912, 819, 525, 915, 820, 523, 917, 821, 520, 920, 822, 518
   \              0x0333 0x020D
   \              0x0393 0x0334
   \              0x020B 0x0395
   \              0x0335 0x0208
   \              0x0398 0x0336
   \              0x0206       
   \   00000104   0x039A 0x0337      DC16 922, 823, 516, 924, 824, 514, 926, 825, 512, 928, 826, 510, 930
   \              0x0204 0x039C
   \              0x0338 0x0202
   \              0x039E 0x0339
   \              0x0200 0x03A0
   \              0x033A 0x01FE
   \              0x03A2       
   \   0000011E   0x033B 0x01FC      DC16 827, 508, 932, 828, 506, 934, 829, 504, 936, 830, 502, 938, 831
   \              0x03A4 0x033C
   \              0x01FA 0x03A6
   \              0x033D 0x01F8
   \              0x03A8 0x033E
   \              0x01F6 0x03AA
   \              0x033F       
   \   00000138   0x01F4 0x03AC      DC16 500, 940, 832, 498, 942, 833, 496, 944, 834, 494, 946, 835, 492
   \              0x0340 0x01F2
   \              0x03AE 0x0341
   \              0x01F0 0x03B0
   \              0x0342 0x01EE
   \              0x03B2 0x0343
   \              0x01EC       
   \   00000152   0x03B4 0x0344      DC16 948, 836, 491, 949, 837, 489, 951, 838, 487, 953, 839, 485, 955
   \              0x01EB 0x03B5
   \              0x0345 0x01E9
   \              0x03B7 0x0346
   \              0x01E7 0x03B9
   \              0x0347 0x01E5
   \              0x03BB       
   \   0000016C   0x0348 0x01E3      DC16 840, 483, 957, 841, 481, 959, 842, 479, 961, 843, 477, 963, 844
   \              0x03BD 0x0349
   \              0x01E1 0x03BF
   \              0x034A 0x01DF
   \              0x03C1 0x034B
   \              0x01DD 0x03C3
   \              0x034C       
   \   00000186   0x01DB 0x03C5      DC16 475, 965, 845, 473, 967, 846, 471, 969, 847, 469, 971, 848, 467
   \              0x034D 0x01D9
   \              0x03C7 0x034E
   \              0x01D7 0x03C9
   \              0x034F 0x01D5
   \              0x03CB 0x0350
   \              0x01D3       
   \   000001A0   0x03CD 0x0351      DC16 973, 849, 465, 975, 850, 464, 976, 851, 462, 978, 852, 461, 979
   \              0x01D1 0x03CF
   \              0x0352 0x01D0
   \              0x03D0 0x0353
   \              0x01CE 0x03D2
   \              0x0354 0x01CD
   \              0x03D3       
   \   000001BA   0x0355 0x01CC      DC16 853, 460, 980, 854, 458, 982, 855, 457, 983, 856, 455, 985, 857
   \              0x03D4 0x0356
   \              0x01CA 0x03D6
   \              0x0357 0x01C9
   \              0x03D7 0x0358
   \              0x01C7 0x03D9
   \              0x0359       
   \   000001D4   0x01C6 0x03DA      DC16 454, 986, 858, 452, 988, 859, 451, 989, 860, 449, 991, 861, 448
   \              0x035A 0x01C4
   \              0x03DC 0x035B
   \              0x01C3 0x03DD
   \              0x035C 0x01C1
   \              0x03DF 0x035D
   \              0x01C0       
   \   000001EE   0x03E0 0x035E      DC16 992, 862, 446, 994, 863, 445, 995, 864, 443, 997, 865, 442, 998
   \              0x01BE 0x03E2
   \              0x035F 0x01BD
   \              0x03E3 0x0360
   \              0x01BB 0x03E5
   \              0x0361 0x01BA
   \              0x03E6       
   \   00000208   0x0362 0x01B8      DC16 866, 440, 1000, 867, 439, 1001, 868, 437, 1003, 869, 436, 1004
   \              0x03E8 0x0363
   \              0x01B7 0x03E9
   \              0x0364 0x01B5
   \              0x03EB 0x0365
   \              0x01B4 0x03EC
   \   00000220   0x0366 0x01B2      DC16 870, 434, 1006, 871, 433, 1007, 872, 431, 1009, 873, 430, 1010
   \              0x03EE 0x0367
   \              0x01B1 0x03EF
   \              0x0368 0x01AF
   \              0x03F1 0x0369
   \              0x01AE 0x03F2
   \   00000238   0x036A 0x01AC      DC16 874, 428, 1012, 875, 427, 1013, 876, 425, 1015, 877, 424, 1016
   \              0x03F4 0x036B
   \              0x01AB 0x03F5
   \              0x036C 0x01A9
   \              0x03F7 0x036D
   \              0x01A8 0x03F8
   \   00000250   0x036E 0x01A6      DC16 878, 422, 1018, 879, 421, 1019, 880, 419, 1021, 881, 418, 1022
   \              0x03FA 0x036F
   \              0x01A5 0x03FB
   \              0x0370 0x01A3
   \              0x03FD 0x0371
   \              0x01A2 0x03FE
   \   00000268   0x0372 0x01A1      DC16 882, 417, 1023, 883, 415, 1025, 884, 414, 1026, 885, 413, 1027
   \              0x03FF 0x0373
   \              0x019F 0x0401
   \              0x0374 0x019E
   \              0x0402 0x0375
   \              0x019D 0x0403
   \   00000280   0x0376 0x019C      DC16 886, 412, 1028, 887, 411, 1029, 888, 410, 1030, 889, 408, 1032
   \              0x0404 0x0377
   \              0x019B 0x0405
   \              0x0378 0x019A
   \              0x0406 0x0379
   \              0x0198 0x0408
   \   00000298   0x037A 0x0197      DC16 890, 407, 1033, 891, 406, 1034, 892, 405, 1035, 893, 404, 1036
   \              0x0409 0x037B
   \              0x0196 0x040A
   \              0x037C 0x0195
   \              0x040B 0x037D
   \              0x0194 0x040C
   \   000002B0   0x037E 0x0193      DC16 894, 403, 1037, 895, 402, 1038, 896, 400, 1040, 897, 399, 1041
   \              0x040D 0x037F
   \              0x0192 0x040E
   \              0x0380 0x0190
   \              0x0410 0x0381
   \              0x018F 0x0411
   \   000002C8   0x0382 0x018E      DC16 898, 398, 1042, 899, 397, 1043, 900, 396, 1044, 901, 395, 1045
   \              0x0412 0x0383
   \              0x018D 0x0413
   \              0x0384 0x018C
   \              0x0414 0x0385
   \              0x018B 0x0415
   \   000002E0   0x0386 0x0189      DC16 902, 393, 1047, 903, 392, 1048, 904, 391, 1049, 905, 390, 1050
   \              0x0417 0x0387
   \              0x0188 0x0418
   \              0x0388 0x0187
   \              0x0419 0x0389
   \              0x0186 0x041A
   \   000002F8   0x038A 0x0185      DC16 906, 389, 1051, 907, 388, 1052, 908, 386, 1054, 909, 385, 1055
   \              0x041B 0x038B
   \              0x0184 0x041C
   \              0x038C 0x0182
   \              0x041E 0x038D
   \              0x0181 0x041F
   \   00000310   0x038E 0x0180      DC16 910, 384, 1056, 911, 383, 1057, 912, 382, 1058, 913, 381, 1059
   \              0x0420 0x038F
   \              0x017F 0x0421
   \              0x0390 0x017E
   \              0x0422 0x0391
   \              0x017D 0x0423
   \   00000328   0x0392 0x017B      DC16 914, 379, 1061, 915, 378, 1062, 916, 377, 1063, 917, 376, 1064
   \              0x0425 0x0393
   \              0x017A 0x0426
   \              0x0394 0x0179
   \              0x0427 0x0395
   \              0x0178 0x0428
   \   00000340   0x0396 0x0177      DC16 918, 375, 1065, 919, 374, 1066, 920, 372, 1067, 921, 372, 1068
   \              0x0429 0x0397
   \              0x0176 0x042A
   \              0x0398 0x0174
   \              0x042B 0x0399
   \              0x0174 0x042C
   \   00000358   0x039A 0x0173      DC16 922, 371, 1069, 923, 370, 1070, 924, 369, 1071, 925, 368, 1072
   \              0x042D 0x039B
   \              0x0172 0x042E
   \              0x039C 0x0171
   \              0x042F 0x039D
   \              0x0170 0x0430
   \   00000370   0x039E 0x016F      DC16 926, 367, 1073, 927, 366, 1074, 928, 365, 1075, 929, 364, 1076
   \              0x0431 0x039F
   \              0x016E 0x0432
   \              0x03A0 0x016D
   \              0x0433 0x03A1
   \              0x016C 0x0434
   \   00000388   0x03A2 0x016B      DC16 930, 363, 1077, 931, 362, 1078, 932, 361, 1079, 933, 361, 1079
   \              0x0435 0x03A3
   \              0x016A 0x0436
   \              0x03A4 0x0169
   \              0x0437 0x03A5
   \              0x0169 0x0437
   \   000003A0   0x03A6 0x0168      DC16 934, 360, 1080, 935, 359, 1081, 936, 358, 1082, 937, 357, 1083
   \              0x0438 0x03A7
   \              0x0167 0x0439
   \              0x03A8 0x0166
   \              0x043A 0x03A9
   \              0x0165 0x043B
   \   000003B8   0x03AA 0x0164      DC16 938, 356, 1084, 939, 355, 1085, 940, 354, 1086, 941, 353, 1087
   \              0x043C 0x03AB
   \              0x0163 0x043D
   \              0x03AC 0x0162
   \              0x043E 0x03AD
   \              0x0161 0x043F
   \   000003D0   0x03AE 0x0160      DC16 942, 352, 1088, 943, 351, 1089, 944, 350, 1090, 945, 350, 1090
   \              0x0440 0x03AF
   \              0x015F 0x0441
   \              0x03B0 0x015E
   \              0x0442 0x03B1
   \              0x015E 0x0442
   \   000003E8   0x03B2 0x015D      DC16 946, 349, 1091, 947, 348, 1092, 948, 347, 1093, 949, 346, 1094
   \              0x0443 0x03B3
   \              0x015C 0x0444
   \              0x03B4 0x015B
   \              0x0445 0x03B5
   \              0x015A 0x0446
   \   00000400   0x03B6 0x0159      DC16 950, 345, 1095, 951, 344, 1096, 952, 343, 1097, 953, 342, 1098
   \              0x0447 0x03B7
   \              0x0158 0x0448
   \              0x03B8 0x0157
   \              0x0449 0x03B9
   \              0x0156 0x044A
   \   00000418   0x03BA 0x0155      DC16 954, 341, 1099, 955, 340, 1100, 956, 339, 1100, 957, 339, 1101
   \              0x044B 0x03BB
   \              0x0154 0x044C
   \              0x03BC 0x0153
   \              0x044C 0x03BD
   \              0x0153 0x044D
   \   00000430   0x03BE 0x0152      DC16 958, 338, 1102, 959, 337, 1103, 960, 336, 1104, 961, 335, 1105
   \              0x044E 0x03BF
   \              0x0151 0x044F
   \              0x03C0 0x0150
   \              0x0450 0x03C1
   \              0x014F 0x0451
   \   00000448   0x03C2 0x014E      DC16 962, 334, 1106, 963, 333, 1107, 964, 332, 1108, 965, 331, 1108
   \              0x0452 0x03C3
   \              0x014D 0x0453
   \              0x03C4 0x014C
   \              0x0454 0x03C5
   \              0x014B 0x0454
   \   00000460   0x03C6 0x014B      DC16 966, 331, 1109, 967, 330, 1110, 968, 329, 1111, 969, 329, 1111
   \              0x0455 0x03C7
   \              0x014A 0x0456
   \              0x03C8 0x0149
   \              0x0457 0x03C9
   \              0x0149 0x0457
   \   00000478   0x03CA 0x0148      DC16 970, 328, 1112, 971, 327, 1113, 972, 326, 1114, 973, 326, 1114
   \              0x0458 0x03CB
   \              0x0147 0x0459
   \              0x03CC 0x0146
   \              0x045A 0x03CD
   \              0x0146 0x045A
   \   00000490   0x03CE 0x0145      DC16 974, 325, 1115, 975, 324, 1116, 976, 324, 1116, 977, 323, 1117
   \              0x045B 0x03CF
   \              0x0144 0x045C
   \              0x03D0 0x0144
   \              0x045C 0x03D1
   \              0x0143 0x045D
   \   000004A8   0x03D2 0x0142      DC16 978, 322, 1118, 979, 321, 1119, 980, 321, 1119, 981, 320, 1120
   \              0x045E 0x03D3
   \              0x0141 0x045F
   \              0x03D4 0x0141
   \              0x045F 0x03D5
   \              0x0140 0x0460
   \   000004C0   0x03D6 0x013F      DC16 982, 319, 1121, 983, 319, 1121, 984, 318, 1122, 985, 317, 1123
   \              0x0461 0x03D7
   \              0x013F 0x0461
   \              0x03D8 0x013E
   \              0x0462 0x03D9
   \              0x013D 0x0463
   \   000004D8   0x03DA 0x013C      DC16 986, 316, 1124, 987, 316, 1124, 988, 315, 1125, 989, 314, 1126
   \              0x0464 0x03DB
   \              0x013C 0x0464
   \              0x03DC 0x013B
   \              0x0465 0x03DD
   \              0x013A 0x0466
   \   000004F0   0x03DE 0x013A      DC16 990, 314, 1126, 991, 313, 1127, 992, 312, 1128, 993, 311, 1129
   \              0x0466 0x03DF
   \              0x0139 0x0467
   \              0x03E0 0x0138
   \              0x0468 0x03E1
   \              0x0137 0x0469
   \   00000508   0x03E2 0x0137      DC16 994, 311, 1129, 995, 310, 1130, 996, 309, 1131, 997, 309, 1131
   \              0x0469 0x03E3
   \              0x0136 0x046A
   \              0x03E4 0x0135
   \              0x046B 0x03E5
   \              0x0135 0x046B
   \   00000520   0x03E6 0x0134      DC16 998, 308, 1132, 999, 307, 1133, 1000, 306, 1134, 1001, 306, 1134
   \              0x046C 0x03E7
   \              0x0133 0x046D
   \              0x03E8 0x0132
   \              0x046E 0x03E9
   \              0x0132 0x046E
   \   00000538   0x03EA 0x0131      DC16 1002, 305, 1135, 1003, 304, 1136, 1004, 303, 1136, 1005, 303, 1137
   \              0x046F 0x03EB
   \              0x0130 0x0470
   \              0x03EC 0x012F
   \              0x0470 0x03ED
   \              0x012F 0x0471
   \   00000550   0x03EE 0x012E      DC16 1006, 302, 1138, 1007, 301, 1139, 1008, 301, 1139, 1009, 300, 1140
   \              0x0472 0x03EF
   \              0x012D 0x0473
   \              0x03F0 0x012D
   \              0x0473 0x03F1
   \              0x012C 0x0474
   \   00000568   0x03F2 0x012B      DC16 1010, 299, 1141, 1011, 298, 1142, 1012, 298, 1142, 1013, 297, 1143
   \              0x0475 0x03F3
   \              0x012A 0x0476
   \              0x03F4 0x012A
   \              0x0476 0x03F5
   \              0x0129 0x0477
   \   00000580   0x03F6 0x0129      DC16 1014, 297, 1143, 1015, 296, 1144, 1016, 296, 1144, 1017, 295, 1145
   \              0x0477 0x03F7
   \              0x0128 0x0478
   \              0x03F8 0x0128
   \              0x0478 0x03F9
   \              0x0127 0x0479
   \   00000598   0x03FA 0x0126      DC16 1018, 294, 1146, 1019, 294, 1146, 1020, 293, 1147, 1021, 293, 1147
   \              0x047A 0x03FB
   \              0x0126 0x047A
   \              0x03FC 0x0125
   \              0x047B 0x03FD
   \              0x0125 0x047B
   \   000005B0   0x03FE 0x0124      DC16 1022, 292, 1148, 1023, 292, 1148, 1024, 291, 1149, 1025, 291, 1149
   \              0x047C 0x03FF
   \              0x0124 0x047C
   \              0x0400 0x0123
   \              0x047D 0x0401
   \              0x0123 0x047D
   \   000005C8   0x0402 0x0122      DC16 1026, 290, 1150, 1027, 289, 1151, 1028, 289, 1151, 1029, 288, 1152
   \              0x047E 0x0403
   \              0x0121 0x047F
   \              0x0404 0x0121
   \              0x047F 0x0405
   \              0x0120 0x0480
   \   000005E0   0x0406 0x0120      DC16 1030, 288, 1152, 1031, 287, 1153, 1032, 287, 1153, 1033, 286, 1154
   \              0x0480 0x0407
   \              0x011F 0x0481
   \              0x0408 0x011F
   \              0x0481 0x0409
   \              0x011E 0x0482
   \   000005F8   0x040A 0x011E      DC16 1034, 286, 1154, 1035, 285, 1155, 1036, 285, 1155, 1037, 284, 1156
   \              0x0482 0x040B
   \              0x011D 0x0483
   \              0x040C 0x011D
   \              0x0483 0x040D
   \              0x011C 0x0484
   \   00000610   0x040E 0x011B      DC16 1038, 283, 1157, 1039, 283, 1157, 1040, 282, 1158, 1041, 282, 1158
   \              0x0485 0x040F
   \              0x011B 0x0485
   \              0x0410 0x011A
   \              0x0486 0x0411
   \              0x011A 0x0486
   \   00000628   0x0412 0x0119      DC16 1042, 281, 1159, 1043, 281, 1159, 1044, 280, 1160, 1045, 280, 1160
   \              0x0487 0x0413
   \              0x0119 0x0487
   \              0x0414 0x0118
   \              0x0488 0x0415
   \              0x0118 0x0488
   \   00000640   0x0416 0x0117      DC16 1046, 279, 1161, 1047, 278, 1162, 1048, 278, 1162, 1049, 277, 1163
   \              0x0489 0x0417
   \              0x0116 0x048A
   \              0x0418 0x0116
   \              0x048A 0x0419
   \              0x0115 0x048B
   \   00000658   0x041A 0x0115      DC16 1050, 277, 1163, 1051, 276, 1164, 1052, 276, 1164, 1053, 275, 1165
   \              0x048B 0x041B
   \              0x0114 0x048C
   \              0x041C 0x0114
   \              0x048C 0x041D
   \              0x0113 0x048D
   \   00000670   0x041E 0x0113      DC16 1054, 275, 1165, 1055, 274, 1166, 1056, 273, 1167, 1057, 273, 1167
   \              0x048D 0x041F
   \              0x0112 0x048E
   \              0x0420 0x0111
   \              0x048F 0x0421
   \              0x0111 0x048F
   \   00000688   0x0422 0x0110      DC16 1058, 272, 1168, 1059, 272, 1168, 1060, 271, 1169, 1061, 271, 1169
   \              0x0490 0x0423
   \              0x0110 0x0490
   \              0x0424 0x010F
   \              0x0491 0x0425
   \              0x010F 0x0491
   \   000006A0   0x0426 0x010E      DC16 1062, 270, 1170, 1063, 270, 1170, 1064, 269, 1171, 1065, 269, 1171
   \              0x0492 0x0427
   \              0x010E 0x0492
   \              0x0428 0x010D
   \              0x0493 0x0429
   \              0x010D 0x0493
   \   000006B8   0x042A 0x010C      DC16 1066, 268, 1172, 1067, 268, 1172, 1068, 267, 1173, 1069, 267, 1173
   \              0x0494 0x042B
   \              0x010C 0x0494
   \              0x042C 0x010B
   \              0x0495 0x042D
   \              0x010B 0x0495
   \   000006D0   0x042E 0x010B      DC16 1070, 267, 1173, 1071, 266, 1174, 1072, 266, 1174, 1073, 265, 1175
   \              0x0495 0x042F
   \              0x010A 0x0496
   \              0x0430 0x010A
   \              0x0496 0x0431
   \              0x0109 0x0497
   \   000006E8   0x0432 0x0109      DC16 1074, 265, 1175, 1075, 265, 1175, 1076, 264, 1176, 1077, 264, 1176
   \              0x0497 0x0433
   \              0x0109 0x0497
   \              0x0434 0x0108
   \              0x0498 0x0435
   \              0x0108 0x0498
   \   00000700   0x0436 0x0107      DC16 1078, 263, 1177, 1079, 263, 1177, 1080, 263, 1177, 1081, 262, 1178
   \              0x0499 0x0437
   \              0x0107 0x0499
   \              0x0438 0x0107
   \              0x0499 0x0439
   \              0x0106 0x049A
   \   00000718   0x043A 0x0106      DC16 1082, 262, 1178, 1083, 261, 1179, 1084, 261, 1179, 1085, 261, 1179
   \              0x049A 0x043B
   \              0x0105 0x049B
   \              0x043C 0x0105
   \              0x049B 0x043D
   \              0x0105 0x049B
   \   00000730   0x043E 0x0104      DC16 1086, 260, 1180, 1087, 260, 1180, 1088, 259, 1181, 1089, 259, 1181
   \              0x049C 0x043F
   \              0x0104 0x049C
   \              0x0440 0x0103
   \              0x049D 0x0441
   \              0x0103 0x049D
   \   00000748   0x0442 0x0103      DC16 1090, 259, 1181, 1091, 258, 1182, 1092, 258, 1182, 1093, 257, 1183
   \              0x049D 0x0443
   \              0x0102 0x049E
   \              0x0444 0x0102
   \              0x049E 0x0445
   \              0x0101 0x049F
   \   00000760   0x0446 0x0101      DC16 1094, 257, 1183, 1095, 257, 1183, 1096, 256, 1184, 1097, 256, 1184
   \              0x049F 0x0447
   \              0x0101 0x049F
   \              0x0448 0x0100
   \              0x04A0 0x0449
   \              0x0100 0x04A0
   \   00000778   0x044A 0x00FF      DC16 1098, 255, 1185, 1099, 255, 1185, 1100, 254, 1186, 1101, 254, 1186
   \              0x04A1 0x044B
   \              0x00FF 0x04A1
   \              0x044C 0x00FE
   \              0x04A2 0x044D
   \              0x00FE 0x04A2
   \   00000790   0x044E 0x00FE      DC16 1102, 254, 1186, 1103, 253, 1187, 1104, 253, 1187, 1105, 252, 1188
   \              0x04A2 0x044F
   \              0x00FD 0x04A3
   \              0x0450 0x00FD
   \              0x04A3 0x0451
   \              0x00FC 0x04A4
   \   000007A8   0x0452 0x00FC      DC16 1106, 252, 1188, 1107, 252, 1188, 1108, 251, 1189, 1109, 251, 1189
   \              0x04A4 0x0453
   \              0x00FC 0x04A4
   \              0x0454 0x00FB
   \              0x04A5 0x0455
   \              0x00FB 0x04A5
   \   000007C0   0x0456 0x00FA      DC16 1110, 250, 1190, 1111, 250, 1190, 1112, 250, 1190, 1113, 249, 1191
   \              0x04A6 0x0457
   \              0x00FA 0x04A6
   \              0x0458 0x00FA
   \              0x04A6 0x0459
   \              0x00F9 0x04A7
   \   000007D8   0x045A 0x00F9      DC16 1114, 249, 1191, 1115, 248, 1192, 1116, 248, 1192, 1117, 248, 1192
   \              0x04A7 0x045B
   \              0x00F8 0x04A8
   \              0x045C 0x00F8
   \              0x04A8 0x045D
   \              0x00F8 0x04A8
   \   000007F0   0x045E 0x00F7      DC16 1118, 247, 1193, 1119, 247, 1193, 1120, 247, 1193, 1121, 246, 1194
   \              0x04A9 0x045F
   \              0x00F7 0x04A9
   \              0x0460 0x00F7
   \              0x04A9 0x0461
   \              0x00F6 0x04AA
   \   00000808   0x0462 0x00F6      DC16 1122, 246, 1194, 1123, 246, 1194, 1124, 245, 1195, 1125, 245, 1195
   \              0x04AA 0x0463
   \              0x00F6 0x04AA
   \              0x0464 0x00F5
   \              0x04AB 0x0465
   \              0x00F5 0x04AB
   \   00000820   0x0466 0x00F5      DC16 1126, 245, 1195, 1127, 245, 1195, 1128, 244, 1196, 1129, 244, 1196
   \              0x04AB 0x0467
   \              0x00F5 0x04AB
   \              0x0468 0x00F4
   \              0x04AC 0x0469
   \              0x00F4 0x04AC
   \   00000838   0x046A 0x00F4      DC16 1130, 244, 1196, 1131, 244, 1196, 1132, 243, 1197, 1133, 243, 1197
   \              0x04AC 0x046B
   \              0x00F4 0x04AC
   \              0x046C 0x00F3
   \              0x04AD 0x046D
   \              0x00F3 0x04AD
   \   00000850   0x046E 0x00F3      DC16 1134, 243, 1197, 1135, 242, 1198, 1136, 242, 1198, 1137, 242, 1198
   \              0x04AD 0x046F
   \              0x00F2 0x04AE
   \              0x0470 0x00F2
   \              0x04AE 0x0471
   \              0x00F2 0x04AE
   \   00000868   0x0472 0x00F2      DC16 1138, 242, 1198, 1139, 241, 1199, 1140, 241, 1199, 1141, 241, 1199
   \              0x04AE 0x0473
   \              0x00F1 0x04AF
   \              0x0474 0x00F1
   \              0x04AF 0x0475
   \              0x00F1 0x04AF
   \   00000880   0x0476 0x00F1      DC16 1142, 241, 1199, 1143, 240, 1200, 1144, 240, 1200, 1145, 240, 1200
   \              0x04AF 0x0477
   \              0x00F0 0x04B0
   \              0x0478 0x00F0
   \              0x04B0 0x0479
   \              0x00F0 0x04B0
   \   00000898   0x047A 0x00EF      DC16 1146, 239, 1201, 1147, 239, 1201, 1148, 239, 1201, 1149, 239, 1201
   \              0x04B1 0x047B
   \              0x00EF 0x04B1
   \              0x047C 0x00EF
   \              0x04B1 0x047D
   \              0x00EF 0x04B1
   \   000008B0   0x047E 0x00EE      DC16 1150, 238, 1202, 1151, 238, 1202, 1152, 238, 1202, 1153, 238, 1202
   \              0x04B2 0x047F
   \              0x00EE 0x04B2
   \              0x0480 0x00EE
   \              0x04B2 0x0481
   \              0x00EE 0x04B2
   \   000008C8   0x0482 0x00ED      DC16 1154, 237, 1203, 1155, 237, 1203, 1156, 237, 1203, 1157, 236, 1204
   \              0x04B3 0x0483
   \              0x00ED 0x04B3
   \              0x0484 0x00ED
   \              0x04B3 0x0485
   \              0x00EC 0x04B4
   \   000008E0   0x0486 0x00EC      DC16 1158, 236, 1204, 1159, 236, 1204, 1160, 236, 1204, 1161, 235, 1205
   \              0x04B4 0x0487
   \              0x00EC 0x04B4
   \              0x0488 0x00EC
   \              0x04B4 0x0489
   \              0x00EB 0x04B5
   \   000008F8   0x048A 0x00EB      DC16 1162, 235, 1205, 1163, 235, 1205, 1164, 234, 1205, 1165, 234, 1206
   \              0x04B5 0x048B
   \              0x00EB 0x04B5
   \              0x048C 0x00EA
   \              0x04B5 0x048D
   \              0x00EA 0x04B6
   \   00000910   0x048E 0x00EA      DC16 1166, 234, 1206, 1167, 234, 1206, 1168, 233, 1207, 1169, 233, 1207
   \              0x04B6 0x048F
   \              0x00EA 0x04B6
   \              0x0490 0x00E9
   \              0x04B7 0x0491
   \              0x00E9 0x04B7
   \   00000928   0x0492 0x00E9      DC16 1170, 233, 1207, 1171, 233, 1207, 1172, 232, 1208, 1173, 232, 1208
   \              0x04B7 0x0493
   \              0x00E9 0x04B7
   \              0x0494 0x00E8
   \              0x04B8 0x0495
   \              0x00E8 0x04B8
   \   00000940   0x0496 0x00E8      DC16 1174, 232, 1208, 1175, 231, 1208, 1176, 231, 1209, 1177, 231, 1209
   \              0x04B8 0x0497
   \              0x00E7 0x04B8
   \              0x0498 0x00E7
   \              0x04B9 0x0499
   \              0x00E7 0x04B9
   \   00000958   0x049A 0x00E7      DC16 1178, 231, 1209, 1179, 231, 1209, 1180, 231, 1209, 1181, 230, 1210
   \              0x04B9 0x049B
   \              0x00E7 0x04B9
   \              0x049C 0x00E7
   \              0x04B9 0x049D
   \              0x00E6 0x04BA
   \   00000970   0x049E 0x00E6      DC16 1182, 230, 1210, 1183, 230, 1210, 1184, 230, 1210, 1185, 230, 1210
   \              0x04BA 0x049F
   \              0x00E6 0x04BA
   \              0x04A0 0x00E6
   \              0x04BA 0x04A1
   \              0x00E6 0x04BA
   \   00000988   0x04A2 0x00E6      DC16 1186, 230, 1210, 1187, 230, 1210, 1188, 229, 1211, 1189, 229, 1211
   \              0x04BA 0x04A3
   \              0x00E6 0x04BA
   \              0x04A4 0x00E5
   \              0x04BB 0x04A5
   \              0x00E5 0x04BB
   \   000009A0   0x04A6 0x00E5      DC16 1190, 229, 1211, 1191, 229, 1211, 1192, 229, 1211, 1193, 229, 1211
   \              0x04BB 0x04A7
   \              0x00E5 0x04BB
   \              0x04A8 0x00E5
   \              0x04BB 0x04A9
   \              0x00E5 0x04BB
   \   000009B8   0x04AA 0x00E5      DC16 1194, 229, 1211, 1195, 228, 1212, 1196, 228, 1212, 1197, 228, 1212
   \              0x04BB 0x04AB
   \              0x00E4 0x04BC
   \              0x04AC 0x00E4
   \              0x04BC 0x04AD
   \              0x00E4 0x04BC
   \   000009D0   0x04AE 0x00E4      DC16 1198, 228, 1212, 1199, 228, 1212, 1200, 228, 1212, 1201, 227, 1213
   \              0x04BC 0x04AF
   \              0x00E4 0x04BC
   \              0x04B0 0x00E4
   \              0x04BC 0x04B1
   \              0x00E3 0x04BD
   \   000009E8   0x04B2 0x00E3      DC16 1202, 227, 1213, 1203, 227, 1213, 1204, 227, 1213, 1205, 227, 1213
   \              0x04BD 0x04B3
   \              0x00E3 0x04BD
   \              0x04B4 0x00E3
   \              0x04BD 0x04B5
   \              0x00E3 0x04BD
   \   00000A00   0x04B6 0x00E3      DC16 1206, 227, 1213, 1207, 227, 1213, 1208, 226, 1214, 1209, 226, 1214
   \              0x04BD 0x04B7
   \              0x00E3 0x04BD
   \              0x04B8 0x00E2
   \              0x04BE 0x04B9
   \              0x00E2 0x04BE
   \   00000A18   0x04BA 0x00E2      DC16 1210, 226, 1214, 1211, 226, 1214, 1212, 226, 1214, 1213, 226, 1214
   \              0x04BE 0x04BB
   \              0x00E2 0x04BE
   \              0x04BC 0x00E2
   \              0x04BE 0x04BD
   \              0x00E2 0x04BE
   \   00000A30   0x04BE 0x00E2      DC16 1214, 226, 1214, 1215, 225, 1215, 1216, 225, 1215, 1217, 225, 1215
   \              0x04BE 0x04BF
   \              0x00E1 0x04BF
   \              0x04C0 0x00E1
   \              0x04BF 0x04C1
   \              0x00E1 0x04BF
   \   00000A48   0x04C2 0x00E1      DC16 1218, 225, 1215, 1219, 225, 1215, 1220, 225, 1215, 1221, 224, 1215
   \              0x04BF 0x04C3
   \              0x00E1 0x04BF
   \              0x04C4 0x00E1
   \              0x04BF 0x04C5
   \              0x00E0 0x04BF
   \   00000A60   0x04C6 0x00E0      DC16 1222, 224, 1216, 1223, 224, 1216, 1224, 224, 1216, 1225, 224, 1216
   \              0x04C0 0x04C7
   \              0x00E0 0x04C0
   \              0x04C8 0x00E0
   \              0x04C0 0x04C9
   \              0x00E0 0x04C0
   \   00000A78   0x04CA 0x00E0      DC16 1226, 224, 1216, 1227, 224, 1216, 1228, 223, 1217, 1229, 223, 1217
   \              0x04C0 0x04CB
   \              0x00E0 0x04C0
   \              0x04CC 0x00DF
   \              0x04C1 0x04CD
   \              0x00DF 0x04C1
   \   00000A90   0x04CE 0x00DF      DC16 1230, 223, 1217, 1231, 223, 1217, 1232, 223, 1217, 1233, 223, 1217
   \              0x04C1 0x04CF
   \              0x00DF 0x04C1
   \              0x04D0 0x00DF
   \              0x04C1 0x04D1
   \              0x00DF 0x04C1
   \   00000AA8   0x04D2 0x00DF      DC16 1234, 223, 1217, 1235, 222, 1218, 1236, 222, 1218, 1237, 222, 1218
   \              0x04C1 0x04D3
   \              0x00DE 0x04C2
   \              0x04D4 0x00DE
   \              0x04C2 0x04D5
   \              0x00DE 0x04C2
   \   00000AC0   0x04D6 0x00DE      DC16 1238, 222, 1218, 1239, 222, 1218, 1240, 222, 1218, 1241, 222, 1218
   \              0x04C2 0x04D7
   \              0x00DE 0x04C2
   \              0x04D8 0x00DE
   \              0x04C2 0x04D9
   \              0x00DE 0x04C2
   \   00000AD8   0x04DA 0x00DE      DC16 1242, 222, 1218, 1243, 222, 1218, 1244, 222, 1218, 1245, 222, 1218
   \              0x04C2 0x04DB
   \              0x00DE 0x04C2
   \              0x04DC 0x00DE
   \              0x04C2 0x04DD
   \              0x00DE 0x04C2
   \   00000AF0   0x04DE 0x00DE      DC16 1246, 222, 1218, 1247, 222, 1218, 1248, 222, 1218, 1249, 222, 1218
   \              0x04C2 0x04DF
   \              0x00DE 0x04C2
   \              0x04E0 0x00DE
   \              0x04C2 0x04E1
   \              0x00DE 0x04C2
   \   00000B08   0x04E2 0x00DE      DC16 1250, 222, 1218, 1251, 222, 1218, 1252, 222, 1218, 1253, 222, 1218
   \              0x04C2 0x04E3
   \              0x00DE 0x04C2
   \              0x04E4 0x00DE
   \              0x04C2 0x04E5
   \              0x00DE 0x04C2
   \   00000B20   0x04E6 0x00DE      DC16 1254, 222, 1218, 1255, 222, 1218, 1256, 222, 1218, 1257, 222, 1218
   \              0x04C2 0x04E7
   \              0x00DE 0x04C2
   \              0x04E8 0x00DE
   \              0x04C2 0x04E9
   \              0x00DE 0x04C2
   \   00000B38   0x04EA 0x00DE      DC16 1258, 222, 1218, 1259, 222, 1218, 1260, 222, 1218, 1261, 222, 1218
   \              0x04C2 0x04EB
   \              0x00DE 0x04C2
   \              0x04EC 0x00DE
   \              0x04C2 0x04ED
   \              0x00DE 0x04C2
   \   00000B50   0x04EE 0x00DE      DC16 1262, 222, 1218, 1263, 222, 1218, 1264, 222, 1218, 1265, 222, 1218
   \              0x04C2 0x04EF
   \              0x00DE 0x04C2
   \              0x04F0 0x00DE
   \              0x04C2 0x04F1
   \              0x00DE 0x04C2
   \   00000B68   0x04F2 0x00DE      DC16 1266, 222, 1218, 1267, 222, 1218, 1268, 221, 1219, 1269, 221, 1219
   \              0x04C2 0x04F3
   \              0x00DE 0x04C2
   \              0x04F4 0x00DD
   \              0x04C3 0x04F5
   \              0x00DD 0x04C3
   \   00000B80   0x04F6 0x00DD      DC16 1270, 221, 1219, 1271, 221, 1219, 1272, 221, 1219, 1273, 221, 1219
   \              0x04C3 0x04F7
   \              0x00DD 0x04C3
   \              0x04F8 0x00DD
   \              0x04C3 0x04F9
   \              0x00DD 0x04C3
   \   00000B98   0x04FA 0x00DD      DC16 1274, 221, 1219, 1275, 221, 1219, 1276, 221, 1219, 1277, 221, 1219
   \              0x04C3 0x04FB
   \              0x00DD 0x04C3
   \              0x04FC 0x00DD
   \              0x04C3 0x04FD
   \              0x00DD 0x04C3
   \   00000BB0   0x04FE 0x00DD      DC16 1278, 221, 1219, 1279, 221, 1219, 1280, 221, 1219, 1281, 221, 1219
   \              0x04C3 0x04FF
   \              0x00DD 0x04C3
   \              0x0500 0x00DD
   \              0x04C3 0x0501
   \              0x00DD 0x04C3
   \   00000BC8   0x0502 0x00DD      DC16 1282, 221, 1219, 1283, 221, 1219, 1284, 221, 1219, 1285, 221, 1219
   \              0x04C3 0x0503
   \              0x00DD 0x04C3
   \              0x0504 0x00DD
   \              0x04C3 0x0505
   \              0x00DD 0x04C3
   \   00000BE0   0x0506 0x00DD      DC16 1286, 221, 1219, 1287, 221, 1219, 1288, 221, 1219, 1289, 221, 1219
   \              0x04C3 0x0507
   \              0x00DD 0x04C3
   \              0x0508 0x00DD
   \              0x04C3 0x0509
   \              0x00DD 0x04C3
   \   00000BF8   0x050A 0x00DD      DC16 1290, 221, 1219, 1291, 221, 1219, 1292, 221, 1219, 1293, 221, 1219
   \              0x04C3 0x050B
   \              0x00DD 0x04C3
   \              0x050C 0x00DD
   \              0x04C3 0x050D
   \              0x00DD 0x04C3
   \   00000C10   0x050E 0x00DD      DC16 1294, 221, 1219, 1295, 221, 1219, 1296, 221, 1219, 1297, 221, 1219
   \              0x04C3 0x050F
   \              0x00DD 0x04C3
   \              0x0510 0x00DD
   \              0x04C3 0x0511
   \              0x00DD 0x04C3
   \   00000C28   0x0512 0x00DD      DC16 1298, 221, 1219, 1299, 221, 1219, 1300, 221, 1219, 1301, 221, 1219
   \              0x04C3 0x0513
   \              0x00DD 0x04C3
   \              0x0514 0x00DD
   \              0x04C3 0x0515
   \              0x00DD 0x04C3
   \   00000C40   0x0516 0x00DD      DC16 1302, 221, 1219, 1303, 222, 1218, 1304, 222, 1218, 1305, 222, 1218
   \              0x04C3 0x0517
   \              0x00DE 0x04C2
   \              0x0518 0x00DE
   \              0x04C2 0x0519
   \              0x00DE 0x04C2
   \   00000C58   0x051A 0x00DE      DC16 1306, 222, 1218, 1307, 222, 1218, 1308, 222, 1218, 1309, 222, 1218
   \              0x04C2 0x051B
   \              0x00DE 0x04C2
   \              0x051C 0x00DE
   \              0x04C2 0x051D
   \              0x00DE 0x04C2
   \   00000C70   0x051E 0x00DE      DC16 1310, 222, 1218, 1311, 222, 1218, 1312, 222, 1218, 1313, 222, 1218
   \              0x04C2 0x051F
   \              0x00DE 0x04C2
   \              0x0520 0x00DE
   \              0x04C2 0x0521
   \              0x00DE 0x04C2
   \   00000C88   0x0522 0x00DF      DC16 1314, 223, 1217, 1315, 223, 1217, 1316, 223, 1217, 1317, 223, 1217
   \              0x04C1 0x0523
   \              0x00DF 0x04C1
   \              0x0524 0x00DF
   \              0x04C1 0x0525
   \              0x00DF 0x04C1
   \   00000CA0   0x0526 0x00DF      DC16 1318, 223, 1217, 1319, 223, 1217, 1320, 223, 1217, 1321, 223, 1217
   \              0x04C1 0x0527
   \              0x00DF 0x04C1
   \              0x0528 0x00DF
   \              0x04C1 0x0529
   \              0x00DF 0x04C1
   \   00000CB8   0x052A 0x00DF      DC16 1322, 223, 1217, 1323, 223, 1217, 1324, 223, 1217, 1325, 223, 1216
   \              0x04C1 0x052B
   \              0x00DF 0x04C1
   \              0x052C 0x00DF
   \              0x04C1 0x052D
   \              0x00DF 0x04C0
   \   00000CD0   0x052E 0x00E0      DC16 1326, 224, 1216, 1327, 224, 1216, 1328, 224, 1216, 1329, 224, 1216
   \              0x04C0 0x052F
   \              0x00E0 0x04C0
   \              0x0530 0x00E0
   \              0x04C0 0x0531
   \              0x00E0 0x04C0
   \   00000CE8   0x0532 0x00E0      DC16 1330, 224, 1216, 1331, 224, 1216, 1332, 224, 1216, 1333, 224, 1216
   \              0x04C0 0x0533
   \              0x00E0 0x04C0
   \              0x0534 0x00E0
   \              0x04C0 0x0535
   \              0x00E0 0x04C0
   \   00000D00   0x0536 0x00E0      DC16 1334, 224, 1216, 1335, 224, 1216, 1336, 224, 1216, 1337, 225, 1215
   \              0x04C0 0x0537
   \              0x00E0 0x04C0
   \              0x0538 0x00E0
   \              0x04C0 0x0539
   \              0x00E1 0x04BF
   \   00000D18   0x053A 0x00E1      DC16 1338, 225, 1215, 1339, 225, 1215, 1340, 225, 1215, 1341, 225, 1215
   \              0x04BF 0x053B
   \              0x00E1 0x04BF
   \              0x053C 0x00E1
   \              0x04BF 0x053D
   \              0x00E1 0x04BF
   \   00000D30   0x053E 0x00E1      DC16 1342, 225, 1215, 1343, 225, 1215, 1344, 225, 1215, 1345, 225, 1215
   \              0x04BF 0x053F
   \              0x00E1 0x04BF
   \              0x0540 0x00E1
   \              0x04BF 0x0541
   \              0x00E1 0x04BF
   \   00000D48   0x0542 0x00E1      DC16 1346, 225, 1215, 1347, 225, 1215, 1348, 226, 1214, 1349, 226, 1214
   \              0x04BF 0x0543
   \              0x00E1 0x04BF
   \              0x0544 0x00E2
   \              0x04BE 0x0545
   \              0x00E2 0x04BE
   \   00000D60   0x0546 0x00E2      DC16 1350, 226, 1214, 1351, 226, 1214, 1352, 226, 1214, 1353, 226, 1214
   \              0x04BE 0x0547
   \              0x00E2 0x04BE
   \              0x0548 0x00E2
   \              0x04BE 0x0549
   \              0x00E2 0x04BE
   \   00000D78   0x054A 0x00E2      DC16 1354, 226, 1214, 1355, 226, 1214, 1356, 227, 1213, 1357, 227, 1213
   \              0x04BE 0x054B
   \              0x00E2 0x04BE
   \              0x054C 0x00E3
   \              0x04BD 0x054D
   \              0x00E3 0x04BD
   \   00000D90   0x054E 0x00E3      DC16 1358, 227, 1213, 1359, 227, 1213, 1360, 227, 1213, 1361, 228, 1212
   \              0x04BD 0x054F
   \              0x00E3 0x04BD
   \              0x0550 0x00E3
   \              0x04BD 0x0551
   \              0x00E4 0x04BC
   \   00000DA8   0x0552 0x00E4      DC16 1362, 228, 1212, 1363, 228, 1212, 1364, 228, 1212, 1365, 229, 1211
   \              0x04BC 0x0553
   \              0x00E4 0x04BC
   \              0x0554 0x00E4
   \              0x04BC 0x0555
   \              0x00E5 0x04BB
   \   00000DC0   0x0556 0x00E5      DC16 1366, 229, 1211, 1367, 229, 1211, 1368, 229, 1211, 1369, 229, 1211
   \              0x04BB 0x0557
   \              0x00E5 0x04BB
   \              0x0558 0x00E5
   \              0x04BB 0x0559
   \              0x00E5 0x04BB
   \   00000DD8   0x055A 0x00E6      DC16 1370, 230, 1210, 1371, 230, 1210, 1372, 230, 1210, 1373, 230, 1210
   \              0x04BA 0x055B
   \              0x00E6 0x04BA
   \              0x055C 0x00E6
   \              0x04BA 0x055D
   \              0x00E6 0x04BA
   \   00000DF0   0x055E 0x00E6      DC16 1374, 230, 1210, 1375, 231, 1209, 1376, 231, 1209, 1377, 231, 1209
   \              0x04BA 0x055F
   \              0x00E7 0x04B9
   \              0x0560 0x00E7
   \              0x04B9 0x0561
   \              0x00E7 0x04B9
   \   00000E08   0x0562 0x00E7      DC16 1378, 231, 1209, 1379, 231, 1209, 1380, 232, 1208, 1381, 232, 1208
   \              0x04B9 0x0563
   \              0x00E7 0x04B9
   \              0x0564 0x00E8
   \              0x04B8 0x0565
   \              0x00E8 0x04B8
   \   00000E20   0x0566 0x00E8      DC16 1382, 232, 1208, 1383, 232, 1208, 1384, 233, 1207, 1385, 233, 1207
   \              0x04B8 0x0567
   \              0x00E8 0x04B8
   \              0x0568 0x00E9
   \              0x04B7 0x0569
   \              0x00E9 0x04B7
   \   00000E38   0x056A 0x00E9      DC16 1386, 233, 1207, 1387, 233, 1207, 1388, 233, 1207, 1389, 234, 1206
   \              0x04B7 0x056B
   \              0x00E9 0x04B7
   \              0x056C 0x00E9
   \              0x04B7 0x056D
   \              0x00EA 0x04B6
   \   00000E50   0x056E 0x00EA      DC16 1390, 234, 1206, 1391, 234, 1206, 1392, 234, 1206, 1393, 234, 1206
   \              0x04B6 0x056F
   \              0x00EA 0x04B6
   \              0x0570 0x00EA
   \              0x04B6 0x0571
   \              0x00EA 0x04B6
   \   00000E68   0x0572 0x00EB      DC16 1394, 235, 1205, 1395, 235, 1205, 1396, 235, 1205, 1397, 235, 1205
   \              0x04B5 0x0573
   \              0x00EB 0x04B5
   \              0x0574 0x00EB
   \              0x04B5 0x0575
   \              0x00EB 0x04B5
   \   00000E80   0x0576 0x00EB      DC16 1398, 235, 1205, 1399, 236, 1204, 1400, 236, 1204, 1401, 236, 1204
   \              0x04B5 0x0577
   \              0x00EC 0x04B4
   \              0x0578 0x00EC
   \              0x04B4 0x0579
   \              0x00EC 0x04B4
   \   00000E98   0x057A 0x00EC      DC16 1402, 236, 1204, 1403, 237, 1203, 1404, 237, 1203, 1405, 237, 1203
   \              0x04B4 0x057B
   \              0x00ED 0x04B3
   \              0x057C 0x00ED
   \              0x04B3 0x057D
   \              0x00ED 0x04B3
   \   00000EB0   0x057E 0x00ED      DC16 1406, 237, 1203, 1407, 237, 1203, 1408, 238, 1202, 1409, 238, 1202
   \              0x04B3 0x057F
   \              0x00ED 0x04B3
   \              0x0580 0x00EE
   \              0x04B2 0x0581
   \              0x00EE 0x04B2
   \   00000EC8   0x0582 0x00EE      DC16 1410, 238, 1202, 1411, 238, 1202, 1412, 239, 1201, 1413, 239, 1201
   \              0x04B2 0x0583
   \              0x00EE 0x04B2
   \              0x0584 0x00EF
   \              0x04B1 0x0585
   \              0x00EF 0x04B1
   \   00000EE0   0x0586 0x00EF      DC16 1414, 239, 1201, 1415, 240, 1200, 1416, 240, 1200, 1417, 240, 1200
   \              0x04B1 0x0587
   \              0x00F0 0x04B0
   \              0x0588 0x00F0
   \              0x04B0 0x0589
   \              0x00F0 0x04B0
   \   00000EF8   0x058A 0x00F1      DC16 1418, 241, 1199, 1419, 241, 1199, 1420, 241, 1199, 1421, 242, 1198
   \              0x04AF 0x058B
   \              0x00F1 0x04AF
   \              0x058C 0x00F1
   \              0x04AF 0x058D
   \              0x00F2 0x04AE
   \   00000F10   0x058E 0x00F2      DC16 1422, 242, 1198, 1423, 242, 1198, 1424, 243, 1197, 1425, 243, 1197
   \              0x04AE 0x058F
   \              0x00F2 0x04AE
   \              0x0590 0x00F3
   \              0x04AD 0x0591
   \              0x00F3 0x04AD
   \   00000F28   0x0592 0x00F3      DC16 1426, 243, 1197, 1427, 244, 1196, 1428, 244, 1196, 1429, 244, 1196
   \              0x04AD 0x0593
   \              0x00F4 0x04AC
   \              0x0594 0x00F4
   \              0x04AC 0x0595
   \              0x00F4 0x04AC
   \   00000F40   0x0596 0x00F5      DC16 1430, 245, 1195, 1431, 245, 1195, 1432, 245, 1195, 1433, 246, 1194
   \              0x04AB 0x0597
   \              0x00F5 0x04AB
   \              0x0598 0x00F5
   \              0x04AB 0x0599
   \              0x00F6 0x04AA
   \   00000F58   0x059A 0x00F6      DC16 1434, 246, 1194, 1435, 246, 1194, 1436, 247, 1193, 1437, 247, 1193
   \              0x04AA 0x059B
   \              0x00F6 0x04AA
   \              0x059C 0x00F7
   \              0x04A9 0x059D
   \              0x00F7 0x04A9
   \   00000F70   0x059E 0x00F7      DC16 1438, 247, 1193, 1439, 248, 1192, 1440, 248, 1192, 1441, 248, 1192
   \              0x04A9 0x059F
   \              0x00F8 0x04A8
   \              0x05A0 0x00F8
   \              0x04A8 0x05A1
   \              0x00F8 0x04A8
   \   00000F88   0x05A2 0x00F9      DC16 1442, 249, 1191, 1443, 249, 1191, 1444, 249, 1191, 1445, 250, 1190
   \              0x04A7 0x05A3
   \              0x00F9 0x04A7
   \              0x05A4 0x00F9
   \              0x04A7 0x05A5
   \              0x00FA 0x04A6
   \   00000FA0   0x05A6 0x00FA      DC16 1446, 250, 1190, 1447, 250, 1190, 1448, 251, 1189, 1449, 251, 1189
   \              0x04A6 0x05A7
   \              0x00FA 0x04A6
   \              0x05A8 0x00FB
   \              0x04A5 0x05A9
   \              0x00FB 0x04A5
   \   00000FB8   0x05AA 0x00FB      DC16 1450, 251, 1189, 1451, 252, 1188, 1452, 252, 1188, 1453, 252, 1188
   \              0x04A5 0x05AB
   \              0x00FC 0x04A4
   \              0x05AC 0x00FC
   \              0x04A4 0x05AD
   \              0x00FC 0x04A4
   \   00000FD0   0x05AE 0x00FD      DC16 1454, 253, 1187, 1455, 253, 1187, 1456, 253, 1187, 1457, 254, 1186
   \              0x04A3 0x05AF
   \              0x00FD 0x04A3
   \              0x05B0 0x00FD
   \              0x04A3 0x05B1
   \              0x00FE 0x04A2
   \   00000FE8   0x05B2 0x00FE      DC16 1458, 254, 1186, 1459, 254, 1186, 1460, 255, 1185, 1461, 255, 1185
   \              0x04A2 0x05B3
   \              0x00FE 0x04A2
   \              0x05B4 0x00FF
   \              0x04A1 0x05B5
   \              0x00FF 0x04A1
   \   00001000   0x05B6 0x00FF      DC16 1462, 255, 1185, 1463, 256, 1184, 1464, 256, 1184, 1465, 256, 1183
   \              0x04A1 0x05B7
   \              0x0100 0x04A0
   \              0x05B8 0x0100
   \              0x04A0 0x05B9
   \              0x0100 0x049F
   \   00001018   0x05BA 0x0101      DC16 1466, 257, 1183, 1467, 257, 1183, 1468, 258, 1182, 1469, 258, 1182
   \              0x049F 0x05BB
   \              0x0101 0x049F
   \              0x05BC 0x0102
   \              0x049E 0x05BD
   \              0x0102 0x049E
   \   00001030   0x05BE 0x0103      DC16 1470, 259, 1181, 1471, 259, 1181, 1472, 260, 1180, 1473, 260, 1180
   \              0x049D 0x05BF
   \              0x0103 0x049D
   \              0x05C0 0x0104
   \              0x049C 0x05C1
   \              0x0104 0x049C
   \   00001048   0x05C2 0x0105      DC16 1474, 261, 1179, 1475, 261, 1179, 1476, 261, 1179, 1477, 262, 1178
   \              0x049B 0x05C3
   \              0x0105 0x049B
   \              0x05C4 0x0105
   \              0x049B 0x05C5
   \              0x0106 0x049A
   \   00001060   0x05C6 0x0106      DC16 1478, 262, 1178, 1479, 263, 1177, 1480, 263, 1177, 1481, 264, 1176
   \              0x049A 0x05C7
   \              0x0107 0x0499
   \              0x05C8 0x0107
   \              0x0499 0x05C9
   \              0x0108 0x0498
   \   00001078   0x05CA 0x0108      DC16 1482, 264, 1176, 1483, 265, 1175, 1484, 265, 1175, 1485, 266, 1174
   \              0x0498 0x05CB
   \              0x0109 0x0497
   \              0x05CC 0x0109
   \              0x0497 0x05CD
   \              0x010A 0x0496
   \   00001090   0x05CE 0x010A      DC16 1486, 266, 1174, 1487, 267, 1173, 1488, 267, 1173, 1489, 268, 1172
   \              0x0496 0x05CF
   \              0x010B 0x0495
   \              0x05D0 0x010B
   \              0x0495 0x05D1
   \              0x010C 0x0494
   \   000010A8   0x05D2 0x010C      DC16 1490, 268, 1172, 1491, 269, 1171, 1492, 269, 1171, 1493, 270, 1170
   \              0x0494 0x05D3
   \              0x010D 0x0493
   \              0x05D4 0x010D
   \              0x0493 0x05D5
   \              0x010E 0x0492
   \   000010C0   0x05D6 0x010E      DC16 1494, 270, 1170, 1495, 271, 1169, 1496, 271, 1169, 1497, 271, 1169
   \              0x0492 0x05D7
   \              0x010F 0x0491
   \              0x05D8 0x010F
   \              0x0491 0x05D9
   \              0x010F 0x0491
   \   000010D8   0x05DA 0x0110      DC16 1498, 272, 1168, 1499, 272, 1168, 1500, 273, 1167, 1501, 273, 1167
   \              0x0490 0x05DB
   \              0x0110 0x0490
   \              0x05DC 0x0111
   \              0x048F 0x05DD
   \              0x0111 0x048F
   \   000010F0   0x05DE 0x0112      DC16 1502, 274, 1166, 1503, 274, 1166, 1504, 275, 1165, 1505, 275, 1165
   \              0x048E 0x05DF
   \              0x0112 0x048E
   \              0x05E0 0x0113
   \              0x048D 0x05E1
   \              0x0113 0x048D
   \   00001108   0x05E2 0x0114      DC16 1506, 276, 1164, 1507, 276, 1164, 1508, 277, 1163, 1509, 277, 1163
   \              0x048C 0x05E3
   \              0x0114 0x048C
   \              0x05E4 0x0115
   \              0x048B 0x05E5
   \              0x0115 0x048B
   \   00001120   0x05E6 0x0116      DC16 1510, 278, 1162, 1511, 278, 1162, 1512, 279, 1161, 1513, 279, 1161
   \              0x048A 0x05E7
   \              0x0116 0x048A
   \              0x05E8 0x0117
   \              0x0489 0x05E9
   \              0x0117 0x0489
   \   00001138   0x05EA 0x0118      DC16 1514, 280, 1160, 1515, 280, 1160, 1516, 281, 1159, 1517, 281, 1159
   \              0x0488 0x05EB
   \              0x0118 0x0488
   \              0x05EC 0x0119
   \              0x0487 0x05ED
   \              0x0119 0x0487
   \   00001150   0x05EE 0x0119      DC16 1518, 281, 1158, 1519, 282, 1158, 1520, 282, 1158, 1521, 283, 1157
   \              0x0486 0x05EF
   \              0x011A 0x0486
   \              0x05F0 0x011A
   \              0x0486 0x05F1
   \              0x011B 0x0485
   \   00001168   0x05F2 0x011C      DC16 1522, 284, 1156, 1523, 284, 1156, 1524, 285, 1155, 1525, 286, 1154
   \              0x0484 0x05F3
   \              0x011C 0x0484
   \              0x05F4 0x011D
   \              0x0483 0x05F5
   \              0x011E 0x0482
   \   00001180   0x05F6 0x011E      DC16 1526, 286, 1154, 1527, 287, 1153, 1528, 287, 1153, 1529, 288, 1152
   \              0x0482 0x05F7
   \              0x011F 0x0481
   \              0x05F8 0x011F
   \              0x0481 0x05F9
   \              0x0120 0x0480
   \   00001198   0x05FA 0x0121      DC16 1530, 289, 1151, 1531, 289, 1151, 1532, 290, 1150, 1533, 291, 1149
   \              0x047F 0x05FB
   \              0x0121 0x047F
   \              0x05FC 0x0122
   \              0x047E 0x05FD
   \              0x0123 0x047D
   \   000011B0   0x05FE 0x0123      DC16 1534, 291, 1149, 1535, 292, 1148, 1536, 292, 1148, 1537, 293, 1147
   \              0x047D 0x05FF
   \              0x0124 0x047C
   \              0x0600 0x0124
   \              0x047C 0x0601
   \              0x0125 0x047B
   \   000011C8   0x0602 0x0126      DC16 1538, 294, 1146, 1539, 294, 1146, 1540, 295, 1145, 1541, 296, 1144
   \              0x047A 0x0603
   \              0x0126 0x047A
   \              0x0604 0x0127
   \              0x0479 0x0605
   \              0x0128 0x0478
   \   000011E0   0x0606 0x0128      DC16 1542, 296, 1144, 1543, 297, 1143, 1544, 298, 1142, 1545, 298, 1142
   \              0x0478 0x0607
   \              0x0129 0x0477
   \              0x0608 0x012A
   \              0x0476 0x0609
   \              0x012A 0x0476
   \   000011F8   0x060A 0x012B      DC16 1546, 299, 1141, 1547, 299, 1141, 1548, 300, 1140, 1549, 301, 1139
   \              0x0475 0x060B
   \              0x012B 0x0475
   \              0x060C 0x012C
   \              0x0474 0x060D
   \              0x012D 0x0473
   \   00001210   0x060E 0x012D      DC16 1550, 301, 1139, 1551, 302, 1138, 1552, 303, 1137, 1553, 303, 1137
   \              0x0473 0x060F
   \              0x012E 0x0472
   \              0x0610 0x012F
   \              0x0471 0x0611
   \              0x012F 0x0471
   \   00001228   0x0612 0x0130      DC16 1554, 304, 1136, 1555, 304, 1136, 1556, 305, 1135, 1557, 306, 1134
   \              0x0470 0x0613
   \              0x0130 0x0470
   \              0x0614 0x0131
   \              0x046F 0x0615
   \              0x0132 0x046E
   \   00001240   0x0616 0x0132      DC16 1558, 306, 1134, 1559, 307, 1133, 1560, 308, 1132, 1561, 308, 1132
   \              0x046E 0x0617
   \              0x0133 0x046D
   \              0x0618 0x0134
   \              0x046C 0x0619
   \              0x0134 0x046C
   \   00001258   0x061A 0x0135      DC16 1562, 309, 1131, 1563, 310, 1130, 1564, 310, 1130, 1565, 311, 1129
   \              0x046B 0x061B
   \              0x0136 0x046A
   \              0x061C 0x0136
   \              0x046A 0x061D
   \              0x0137 0x0469
   \   00001270   0x061E 0x0137      DC16 1566, 311, 1129, 1567, 312, 1128, 1568, 313, 1127, 1569, 313, 1127
   \              0x0469 0x061F
   \              0x0138 0x0468
   \              0x0620 0x0139
   \              0x0467 0x0621
   \              0x0139 0x0467
   \   00001288   0x0622 0x013A      DC16 1570, 314, 1126, 1571, 315, 1125, 1572, 315, 1125, 1573, 316, 1124
   \              0x0466 0x0623
   \              0x013B 0x0465
   \              0x0624 0x013B
   \              0x0465 0x0625
   \              0x013C 0x0464
   \   000012A0   0x0626 0x013D      DC16 1574, 317, 1123, 1575, 318, 1122, 1576, 319, 1121, 1577, 320, 1120
   \              0x0463 0x0627
   \              0x013E 0x0462
   \              0x0628 0x013F
   \              0x0461 0x0629
   \              0x0140 0x0460
   \   000012B8   0x062A 0x0140      DC16 1578, 320, 1120, 1579, 321, 1119, 1580, 322, 1118, 1581, 323, 1117
   \              0x0460 0x062B
   \              0x0141 0x045F
   \              0x062C 0x0142
   \              0x045E 0x062D
   \              0x0143 0x045D
   \   000012D0   0x062E 0x0144      DC16 1582, 324, 1116, 1583, 324, 1116, 1584, 325, 1115, 1585, 326, 1114
   \              0x045C 0x062F
   \              0x0144 0x045C
   \              0x0630 0x0145
   \              0x045B 0x0631
   \              0x0146 0x045A
   \   000012E8   0x0632 0x0147      DC16 1586, 327, 1113, 1587, 328, 1112, 1588, 328, 1112, 1589, 329, 1111
   \              0x0459 0x0633
   \              0x0148 0x0458
   \              0x0634 0x0148
   \              0x0458 0x0635
   \              0x0149 0x0457
   \   00001300   0x0636 0x014A      DC16 1590, 330, 1110, 1591, 331, 1109, 1592, 332, 1108, 1593, 333, 1107
   \              0x0456 0x0637
   \              0x014B 0x0455
   \              0x0638 0x014C
   \              0x0454 0x0639
   \              0x014D 0x0453
   \   00001318   0x063A 0x014D      DC16 1594, 333, 1107, 1595, 334, 1106, 1596, 335, 1105, 1597, 336, 1104
   \              0x0453 0x063B
   \              0x014E 0x0452
   \              0x063C 0x014F
   \              0x0451 0x063D
   \              0x0150 0x0450
   \   00001330   0x063E 0x0151      DC16 1598, 337, 1103, 1599, 337, 1103, 1600, 338, 1102, 1601, 339, 1101
   \              0x044F 0x063F
   \              0x0151 0x044F
   \              0x0640 0x0152
   \              0x044E 0x0641
   \              0x0153 0x044D
   \   00001348   0x0642 0x0154      DC16 1602, 340, 1100, 1603, 341, 1099, 1604, 341, 1099, 1605, 342, 1098
   \              0x044C 0x0643
   \              0x0155 0x044B
   \              0x0644 0x0155
   \              0x044B 0x0645
   \              0x0156 0x044A
   \   00001360   0x0646 0x0157      DC16 1606, 343, 1097, 1607, 344, 1096, 1608, 345, 1095, 1609, 346, 1094
   \              0x0449 0x0647
   \              0x0158 0x0448
   \              0x0648 0x0159
   \              0x0447 0x0649
   \              0x015A 0x0446
   \   00001378   0x064A 0x015A      DC16 1610, 346, 1094, 1611, 347, 1093, 1612, 348, 1092, 1613, 349, 1091
   \              0x0446 0x064B
   \              0x015B 0x0445
   \              0x064C 0x015C
   \              0x0444 0x064D
   \              0x015D 0x0443
   \   00001390   0x064E 0x015E      DC16 1614, 350, 1090, 1615, 350, 1090, 1616, 351, 1089, 1617, 352, 1088
   \              0x0442 0x064F
   \              0x015E 0x0442
   \              0x0650 0x015F
   \              0x0441 0x0651
   \              0x0160 0x0440
   \   000013A8   0x0652 0x0161      DC16 1618, 353, 1087, 1619, 354, 1086, 1620, 355, 1085, 1621, 356, 1084
   \              0x043F 0x0653
   \              0x0162 0x043E
   \              0x0654 0x0163
   \              0x043D 0x0655
   \              0x0164 0x043C
   \   000013C0   0x0656 0x0165      DC16 1622, 357, 1083, 1623, 358, 1082, 1624, 359, 1081, 1625, 360, 1080
   \              0x043B 0x0657
   \              0x0166 0x043A
   \              0x0658 0x0167
   \              0x0439 0x0659
   \              0x0168 0x0438
   \   000013D8   0x065A 0x0169      DC16 1626, 361, 1079, 1627, 362, 1078, 1628, 363, 1077, 1629, 364, 1076
   \              0x0437 0x065B
   \              0x016A 0x0436
   \              0x065C 0x016B
   \              0x0435 0x065D
   \              0x016C 0x0434
   \   000013F0   0x065E 0x016D      DC16 1630, 365, 1074, 1631, 367, 1073, 1632, 368, 1072, 1633, 369, 1071
   \              0x0432 0x065F
   \              0x016F 0x0431
   \              0x0660 0x0170
   \              0x0430 0x0661
   \              0x0171 0x042F
   \   00001408   0x0662 0x0172      DC16 1634, 370, 1070, 1635, 371, 1069, 1636, 372, 1068, 1637, 373, 1067
   \              0x042E 0x0663
   \              0x0173 0x042D
   \              0x0664 0x0174
   \              0x042C 0x0665
   \              0x0175 0x042B
   \   00001420   0x0666 0x0176      DC16 1638, 374, 1066, 1639, 375, 1065, 1640, 376, 1064, 1641, 377, 1063
   \              0x042A 0x0667
   \              0x0177 0x0429
   \              0x0668 0x0178
   \              0x0428 0x0669
   \              0x0179 0x0427
   \   00001438   0x066A 0x017A      DC16 1642, 378, 1062, 1643, 379, 1061, 1644, 380, 1060, 1645, 381, 1059
   \              0x0426 0x066B
   \              0x017B 0x0425
   \              0x066C 0x017C
   \              0x0424 0x066D
   \              0x017D 0x0423
   \   00001450   0x066E 0x017E      DC16 1646, 382, 1058, 1647, 383, 1057, 1648, 384, 1056, 1649, 385, 1055
   \              0x0422 0x066F
   \              0x017F 0x0421
   \              0x0670 0x0180
   \              0x0420 0x0671
   \              0x0181 0x041F
   \   00001468   0x0672 0x0182      DC16 1650, 386, 1054, 1651, 387, 1053, 1652, 388, 1052, 1653, 389, 1051
   \              0x041E 0x0673
   \              0x0183 0x041D
   \              0x0674 0x0184
   \              0x041C 0x0675
   \              0x0185 0x041B
   \   00001480   0x0676 0x0186      DC16 1654, 390, 1050, 1655, 391, 1049, 1656, 392, 1048, 1657, 393, 1047
   \              0x041A 0x0677
   \              0x0187 0x0419
   \              0x0678 0x0188
   \              0x0418 0x0679
   \              0x0189 0x0417
   \   00001498   0x067A 0x018A      DC16 1658, 394, 1046, 1659, 396, 1044, 1660, 397, 1043, 1661, 398, 1042
   \              0x0416 0x067B
   \              0x018C 0x0414
   \              0x067C 0x018D
   \              0x0413 0x067D
   \              0x018E 0x0412
   \   000014B0   0x067E 0x0190      DC16 1662, 400, 1040, 1663, 401, 1039, 1664, 402, 1038, 1665, 404, 1036
   \              0x0410 0x067F
   \              0x0191 0x040F
   \              0x0680 0x0192
   \              0x040E 0x0681
   \              0x0194 0x040C
   \   000014C8   0x0682 0x0195      DC16 1666, 405, 1035, 1667, 406, 1034, 1668, 408, 1032, 1669, 409, 1031
   \              0x040B 0x0683
   \              0x0196 0x040A
   \              0x0684 0x0198
   \              0x0408 0x0685
   \              0x0199 0x0407
   \   000014E0   0x0686 0x019A      DC16 1670, 410, 1030, 1671, 411, 1029, 1672, 413, 1027, 1673, 414, 1026
   \              0x0406 0x0687
   \              0x019B 0x0405
   \              0x0688 0x019D
   \              0x0403 0x0689
   \              0x019E 0x0402
   \   000014F8   0x068A 0x019F      DC16 1674, 415, 1025, 1675, 417, 1023, 1676, 418, 1022, 1677, 419, 1021
   \              0x0401 0x068B
   \              0x01A1 0x03FF
   \              0x068C 0x01A2
   \              0x03FE 0x068D
   \              0x01A3 0x03FD
   \   00001510   0x068E 0x01A5      DC16 1678, 421, 1019, 1679, 422, 1018, 1680, 423, 1017, 1681, 425, 1015
   \              0x03FB 0x068F
   \              0x01A6 0x03FA
   \              0x0690 0x01A7
   \              0x03F9 0x0691
   \              0x01A9 0x03F7
   \   00001528   0x0692 0x01AA      DC16 1682, 426, 1014, 1683, 427, 1013, 1684, 428, 1012, 1685, 430, 1010
   \              0x03F6 0x0693
   \              0x01AB 0x03F5
   \              0x0694 0x01AC
   \              0x03F4 0x0695
   \              0x01AE 0x03F2
   \   00001540   0x0696 0x01AF      DC16 1686, 431, 1009, 1687, 432, 1008, 1688, 434, 1006, 1689, 435, 1005
   \              0x03F1 0x0697
   \              0x01B0 0x03F0
   \              0x0698 0x01B2
   \              0x03EE 0x0699
   \              0x01B3 0x03ED
   \   00001558   0x069A 0x01B4      DC16 1690, 436, 1004, 1691, 438, 1002, 1692, 439, 1001, 1693, 440, 1000
   \              0x03EC 0x069B
   \              0x01B6 0x03EA
   \              0x069C 0x01B7
   \              0x03E9 0x069D
   \              0x01B8 0x03E8
   \   00001570   0x069E 0x01BA      DC16 1694, 442, 998, 1695, 443, 997, 1696, 445, 995, 1697, 447, 993
   \              0x03E6 0x069F
   \              0x01BB 0x03E5
   \              0x06A0 0x01BD
   \              0x03E3 0x06A1
   \              0x01BF 0x03E1
   \   00001588   0x06A2 0x01C0      DC16 1698, 448, 992, 1699, 450, 990, 1700, 452, 988, 1701, 454, 986
   \              0x03E0 0x06A3
   \              0x01C2 0x03DE
   \              0x06A4 0x01C4
   \              0x03DC 0x06A5
   \              0x01C6 0x03DA
   \   000015A0   0x06A6 0x01C7      DC16 1702, 455, 985, 1703, 457, 983, 1704, 459, 981, 1705, 460, 980
   \              0x03D9 0x06A7
   \              0x01C9 0x03D7
   \              0x06A8 0x01CB
   \              0x03D5 0x06A9
   \              0x01CC 0x03D4
   \   000015B8   0x06AA 0x01CE      DC16 1706, 462, 978, 1707, 464, 976, 1708, 465, 975, 1709, 467, 973
   \              0x03D2 0x06AB
   \              0x01D0 0x03D0
   \              0x06AC 0x01D1
   \              0x03CF 0x06AD
   \              0x01D3 0x03CD
   \   000015D0   0x06AE 0x01D5      DC16 1710, 469, 971, 1711, 470, 970, 1712, 472, 968, 1713, 474, 966
   \              0x03CB 0x06AF
   \              0x01D6 0x03CA
   \              0x06B0 0x01D8
   \              0x03C8 0x06B1
   \              0x01DA 0x03C6
   \   000015E8   0x06B2 0x01DC      DC16 1714, 476, 964, 1715, 477, 963, 1716, 479, 961, 1717, 481, 959
   \              0x03C4 0x06B3
   \              0x01DD 0x03C3
   \              0x06B4 0x01DF
   \              0x03C1 0x06B5
   \              0x01E1 0x03BF
   \   00001600   0x06B6 0x01E2      DC16 1718, 482, 958, 1719, 484, 956, 1720, 486, 954, 1721, 487, 953
   \              0x03BE 0x06B7
   \              0x01E4 0x03BC
   \              0x06B8 0x01E6
   \              0x03BA 0x06B9
   \              0x01E7 0x03B9
   \   00001618   0x06BA 0x01E9      DC16 1722, 489, 951, 1723, 491, 949, 1724, 493, 947, 1725, 495, 945
   \              0x03B7 0x06BB
   \              0x01EB 0x03B5
   \              0x06BC 0x01ED
   \              0x03B3 0x06BD
   \              0x01EF 0x03B1
   \   00001630   0x06BE 0x01F1      DC16 1726, 497, 943, 1727, 499, 941, 1728, 502, 938, 1729, 504, 936
   \              0x03AF 0x06BF
   \              0x01F3 0x03AD
   \              0x06C0 0x01F6
   \              0x03AA 0x06C1
   \              0x01F8 0x03A8
   \   00001648   0x06C2 0x01FA      DC16 1730, 506, 934, 1731, 508, 932, 1732, 511, 929, 1733, 513, 927
   \              0x03A6 0x06C3
   \              0x01FC 0x03A4
   \              0x06C4 0x01FF
   \              0x03A1 0x06C5
   \              0x0201 0x039F
   \   00001660   0x06C6 0x0203      DC16 1734, 515, 925, 1735, 518, 922, 1736, 520, 920, 1737, 522, 918
   \              0x039D 0x06C7
   \              0x0206 0x039A
   \              0x06C8 0x0208
   \              0x0398 0x06C9
   \              0x020A 0x0396
   \   00001678   0x06CA 0x020C      DC16 1738, 524, 916, 1739, 527, 913, 1740, 529, 911, 1741, 531, 909
   \              0x0394 0x06CB
   \              0x020F 0x0391
   \              0x06CC 0x0211
   \              0x038F 0x06CD
   \              0x0213 0x038D
   \   00001690   0x06CE 0x0215      DC16 1742, 533, 907, 1743, 536, 904, 1744, 538, 902, 1745, 540, 900
   \              0x038B 0x06CF
   \              0x0218 0x0388
   \              0x06D0 0x021A
   \              0x0386 0x06D1
   \              0x021C 0x0384
   \   000016A8   0x06D2 0x021F      DC16 1746, 543, 897, 1747, 545, 895, 1748, 547, 893, 1749, 551, 889
   \              0x0381 0x06D3
   \              0x0221 0x037F
   \              0x06D4 0x0223
   \              0x037D 0x06D5
   \              0x0227 0x0379
   \   000016C0   0x06D6 0x022A      DC16 1750, 554, 886, 1751, 557, 883, 1752, 560, 880, 1753, 564, 876
   \              0x0376 0x06D7
   \              0x022D 0x0373
   \              0x06D8 0x0230
   \              0x0370 0x06D9
   \              0x0234 0x036C
   \   000016D8   0x06DA 0x0237      DC16 1754, 567, 873, 1755, 570, 870, 1756, 574, 866, 1757, 577, 863
   \              0x0369 0x06DB
   \              0x023A 0x0366
   \              0x06DC 0x023E
   \              0x0362 0x06DD
   \              0x0241 0x035F
   \   000016F0   0x06DE 0x0244      DC16 1758, 580, 860, 1759, 583, 857, 1760, 587, 853, 1761, 590, 850
   \              0x035C 0x06DF
   \              0x0247 0x0359
   \              0x06E0 0x024B
   \              0x0355 0x06E1
   \              0x024E 0x0352
   \   00001708   0x06E2 0x0251      DC16 1762, 593, 847, 1763, 596, 843, 1764, 600, 840, 1765, 603, 837
   \              0x034F 0x06E3
   \              0x0254 0x034B
   \              0x06E4 0x0258
   \              0x0348 0x06E5
   \              0x025B 0x0345
   \   00001720   0x06E6 0x0261      DC16 1766, 609, 831, 1767, 614, 826, 1768, 620, 820, 1769, 625, 815
   \              0x033F 0x06E7
   \              0x0266 0x033A
   \              0x06E8 0x026C
   \              0x0334 0x06E9
   \              0x0271 0x032F
   \   00001738   0x06EA 0x0277      DC16 1770, 631, 809, 1771, 636, 804, 1772, 642, 798, 1773, 648, 792
   \              0x0329 0x06EB
   \              0x027C 0x0324
   \              0x06EC 0x0282
   \              0x031E 0x06ED
   \              0x0288 0x0318
   \   00001750   0x06EE 0x028D      DC16 1774, 653, 787, 1775, 659, 781, 1776, 670, 770, 1777, 687, 753
   \              0x0313 0x06EF
   \              0x0293 0x030D
   \              0x06F0 0x029E
   \              0x0302 0x06F1
   \              0x02AF 0x02F1
   \   00001768   0x06F2 0x02C0      DC16 1778, 704, 736, 1779
   \              0x02E0 0x06F3

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __vfp float strting2float(BYTE *, BYTE)
   \                     _Z13strting2floatPhh: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x2210             MOVS     R2,#+16
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0xA800             ADD      R0,SP,#+0
   \   0000000E   0x.... 0x....      BL       memset
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xAA00             ADD      R2,SP,#+0
   \   00000016   0xE005             B.N      ??strting2float_0
   \                     ??strting2float_1: (+1)
   \   00000018   0xEB04 0x0140      ADD      R1,R4,R0, LSL #+1
   \   0000001C   0xF991 0x1001      LDRSB    R1,[R1, #+1]
   \   00000020   0x5481             STRB     R1,[R0, R2]
   \   00000022   0x1C40             ADDS     R0,R0,#+1
   \                     ??strting2float_0: (+1)
   \   00000024   0xEBB0 0x0F55      CMP      R0,R5, LSR #+1
   \   00000028   0xDBF6             BLT.N    ??strting2float_1
   \   0000002A   0xA800             ADD      R0,SP,#+0
   \   0000002C   0x.... 0x....      BL       atof
   \   00000030   0xEC51 0x0B10      VMOV     R0,R1,D0
   \   00000034   0x.... 0x....      BL       __aeabi_d2f
   \   00000038   0xEE00 0x0A10      VMOV     S0,R0
   \   0000003C   0xB005             ADD      SP,SP,#+20
   \   0000003E   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void find_next_bmp()
   \                     _Z13find_next_bmpv: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB089             SUB      SP,SP,#+36

          uint8_t rc;
                  ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",51  Warning[Pe550]: 
          variable "rc" was set but never used
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   0000000A   0xAC00             ADD      R4,SP,#+0
   \   0000000C   0x.... 0x....      LDR.W    R5,??DataTable152_1
   \   00000010   0xE002             B.N      ??find_next_bmp_0
   \                     ??find_next_bmp_1: (+1)
   \   00000012   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000016   0x7060             STRB     R0,[R4, #+1]
   \                     ??find_next_bmp_0: (+1)
   \   00000018   0x4628             MOV      R0,R5
   \   0000001A   0x.... 0x....      BL       _ZN10CardReader3eofEv
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD10B             BNE.N    ??find_next_bmp_2
   \   00000022   0x2201             MOVS     R2,#+1
   \   00000024   0xA900             ADD      R1,SP,#+0
   \   00000026   0x4628             MOV      R0,R5
   \   00000028   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   0000002C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000030   0x280A             CMP      R0,#+10
   \   00000032   0xD1EE             BNE.N    ??find_next_bmp_1
   \   00000034   0x7860             LDRB     R0,[R4, #+1]
   \   00000036   0x280D             CMP      R0,#+13
   \   00000038   0xD1EB             BNE.N    ??find_next_bmp_1
   \                     ??find_next_bmp_2: (+1)
   \   0000003A   0xB009             ADD      SP,SP,#+36
   \   0000003C   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 4
   \   __interwork __softfp void clr_ticket()
   \                     _Z10clr_ticketv: (+1)
   \   00000000   0xB672             cpsid i
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x4902             LDR.N    R1,??clr_ticket_0
   \   00000006   0xF8C1 0x0C9C      STR      R0,[R1, #+3228]
   \   0000000A   0xB662             cpsie i
   \   0000000C   0x4770             BX       LR               ;; return
   \   0000000E   0xBF00             Nop      
   \                     ??clr_ticket_0:
   \   00000010   0x........         DC32     card

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void InvertUint8(unsigned char *, unsigned char *)
   \                     _Z11InvertUint8PhS_: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x4613             MOV      R3,R2
   \   00000006   0xE00B             B.N      ??InvertUint8_0
   \                     ??InvertUint8_1: (+1)
   \   00000008   0x2401             MOVS     R4,#+1
   \   0000000A   0x780D             LDRB     R5,[R1, #+0]
   \   0000000C   0xFA04 0xF603      LSL      R6,R4,R3
   \   00000010   0x4235             TST      R5,R6
   \   00000012   0xD004             BEQ.N    ??InvertUint8_2
   \   00000014   0xF1C3 0x0507      RSB      R5,R3,#+7
   \   00000018   0x40AC             LSLS     R4,R4,R5
   \   0000001A   0x4322             ORRS     R2,R4,R2
   \   0000001C   0xB2D2             UXTB     R2,R2
   \                     ??InvertUint8_2: (+1)
   \   0000001E   0x1C5B             ADDS     R3,R3,#+1
   \                     ??InvertUint8_0: (+1)
   \   00000020   0x2B08             CMP      R3,#+8
   \   00000022   0xDBF1             BLT.N    ??InvertUint8_1
   \   00000024   0x7002             STRB     R2,[R0, #+0]
   \   00000026   0xBC70             POP      {R4-R6}
   \   00000028   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void InvertUint16(unsigned short *, unsigned short *)
   \                     _Z12InvertUint16PtS_: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x4613             MOV      R3,R2
   \   00000006   0xE00B             B.N      ??InvertUint16_0
   \                     ??InvertUint16_1: (+1)
   \   00000008   0x2401             MOVS     R4,#+1
   \   0000000A   0x880D             LDRH     R5,[R1, #+0]
   \   0000000C   0xFA04 0xF603      LSL      R6,R4,R3
   \   00000010   0x4235             TST      R5,R6
   \   00000012   0xD004             BEQ.N    ??InvertUint16_2
   \   00000014   0xF1C3 0x050F      RSB      R5,R3,#+15
   \   00000018   0x40AC             LSLS     R4,R4,R5
   \   0000001A   0x4322             ORRS     R2,R4,R2
   \   0000001C   0xB292             UXTH     R2,R2
   \                     ??InvertUint16_2: (+1)
   \   0000001E   0x1C5B             ADDS     R3,R3,#+1
   \                     ??InvertUint16_0: (+1)
   \   00000020   0x2B10             CMP      R3,#+16
   \   00000022   0xDBF1             BLT.N    ??InvertUint16_1
   \   00000024   0x8002             STRH     R2,[R0, #+0]
   \   00000026   0xBC70             POP      {R4-R6}
   \   00000028   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp uint16_t CRC16_XMODEM(unsigned char *, unsigned int)
   \                     _Z12CRC16_XMODEMPhj: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x2200             MOVS     R2,#+0
   \                     ??CRC16_XMODEM_0: (+1)
   \   00000004   0x460B             MOV      R3,R1
   \   00000006   0x1E59             SUBS     R1,R3,#+1
   \   00000008   0x2B00             CMP      R3,#+0
   \   0000000A   0xD013             BEQ.N    ??CRC16_XMODEM_1
   \   0000000C   0xF810 0x3B01      LDRB     R3,[R0], #+1
   \   00000010   0xEA82 0x2203      EOR      R2,R2,R3, LSL #+8
   \   00000014   0x2300             MOVS     R3,#+0
   \   00000016   0xE002             B.N      ??CRC16_XMODEM_2
   \                     ??CRC16_XMODEM_3: (+1)
   \   00000018   0x4622             MOV      R2,R4
   \   0000001A   0xB292             UXTH     R2,R2
   \                     ??CRC16_XMODEM_4: (+1)
   \   0000001C   0x1C5B             ADDS     R3,R3,#+1
   \                     ??CRC16_XMODEM_2: (+1)
   \   0000001E   0x2B08             CMP      R3,#+8
   \   00000020   0xDAF0             BGE.N    ??CRC16_XMODEM_0
   \   00000022   0x0054             LSLS     R4,R2,#+1
   \   00000024   0x0412             LSLS     R2,R2,#+16
   \   00000026   0xD5F7             BPL.N    ??CRC16_XMODEM_3
   \   00000028   0xF484 0x5280      EOR      R2,R4,#0x1000
   \   0000002C   0xF082 0x0221      EOR      R2,R2,#0x21
   \   00000030   0xB292             UXTH     R2,R2
   \   00000032   0xE7F3             B.N      ??CRC16_XMODEM_4
   \                     ??CRC16_XMODEM_1: (+1)
   \   00000034   0x4610             MOV      R0,R2
   \   00000036   0x0A00             LSRS     R0,R0,#+8
   \   00000038   0xEA40 0x2002      ORR      R0,R0,R2, LSL #+8
   \   0000003C   0xB280             UXTH     R0,R0
   \   0000003E   0xBC10             POP      {R4}
   \   00000040   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp MKS_DLP::MKS_DLP()
   \                     _ZN7MKS_DLPC1Ev: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xF204 0x20F2      ADDW     R0,R4,#+754
   \   00000008   0x.... 0x....      BL       _ZN7SSD2828C1Ev
   \   0000000C   0xF504 0x70EE      ADD      R0,R4,#+476
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x75C1             STRB     R1,[R0, #+23]
   \   00000014   0xF8A4 0x11DC      STRH     R1,[R4, #+476]
   \   00000018   0x7081             STRB     R1,[R0, #+2]
   \   0000001A   0x70C1             STRB     R1,[R0, #+3]
   \   0000001C   0x7301             STRB     R1,[R0, #+12]
   \   0000001E   0x7101             STRB     R1,[R0, #+4]
   \   00000020   0xF8C4 0x12D8      STR      R1,[R4, #+728]
   \   00000024   0xF241 0x3188      MOVW     R1,#+5000
   \   00000028   0x6081             STR      R1,[R0, #+8]
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0x7341             STRB     R1,[R0, #+13]
   \   0000002E   0x6101             STR      R1,[R0, #+16]
   \   00000030   0x4608             MOV      R0,R1
   \   00000032   0xE010             B.N      ??MKS_DLP_0
   \                     ??MKS_DLP_1: (+1)
   \   00000034   0xEB04 0x0180      ADD      R1,R4,R0, LSL #+2
   \   00000038   0x2200             MOVS     R2,#+0
   \   0000003A   0xF8C1 0x21F8      STR      R2,[R1, #+504]
   \   0000003E   0xEB04 0x0340      ADD      R3,R4,R0, LSL #+1
   \   00000042   0xF8A3 0x2248      STRH     R2,[R3, #+584]
   \   00000046   0x22A6             MOVS     R2,#+166
   \   00000048   0x1903             ADDS     R3,R0,R4
   \   0000004A   0xF883 0x2270      STRB     R2,[R3, #+624]
   \   0000004E   0x2200             MOVS     R2,#+0
   \   00000050   0xF8C1 0x2284      STR      R2,[R1, #+644]
   \   00000054   0x1C40             ADDS     R0,R0,#+1
   \                     ??MKS_DLP_0: (+1)
   \   00000056   0x2814             CMP      R0,#+20
   \   00000058   0xDBEC             BLT.N    ??MKS_DLP_1
   \   0000005A   0x4620             MOV      R0,R4
   \   0000005C   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::status_init()
   \                     _ZN7MKS_DLP11status_initEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF8A4 0x01DC      STRH     R0,[R4, #+476]
   \   0000000A   0xF504 0x70EE      ADD      R0,R4,#+476
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x7081             STRB     R1,[R0, #+2]
   \   00000012   0x70C1             STRB     R1,[R0, #+3]
   \   00000014   0x7101             STRB     R1,[R0, #+4]
   \   00000016   0x7341             STRB     R1,[R0, #+13]
   \   00000018   0x.... 0x....      BL       _Z10clr_ticketv
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable164
   \   00000020   0x.... 0x....      BL       _ZN9Stopwatch5startEv
   \   00000024   0x.... 0x....      ADR.W    R0,`?<Constant "totalTime(s):">`
   \   00000028   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       _ZN7MKS_DLP18get_totalPrintTimeEv
   \   00000032   0x220A             MOVS     R2,#+10
   \   00000034   0x4601             MOV      R1,R0
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable164_1
   \   0000003A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000003E   0x.... 0x....      B.W      _ZN5Print5printEji

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __vfp void MKS_DLP::moveRelative_Z(float, float)
   \                     _ZN7MKS_DLP14moveRelative_ZEff: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xED6D 0x0A01      VPUSH    {S1}
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0xF880 0x11EA      STRB     R1,[R0, #+490]
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable157
   \   00000010   0xEDD0 0x0A0F      VLDR     S1,[R0, #+60]
   \   00000014   0xEE30 0x0A80      VADD.F32 S0,S1,S0
   \   00000018   0xED80 0x0A0F      VSTR     S0,[R0, #+60]
   \   0000001C   0xA900             ADD      R1,SP,#+0
   \   0000001E   0x303C             ADDS     R0,R0,#+60
   \   00000020   0x.... 0x....      BL       _Z21do_blocking_move_to_zRKfS0_
   \   00000024   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   \   00000028   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __vfp void MKS_DLP::moveRelativeZandGetBmp(float, float)
   \                     _ZN7MKS_DLP22moveRelativeZandGetBmpEff: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xED6D 0x0A01      VPUSH    {S1}
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF884 0x01EA      STRB     R0,[R4, #+490]
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable157
   \   00000012   0xEDD0 0x0A0F      VLDR     S1,[R0, #+60]
   \   00000016   0xEE30 0x0A80      VADD.F32 S0,S1,S0
   \   0000001A   0xED80 0x0A0F      VSTR     S0,[R0, #+60]
   \   0000001E   0xA900             ADD      R1,SP,#+0
   \   00000020   0x303C             ADDS     R0,R0,#+60
   \   00000022   0x.... 0x....      BL       _Z28do_blocking_move_to_z_nowaitRKfS0_
   \   00000026   0x.... 0x....      LDR.W    R5,??DataTable165
   \   0000002A   0xF895 0x0CB7      LDRB     R0,[R5, #+3255]
   \   0000002E   0x2801             CMP      R0,#+1
   \   00000030   0xD103             BNE.N    ??moveRelativeZandGetBmp_0
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       _ZN7MKS_DLP15get_sdcard_bmpsEv
   \   00000038   0xE024             B.N      ??moveRelativeZandGetBmp_1
   \                     ??moveRelativeZandGetBmp_0: (+1)
   \   0000003A   0xF605 0x56D4      ADDW     R6,R5,#+3540
   \   0000003E   0x69B0             LDR      R0,[R6, #+24]
   \   00000040   0x2802             CMP      R0,#+2
   \   00000042   0xDB15             BLT.N    ??moveRelativeZandGetBmp_2
   \   00000044   0x2700             MOVS     R7,#+0
   \                     ??moveRelativeZandGetBmp_3: (+1)
   \   00000046   0xB2FF             UXTB     R7,R7
   \   00000048   0x4638             MOV      R0,R7
   \   0000004A   0x69B1             LDR      R1,[R6, #+24]
   \   0000004C   0x4288             CMP      R0,R1
   \   0000004E   0xDA19             BGE.N    ??moveRelativeZandGetBmp_1
   \   00000050   0x463A             MOV      R2,R7
   \   00000052   0xF8B4 0x11DC      LDRH     R1,[R4, #+476]
   \   00000056   0x8EA3             LDRH     R3,[R4, #+52]
   \   00000058   0xFA13 0xF181      UXTAH    R1,R3,R1
   \   0000005C   0x1E49             SUBS     R1,R1,#+1
   \   0000005E   0xF8D5 0x3DD4      LDR      R3,[R5, #+3540]
   \   00000062   0xFB03 0x1100      MLA      R1,R3,R0,R1
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0x.... 0x....      BL       _ZN7MKS_DLP21decode_layer_from_rleEjh
   \   0000006C   0x1C7F             ADDS     R7,R7,#+1
   \   0000006E   0xE7EA             B.N      ??moveRelativeZandGetBmp_3
   \                     ??moveRelativeZandGetBmp_2: (+1)
   \   00000070   0x2200             MOVS     R2,#+0
   \   00000072   0xF8B4 0x01DC      LDRH     R0,[R4, #+476]
   \   00000076   0x8EA1             LDRH     R1,[R4, #+52]
   \   00000078   0xFA11 0xF080      UXTAH    R0,R1,R0
   \   0000007C   0x1E41             SUBS     R1,R0,#+1
   \   0000007E   0x4620             MOV      R0,R4
   \   00000080   0x.... 0x....      BL       _ZN7MKS_DLP21decode_layer_from_rleEjh
   \                     ??moveRelativeZandGetBmp_1: (+1)
   \   00000084   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   \   00000088   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \   __interwork __softfp void MKS_DLP::moveFistLayer_Z()
   \                     _ZN7MKS_DLP15moveFistLayer_ZEv: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x.... 0x....      LDR.W    R6,??DataTable157
   \   00000008   0xED95 0x0A09      VLDR     S0,[R5, #+36]
   \   0000000C   0xEDD6 0x0A17      VLDR     S1,[R6, #+92]
   \   00000010   0xEE30 0x0A60      VSUB.F32 S0,S0,S1
   \   00000014   0xED86 0x0A0F      VSTR     S0,[R6, #+60]
   \   00000018   0x....             LDR.N    R0,??DataTable153_2
   \   0000001A   0xED90 0x0A04      VLDR     S0,[R0, #+16]
   \   0000001E   0xEDDF 0x....      VLDR.W   S1,??DataTable153  ;; 0x42f00000
   \   00000022   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   00000026   0xED8D 0x0A00      VSTR     S0,[SP, #+0]
   \   0000002A   0xA900             ADD      R1,SP,#+0
   \   0000002C   0xF106 0x003C      ADD      R0,R6,#+60
   \   00000030   0x.... 0x....      BL       _Z21do_blocking_move_to_zRKfS0_
   \   00000034   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   \   00000038   0x.... 0x....      ADR.W    R0,`?<Constant "Move Z offset:">`
   \   0000003C   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   00000040   0x.... 0x....      LDR.W    R7,??DataTable164_1
   \   00000044   0x2102             MOVS     R1,#+2
   \   00000046   0x460C             MOV      R4,R1
   \   00000048   0x6DF0             LDR      R0,[R6, #+92]
   \   0000004A   0x.... 0x....      BL       __aeabi_f2d
   \   0000004E   0xEC41 0x0B10      VMOV     D0,R0,R1
   \   00000052   0x4621             MOV      R1,R4
   \   00000054   0x4638             MOV      R0,R7
   \   00000056   0x.... 0x....      BL       _ZN5Print5printEdi
   \   0000005A   0x.... 0x....      BL       _ZN7Stepper16report_positionsEv
   \   0000005E   0xED95 0x0A09      VLDR     S0,[R5, #+36]
   \   00000062   0xED86 0x0A0B      VSTR     S0,[R6, #+44]
   \   00000066   0xED86 0x0A0F      VSTR     S0,[R6, #+60]
   \   0000006A   0x.... 0x....      ADR.W    R0,`?<Constant "Reset Z:">`
   \   0000006E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   00000072   0x6AF0             LDR      R0,[R6, #+44]
   \   00000074   0x.... 0x....      BL       __aeabi_f2d
   \   00000078   0xEC41 0x0B10      VMOV     D0,R0,R1
   \   0000007C   0x4621             MOV      R1,R4
   \   0000007E   0x4638             MOV      R0,R7
   \   00000080   0x.... 0x....      BL       _ZN5Print5printEdi
   \   00000084   0x.... 0x....      BL       _ZN7Stepper16report_positionsEv
   \   00000088   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \   __interwork __softfp void MKS_DLP::moveMax_Z()
   \                     _ZN7MKS_DLP9moveMax_ZEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable157
   \   00000006   0x....             LDR.N    R1,??DataTable153_2
   \   00000008   0x688A             LDR      R2,[R1, #+8]
   \   0000000A   0x63C2             STR      R2,[R0, #+60]
   \   0000000C   0xED91 0x0A04      VLDR     S0,[R1, #+16]
   \   00000010   0xEDDF 0x....      VLDR.W   S1,??DataTable153  ;; 0x42f00000
   \   00000014   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   00000018   0xEEF0 0x0A00      VMOV.F32 S1,#2.0
   \   0000001C   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000020   0xED8D 0x0A00      VSTR     S0,[SP, #+0]
   \   00000024   0xA900             ADD      R1,SP,#+0
   \   00000026   0x303C             ADDS     R0,R0,#+60
   \   00000028   0x.... 0x....      BL       _Z21do_blocking_move_to_zRKfS0_
   \   0000002C   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   \   00000030   0x.... 0x....      BL       _Z23report_current_positionv
   \   00000034   0x.... 0x....      ADR.W    R0,`?<Constant "print end.\\n">`
   \   00000038   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   0000003C   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::getHead()
   \                     _ZN7MKS_DLP7getHeadEv: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x4604             MOV      R4,R0

  	uint8_t rc;
  	        ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",318  Warning[Pe550]: 
          variable "rc" was set but never used
   \   00000006   0x....             LDR.N    R5,??DataTable152_1
   \   00000008   0x2203             MOVS     R2,#+3
   \   0000000A   0xA900             ADD      R1,SP,#+0
   \   0000000C   0x4628             MOV      R0,R5
   \   0000000E   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000012   0x2203             MOVS     R2,#+3
   \   00000014   0xA900             ADD      R1,SP,#+0
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       memcpy
   \   0000001C   0x2208             MOVS     R2,#+8
   \   0000001E   0xA900             ADD      R1,SP,#+0
   \   00000020   0x4628             MOV      R0,R5
   \   00000022   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000026   0x2208             MOVS     R2,#+8
   \   00000028   0xA900             ADD      R1,SP,#+0
   \   0000002A   0x1CE0             ADDS     R0,R4,#+3
   \   0000002C   0x.... 0x....      BL       memcpy
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x72A0             STRB     R0,[R4, #+10]
   \   00000034   0x.... 0x....      ADR.W    R1,`?<Constant "MKSDLP">`
   \   00000038   0x1CE0             ADDS     R0,R4,#+3
   \   0000003A   0x.... 0x....      BL       _Z6strstrPcPKc
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD103             BNE.N    ??getHead_0
   \   00000042   0x4628             MOV      R0,R5
   \   00000044   0x.... 0x....      BL       _ZN10CardReader19printingHasFinishedEv
   \   00000048   0xE092             B.N      ??getHead_1
   \                     ??getHead_0: (+1)
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable165_2  ;; 0x186af
   \   0000004E   0x4628             MOV      R0,R5
   \   00000050   0x.... 0x....      BL       _ZN10CardReader8setIndexEl
   \   00000054   0x2202             MOVS     R2,#+2
   \   00000056   0xA900             ADD      R1,SP,#+0
   \   00000058   0x4628             MOV      R0,R5
   \   0000005A   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   0000005E   0xAE00             ADD      R6,SP,#+0
   \   00000060   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000064   0x7871             LDRB     R1,[R6, #+1]
   \   00000066   0xEA41 0x2000      ORR      R0,R1,R0, LSL #+8
   \   0000006A   0x81A0             STRH     R0,[R4, #+12]
   \   0000006C   0x2202             MOVS     R2,#+2
   \   0000006E   0xA900             ADD      R1,SP,#+0
   \   00000070   0x4628             MOV      R0,R5
   \   00000072   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000076   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000007A   0x7871             LDRB     R1,[R6, #+1]
   \   0000007C   0xEA41 0x2000      ORR      R0,R1,R0, LSL #+8
   \   00000080   0x81E0             STRH     R0,[R4, #+14]
   \   00000082   0x2202             MOVS     R2,#+2
   \   00000084   0xA900             ADD      R1,SP,#+0
   \   00000086   0x4628             MOV      R0,R5
   \   00000088   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   0000008C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000090   0x7871             LDRB     R1,[R6, #+1]
   \   00000092   0xEA41 0x2000      ORR      R0,R1,R0, LSL #+8
   \   00000096   0x8220             STRH     R0,[R4, #+16]
   \   00000098   0x2204             MOVS     R2,#+4
   \   0000009A   0xA900             ADD      R1,SP,#+0
   \   0000009C   0x4628             MOV      R0,R5
   \   0000009E   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   000000A2   0x78F2             LDRB     R2,[R6, #+3]
   \   000000A4   0x74A2             STRB     R2,[R4, #+18]
   \   000000A6   0xA900             ADD      R1,SP,#+0
   \   000000A8   0x4628             MOV      R0,R5
   \   000000AA   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   000000AE   0x7CA1             LDRB     R1,[R4, #+18]
   \   000000B0   0xA800             ADD      R0,SP,#+0
   \   000000B2   0x.... 0x....      BL       _Z13strting2floatPhh
   \   000000B6   0xED84 0x0A05      VSTR     S0,[R4, #+20]
   \   000000BA   0x2204             MOVS     R2,#+4
   \   000000BC   0xA900             ADD      R1,SP,#+0
   \   000000BE   0x4628             MOV      R0,R5
   \   000000C0   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   000000C4   0x78F2             LDRB     R2,[R6, #+3]
   \   000000C6   0x7622             STRB     R2,[R4, #+24]
   \   000000C8   0xA900             ADD      R1,SP,#+0
   \   000000CA   0x4628             MOV      R0,R5
   \   000000CC   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   000000D0   0x7E21             LDRB     R1,[R4, #+24]
   \   000000D2   0xA800             ADD      R0,SP,#+0
   \   000000D4   0x.... 0x....      BL       _Z13strting2floatPhh
   \   000000D8   0xED84 0x0A07      VSTR     S0,[R4, #+28]
   \   000000DC   0x2204             MOVS     R2,#+4
   \   000000DE   0xA900             ADD      R1,SP,#+0
   \   000000E0   0x4628             MOV      R0,R5
   \   000000E2   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   000000E6   0x78F2             LDRB     R2,[R6, #+3]
   \   000000E8   0xF884 0x2020      STRB     R2,[R4, #+32]
   \   000000EC   0xA900             ADD      R1,SP,#+0
   \   000000EE   0x4628             MOV      R0,R5
   \   000000F0   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   000000F4   0xF894 0x1020      LDRB     R1,[R4, #+32]
   \   000000F8   0xA800             ADD      R0,SP,#+0
   \   000000FA   0x.... 0x....      BL       _Z13strting2floatPhh
   \   000000FE   0xED84 0x0A09      VSTR     S0,[R4, #+36]
   \   00000102   0x2202             MOVS     R2,#+2
   \   00000104   0xA900             ADD      R1,SP,#+0
   \   00000106   0x4628             MOV      R0,R5
   \   00000108   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   0000010C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000110   0x7871             LDRB     R1,[R6, #+1]
   \   00000112   0xEA41 0x2100      ORR      R1,R1,R0, LSL #+8
   \   00000116   0x4620             MOV      R0,R4
   \   00000118   0x.... 0x....      BL       _ZN7MKS_DLP13set_LedOnTimeEt
   \   0000011C   0x2202             MOVS     R2,#+2
   \   0000011E   0xA900             ADD      R1,SP,#+0
   \   00000120   0x4628             MOV      R0,R5
   \   00000122   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000126   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000012A   0x7871             LDRB     R1,[R6, #+1]
   \   0000012C   0xEA41 0x2100      ORR      R1,R1,R0, LSL #+8
   \   00000130   0x4620             MOV      R0,R4
   \   00000132   0x.... 0x....      BL       _ZN7MKS_DLP14set_LedOffTimeEt
   \   00000136   0x2202             MOVS     R2,#+2
   \   00000138   0xA900             ADD      R1,SP,#+0
   \   0000013A   0x4628             MOV      R0,R5
   \   0000013C   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000140   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000144   0x7871             LDRB     R1,[R6, #+1]
   \   00000146   0xEA41 0x2100      ORR      R1,R1,R0, LSL #+8
   \   0000014A   0x4620             MOV      R0,R4
   \   0000014C   0x.... 0x....      BL       _ZN7MKS_DLP19set_BottomLedOnTimeEt
   \   00000150   0x2202             MOVS     R2,#+2
   \   00000152   0xA900             ADD      R1,SP,#+0
   \   00000154   0x4628             MOV      R0,R5
   \   00000156   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   0000015A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000015E   0x7871             LDRB     R1,[R6, #+1]
   \   00000160   0xEA41 0x2100      ORR      R1,R1,R0, LSL #+8
   \   00000164   0x4620             MOV      R0,R4
   \   00000166   0x.... 0x....      BL       _ZN7MKS_DLP16set_BottomlayersEt
   \   0000016A   0x4620             MOV      R0,R4
   \   0000016C   0x.... 0x....      BL       _ZN7MKS_DLP11status_initEv
   \                     ??getHead_1: (+1)
   \   00000170   0xB008             ADD      SP,SP,#+32
   \   00000172   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::getHead1()
   \                     _ZN7MKS_DLP8getHead1Ev: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x4604             MOV      R4,R0

  		uint8_t rc;
  		        ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",387  Warning[Pe550]: 
          variable "rc" was set but never used
   \   00000006   0x.... 0x....      LDR.W    R5,??DataTable165
   \   0000000A   0x2203             MOVS     R2,#+3
   \   0000000C   0xA900             ADD      R1,SP,#+0
   \   0000000E   0x4628             MOV      R0,R5
   \   00000010   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000014   0x2203             MOVS     R2,#+3
   \   00000016   0xA900             ADD      R1,SP,#+0
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       memcpy
   \   0000001E   0x2208             MOVS     R2,#+8
   \   00000020   0xA900             ADD      R1,SP,#+0
   \   00000022   0x4628             MOV      R0,R5
   \   00000024   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000028   0x2208             MOVS     R2,#+8
   \   0000002A   0xA900             ADD      R1,SP,#+0
   \   0000002C   0x1CE0             ADDS     R0,R4,#+3
   \   0000002E   0x.... 0x....      BL       memcpy
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x72A0             STRB     R0,[R4, #+10]
   \   00000036   0x.... 0x....      ADR.W    R1,`?<Constant "MKSDLP">`
   \   0000003A   0x1CE0             ADDS     R0,R4,#+3
   \   0000003C   0x.... 0x....      BL       _Z6strstrPcPKc
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD103             BNE.N    ??getHead1_0
   \   00000044   0x4628             MOV      R0,R5
   \   00000046   0x.... 0x....      BL       _ZN10CardReader19printingHasFinishedEv
   \   0000004A   0xE05B             B.N      ??getHead1_1
   \                     ??getHead1_0: (+1)
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable167  ;; 0x2fa37
   \   00000050   0x4628             MOV      R0,R5
   \   00000052   0x.... 0x....      BL       _ZN10CardReader8setIndexEl
   \   00000056   0x2202             MOVS     R2,#+2
   \   00000058   0xA900             ADD      R1,SP,#+0
   \   0000005A   0x4628             MOV      R0,R5
   \   0000005C   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000060   0xAE00             ADD      R6,SP,#+0
   \   00000062   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000066   0x7871             LDRB     R1,[R6, #+1]
   \   00000068   0xEA41 0x2000      ORR      R0,R1,R0, LSL #+8
   \   0000006C   0x81A0             STRH     R0,[R4, #+12]
   \   0000006E   0x2202             MOVS     R2,#+2
   \   00000070   0xA900             ADD      R1,SP,#+0
   \   00000072   0x4628             MOV      R0,R5
   \   00000074   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000078   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000007C   0x7871             LDRB     R1,[R6, #+1]
   \   0000007E   0xEA41 0x2000      ORR      R0,R1,R0, LSL #+8
   \   00000082   0x81E0             STRH     R0,[R4, #+14]
   \   00000084   0x2202             MOVS     R2,#+2
   \   00000086   0xA900             ADD      R1,SP,#+0
   \   00000088   0x4628             MOV      R0,R5
   \   0000008A   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   0000008E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000092   0x7871             LDRB     R1,[R6, #+1]
   \   00000094   0xEA41 0x2000      ORR      R0,R1,R0, LSL #+8
   \   00000098   0x8220             STRH     R0,[R4, #+16]
   \   0000009A   0x2204             MOVS     R2,#+4
   \   0000009C   0xA900             ADD      R1,SP,#+0
   \   0000009E   0x4628             MOV      R0,R5
   \   000000A0   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   000000A4   0x78F2             LDRB     R2,[R6, #+3]
   \   000000A6   0x74A2             STRB     R2,[R4, #+18]
   \   000000A8   0xA900             ADD      R1,SP,#+0
   \   000000AA   0x4628             MOV      R0,R5
   \   000000AC   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   000000B0   0x7CA1             LDRB     R1,[R4, #+18]
   \   000000B2   0xA800             ADD      R0,SP,#+0
   \   000000B4   0x.... 0x....      BL       _Z13strting2floatPhh
   \   000000B8   0xED84 0x0A05      VSTR     S0,[R4, #+20]
   \   000000BC   0x2204             MOVS     R2,#+4
   \   000000BE   0xA900             ADD      R1,SP,#+0
   \   000000C0   0x4628             MOV      R0,R5
   \   000000C2   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   000000C6   0x78F2             LDRB     R2,[R6, #+3]
   \   000000C8   0x7622             STRB     R2,[R4, #+24]
   \   000000CA   0xA900             ADD      R1,SP,#+0
   \   000000CC   0x4628             MOV      R0,R5
   \   000000CE   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   000000D2   0x7E21             LDRB     R1,[R4, #+24]
   \   000000D4   0xA800             ADD      R0,SP,#+0
   \   000000D6   0x.... 0x....      BL       _Z13strting2floatPhh
   \   000000DA   0xED84 0x0A07      VSTR     S0,[R4, #+28]
   \   000000DE   0x2204             MOVS     R2,#+4
   \   000000E0   0xA900             ADD      R1,SP,#+0
   \   000000E2   0x4628             MOV      R0,R5
   \   000000E4   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   000000E8   0x78F2             LDRB     R2,[R6, #+3]
   \   000000EA   0xF884 0x2020      STRB     R2,[R4, #+32]
   \   000000EE   0xA900             ADD      R1,SP,#+0
   \   000000F0   0x4628             MOV      R0,R5
   \   000000F2   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   000000F6   0xF894 0x1020      LDRB     R1,[R4, #+32]
   \   000000FA   0xA800             ADD      R0,SP,#+0
   \   000000FC   0x.... 0x....      BL       _Z13strting2floatPhh
   \   00000100   0xED84 0x0A09      VSTR     S0,[R4, #+36]
   \                     ??getHead1_1: (+1)
   \   00000104   0xB008             ADD      SP,SP,#+32
   \   00000106   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::getHead2()
   \                     _ZN7MKS_DLP8getHead2Ev: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x4604             MOV      R4,R0

  	uint8_t rc;
  	        ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",435  Warning[Pe550]: 
          variable "rc" was set but never used
   \   00000006   0x.... 0x....      LDR.W    R5,??DataTable165
   \   0000000A   0x2202             MOVS     R2,#+2
   \   0000000C   0xA900             ADD      R1,SP,#+0
   \   0000000E   0x4628             MOV      R0,R5
   \   00000010   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000014   0xAE00             ADD      R6,SP,#+0
   \   00000016   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001A   0x7871             LDRB     R1,[R6, #+1]
   \   0000001C   0xEA41 0x2100      ORR      R1,R1,R0, LSL #+8
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       _ZN7MKS_DLP13set_LedOnTimeEt
   \   00000026   0x2202             MOVS     R2,#+2
   \   00000028   0xA900             ADD      R1,SP,#+0
   \   0000002A   0x4628             MOV      R0,R5
   \   0000002C   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000030   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000034   0x7871             LDRB     R1,[R6, #+1]
   \   00000036   0xEA41 0x2100      ORR      R1,R1,R0, LSL #+8
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       _ZN7MKS_DLP14set_LedOffTimeEt
   \   00000040   0x2202             MOVS     R2,#+2
   \   00000042   0xA900             ADD      R1,SP,#+0
   \   00000044   0x4628             MOV      R0,R5
   \   00000046   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   0000004A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000004E   0x7871             LDRB     R1,[R6, #+1]
   \   00000050   0xEA41 0x2100      ORR      R1,R1,R0, LSL #+8
   \   00000054   0x4620             MOV      R0,R4
   \   00000056   0x.... 0x....      BL       _ZN7MKS_DLP19set_BottomLedOnTimeEt
   \   0000005A   0x2202             MOVS     R2,#+2
   \   0000005C   0xA900             ADD      R1,SP,#+0
   \   0000005E   0x4628             MOV      R0,R5
   \   00000060   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000064   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000068   0x7871             LDRB     R1,[R6, #+1]
   \   0000006A   0xEA41 0x2100      ORR      R1,R1,R0, LSL #+8
   \   0000006E   0x4620             MOV      R0,R4
   \   00000070   0x.... 0x....      BL       _ZN7MKS_DLP16set_BottomlayersEt
   \   00000074   0x6AA0             LDR      R0,[R4, #+40]
   \   00000076   0x63A0             STR      R0,[R4, #+56]
   \   00000078   0x6B20             LDR      R0,[R4, #+48]
   \   0000007A   0x63E0             STR      R0,[R4, #+60]
   \   0000007C   0xB008             ADD      SP,SP,#+32
   \   0000007E   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::startFileprint()
   \                     _ZN7MKS_DLP14startFileprintEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable165
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0xF8C0 0x1DEC      STR      R1,[R0, #+3564]
   \   0000000E   0xF600 0x40B6      ADDW     R0,R0,#+3254
   \   00000012   0x.... 0x....      BL       _ZN7SSD28284initEv
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       _ZN7MKS_DLP8getHead1Ev
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       _ZN7MKS_DLP8getHead2Ev
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       _ZN7MKS_DLP23clean_Information_layerEv
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       _ZN7MKS_DLP11status_initEv
   \   0000002E   0x.... 0x....      BL       draw_status_clear
   \   00000032   0x.... 0x....      BL       display_print_statue
   \   00000036   0x.... 0x....      BL       GUI_Exec
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable169
   \   0000003E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000042   0x.... 0x....      B.W      _Z7mks_G28Pc

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp uint8_t MKS_DLP::bank2disp_read()
   \                     _ZN7MKS_DLP14bank2disp_readEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}

  	uint8_t mark=0;
  	        ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",470  Warning[Pe550]: 
          variable "mark" was set but never used

  	uint8_t data1=0;
  	        ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",471  Warning[Pe550]: 
          variable "data1" was set but never used
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable169_1  ;; 0x4240029c
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x6020             STR      R0,[R4, #+0]
   \   0000000A   0x2080             MOVS     R0,#+128
   \   0000000C   0x.... 0x....      BL       SPI1_ReadWriteByte
   \   00000010   0x20FF             MOVS     R0,#+255
   \   00000012   0x.... 0x....      BL       SPI1_ReadWriteByte
   \   00000016   0x20FF             MOVS     R0,#+255
   \   00000018   0x.... 0x....      BL       SPI1_ReadWriteByte
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x6021             STR      R1,[R4, #+0]
   \   00000020   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp uint8_t MKS_DLP::bank2disp_enable(uint8_t, uint8_t, uint8_t)
   \                     _ZN7MKS_DLP16bank2disp_enableEhhh: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF884 0x01F0      STRB     R0,[R4, #+496]
   \   0000000A   0xF504 0x75F8      ADD      R5,R4,#+496
   \   0000000E   0x7068             STRB     R0,[R5, #+1]
   \   00000010   0x0198             LSLS     R0,R3,#+6
   \   00000012   0xEA40 0x10C2      ORR      R0,R0,R2, LSL #+7
   \   00000016   0xEA40 0x1001      ORR      R0,R0,R1, LSL #+4
   \   0000001A   0x70A8             STRB     R0,[R5, #+2]
   \   0000001C   0x2600             MOVS     R6,#+0
   \   0000001E   0xE000             B.N      ??bank2disp_enable_0
   \                     ??bank2disp_enable_1: (+1)
   \   00000020   0x1C76             ADDS     R6,R6,#+1
   \                     ??bank2disp_enable_0: (+1)
   \   00000022   0xB2F6             UXTB     R6,R6
   \   00000024   0x2E05             CMP      R6,#+5
   \   00000026   0xDA19             BGE.N    ??bank2disp_enable_2
   \   00000028   0x.... 0x....      LDR.W    R7,??DataTable169_1  ;; 0x4240029c
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x6038             STR      R0,[R7, #+0]
   \   00000030   0xF894 0x01F0      LDRB     R0,[R4, #+496]
   \   00000034   0x.... 0x....      BL       SPI1_ReadWriteByte
   \   00000038   0x7868             LDRB     R0,[R5, #+1]
   \   0000003A   0x.... 0x....      BL       SPI1_ReadWriteByte
   \   0000003E   0x78A8             LDRB     R0,[R5, #+2]
   \   00000040   0x.... 0x....      BL       SPI1_ReadWriteByte
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x6038             STR      R0,[R7, #+0]
   \   00000048   0x78AF             LDRB     R7,[R5, #+2]
   \   0000004A   0x4620             MOV      R0,R4
   \   0000004C   0x.... 0x....      BL       _ZN7MKS_DLP14bank2disp_readEv
   \   00000050   0xF000 0x00F0      AND      R0,R0,#0xF0
   \   00000054   0x4287             CMP      R7,R0
   \   00000056   0xD1E3             BNE.N    ??bank2disp_enable_1
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??bank2disp_enable_2: (+1)
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp uint8_t MKS_DLP::reTransmission()
   \                     _ZN7MKS_DLP14reTransmissionEv: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x2500             MOVS     R5,#+0
   \   00000006   0x.... 0x....      LDR.W    R6,??DataTable169_1  ;; 0x4240029c
   \   0000000A   0x.... 0x....      LDR.W    R7,??DataTable169_2
   \   0000000E   0xE000             B.N      ??reTransmission_0
   \                     ??reTransmission_1: (+1)
   \   00000010   0x1C6D             ADDS     R5,R5,#+1
   \                     ??reTransmission_0: (+1)
   \   00000012   0xB2ED             UXTB     R5,R5
   \   00000014   0x2D05             CMP      R5,#+5
   \   00000016   0xDA30             BGE.N    ??reTransmission_2
   \   00000018   0x68B8             LDR      R0,[R7, #+8]
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \   0000001C   0x60B8             STR      R0,[R7, #+8]
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x6030             STR      R0,[R6, #+0]
   \   00000022   0x22C4             MOVS     R2,#+196
   \   00000024   0xF504 0x718A      ADD      R1,R4,#+276
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable169_3
   \   0000002C   0x.... 0x....      BL       HAL_SPI_Transmit_DMA
   \   00000030   0x68F8             LDR      R0,[R7, #+12]
   \   00000032   0x6801             LDR      R1,[R0, #+0]
   \   00000034   0xF021 0x0108      BIC      R1,R1,#0x8
   \   00000038   0x6001             STR      R1,[R0, #+0]
   \                     ??reTransmission_3: (+1)
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable169_4
   \   0000003E   0xF990 0x0035      LDRSB    R0,[R0, #+53]
   \   00000042   0x2802             CMP      R0,#+2
   \   00000044   0xD0F9             BEQ.N    ??reTransmission_3
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0x6030             STR      R0,[R6, #+0]
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000050   0xE004             B.N      ??reTransmission_4
   \                     ??reTransmission_5: (+1)
   \   00000052   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000056   0x1C40             ADDS     R0,R0,#+1
   \   00000058   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \                     ??reTransmission_4: (+1)
   \   0000005C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000060   0x280A             CMP      R0,#+10
   \   00000062   0xDBF6             BLT.N    ??reTransmission_5
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable169_5  ;; 0x42408200
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0xF884 0x01D8      STRB     R0,[R4, #+472]
   \   0000006E   0xF894 0x01D8      LDRB     R0,[R4, #+472]
   \   00000072   0x2801             CMP      R0,#+1
   \   00000074   0xD1CC             BNE.N    ??reTransmission_1
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??reTransmission_2: (+1)
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::line_fill_all_one(uint8_t)
   \                     _ZN7MKS_DLP17line_fill_all_oneEh: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1

  	uint8_t cur_block;
  	        ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",536  Warning[Pe177]: 
          variable "cur_block" was declared but never referenced
   \   00000008   0x2600             MOVS     R6,#+0
   \   0000000A   0xF104 0x0850      ADD      R8,R4,#+80
   \   0000000E   0xF504 0x798A      ADD      R9,R4,#+276
   \   00000012   0xE040             B.N      ??line_fill_all_one_0
   \                     ??line_fill_all_one_1: (+1)
   \   00000014   0x1230             ASRS     R0,R6,#+8
   \   00000016   0xF000 0x000F      AND      R0,R0,#0xF
   \   0000001A   0xEA40 0x1005      ORR      R0,R0,R5, LSL #+4
   \   0000001E   0xF040 0x0040      ORR      R0,R0,#0x40
   \   00000022   0xF884 0x0050      STRB     R0,[R4, #+80]
   \   00000026   0xF888 0x6001      STRB     R6,[R8, #+1]
   \   0000002A   0x22C0             MOVS     R2,#+192
   \   0000002C   0x21FF             MOVS     R1,#+255
   \   0000002E   0xF104 0x0052      ADD      R0,R4,#+82
   \   00000032   0x.... 0x....      BL       memset
   \   00000036   0x21C2             MOVS     R1,#+194
   \   00000038   0x4640             MOV      R0,R8
   \   0000003A   0x.... 0x....      BL       _Z12CRC16_XMODEMPhj
   \   0000003E   0xF8A4 0x0112      STRH     R0,[R4, #+274]
   \                     ??line_fill_all_one_2: (+1)
   \   00000042   0xF997 0x0035      LDRSB    R0,[R7, #+53]
   \   00000046   0x2802             CMP      R0,#+2
   \   00000048   0xD0FB             BEQ.N    ??line_fill_all_one_2
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable169_5  ;; 0x42408200
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0xF884 0x01D8      STRB     R0,[R4, #+472]
   \   00000054   0x.... 0x....      LDR.W    R7,??DataTable169_2
   \   00000058   0xF894 0x01D8      LDRB     R0,[R4, #+472]
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD105             BNE.N    ??line_fill_all_one_3
   \   00000060   0x4620             MOV      R0,R4
   \   00000062   0x.... 0x....      BL       _ZN7MKS_DLP14reTransmissionEv
   \   00000066   0x6838             LDR      R0,[R7, #+0]
   \   00000068   0x1C40             ADDS     R0,R0,#+1
   \   0000006A   0x6038             STR      R0,[R7, #+0]
   \                     ??line_fill_all_one_3: (+1)
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable169_1  ;; 0x4240029c
   \   00000072   0x6008             STR      R0,[R1, #+0]
   \   00000074   0x22C4             MOVS     R2,#+196
   \   00000076   0x4641             MOV      R1,R8
   \   00000078   0x4648             MOV      R0,R9
   \   0000007A   0x.... 0x....      BL       memcpy
   \   0000007E   0x22C4             MOVS     R2,#+196
   \   00000080   0x4649             MOV      R1,R9
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable169_3
   \   00000086   0x.... 0x....      BL       HAL_SPI_Transmit_DMA
   \   0000008A   0x68F8             LDR      R0,[R7, #+12]
   \   0000008C   0x6801             LDR      R1,[R0, #+0]
   \   0000008E   0xF021 0x0108      BIC      R1,R1,#0x8
   \   00000092   0x6001             STR      R1,[R0, #+0]
   \   00000094   0x1C76             ADDS     R6,R6,#+1
   \                     ??line_fill_all_one_0: (+1)
   \   00000096   0x.... 0x....      LDR.W    R7,??DataTable169_4
   \   0000009A   0xF5B6 0x6F20      CMP      R6,#+2560
   \   0000009E   0xDBB9             BLT.N    ??line_fill_all_one_1
   \                     ??line_fill_all_one_4: (+1)
   \   000000A0   0xF997 0x0035      LDRSB    R0,[R7, #+53]
   \   000000A4   0x2802             CMP      R0,#+2
   \   000000A6   0xD0FB             BEQ.N    ??line_fill_all_one_4
   \   000000A8   0x2001             MOVS     R0,#+1
   \   000000AA   0x.... 0x....      LDR.W    R1,??DataTable169_1  ;; 0x4240029c
   \   000000AE   0x6008             STR      R0,[R1, #+0]
   \   000000B0   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::line_fill_all_zero(char, uint16_t, uint8_t)
   \                     _ZN7MKS_DLP18line_fill_all_zeroEcth: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4617             MOV      R7,R2
   \   00000008   0x461D             MOV      R5,R3

  	uint8_t cur_block;
  	        ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",586  Warning[Pe177]: 
          variable "cur_block" was declared but never referenced
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD101             BNE.N    ??line_fill_all_zero_0
   \   0000000E   0x2600             MOVS     R6,#+0
   \   00000010   0xE04C             B.N      ??line_fill_all_zero_1
   \                     ??line_fill_all_zero_0: (+1)
   \   00000012   0x463E             MOV      R6,R7
   \   00000014   0xF44F 0x6720      MOV      R7,#+2560
   \   00000018   0xE048             B.N      ??line_fill_all_zero_1
   \                     ??line_fill_all_zero_2: (+1)
   \   0000001A   0x1230             ASRS     R0,R6,#+8
   \   0000001C   0xF000 0x000F      AND      R0,R0,#0xF
   \   00000020   0xEA40 0x1005      ORR      R0,R0,R5, LSL #+4
   \   00000024   0xF040 0x0040      ORR      R0,R0,#0x40
   \   00000028   0xF884 0x0050      STRB     R0,[R4, #+80]
   \   0000002C   0xF104 0x0950      ADD      R9,R4,#+80
   \   00000030   0xF889 0x6001      STRB     R6,[R9, #+1]
   \   00000034   0x22C0             MOVS     R2,#+192
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0xF104 0x0052      ADD      R0,R4,#+82
   \   0000003C   0x.... 0x....      BL       memset
   \   00000040   0x21C2             MOVS     R1,#+194
   \   00000042   0x4648             MOV      R0,R9
   \   00000044   0x.... 0x....      BL       _Z12CRC16_XMODEMPhj
   \   00000048   0xF8A4 0x0112      STRH     R0,[R4, #+274]
   \                     ??line_fill_all_zero_3: (+1)
   \   0000004C   0xF998 0x0035      LDRSB    R0,[R8, #+53]
   \   00000050   0x2802             CMP      R0,#+2
   \   00000052   0xD0FB             BEQ.N    ??line_fill_all_zero_3
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable169_5  ;; 0x42408200
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0xF884 0x01D8      STRB     R0,[R4, #+472]
   \   0000005E   0x.... 0x....      LDR.W    R8,??DataTable169_2
   \   00000062   0xF894 0x01D8      LDRB     R0,[R4, #+472]
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD107             BNE.N    ??line_fill_all_zero_4
   \   0000006A   0x4620             MOV      R0,R4
   \   0000006C   0x.... 0x....      BL       _ZN7MKS_DLP14reTransmissionEv
   \   00000070   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000074   0x1C40             ADDS     R0,R0,#+1
   \   00000076   0xF8C8 0x0000      STR      R0,[R8, #+0]
   \                     ??line_fill_all_zero_4: (+1)
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable169_1  ;; 0x4240029c
   \   00000080   0x6008             STR      R0,[R1, #+0]
   \   00000082   0xF504 0x7A8A      ADD      R10,R4,#+276
   \   00000086   0x22C4             MOVS     R2,#+196
   \   00000088   0x4649             MOV      R1,R9
   \   0000008A   0x4650             MOV      R0,R10
   \   0000008C   0x.... 0x....      BL       memcpy
   \   00000090   0x22C4             MOVS     R2,#+196
   \   00000092   0x4651             MOV      R1,R10
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable169_3
   \   00000098   0x.... 0x....      BL       HAL_SPI_Transmit_DMA
   \   0000009C   0xF8D8 0x000C      LDR      R0,[R8, #+12]
   \   000000A0   0x6801             LDR      R1,[R0, #+0]
   \   000000A2   0xF021 0x0108      BIC      R1,R1,#0x8
   \   000000A6   0x6001             STR      R1,[R0, #+0]
   \   000000A8   0x1C76             ADDS     R6,R6,#+1
   \   000000AA   0xB2B6             UXTH     R6,R6
   \                     ??line_fill_all_zero_1: (+1)
   \   000000AC   0x.... 0x....      LDR.W    R8,??DataTable169_4
   \   000000B0   0x42BE             CMP      R6,R7
   \   000000B2   0xDBB2             BLT.N    ??line_fill_all_zero_2
   \                     ??line_fill_all_zero_5: (+1)
   \   000000B4   0xF998 0x0035      LDRSB    R0,[R8, #+53]
   \   000000B8   0x2802             CMP      R0,#+2
   \   000000BA   0xD0FB             BEQ.N    ??line_fill_all_zero_5
   \   000000BC   0x2001             MOVS     R0,#+1
   \   000000BE   0x.... 0x....      LDR.W    R1,??DataTable169_1  ;; 0x4240029c
   \   000000C2   0x6008             STR      R0,[R1, #+0]
   \   000000C4   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::line_fill_zero(uint16_t, uint8_t)
   \                     _ZN7MKS_DLP14line_fill_zeroEth: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0

  	uint8_t cur_block;
  	        ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",631  Warning[Pe177]: 
          variable "cur_block" was declared but never referenced
   \   00000004   0x1208             ASRS     R0,R1,#+8
   \   00000006   0xF000 0x000F      AND      R0,R0,#0xF
   \   0000000A   0xEA40 0x1002      ORR      R0,R0,R2, LSL #+4
   \   0000000E   0xF040 0x0040      ORR      R0,R0,#0x40
   \   00000012   0xF884 0x0050      STRB     R0,[R4, #+80]
   \   00000016   0xF104 0x0550      ADD      R5,R4,#+80
   \   0000001A   0x7069             STRB     R1,[R5, #+1]
   \   0000001C   0x22C0             MOVS     R2,#+192
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0xF104 0x0052      ADD      R0,R4,#+82
   \   00000024   0x.... 0x....      BL       memset
   \   00000028   0x21C2             MOVS     R1,#+194
   \   0000002A   0x4628             MOV      R0,R5
   \   0000002C   0x.... 0x....      BL       _Z12CRC16_XMODEMPhj
   \   00000030   0xF8A4 0x0112      STRH     R0,[R4, #+274]
   \                     ??line_fill_zero_0: (+1)
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable169_4
   \   00000038   0xF990 0x0035      LDRSB    R0,[R0, #+53]
   \   0000003C   0x2802             CMP      R0,#+2
   \   0000003E   0xD0F9             BEQ.N    ??line_fill_zero_0
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable169_5  ;; 0x42408200
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0xF884 0x01D8      STRB     R0,[R4, #+472]
   \   0000004A   0x.... 0x....      LDR.W    R6,??DataTable169_2
   \   0000004E   0xF894 0x01D8      LDRB     R0,[R4, #+472]
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD105             BNE.N    ??line_fill_zero_1
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0x.... 0x....      BL       _ZN7MKS_DLP14reTransmissionEv
   \   0000005C   0x6830             LDR      R0,[R6, #+0]
   \   0000005E   0x1C40             ADDS     R0,R0,#+1
   \   00000060   0x6030             STR      R0,[R6, #+0]
   \                     ??line_fill_zero_1: (+1)
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable169_1  ;; 0x4240029c
   \   00000068   0x6008             STR      R0,[R1, #+0]
   \   0000006A   0xF504 0x748A      ADD      R4,R4,#+276
   \   0000006E   0x22C4             MOVS     R2,#+196
   \   00000070   0x4629             MOV      R1,R5
   \   00000072   0x4620             MOV      R0,R4
   \   00000074   0x.... 0x....      BL       memcpy
   \   00000078   0x22C4             MOVS     R2,#+196
   \   0000007A   0x4621             MOV      R1,R4
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable169_3
   \   00000080   0x.... 0x....      BL       HAL_SPI_Transmit_DMA
   \   00000084   0x68F0             LDR      R0,[R6, #+12]
   \   00000086   0x6801             LDR      R1,[R0, #+0]
   \   00000088   0xF021 0x0108      BIC      R1,R1,#0x8
   \   0000008C   0x6001             STR      R1,[R0, #+0]
   \   0000008E   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::line_gen_data(uint16_t, uint8_t)
   \                     _ZN7MKS_DLP13line_gen_dataEth: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0

  	uint8_t cur_block;
  	        ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",667  Warning[Pe177]: 
          variable "cur_block" was declared but never referenced

  	uint16_t cur_pixel;
  	         ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",668  Warning[Pe177]: 
          variable "cur_pixel" was declared but never referenced

  	uint8_t pixel_sum = 0;
  	        ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",669  Warning[Pe177]: 
          variable "pixel_sum" was declared but never referenced
   \   00000004   0x0A08             LSRS     R0,R1,#+8
   \   00000006   0xF000 0x000F      AND      R0,R0,#0xF
   \   0000000A   0xEA40 0x1002      ORR      R0,R0,R2, LSL #+4
   \   0000000E   0xF040 0x0040      ORR      R0,R0,#0x40
   \   00000012   0xF885 0x0050      STRB     R0,[R5, #+80]
   \   00000016   0xF105 0x0450      ADD      R4,R5,#+80
   \   0000001A   0x7061             STRB     R1,[R4, #+1]
   \   0000001C   0x22C0             MOVS     R2,#+192
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0xF105 0x0052      ADD      R0,R5,#+82
   \   00000024   0x.... 0x....      BL       memset
   \   00000028   0xF205 0x0052      ADDW     R0,R5,#+82
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable169_6
   \   00000030   0x2200             MOVS     R2,#+0
   \   00000032   0xE00E             B.N      ??line_gen_data_0
   \                     ??line_gen_data_1: (+1)
   \   00000034   0x7803             LDRB     R3,[R0, #+0]
   \   00000036   0x005B             LSLS     R3,R3,#+1
   \   00000038   0x7003             STRB     R3,[R0, #+0]
   \   0000003A   0xF811 0x7B01      LDRB     R7,[R1], #+1
   \   0000003E   0x2F01             CMP      R7,#+1
   \   00000040   0xD102             BNE.N    ??line_gen_data_2
   \   00000042   0xF043 0x0301      ORR      R3,R3,#0x1
   \   00000046   0x7003             STRB     R3,[R0, #+0]
   \                     ??line_gen_data_2: (+1)
   \   00000048   0x1C76             ADDS     R6,R6,#+1
   \                     ??line_gen_data_3: (+1)
   \   0000004A   0x2E08             CMP      R6,#+8
   \   0000004C   0xDBF2             BLT.N    ??line_gen_data_1
   \   0000004E   0x1C40             ADDS     R0,R0,#+1
   \   00000050   0x1C52             ADDS     R2,R2,#+1
   \                     ??line_gen_data_0: (+1)
   \   00000052   0x2AC0             CMP      R2,#+192
   \   00000054   0xDA01             BGE.N    ??line_gen_data_4
   \   00000056   0x2600             MOVS     R6,#+0
   \   00000058   0xE7F7             B.N      ??line_gen_data_3
   \                     ??line_gen_data_4: (+1)
   \   0000005A   0x21C2             MOVS     R1,#+194
   \   0000005C   0x4620             MOV      R0,R4
   \   0000005E   0x.... 0x....      BL       _Z12CRC16_XMODEMPhj
   \   00000062   0xF8A5 0x0112      STRH     R0,[R5, #+274]
   \                     ??line_gen_data_5: (+1)
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable169_4
   \   0000006A   0xF990 0x0035      LDRSB    R0,[R0, #+53]
   \   0000006E   0x2802             CMP      R0,#+2
   \   00000070   0xD0F9             BEQ.N    ??line_gen_data_5
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable169_5  ;; 0x42408200
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0xF885 0x01D8      STRB     R0,[R5, #+472]
   \   0000007C   0x.... 0x....      LDR.W    R6,??DataTable169_2
   \   00000080   0xF895 0x01D8      LDRB     R0,[R5, #+472]
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD105             BNE.N    ??line_gen_data_6
   \   00000088   0x4628             MOV      R0,R5
   \   0000008A   0x.... 0x....      BL       _ZN7MKS_DLP14reTransmissionEv
   \   0000008E   0x6870             LDR      R0,[R6, #+4]
   \   00000090   0x1C40             ADDS     R0,R0,#+1
   \   00000092   0x6070             STR      R0,[R6, #+4]
   \                     ??line_gen_data_6: (+1)
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0x.... 0x....      LDR.W    R1,??DataTable169_1  ;; 0x4240029c
   \   0000009A   0x6008             STR      R0,[R1, #+0]
   \   0000009C   0xF505 0x758A      ADD      R5,R5,#+276
   \   000000A0   0x22C4             MOVS     R2,#+196
   \   000000A2   0x4621             MOV      R1,R4
   \   000000A4   0x4628             MOV      R0,R5
   \   000000A6   0x.... 0x....      BL       memcpy
   \   000000AA   0x22C4             MOVS     R2,#+196
   \   000000AC   0x4629             MOV      R1,R5
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable169_3
   \   000000B2   0x.... 0x....      BL       HAL_SPI_Transmit_DMA
   \   000000B6   0x68F0             LDR      R0,[R6, #+12]
   \   000000B8   0x6801             LDR      R1,[R0, #+0]
   \   000000BA   0xF021 0x0108      BIC      R1,R1,#0x8
   \   000000BE   0x6001             STR      R1,[R0, #+0]
   \   000000C0   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::line_gen_data_TFT(uint16_t)
   \                     _ZN7MKS_DLP17line_gen_data_TFTEt: (+1)
   \   00000000   0x2007             MOVS     R0,#+7
   \   00000002   0x4201             TST      R1,R0
   \   00000004   0xD000             BEQ.N    ??line_gen_data_TFT_0
   \   00000006   0x4770             BX       LR
   \                     ??line_gen_data_TFT_0: (+1)
   \   00000008   0xB470             PUSH     {R4-R6}
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD025             BEQ.N    ??line_gen_data_TFT_1
   \   0000000E   0x10C8             ASRS     R0,R1,#+3
   \   00000010   0x1E40             SUBS     R0,R0,#+1
   \   00000012   0xB280             UXTH     R0,R0
   \   00000014   0x2117             MOVS     R1,#+23
   \   00000016   0x.... 0x....      LDR.W    R2,??DataTable169_7
   \   0000001A   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable169_6
   \   00000022   0x460A             MOV      R2,R1
   \   00000024   0x2300             MOVS     R3,#+0
   \   00000026   0xE014             B.N      ??line_gen_data_TFT_2
   \                     ??line_gen_data_TFT_3: (+1)
   \   00000028   0x7804             LDRB     R4,[R0, #+0]
   \   0000002A   0x0064             LSLS     R4,R4,#+1
   \   0000002C   0x7004             STRB     R4,[R0, #+0]
   \   0000002E   0x7816             LDRB     R6,[R2, #+0]
   \   00000030   0x2E01             CMP      R6,#+1
   \   00000032   0xD102             BNE.N    ??line_gen_data_TFT_4
   \   00000034   0xF044 0x0401      ORR      R4,R4,#0x1
   \   00000038   0x7004             STRB     R4,[R0, #+0]
   \                     ??line_gen_data_TFT_4: (+1)
   \   0000003A   0x3208             ADDS     R2,R2,#+8
   \   0000003C   0x1A54             SUBS     R4,R2,R1
   \   0000003E   0xF5A4 0x7434      SUB      R4,R4,#+720
   \   00000042   0x2C31             CMP      R4,#+49
   \   00000044   0xD200             BCS.N    ??line_gen_data_TFT_5
   \   00000046   0x3230             ADDS     R2,R2,#+48
   \                     ??line_gen_data_TFT_5: (+1)
   \   00000048   0x1C6D             ADDS     R5,R5,#+1
   \                     ??line_gen_data_TFT_6: (+1)
   \   0000004A   0x2D08             CMP      R5,#+8
   \   0000004C   0xDBEC             BLT.N    ??line_gen_data_TFT_3
   \   0000004E   0x1C40             ADDS     R0,R0,#+1
   \   00000050   0x1C5B             ADDS     R3,R3,#+1
   \                     ??line_gen_data_TFT_2: (+1)
   \   00000052   0x2B17             CMP      R3,#+23
   \   00000054   0xDA01             BGE.N    ??line_gen_data_TFT_1
   \   00000056   0x2500             MOVS     R5,#+0
   \   00000058   0xE7F7             B.N      ??line_gen_data_TFT_6
   \                     ??line_gen_data_TFT_1: (+1)
   \   0000005A   0xBC70             POP      {R4-R6}
   \   0000005C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::get_sdcard_bmps()
   \                     _ZN7MKS_DLP15get_sdcard_bmpsEv: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB089             SUB      SP,SP,#+36
   \   00000006   0x4604             MOV      R4,R0

  	uint8_t rc;
  	        ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",752  Warning[Pe550]: 
          variable "rc" was set but never used

  	uint8_t tailed;
  	        ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",753  Warning[Pe177]: 
          variable "tailed" was declared but never referenced
   \   00000008   0x.... 0x....      LDR.W    R5,??DataTable165
   \   0000000C   0xF895 0x09B8      LDRB     R0,[R5, #+2488]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xF000 0x80FF      BEQ.W    ??get_sdcard_bmps_0
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0x.... 0x....      BL       _ZN10CardReader3eofEv
   \   0000001C   0x4628             MOV      R0,R5
   \   0000001E   0x.... 0x....      BL       _ZN10CardReader8getsdposEv
   \   00000022   0xF8C5 0x0D14      STR      R0,[R5, #+3348]
   \   00000026   0x2204             MOVS     R2,#+4
   \   00000028   0xA900             ADD      R1,SP,#+0
   \   0000002A   0x4628             MOV      R0,R5
   \   0000002C   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000030   0xAE00             ADD      R6,SP,#+0
   \   00000032   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000036   0x7871             LDRB     R1,[R6, #+1]
   \   00000038   0x0409             LSLS     R1,R1,#+16
   \   0000003A   0xEA41 0x6000      ORR      R0,R1,R0, LSL #+24
   \   0000003E   0x78B1             LDRB     R1,[R6, #+2]
   \   00000040   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   00000044   0xF89D 0x1003      LDRB     R1,[SP, #+3]
   \   00000048   0x4308             ORRS     R0,R1,R0
   \   0000004A   0x6420             STR      R0,[R4, #+64]
   \   0000004C   0xF605 0x6710      ADDW     R7,R5,#+3600
   \   00000050   0xF44F 0x62C0      MOV      R2,#+1536
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0x4638             MOV      R0,R7
   \   00000058   0x.... 0x....      BL       memset
   \   0000005C   0xF44F 0x52E6      MOV      R2,#+7360
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable169_7
   \   00000066   0x.... 0x....      BL       memset
   \   0000006A   0xF04F 0x0800      MOV      R8,#+0
   \   0000006E   0xF104 0x0940      ADD      R9,R4,#+64
   \   00000072   0xE001             B.N      ??get_sdcard_bmps_1
   \                     ??get_sdcard_bmps_2: (+1)
   \   00000074   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??get_sdcard_bmps_1: (+1)
   \   00000078   0x6C20             LDR      R0,[R4, #+64]
   \   0000007A   0x4580             CMP      R8,R0
   \   0000007C   0xF080 0x809B      BCS.W    ??get_sdcard_bmps_3
   \   00000080   0x2202             MOVS     R2,#+2
   \   00000082   0xA900             ADD      R1,SP,#+0
   \   00000084   0x4628             MOV      R0,R5
   \   00000086   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   0000008A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000008E   0x7871             LDRB     R1,[R6, #+1]
   \   00000090   0xEA41 0x2000      ORR      R0,R1,R0, LSL #+8
   \   00000094   0xF8A9 0x000C      STRH     R0,[R9, #+12]
   \   00000098   0xF5B0 0x6FB4      CMP      R0,#+1440
   \   0000009C   0xDB03             BLT.N    ??get_sdcard_bmps_4
   \   0000009E   0xF240 0x509F      MOVW     R0,#+1439
   \   000000A2   0xF8A9 0x000C      STRH     R0,[R9, #+12]
   \                     ??get_sdcard_bmps_4: (+1)
   \   000000A6   0x2202             MOVS     R2,#+2
   \   000000A8   0xA900             ADD      R1,SP,#+0
   \   000000AA   0x4628             MOV      R0,R5
   \   000000AC   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   000000B0   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000B4   0x7871             LDRB     R1,[R6, #+1]
   \   000000B6   0xEA41 0x2000      ORR      R0,R1,R0, LSL #+8
   \   000000BA   0xF8A9 0x000E      STRH     R0,[R9, #+14]
   \   000000BE   0xF5B0 0x6FB4      CMP      R0,#+1440
   \   000000C2   0xDB03             BLT.N    ??get_sdcard_bmps_5
   \   000000C4   0xF240 0x509F      MOVW     R0,#+1439
   \   000000C8   0xF8A9 0x000E      STRH     R0,[R9, #+14]
   \                     ??get_sdcard_bmps_5: (+1)
   \   000000CC   0x2202             MOVS     R2,#+2
   \   000000CE   0xA900             ADD      R1,SP,#+0
   \   000000D0   0x4628             MOV      R0,R5
   \   000000D2   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   000000D6   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000DA   0x7871             LDRB     R1,[R6, #+1]
   \   000000DC   0xEA41 0x2000      ORR      R0,R1,R0, LSL #+8
   \   000000E0   0xF8A9 0x0008      STRH     R0,[R9, #+8]
   \   000000E4   0xF5B0 0x6F20      CMP      R0,#+2560
   \   000000E8   0xDB03             BLT.N    ??get_sdcard_bmps_6
   \   000000EA   0xF640 0x10FF      MOVW     R0,#+2559
   \   000000EE   0xF8A9 0x0008      STRH     R0,[R9, #+8]
   \                     ??get_sdcard_bmps_6: (+1)
   \   000000F2   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000F6   0xD10A             BNE.N    ??get_sdcard_bmps_7
   \   000000F8   0x2300             MOVS     R3,#+0
   \   000000FA   0xF8B9 0x2008      LDRH     R2,[R9, #+8]
   \   000000FE   0x4619             MOV      R1,R3
   \   00000100   0x4620             MOV      R0,R4
   \   00000102   0x.... 0x....      BL       _ZN7MKS_DLP18line_fill_all_zeroEcth
   \   00000106   0xF8B9 0x0008      LDRH     R0,[R9, #+8]
   \   0000010A   0xF8A9 0x000A      STRH     R0,[R9, #+10]
   \                     ??get_sdcard_bmps_7: (+1)
   \   0000010E   0xF8B9 0x100A      LDRH     R1,[R9, #+10]
   \   00000112   0xF8B9 0x0008      LDRH     R0,[R9, #+8]
   \   00000116   0x4281             CMP      R1,R0
   \   00000118   0xD115             BNE.N    ??get_sdcard_bmps_8
   \   0000011A   0xF8B9 0x100C      LDRH     R1,[R9, #+12]
   \   0000011E   0x1948             ADDS     R0,R1,R5
   \   00000120   0xF600 0x6010      ADDW     R0,R0,#+3600
   \   00000124   0xE004             B.N      ??get_sdcard_bmps_9
   \                     ??get_sdcard_bmps_10: (+1)
   \   00000126   0x2201             MOVS     R2,#+1
   \   00000128   0xF880 0x2030      STRB     R2,[R0, #+48]
   \                     ??get_sdcard_bmps_11: (+1)
   \   0000012C   0x1C40             ADDS     R0,R0,#+1
   \   0000012E   0x1C49             ADDS     R1,R1,#+1
   \                     ??get_sdcard_bmps_9: (+1)
   \   00000130   0xF8B9 0x200E      LDRH     R2,[R9, #+14]
   \   00000134   0x1C52             ADDS     R2,R2,#+1
   \   00000136   0x4291             CMP      R1,R2
   \   00000138   0xDA9C             BGE.N    ??get_sdcard_bmps_2
   \   0000013A   0xF5B1 0x7F34      CMP      R1,#+720
   \   0000013E   0xDAF2             BGE.N    ??get_sdcard_bmps_10
   \   00000140   0x2201             MOVS     R2,#+1
   \   00000142   0x7002             STRB     R2,[R0, #+0]
   \   00000144   0xE7F2             B.N      ??get_sdcard_bmps_11
   \                     ??get_sdcard_bmps_8: (+1)
   \   00000146   0x2200             MOVS     R2,#+0
   \   00000148   0x4620             MOV      R0,R4
   \   0000014A   0x.... 0x....      BL       _ZN7MKS_DLP13line_gen_dataEth
   \   0000014E   0xF8B9 0x100A      LDRH     R1,[R9, #+10]
   \   00000152   0x4620             MOV      R0,R4
   \   00000154   0x.... 0x....      BL       _ZN7MKS_DLP17line_gen_data_TFTEt
   \   00000158   0xE007             B.N      ??get_sdcard_bmps_12
   \                     ??get_sdcard_bmps_13: (+1)
   \   0000015A   0x1C41             ADDS     R1,R0,#+1
   \   0000015C   0xF8A9 0x100A      STRH     R1,[R9, #+10]
   \   00000160   0x2200             MOVS     R2,#+0
   \   00000162   0xB289             UXTH     R1,R1
   \   00000164   0x4620             MOV      R0,R4
   \   00000166   0x.... 0x....      BL       _ZN7MKS_DLP14line_fill_zeroEth
   \                     ??get_sdcard_bmps_12: (+1)
   \   0000016A   0xF8B9 0x000A      LDRH     R0,[R9, #+10]
   \   0000016E   0xF8B9 0x1008      LDRH     R1,[R9, #+8]
   \   00000172   0x1A0A             SUBS     R2,R1,R0
   \   00000174   0x2A02             CMP      R2,#+2
   \   00000176   0xDAF0             BGE.N    ??get_sdcard_bmps_13
   \   00000178   0xF8A9 0x100A      STRH     R1,[R9, #+10]
   \   0000017C   0xF44F 0x62C0      MOV      R2,#+1536
   \   00000180   0x2100             MOVS     R1,#+0
   \   00000182   0x4638             MOV      R0,R7
   \   00000184   0x.... 0x....      BL       memset
   \   00000188   0xF8B9 0x100C      LDRH     R1,[R9, #+12]
   \   0000018C   0x1948             ADDS     R0,R1,R5
   \   0000018E   0xF600 0x6010      ADDW     R0,R0,#+3600
   \   00000192   0xE004             B.N      ??get_sdcard_bmps_14
   \                     ??get_sdcard_bmps_15: (+1)
   \   00000194   0x2201             MOVS     R2,#+1
   \   00000196   0xF880 0x2030      STRB     R2,[R0, #+48]
   \                     ??get_sdcard_bmps_16: (+1)
   \   0000019A   0x1C40             ADDS     R0,R0,#+1
   \   0000019C   0x1C49             ADDS     R1,R1,#+1
   \                     ??get_sdcard_bmps_14: (+1)
   \   0000019E   0xF8B9 0x200E      LDRH     R2,[R9, #+14]
   \   000001A2   0x1C52             ADDS     R2,R2,#+1
   \   000001A4   0x4291             CMP      R1,R2
   \   000001A6   0xF6BF 0xAF65      BGE.W    ??get_sdcard_bmps_2
   \   000001AA   0xF5B1 0x7F34      CMP      R1,#+720
   \   000001AE   0xDAF1             BGE.N    ??get_sdcard_bmps_15
   \   000001B0   0x2201             MOVS     R2,#+1
   \   000001B2   0x7002             STRB     R2,[R0, #+0]
   \   000001B4   0xE7F1             B.N      ??get_sdcard_bmps_16
   \                     ??get_sdcard_bmps_3: (+1)
   \   000001B6   0x2802             CMP      R0,#+2
   \   000001B8   0xD30A             BCC.N    ??get_sdcard_bmps_17
   \   000001BA   0x2200             MOVS     R2,#+0
   \   000001BC   0xF8B9 0x100A      LDRH     R1,[R9, #+10]
   \   000001C0   0x4620             MOV      R0,R4
   \   000001C2   0x.... 0x....      BL       _ZN7MKS_DLP13line_gen_dataEth
   \   000001C6   0xF8B9 0x100A      LDRH     R1,[R9, #+10]
   \   000001CA   0x4620             MOV      R0,R4
   \   000001CC   0x.... 0x....      BL       _ZN7MKS_DLP17line_gen_data_TFTEt
   \                     ??get_sdcard_bmps_17: (+1)
   \   000001D0   0x.... 0x....      LDR.W    R0,??DataTable169_4
   \   000001D4   0xF990 0x0035      LDRSB    R0,[R0, #+53]
   \   000001D8   0x2802             CMP      R0,#+2
   \   000001DA   0xD0F9             BEQ.N    ??get_sdcard_bmps_17
   \   000001DC   0x2001             MOVS     R0,#+1
   \   000001DE   0x.... 0x....      LDR.W    R1,??DataTable169_1  ;; 0x4240029c
   \   000001E2   0x6008             STR      R0,[R1, #+0]
   \   000001E4   0x2300             MOVS     R3,#+0
   \   000001E6   0xF104 0x0040      ADD      R0,R4,#+64
   \   000001EA   0x8940             LDRH     R0,[R0, #+10]
   \   000001EC   0x1C42             ADDS     R2,R0,#+1
   \   000001EE   0xB292             UXTH     R2,R2
   \   000001F0   0x2101             MOVS     R1,#+1
   \   000001F2   0x4620             MOV      R0,R4
   \   000001F4   0x.... 0x....      BL       _ZN7MKS_DLP18line_fill_all_zeroEcth
   \   000001F8   0x2202             MOVS     R2,#+2
   \   000001FA   0xA900             ADD      R1,SP,#+0
   \   000001FC   0x4628             MOV      R0,R5
   \   000001FE   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000202   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000206   0x280D             CMP      R0,#+13
   \   00000208   0xD102             BNE.N    ??get_sdcard_bmps_18
   \   0000020A   0x7870             LDRB     R0,[R6, #+1]
   \   0000020C   0x280A             CMP      R0,#+10
   \   0000020E   0xD001             BEQ.N    ??get_sdcard_bmps_0
   \                     ??get_sdcard_bmps_18: (+1)
   \   00000210   0x.... 0x....      BL       _Z13find_next_bmpv
   \                     ??get_sdcard_bmps_0: (+1)
   \   00000214   0xB009             ADD      SP,SP,#+36
   \   00000216   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return

   \                                 In section .data, align 4
   \                     axis_relative_modes:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     axis_homed:
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     axis_known_position:
   \   00000008   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     temper_error_flg:
   \   0000000C   0x00               DC8 0
   \                     mks_heating_busy:
   \   0000000D   0x00               DC8 0
   \                     Running:
   \   0000000E   0x01               DC8 1
   \                     marlin_debug_flags:
   \   0000000F   0x00               DC8 0
   \                     commands_in_queue:
   \   00000010   0x00               DC8 0
   \   00000011   0x00               DC8 0
   \   00000012   0x00               DC8 0
   \                     active_extruder:
   \   00000013   0x00               DC8 0
   \   00000014   0x00               DC8 0
   \                     wait_for_heatup:
   \   00000015   0x01               DC8 1
   \                     target_extruder:
   \   00000016   0x00               DC8 0
   \                     serial_wait_tick:
   \   00000017   0x00               DC8 0
   \                     from_wifi_flag:
   \   00000018   0x00               DC8 0
   \   __absolute uint8_t aalay_cnt
   \                     aalay_cnt:
   \   00000019   0x00               DC8 0
   \   0000001A   0x00 0x00          DC8 0, 0
   \   0000001C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     feedrate_percentage:
   \   00000020   0x0064             DC16 100
   \                     saved_feedrate_percentage:
   \   00000022   0x00 0x00          DC8 0, 0
   \                     current_position:
   \   00000024   0x00000000         DC32 0H
   \   00000028   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     destination:
   \   00000034   0x00000000         DC32 0H
   \   00000038   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     homing_feedrate_mm_s:
   \   00000044   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     home_offset:
   \   00000054   0x00000000         DC32 0H
   \   00000058   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     home_bump_mm_P:
   \   00000060   0x40A00000         DC32 40A00000H, 40A00000H, 40A00000H
   \              0x40A00000   
   \              0x40A00000   
   \   0000006C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000070   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000074   0x00000000         DC32 0
   \                     feedrate_mm_s:
   \   00000078   0x41C80000         DC32 41C80000H
   \   0000007C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     position_shift:
   \   00000080   0x00000000         DC32 0H
   \   00000084   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000008C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000009C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000AC   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000BC   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000CC   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000DC   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000EC   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000FC   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000010C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000011C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000012C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000013C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000014C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000015C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000016C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000017C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000018C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000019C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000001AC   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000001BC   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000001CC   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000001DC   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000001EC   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000001FC   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .data, align 4
   \                     soft_endstops_enabled:
   \   00000000   0x01               DC8 1
   \   00000001   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   \                     workspace_offset:
   \   00000004   0x00000000         DC32 0H
   \   00000008   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     soft_endstop_min:
   \   00000010   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     soft_endstop_max:
   \   0000001C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .data, align 4
   \                     home_dir_P:
   \   00000000   0xFF 0xFF          DC8 -1, -1, 0, 0
   \              0x00 0x00    
   \                     base_min_pos_P:
   \   00000004   0x00000000         DC32 0H, 0H, 0H
   \              0x00000000   
   \              0x00000000   
   \                     base_max_pos_P:
   \   00000010   0x43480000         DC32 43480000H, 43480000H, 0H
   \              0x43480000   
   \              0x00000000   
   \                     base_home_pos_P:
   \   0000001C   0x00000000         DC32 0H, 0H, 0H
   \              0x00000000   
   \              0x00000000   
   \                     max_length_P:
   \   00000028   0x43480000         DC32 43480000H, 43480000H, 0H
   \              0x43480000   
   \              0x00000000   

   \                                 In section .data, align 4
   \                     wifi_loop_cycle:
   \   00000000   0x000001F4         DC32 500

   \                                 In section .data, align 4
   \   __absolute char *mks_pft_name
   \                     mks_pft_name:
   \   00000000   0x........         DC32 `?<Constant "mks_pft.sys">`

   \                                 In section .data, align 4
   \   __absolute uint32_t volatile reTransmission_zero_cnt
   \                     reTransmission_zero_cnt:
   \   00000000   0x00000000         DC32 0
   \   __absolute uint32_t volatile reTransmission_data_cnt
   \                     reTransmission_data_cnt:
   \   00000004   0x00000000         DC32 0
   \   __absolute uint32_t volatile reTransmission_all_cnt
   \                     reTransmission_all_cnt:
   \   00000008   0x00000000         DC32 0
   \   __absolute uint32_t volatile *spi1_hdmatx_CR
   \                     spi1_hdmatx_CR:
   \   0000000C   0x40026488         DC32 40026488H

   \                                 In section .text, align 4, keep-with-next
   \   __interwork __softfp void MKS_DLP::bottomLayerPrint()
   \                     _ZN7MKS_DLP16bottomLayerPrintEv: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xF504 0x75EE      ADD      R5,R4,#+476
   \   0000000A   0x78A8             LDRB     R0,[R5, #+2]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD16D             BNE.N    ??bottomLayerPrint_0
   \   00000010   0x2300             MOVS     R3,#+0
   \   00000012   0x461A             MOV      R2,R3
   \   00000014   0x4611             MOV      R1,R2
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       _ZN7MKS_DLP16bank2disp_enableEhhh
   \   0000001C   0x....             LDR.N    R7,??DataTable165
   \   0000001E   0xF897 0x0CB7      LDRB     R0,[R7, #+3255]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD10B             BNE.N    ??bottomLayerPrint_1
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       _ZN7MKS_DLP15get_sdcard_bmpsEv
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x70E8             STRB     R0,[R5, #+3]
   \   00000030   0x4603             MOV      R3,R0
   \   00000032   0x4602             MOV      R2,R0
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       _ZN7MKS_DLP16bank2disp_enableEhhh
   \   0000003C   0xE035             B.N      ??bottomLayerPrint_2
   \                     ??bottomLayerPrint_1: (+1)
   \   0000003E   0xF607 0x58D4      ADDW     R8,R7,#+3540
   \   00000042   0xF8D8 0x0018      LDR      R0,[R8, #+24]
   \   00000046   0x2802             CMP      R0,#+2
   \   00000048   0xDB22             BLT.N    ??bottomLayerPrint_3
   \   0000004A   0x.... 0x....      LDR.W    R6,??DataTable169_8
   \   0000004E   0x7E70             LDRB     R0,[R6, #+25]
   \   00000050   0x1C40             ADDS     R0,R0,#+1
   \   00000052   0x7670             STRB     R0,[R6, #+25]
   \   00000054   0xF04F 0x0900      MOV      R9,#+0
   \   00000058   0xE00A             B.N      ??bottomLayerPrint_4
   \                     ??bottomLayerPrint_5: (+1)
   \   0000005A   0x464A             MOV      R2,R9
   \   0000005C   0x78A9             LDRB     R1,[R5, #+2]
   \   0000005E   0xF8D7 0x3DD4      LDR      R3,[R7, #+3540]
   \   00000062   0x4358             MULS     R0,R3,R0
   \   00000064   0x1841             ADDS     R1,R0,R1
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0x.... 0x....      BL       _ZN7MKS_DLP21decode_layer_from_rleEjh
   \   0000006C   0xF109 0x0901      ADD      R9,R9,#+1
   \                     ??bottomLayerPrint_4: (+1)
   \   00000070   0xFA5F 0xF989      UXTB     R9,R9
   \   00000074   0x4648             MOV      R0,R9
   \   00000076   0xF8D8 0x1018      LDR      R1,[R8, #+24]
   \   0000007A   0x4288             CMP      R0,R1
   \   0000007C   0xDBED             BLT.N    ??bottomLayerPrint_5
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0x70E8             STRB     R0,[R5, #+3]
   \   00000082   0x4603             MOV      R3,R0
   \   00000084   0x4602             MOV      R2,R0
   \   00000086   0x2100             MOVS     R1,#+0
   \   00000088   0x4620             MOV      R0,R4
   \   0000008A   0x.... 0x....      BL       _ZN7MKS_DLP16bank2disp_enableEhhh
   \   0000008E   0xE00C             B.N      ??bottomLayerPrint_2
   \                     ??bottomLayerPrint_3: (+1)
   \   00000090   0x2200             MOVS     R2,#+0
   \   00000092   0x78A9             LDRB     R1,[R5, #+2]
   \   00000094   0x4620             MOV      R0,R4
   \   00000096   0x.... 0x....      BL       _ZN7MKS_DLP21decode_layer_from_rleEjh
   \   0000009A   0x2001             MOVS     R0,#+1
   \   0000009C   0x70E8             STRB     R0,[R5, #+3]
   \   0000009E   0x4603             MOV      R3,R0
   \   000000A0   0x4602             MOV      R2,R0
   \   000000A2   0x2100             MOVS     R1,#+0
   \   000000A4   0x4620             MOV      R0,R4
   \   000000A6   0x.... 0x....      BL       _ZN7MKS_DLP16bank2disp_enableEhhh
   \                     ??bottomLayerPrint_2: (+1)
   \   000000AA   0x.... 0x....      LDR.W    R6,??DataTable169_8
   \   000000AE   0x6A60             LDR      R0,[R4, #+36]
   \   000000B0   0x63F0             STR      R0,[R6, #+60]
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable169_9
   \   000000B6   0xED90 0x0A04      VLDR     S0,[R0, #+16]
   \   000000BA   0xEDDF 0x....      VLDR.W   S1,??DataTable165_1  ;; 0x42f00000
   \   000000BE   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   000000C2   0xED8D 0x0A00      VSTR     S0,[SP, #+0]
   \   000000C6   0xA900             ADD      R1,SP,#+0
   \   000000C8   0xF106 0x003C      ADD      R0,R6,#+60
   \   000000CC   0x.... 0x....      BL       _Z21do_blocking_move_to_zRKfS0_
   \   000000D0   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   \   000000D4   0x.... 0x....      BL       _Z23report_current_positionv
   \   000000D8   0x78A8             LDRB     R0,[R5, #+2]
   \   000000DA   0x1C40             ADDS     R0,R0,#+1
   \   000000DC   0x70A8             STRB     R0,[R5, #+2]
   \   000000DE   0x.... 0x....      BL       _Z22report_mksdlp_positionv
   \   000000E2   0x4620             MOV      R0,R4
   \   000000E4   0x.... 0x....      BL       _ZN7MKS_DLP6led_onEv
   \   000000E8   0x.... 0x....      BL       _Z10clr_ticketv
   \                     ??bottomLayerPrint_0: (+1)
   \   000000EC   0x78E8             LDRB     R0,[R5, #+3]
   \   000000EE   0x2800             CMP      R0,#+0
   \   000000F0   0xD106             BNE.N    ??bottomLayerPrint_6
   \   000000F2   0xF104 0x0124      ADD      R1,R4,#+36
   \   000000F6   0x6889             LDR      R1,[R1, #+8]
   \   000000F8   0xF8D4 0x22D8      LDR      R2,[R4, #+728]
   \   000000FC   0x4291             CMP      R1,R2
   \   000000FE   0xD30B             BCC.N    ??bottomLayerPrint_7
   \                     ??bottomLayerPrint_6: (+1)
   \   00000100   0x2800             CMP      R0,#+0
   \   00000102   0xD15F             BNE.N    ??bottomLayerPrint_8
   \   00000104   0x.... 0x....      LDR.W    R0,??DataTable169_8
   \   00000108   0x7E40             LDRB     R0,[R0, #+25]
   \   0000010A   0x2800             CMP      R0,#+0
   \   0000010C   0xD05A             BEQ.N    ??bottomLayerPrint_8
   \   0000010E   0x.... 0x....      LDR.W    R0,??DataTable169_10
   \   00000112   0x6980             LDR      R0,[R0, #+24]
   \   00000114   0x2802             CMP      R0,#+2
   \   00000116   0xDB55             BLT.N    ??bottomLayerPrint_8
   \                     ??bottomLayerPrint_7: (+1)
   \   00000118   0x....             LDR.N    R7,??DataTable165
   \   0000011A   0xF897 0x0CB7      LDRB     R0,[R7, #+3255]
   \   0000011E   0x2801             CMP      R0,#+1
   \   00000120   0xD043             BEQ.N    ??bottomLayerPrint_9
   \   00000122   0xF607 0x58D4      ADDW     R8,R7,#+3540
   \   00000126   0xF8D8 0x0018      LDR      R0,[R8, #+24]
   \   0000012A   0x2802             CMP      R0,#+2
   \   0000012C   0xDB2A             BLT.N    ??bottomLayerPrint_10
   \   0000012E   0x.... 0x....      LDR.W    R6,??DataTable169_8
   \   00000132   0x7E70             LDRB     R0,[R6, #+25]
   \   00000134   0x2800             CMP      R0,#+0
   \   00000136   0xD117             BNE.N    ??bottomLayerPrint_11
   \   00000138   0xF04F 0x0900      MOV      R9,#+0
   \   0000013C   0xE00A             B.N      ??bottomLayerPrint_12
   \                     ??bottomLayerPrint_13: (+1)
   \   0000013E   0x464A             MOV      R2,R9
   \   00000140   0x78A9             LDRB     R1,[R5, #+2]
   \   00000142   0xF8D7 0x3DD4      LDR      R3,[R7, #+3540]
   \   00000146   0x4358             MULS     R0,R3,R0
   \   00000148   0x1841             ADDS     R1,R0,R1
   \   0000014A   0x4620             MOV      R0,R4
   \   0000014C   0x.... 0x....      BL       _ZN7MKS_DLP21decode_layer_from_rleEjh
   \   00000150   0xF109 0x0901      ADD      R9,R9,#+1
   \                     ??bottomLayerPrint_12: (+1)
   \   00000154   0xFA5F 0xF989      UXTB     R9,R9
   \   00000158   0x4648             MOV      R0,R9
   \   0000015A   0xF8D8 0x1018      LDR      R1,[R8, #+24]
   \   0000015E   0x4288             CMP      R0,R1
   \   00000160   0xDBED             BLT.N    ??bottomLayerPrint_13
   \   00000162   0x4620             MOV      R0,R4
   \   00000164   0x.... 0x....      BL       _ZN7MKS_DLP6led_onEv
   \                     ??bottomLayerPrint_11: (+1)
   \   00000168   0x2301             MOVS     R3,#+1
   \   0000016A   0x461A             MOV      R2,R3
   \   0000016C   0x7E71             LDRB     R1,[R6, #+25]
   \   0000016E   0x4620             MOV      R0,R4
   \   00000170   0x.... 0x....      BL       _ZN7MKS_DLP16bank2disp_enableEhhh
   \   00000174   0x7E70             LDRB     R0,[R6, #+25]
   \   00000176   0x1C40             ADDS     R0,R0,#+1
   \   00000178   0x7670             STRB     R0,[R6, #+25]
   \   0000017A   0x2001             MOVS     R0,#+1
   \   0000017C   0x70E8             STRB     R0,[R5, #+3]
   \   0000017E   0x.... 0x....      BL       _Z10clr_ticketv
   \   00000182   0xE01F             B.N      ??bottomLayerPrint_8
   \                     ??bottomLayerPrint_10: (+1)
   \   00000184   0x2200             MOVS     R2,#+0
   \   00000186   0x78A9             LDRB     R1,[R5, #+2]
   \   00000188   0x4620             MOV      R0,R4
   \   0000018A   0x.... 0x....      BL       _ZN7MKS_DLP21decode_layer_from_rleEjh
   \   0000018E   0x2301             MOVS     R3,#+1
   \   00000190   0x461A             MOV      R2,R3
   \   00000192   0x2100             MOVS     R1,#+0
   \   00000194   0x4620             MOV      R0,R4
   \   00000196   0x.... 0x....      BL       _ZN7MKS_DLP16bank2disp_enableEhhh
   \   0000019A   0x2001             MOVS     R0,#+1
   \   0000019C   0x70E8             STRB     R0,[R5, #+3]
   \   0000019E   0x4620             MOV      R0,R4
   \   000001A0   0x.... 0x....      BL       _ZN7MKS_DLP6led_onEv
   \   000001A4   0x.... 0x....      BL       _Z10clr_ticketv
   \   000001A8   0xE00C             B.N      ??bottomLayerPrint_8
   \                     ??bottomLayerPrint_9: (+1)
   \   000001AA   0x2301             MOVS     R3,#+1
   \   000001AC   0x461A             MOV      R2,R3
   \   000001AE   0x2100             MOVS     R1,#+0
   \   000001B0   0x4620             MOV      R0,R4
   \   000001B2   0x.... 0x....      BL       _ZN7MKS_DLP16bank2disp_enableEhhh
   \   000001B6   0x2001             MOVS     R0,#+1
   \   000001B8   0x70E8             STRB     R0,[R5, #+3]
   \   000001BA   0x4620             MOV      R0,R4
   \   000001BC   0x.... 0x....      BL       _ZN7MKS_DLP6led_onEv
   \   000001C0   0x.... 0x....      BL       _Z10clr_ticketv
   \                     ??bottomLayerPrint_8: (+1)
   \   000001C4   0x78E8             LDRB     R0,[R5, #+3]
   \   000001C6   0x2800             CMP      R0,#+0
   \   000001C8   0xD07C             BEQ.N    ??bottomLayerPrint_14
   \   000001CA   0xF104 0x0024      ADD      R0,R4,#+36
   \   000001CE   0x6981             LDR      R1,[R0, #+24]
   \   000001D0   0xF8D4 0x22D8      LDR      R2,[R4, #+728]
   \   000001D4   0x4291             CMP      R1,R2
   \   000001D6   0xD275             BCS.N    ??bottomLayerPrint_14
   \   000001D8   0x.... 0x....      LDR.W    R6,??DataTable169_8
   \   000001DC   0x78A9             LDRB     R1,[R5, #+2]
   \   000001DE   0x8A02             LDRH     R2,[R0, #+16]
   \   000001E0   0x4291             CMP      R1,R2
   \   000001E2   0xD261             BCS.N    ??bottomLayerPrint_15
   \   000001E4   0x2000             MOVS     R0,#+0
   \   000001E6   0x70E8             STRB     R0,[R5, #+3]
   \   000001E8   0x.... 0x....      BL       _Z10clr_ticketv
   \   000001EC   0x....             LDR.N    R7,??DataTable165
   \   000001EE   0xF607 0x58D4      ADDW     R8,R7,#+3540
   \   000001F2   0xF8D8 0x0018      LDR      R0,[R8, #+24]
   \   000001F6   0x2802             CMP      R0,#+2
   \   000001F8   0xDB23             BLT.N    ??bottomLayerPrint_16
   \   000001FA   0x7E71             LDRB     R1,[R6, #+25]
   \   000001FC   0x4281             CMP      R1,R0
   \   000001FE   0xDB50             BLT.N    ??bottomLayerPrint_17
   \   00000200   0x2000             MOVS     R0,#+0
   \   00000202   0x7670             STRB     R0,[R6, #+25]
   \   00000204   0x.... 0x....      LDR.W    R1,??DataTable169_11  ;; 0x42420288
   \   00000208   0x6008             STR      R0,[R1, #+0]
   \   0000020A   0x4620             MOV      R0,R4
   \   0000020C   0x.... 0x....      BL       _ZN7MKS_DLP14CleanDataTransEv
   \   00000210   0x4620             MOV      R0,R4
   \   00000212   0x.... 0x....      BL       _ZN7MKS_DLP7led_offEv
   \   00000216   0x21A6             MOVS     R1,#+166
   \   00000218   0x4620             MOV      R0,R4
   \   0000021A   0x.... 0x....      BL       _ZN7MKS_DLP23write_Information_layerE15DLP_MOVE_STATUS
   \   0000021E   0x.... 0x....      LDR.W    R0,??DataTable169_9
   \   00000222   0xED90 0x0A04      VLDR     S0,[R0, #+16]
   \   00000226   0xEDDF 0x....      VLDR.W   S1,??DataTable165_1  ;; 0x42f00000
   \   0000022A   0xEEC0 0x0A20      VDIV.F32 S1,S0,S1
   \   0000022E   0xED96 0x0A1A      VLDR     S0,[R6, #+104]
   \   00000232   0x4620             MOV      R0,R4
   \   00000234   0x.... 0x....      BL       _ZN7MKS_DLP14moveRelative_ZEff
   \   00000238   0xF897 0x0D10      LDRB     R0,[R7, #+3344]
   \   0000023C   0x28A7             CMP      R0,#+167
   \   0000023E   0xD129             BNE.N    ??bottomLayerPrint_18
   \   00000240   0xE017             B.N      ??bottomLayerPrint_19
   \                     ??bottomLayerPrint_16: (+1)
   \   00000242   0x4620             MOV      R0,R4
   \   00000244   0x.... 0x....      BL       _ZN7MKS_DLP7led_offEv
   \   00000248   0x21A6             MOVS     R1,#+166
   \   0000024A   0x4620             MOV      R0,R4
   \   0000024C   0x.... 0x....      BL       _ZN7MKS_DLP23write_Information_layerE15DLP_MOVE_STATUS
   \   00000250   0x.... 0x....      LDR.W    R0,??DataTable169_9
   \   00000254   0xED90 0x0A04      VLDR     S0,[R0, #+16]
   \   00000258   0xEDDF 0x....      VLDR.W   S1,??DataTable165_1  ;; 0x42f00000
   \   0000025C   0xEEC0 0x0A20      VDIV.F32 S1,S0,S1
   \   00000260   0xED96 0x0A1A      VLDR     S0,[R6, #+104]
   \   00000264   0x4620             MOV      R0,R4
   \   00000266   0x.... 0x....      BL       _ZN7MKS_DLP14moveRelative_ZEff
   \   0000026A   0xF897 0x0D10      LDRB     R0,[R7, #+3344]
   \   0000026E   0x28A7             CMP      R0,#+167
   \   00000270   0xD110             BNE.N    ??bottomLayerPrint_18
   \                     ??bottomLayerPrint_19: (+1)
   \   00000272   0x.... 0x....      LDR.W    R0,??DataTable169_9
   \   00000276   0xED90 0x0A04      VLDR     S0,[R0, #+16]
   \   0000027A   0xEDDF 0x....      VLDR.W   S1,??DataTable165_1  ;; 0x42f00000
   \   0000027E   0xEEC0 0x0A20      VDIV.F32 S1,S0,S1
   \   00000282   0xED94 0x0A09      VLDR     S0,[R4, #+36]
   \   00000286   0xED96 0x1A1A      VLDR     S2,[R6, #+104]
   \   0000028A   0xEE30 0x0A41      VSUB.F32 S0,S0,S2
   \   0000028E   0x4620             MOV      R0,R4
   \   00000290   0x.... 0x....      BL       _ZN7MKS_DLP14moveRelative_ZEff
   \                     ??bottomLayerPrint_18: (+1)
   \   00000294   0x21A7             MOVS     R1,#+167
   \   00000296   0x4620             MOV      R0,R4
   \   00000298   0x.... 0x....      BL       _ZN7MKS_DLP23write_Information_layerE15DLP_MOVE_STATUS
   \   0000029C   0x78A8             LDRB     R0,[R5, #+2]
   \   0000029E   0x1C40             ADDS     R0,R0,#+1
   \   000002A0   0x70A8             STRB     R0,[R5, #+2]
   \                     ??bottomLayerPrint_17: (+1)
   \   000002A2   0x.... 0x....      BL       _Z22report_mksdlp_positionv
   \   000002A6   0xE00D             B.N      ??bottomLayerPrint_14
   \                     ??bottomLayerPrint_15: (+1)
   \   000002A8   0x2100             MOVS     R1,#+0
   \   000002AA   0x7671             STRB     R1,[R6, #+25]
   \   000002AC   0x6940             LDR      R0,[R0, #+20]
   \   000002AE   0x1C40             ADDS     R0,R0,#+1
   \   000002B0   0xF8C4 0x02D8      STR      R0,[R4, #+728]
   \   000002B4   0xF8B4 0x01DC      LDRH     R0,[R4, #+476]
   \   000002B8   0x1C40             ADDS     R0,R0,#+1
   \   000002BA   0xF8A4 0x01DC      STRH     R0,[R4, #+476]
   \   000002BE   0x4620             MOV      R0,R4
   \   000002C0   0x.... 0x....      BL       _ZN7MKS_DLP18GeneralLayersPrintEv
   \                     ??bottomLayerPrint_14: (+1)
   \   000002C4   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \   __interwork __softfp void MKS_DLP::GeneralLayersPrint()
   \                     _ZN7MKS_DLP18GeneralLayersPrintEv: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xF504 0x75EE      ADD      R5,R4,#+476
   \   0000000A   0x78E8             LDRB     R0,[R5, #+3]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xF000 0x80B2      BEQ.W    ??GeneralLayersPrint_0
   \   00000012   0xF104 0x060C      ADD      R6,R4,#+12
   \   00000016   0x6AF0             LDR      R0,[R6, #+44]
   \   00000018   0xF8D4 0x12D8      LDR      R1,[R4, #+728]
   \   0000001C   0x4288             CMP      R0,R1
   \   0000001E   0xF080 0x80AA      BCS.W    ??GeneralLayersPrint_0
   \   00000022   0x89A0             LDRH     R0,[R4, #+12]
   \   00000024   0xF8B4 0x11DC      LDRH     R1,[R4, #+476]
   \   00000028   0x.... 0x....      LDR.W    R7,??DataTable169_12
   \   0000002C   0x4281             CMP      R1,R0
   \   0000002E   0xD203             BCS.N    ??GeneralLayersPrint_1
   \   00000030   0xF897 0x2CB7      LDRB     R2,[R7, #+3255]
   \   00000034   0x2A01             CMP      R2,#+1
   \   00000036   0xD00A             BEQ.N    ??GeneralLayersPrint_2
   \                     ??GeneralLayersPrint_1: (+1)
   \   00000038   0x1E49             SUBS     R1,R1,#+1
   \   0000003A   0x8D32             LDRH     R2,[R6, #+40]
   \   0000003C   0x1A80             SUBS     R0,R0,R2
   \   0000003E   0x4281             CMP      R1,R0
   \   00000040   0xF280 0x8089      BGE.W    ??GeneralLayersPrint_3
   \   00000044   0xF897 0x0CB7      LDRB     R0,[R7, #+3255]
   \   00000048   0x2801             CMP      R0,#+1
   \   0000004A   0xF000 0x8084      BEQ.W    ??GeneralLayersPrint_3
   \                     ??GeneralLayersPrint_2: (+1)
   \   0000004E   0x.... 0x....      LDR.W    R8,??DataTable169_8
   \   00000052   0xF8D7 0x0DEC      LDR      R0,[R7, #+3564]
   \   00000056   0x2802             CMP      R0,#+2
   \   00000058   0xDB45             BLT.N    ??GeneralLayersPrint_4
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x70E8             STRB     R0,[R5, #+3]
   \   0000005E   0xF898 0x0019      LDRB     R0,[R8, #+25]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD13C             BNE.N    ??GeneralLayersPrint_5
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable169_11  ;; 0x42420288
   \   0000006C   0x6008             STR      R0,[R1, #+0]
   \   0000006E   0x4620             MOV      R0,R4
   \   00000070   0x.... 0x....      BL       _ZN7MKS_DLP14CleanDataTransEv
   \   00000074   0x4620             MOV      R0,R4
   \   00000076   0x.... 0x....      BL       _ZN7MKS_DLP7led_offEv
   \   0000007A   0xF898 0x0019      LDRB     R0,[R8, #+25]
   \   0000007E   0x1C40             ADDS     R0,R0,#+1
   \   00000080   0xF888 0x0019      STRB     R0,[R8, #+25]
   \   00000084   0x2300             MOVS     R3,#+0
   \   00000086   0x461A             MOV      R2,R3
   \   00000088   0x4611             MOV      R1,R2
   \   0000008A   0x4620             MOV      R0,R4
   \   0000008C   0x.... 0x....      BL       _ZN7MKS_DLP16bank2disp_enableEhhh
   \   00000090   0x21A6             MOVS     R1,#+166
   \   00000092   0x4620             MOV      R0,R4
   \   00000094   0x.... 0x....      BL       _ZN7MKS_DLP23write_Information_layerE15DLP_MOVE_STATUS
   \   00000098   0x.... 0x....      LDR.W    R9,??DataTable169_9
   \   0000009C   0xED99 0x0A04      VLDR     S0,[R9, #+16]
   \   000000A0   0xEDDF 0x....      VLDR.W   S1,??DataTable168  ;; 0x42f00000
   \   000000A4   0xEEC0 0x0A20      VDIV.F32 S1,S0,S1
   \   000000A8   0xED98 0x0A1A      VLDR     S0,[R8, #+104]
   \   000000AC   0x4620             MOV      R0,R4
   \   000000AE   0x.... 0x....      BL       _ZN7MKS_DLP22moveRelativeZandGetBmpEff
   \   000000B2   0xF897 0x0D10      LDRB     R0,[R7, #+3344]
   \   000000B6   0x28A7             CMP      R0,#+167
   \   000000B8   0xD10E             BNE.N    ??GeneralLayersPrint_6
   \   000000BA   0xED99 0x0A04      VLDR     S0,[R9, #+16]
   \   000000BE   0xEDDF 0x....      VLDR.W   S1,??DataTable168  ;; 0x42f00000
   \   000000C2   0xEEC0 0x0A20      VDIV.F32 S1,S0,S1
   \   000000C6   0xED96 0x0A06      VLDR     S0,[R6, #+24]
   \   000000CA   0xED98 0x1A1A      VLDR     S2,[R8, #+104]
   \   000000CE   0xEE30 0x0A41      VSUB.F32 S0,S0,S2
   \   000000D2   0x4620             MOV      R0,R4
   \   000000D4   0x.... 0x....      BL       _ZN7MKS_DLP14moveRelative_ZEff
   \                     ??GeneralLayersPrint_6: (+1)
   \   000000D8   0x21A7             MOVS     R1,#+167
   \   000000DA   0x4620             MOV      R0,R4
   \   000000DC   0x.... 0x....      BL       _ZN7MKS_DLP23write_Information_layerE15DLP_MOVE_STATUS
   \                     ??GeneralLayersPrint_5: (+1)
   \   000000E0   0x.... 0x....      BL       _Z10clr_ticketv
   \   000000E4   0xE034             B.N      ??GeneralLayersPrint_7
   \                     ??GeneralLayersPrint_4: (+1)
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0x70E8             STRB     R0,[R5, #+3]
   \   000000EA   0x4620             MOV      R0,R4
   \   000000EC   0x.... 0x....      BL       _ZN7MKS_DLP7led_offEv
   \   000000F0   0x.... 0x....      BL       _Z10clr_ticketv
   \   000000F4   0x2300             MOVS     R3,#+0
   \   000000F6   0x461A             MOV      R2,R3
   \   000000F8   0x4611             MOV      R1,R2
   \   000000FA   0x4620             MOV      R0,R4
   \   000000FC   0x.... 0x....      BL       _ZN7MKS_DLP16bank2disp_enableEhhh
   \   00000100   0x21A6             MOVS     R1,#+166
   \   00000102   0x4620             MOV      R0,R4
   \   00000104   0x.... 0x....      BL       _ZN7MKS_DLP23write_Information_layerE15DLP_MOVE_STATUS
   \   00000108   0x.... 0x....      LDR.W    R9,??DataTable169_9
   \   0000010C   0xED99 0x0A04      VLDR     S0,[R9, #+16]
   \   00000110   0xEDDF 0x....      VLDR.W   S1,??DataTable168  ;; 0x42f00000
   \   00000114   0xEEC0 0x0A20      VDIV.F32 S1,S0,S1
   \   00000118   0xED98 0x0A1A      VLDR     S0,[R8, #+104]
   \   0000011C   0x4620             MOV      R0,R4
   \   0000011E   0x.... 0x....      BL       _ZN7MKS_DLP22moveRelativeZandGetBmpEff
   \   00000122   0xF897 0x0D10      LDRB     R0,[R7, #+3344]
   \   00000126   0x28A7             CMP      R0,#+167
   \   00000128   0xD10E             BNE.N    ??GeneralLayersPrint_8
   \   0000012A   0xED99 0x0A04      VLDR     S0,[R9, #+16]
   \   0000012E   0xEDDF 0x....      VLDR.W   S1,??DataTable168  ;; 0x42f00000
   \   00000132   0xEEC0 0x0A20      VDIV.F32 S1,S0,S1
   \   00000136   0xED96 0x0A06      VLDR     S0,[R6, #+24]
   \   0000013A   0xED98 0x1A1A      VLDR     S2,[R8, #+104]
   \   0000013E   0xEE30 0x0A41      VSUB.F32 S0,S0,S2
   \   00000142   0x4620             MOV      R0,R4
   \   00000144   0x.... 0x....      BL       _ZN7MKS_DLP14moveRelative_ZEff
   \                     ??GeneralLayersPrint_8: (+1)
   \   00000148   0x21A7             MOVS     R1,#+167
   \   0000014A   0x4620             MOV      R0,R4
   \   0000014C   0x.... 0x....      BL       _ZN7MKS_DLP23write_Information_layerE15DLP_MOVE_STATUS
   \                     ??GeneralLayersPrint_7: (+1)
   \   00000150   0x.... 0x....      BL       _Z22report_mksdlp_positionv
   \   00000154   0xE00F             B.N      ??GeneralLayersPrint_0
   \                     ??GeneralLayersPrint_3: (+1)
   \   00000156   0xF8D7 0x0DEC      LDR      R0,[R7, #+3564]
   \   0000015A   0x2802             CMP      R0,#+2
   \   0000015C   0xDB08             BLT.N    ??GeneralLayersPrint_9
   \   0000015E   0x2000             MOVS     R0,#+0
   \   00000160   0x....             LDR.N    R1,??DataTable169_11  ;; 0x42420288
   \   00000162   0x6008             STR      R0,[R1, #+0]
   \   00000164   0x4620             MOV      R0,R4
   \   00000166   0x.... 0x....      BL       _ZN7MKS_DLP24ExposureDataTrans_circleEv
   \   0000016A   0x4620             MOV      R0,R4
   \   0000016C   0x.... 0x....      BL       _ZN7MKS_DLP14CleanDataTransEv
   \                     ??GeneralLayersPrint_9: (+1)
   \   00000170   0x4620             MOV      R0,R4
   \   00000172   0x.... 0x....      BL       _ZN7MKS_DLP19printingHasFinishedEv
   \                     ??GeneralLayersPrint_0: (+1)
   \   00000176   0x78E8             LDRB     R0,[R5, #+3]
   \   00000178   0x2800             CMP      R0,#+0
   \   0000017A   0xD106             BNE.N    ??GeneralLayersPrint_10
   \   0000017C   0xF104 0x010C      ADD      R1,R4,#+12
   \   00000180   0x6A09             LDR      R1,[R1, #+32]
   \   00000182   0xF8D4 0x22D8      LDR      R2,[R4, #+728]
   \   00000186   0x4291             CMP      R1,R2
   \   00000188   0xD30A             BCC.N    ??GeneralLayersPrint_11
   \                     ??GeneralLayersPrint_10: (+1)
   \   0000018A   0x2800             CMP      R0,#+0
   \   0000018C   0xD14A             BNE.N    ??GeneralLayersPrint_12
   \   0000018E   0x....             LDR.N    R0,??DataTable169_8
   \   00000190   0x7E40             LDRB     R0,[R0, #+25]
   \   00000192   0x2800             CMP      R0,#+0
   \   00000194   0xD046             BEQ.N    ??GeneralLayersPrint_12
   \   00000196   0x....             LDR.N    R0,??DataTable169_12
   \   00000198   0xF8D0 0x0DEC      LDR      R0,[R0, #+3564]
   \   0000019C   0x2802             CMP      R0,#+2
   \   0000019E   0xDB41             BLT.N    ??GeneralLayersPrint_12
   \                     ??GeneralLayersPrint_11: (+1)
   \   000001A0   0x....             LDR.N    R7,??DataTable169_12
   \   000001A2   0xF8D7 0x0DEC      LDR      R0,[R7, #+3564]
   \   000001A6   0x2802             CMP      R0,#+2
   \   000001A8   0xDB2A             BLT.N    ??GeneralLayersPrint_13
   \   000001AA   0x.... 0x....      LDR.W    R8,??DataTable169_8
   \   000001AE   0x2301             MOVS     R3,#+1
   \   000001B0   0x461A             MOV      R2,R3
   \   000001B2   0xF898 0x0019      LDRB     R0,[R8, #+25]
   \   000001B6   0x1E41             SUBS     R1,R0,#+1
   \   000001B8   0xB2C9             UXTB     R1,R1
   \   000001BA   0x4620             MOV      R0,R4
   \   000001BC   0x.... 0x....      BL       _ZN7MKS_DLP16bank2disp_enableEhhh
   \   000001C0   0xF898 0x0019      LDRB     R0,[R8, #+25]
   \   000001C4   0x2801             CMP      R0,#+1
   \   000001C6   0xD102             BNE.N    ??GeneralLayersPrint_14
   \   000001C8   0x4620             MOV      R0,R4
   \   000001CA   0x.... 0x....      BL       _ZN7MKS_DLP6led_onEv
   \                     ??GeneralLayersPrint_14: (+1)
   \   000001CE   0xF898 0x0019      LDRB     R0,[R8, #+25]
   \   000001D2   0x1C40             ADDS     R0,R0,#+1
   \   000001D4   0xF888 0x0019      STRB     R0,[R8, #+25]
   \   000001D8   0x2001             MOVS     R0,#+1
   \   000001DA   0x70E8             STRB     R0,[R5, #+3]
   \   000001DC   0x.... 0x....      BL       _Z10clr_ticketv
   \   000001E0   0xF898 0x0019      LDRB     R0,[R8, #+25]
   \   000001E4   0x1E40             SUBS     R0,R0,#+1
   \   000001E6   0xF8D7 0x1DEC      LDR      R1,[R7, #+3564]
   \   000001EA   0x4288             CMP      R0,R1
   \   000001EC   0xDB1A             BLT.N    ??GeneralLayersPrint_12
   \   000001EE   0x2000             MOVS     R0,#+0
   \   000001F0   0xF888 0x0019      STRB     R0,[R8, #+25]
   \   000001F4   0xF8B4 0x01DC      LDRH     R0,[R4, #+476]
   \   000001F8   0x1C40             ADDS     R0,R0,#+1
   \   000001FA   0xF8A4 0x01DC      STRH     R0,[R4, #+476]
   \   000001FE   0xE011             B.N      ??GeneralLayersPrint_12
   \                     ??GeneralLayersPrint_13: (+1)
   \   00000200   0x2301             MOVS     R3,#+1
   \   00000202   0x461A             MOV      R2,R3
   \   00000204   0x2100             MOVS     R1,#+0
   \   00000206   0x4620             MOV      R0,R4
   \   00000208   0x.... 0x....      BL       _ZN7MKS_DLP16bank2disp_enableEhhh
   \   0000020C   0x4620             MOV      R0,R4
   \   0000020E   0x.... 0x....      BL       _ZN7MKS_DLP6led_onEv
   \   00000212   0x2001             MOVS     R0,#+1
   \   00000214   0x70E8             STRB     R0,[R5, #+3]
   \   00000216   0x.... 0x....      BL       _Z10clr_ticketv
   \   0000021A   0xF8B4 0x01DC      LDRH     R0,[R4, #+476]
   \   0000021E   0x1C40             ADDS     R0,R0,#+1
   \   00000220   0xF8A4 0x01DC      STRH     R0,[R4, #+476]
   \                     ??GeneralLayersPrint_12: (+1)
   \   00000224   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::get_available_bmps()
   \                     _ZN7MKS_DLP18get_available_bmpsEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x....             LDR.N    R5,??DataTable169_12
   \   00000006   0xF895 0x09B8      LDRB     R0,[R5, #+2488]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD022             BEQ.N    ??get_available_bmps_0
   \   0000000E   0x4628             MOV      R0,R5
   \   00000010   0x.... 0x....      BL       _ZN10CardReader3eofEv
   \   00000014   0xF8B4 0x11DC      LDRH     R1,[R4, #+476]
   \   00000018   0x89A2             LDRH     R2,[R4, #+12]
   \   0000001A   0x428A             CMP      R2,R1
   \   0000001C   0xD301             BCC.N    ??get_available_bmps_1
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD003             BEQ.N    ??get_available_bmps_2
   \                     ??get_available_bmps_1: (+1)
   \   00000022   0xF895 0x0CB7      LDRB     R0,[R5, #+3255]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD006             BEQ.N    ??get_available_bmps_3
   \                     ??get_available_bmps_2: (+1)
   \   0000002A   0x1E48             SUBS     R0,R1,#+1
   \   0000002C   0x4282             CMP      R2,R0
   \   0000002E   0xDA08             BGE.N    ??get_available_bmps_4
   \   00000030   0xF895 0x0CB7      LDRB     R0,[R5, #+3255]
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD004             BEQ.N    ??get_available_bmps_4
   \                     ??get_available_bmps_3: (+1)
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000003E   0x.... 0x....      B.W      _ZN7MKS_DLP19printingHasFinishedEv
   \                     ??get_available_bmps_4: (+1)
   \   00000042   0x2900             CMP      R1,#+0
   \   00000044   0x4620             MOV      R0,R4
   \   00000046   0xD102             BNE.N    ??get_available_bmps_5
   \   00000048   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000004C   0x....             B.N      _ZN7MKS_DLP16bottomLayerPrintEv
   \                     ??get_available_bmps_5: (+1)
   \   0000004E   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000052   0x....             B.N      _ZN7MKS_DLP18GeneralLayersPrintEv
   \                     ??get_available_bmps_0: (+1)
   \   00000054   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::ExposureDataTrans_circle()
   \                     _ZN7MKS_DLP24ExposureDataTrans_circleEv: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x461A             MOV      R2,R3
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x.... 0x....      BL       _ZN7MKS_DLP16bank2disp_enableEhhh
   \   0000000E   0x2301             MOVS     R3,#+1
   \   00000010   0xF44F 0x7243      MOV      R2,#+780
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       _ZN7MKS_DLP18line_fill_all_zeroEcth
   \   0000001C   0xF44F 0x52E6      MOV      R2,#+7360
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x....             LDR.N    R0,??DataTable169_7
   \   00000024   0x.... 0x....      BL       memset
   \   00000028   0x2500             MOVS     R5,#+0
   \   0000002A   0xE00D             B.N      ??ExposureDataTrans_circle_0
   \                     ??ExposureDataTrans_circle_1: (+1)
   \   0000002C   0xF505 0x7643      ADD      R6,R5,#+780
   \   00000030   0x2201             MOVS     R2,#+1
   \   00000032   0x4631             MOV      R1,R6
   \   00000034   0xB289             UXTH     R1,R1
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       _ZN7MKS_DLP13line_gen_dataEth
   \   0000003C   0x4631             MOV      R1,R6
   \   0000003E   0xB289             UXTH     R1,R1
   \   00000040   0x4620             MOV      R0,R4
   \   00000042   0x.... 0x....      BL       _ZN7MKS_DLP17line_gen_data_TFTEt
   \   00000046   0x1C6D             ADDS     R5,R5,#+1
   \                     ??ExposureDataTrans_circle_0: (+1)
   \   00000048   0xF5B5 0x7F7A      CMP      R5,#+1000
   \   0000004C   0xDA21             BGE.N    ??ExposureDataTrans_circle_2
   \   0000004E   0x....             LDR.N    R6,??DataTable169_12
   \   00000050   0xF44F 0x62C0      MOV      R2,#+1536
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0xF506 0x6061      ADD      R0,R6,#+3600
   \   0000005A   0x.... 0x....      BL       memset
   \   0000005E   0xEB05 0x0045      ADD      R0,R5,R5, LSL #+1
   \   00000062   0x0040             LSLS     R0,R0,#+1
   \   00000064   0x.... 0x....      ADR.W    R1,exposure_bmp_data_circle
   \   00000068   0x5A42             LDRH     R2,[R0, R1]
   \   0000006A   0x1993             ADDS     R3,R2,R6
   \   0000006C   0xF603 0x6310      ADDW     R3,R3,#+3600
   \   00000070   0xE004             B.N      ??ExposureDataTrans_circle_3
   \                     ??ExposureDataTrans_circle_4: (+1)
   \   00000072   0x2601             MOVS     R6,#+1
   \   00000074   0xF883 0x6030      STRB     R6,[R3, #+48]
   \                     ??ExposureDataTrans_circle_5: (+1)
   \   00000078   0x1C5B             ADDS     R3,R3,#+1
   \   0000007A   0x1C52             ADDS     R2,R2,#+1
   \                     ??ExposureDataTrans_circle_3: (+1)
   \   0000007C   0x1846             ADDS     R6,R0,R1
   \   0000007E   0x8876             LDRH     R6,[R6, #+2]
   \   00000080   0x1C76             ADDS     R6,R6,#+1
   \   00000082   0x42B2             CMP      R2,R6
   \   00000084   0xDAD2             BGE.N    ??ExposureDataTrans_circle_1
   \   00000086   0xF5B2 0x7F34      CMP      R2,#+720
   \   0000008A   0xDAF2             BGE.N    ??ExposureDataTrans_circle_4
   \   0000008C   0x2601             MOVS     R6,#+1
   \   0000008E   0x701E             STRB     R6,[R3, #+0]
   \   00000090   0xE7F2             B.N      ??ExposureDataTrans_circle_5
   \                     ??ExposureDataTrans_circle_2: (+1)
   \   00000092   0x....             LDR.N    R0,??DataTable169_4
   \   00000094   0xF990 0x0035      LDRSB    R0,[R0, #+53]
   \   00000098   0x2802             CMP      R0,#+2
   \   0000009A   0xD0FA             BEQ.N    ??ExposureDataTrans_circle_2
   \   0000009C   0x2001             MOVS     R0,#+1
   \   0000009E   0x....             LDR.N    R1,??DataTable169_1  ;; 0x4240029c
   \   000000A0   0x6008             STR      R0,[R1, #+0]
   \   000000A2   0x4603             MOV      R3,R0
   \   000000A4   0xF240 0x62F4      MOVW     R2,#+1780
   \   000000A8   0x4601             MOV      R1,R0
   \   000000AA   0x4620             MOV      R0,R4
   \   000000AC   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   000000B0   0x.... 0x....      B.W      _ZN7MKS_DLP18line_fill_all_zeroEcth

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::CleanDataTrans()
   \                     _ZN7MKS_DLP14CleanDataTransEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0

  	int i;
  	    ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",1180  Warning[Pe177]: 
          variable "i" was declared but never referenced

  	uint8_t *p;
  	         ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",1181  Warning[Pe177]: 
          variable "p" was declared but never referenced
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x461A             MOV      R2,R3
   \   00000008   0x2102             MOVS     R1,#+2
   \   0000000A   0x.... 0x....      BL       _ZN7MKS_DLP16bank2disp_enableEhhh
   \   0000000E   0x2302             MOVS     R3,#+2
   \   00000010   0xF44F 0x6220      MOV      R2,#+2560
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001C   0x.... 0x....      B.W      _ZN7MKS_DLP18line_fill_all_zeroEcth

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::ExposureData2TFT_circle()
   \                     _ZN7MKS_DLP23ExposureData2TFT_circleEv: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x2301             MOVS     R3,#+1
   \   00000006   0xF44F 0x7243      MOV      R2,#+780
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x.... 0x....      BL       _ZN7MKS_DLP18line_fill_all_zeroEcth
   \   00000010   0xF44F 0x52E6      MOV      R2,#+7360
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x....             LDR.N    R0,??DataTable169_7
   \   00000018   0x.... 0x....      BL       memset
   \   0000001C   0x2500             MOVS     R5,#+0
   \   0000001E   0xE006             B.N      ??ExposureData2TFT_circle_0
   \                     ??ExposureData2TFT_circle_1: (+1)
   \   00000020   0xF505 0x7143      ADD      R1,R5,#+780
   \   00000024   0xB289             UXTH     R1,R1
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       _ZN7MKS_DLP17line_gen_data_TFTEt
   \                     ??ExposureData2TFT_circle_2: (+1)
   \   0000002C   0x1C6D             ADDS     R5,R5,#+1
   \                     ??ExposureData2TFT_circle_0: (+1)
   \   0000002E   0xF5B5 0x7F7A      CMP      R5,#+1000
   \   00000032   0xDA2A             BGE.N    ??ExposureData2TFT_circle_3
   \   00000034   0xF505 0x7043      ADD      R0,R5,#+780
   \   00000038   0x1081             ASRS     R1,R0,#+2
   \   0000003A   0xEB00 0x7151      ADD      R1,R0,R1, LSR #+29
   \   0000003E   0x10C9             ASRS     R1,R1,#+3
   \   00000040   0xEBB0 0x00C1      SUBS     R0,R0,R1, LSL #+3
   \   00000044   0xD1F2             BNE.N    ??ExposureData2TFT_circle_2
   \   00000046   0x....             LDR.N    R6,??DataTable169_12
   \   00000048   0xF44F 0x62C0      MOV      R2,#+1536
   \   0000004C   0x2100             MOVS     R1,#+0
   \   0000004E   0xF506 0x6061      ADD      R0,R6,#+3600
   \   00000052   0x.... 0x....      BL       memset
   \   00000056   0xEB05 0x0045      ADD      R0,R5,R5, LSL #+1
   \   0000005A   0x0040             LSLS     R0,R0,#+1
   \   0000005C   0x.... 0x....      ADR.W    R1,exposure_bmp_data_circle
   \   00000060   0x5A42             LDRH     R2,[R0, R1]
   \   00000062   0x1993             ADDS     R3,R2,R6
   \   00000064   0xF603 0x6310      ADDW     R3,R3,#+3600
   \   00000068   0xE004             B.N      ??ExposureData2TFT_circle_4
   \                     ??ExposureData2TFT_circle_5: (+1)
   \   0000006A   0x2601             MOVS     R6,#+1
   \   0000006C   0xF883 0x6030      STRB     R6,[R3, #+48]
   \                     ??ExposureData2TFT_circle_6: (+1)
   \   00000070   0x1C5B             ADDS     R3,R3,#+1
   \   00000072   0x1C52             ADDS     R2,R2,#+1
   \                     ??ExposureData2TFT_circle_4: (+1)
   \   00000074   0x1846             ADDS     R6,R0,R1
   \   00000076   0x8876             LDRH     R6,[R6, #+2]
   \   00000078   0x1C76             ADDS     R6,R6,#+1
   \   0000007A   0x42B2             CMP      R2,R6
   \   0000007C   0xDAD0             BGE.N    ??ExposureData2TFT_circle_1
   \   0000007E   0xF5B2 0x7F34      CMP      R2,#+720
   \   00000082   0xDAF2             BGE.N    ??ExposureData2TFT_circle_5
   \   00000084   0x2601             MOVS     R6,#+1
   \   00000086   0x701E             STRB     R6,[R3, #+0]
   \   00000088   0xE7F2             B.N      ??ExposureData2TFT_circle_6
   \                     ??ExposureData2TFT_circle_3: (+1)
   \   0000008A   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::ExposureDataTrans_square()
   \                     _ZN7MKS_DLP24ExposureDataTrans_squareEv: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x461A             MOV      R2,R3
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x.... 0x....      BL       _ZN7MKS_DLP16bank2disp_enableEhhh
   \   0000000E   0x2301             MOVS     R3,#+1
   \   00000010   0xF44F 0x725C      MOV      R2,#+880
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       _ZN7MKS_DLP18line_fill_all_zeroEcth
   \   0000001C   0xF44F 0x52E6      MOV      R2,#+7360
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x....             LDR.N    R0,??DataTable170
   \   00000024   0x.... 0x....      BL       memset
   \   00000028   0x2500             MOVS     R5,#+0
   \   0000002A   0xE00D             B.N      ??ExposureDataTrans_square_0
   \                     ??ExposureDataTrans_square_1: (+1)
   \   0000002C   0x2201             MOVS     R2,#+1
   \   0000002E   0xF505 0x715C      ADD      R1,R5,#+880
   \   00000032   0xB289             UXTH     R1,R1
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x.... 0x....      BL       _ZN7MKS_DLP13line_gen_dataEth
   \   0000003A   0xF505 0x7143      ADD      R1,R5,#+780
   \   0000003E   0xB289             UXTH     R1,R1
   \   00000040   0x4620             MOV      R0,R4
   \   00000042   0x.... 0x....      BL       _ZN7MKS_DLP17line_gen_data_TFTEt
   \   00000046   0x1C6D             ADDS     R5,R5,#+1
   \                     ??ExposureDataTrans_square_0: (+1)
   \   00000048   0xF5B5 0x7F48      CMP      R5,#+800
   \   0000004C   0xDA21             BGE.N    ??ExposureDataTrans_square_2
   \   0000004E   0x....             LDR.N    R6,??DataTable170_1
   \   00000050   0xF44F 0x62C0      MOV      R2,#+1536
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0xF506 0x6061      ADD      R0,R6,#+3600
   \   0000005A   0x.... 0x....      BL       memset
   \   0000005E   0xEB05 0x0045      ADD      R0,R5,R5, LSL #+1
   \   00000062   0x0040             LSLS     R0,R0,#+1
   \   00000064   0x.... 0x....      ADR.W    R1,exposure_bmp_data_square
   \   00000068   0x5A42             LDRH     R2,[R0, R1]
   \   0000006A   0x1993             ADDS     R3,R2,R6
   \   0000006C   0xF603 0x6310      ADDW     R3,R3,#+3600
   \   00000070   0xE004             B.N      ??ExposureDataTrans_square_3
   \                     ??ExposureDataTrans_square_4: (+1)
   \   00000072   0x2601             MOVS     R6,#+1
   \   00000074   0xF883 0x6030      STRB     R6,[R3, #+48]
   \                     ??ExposureDataTrans_square_5: (+1)
   \   00000078   0x1C5B             ADDS     R3,R3,#+1
   \   0000007A   0x1C52             ADDS     R2,R2,#+1
   \                     ??ExposureDataTrans_square_3: (+1)
   \   0000007C   0x1846             ADDS     R6,R0,R1
   \   0000007E   0x8876             LDRH     R6,[R6, #+2]
   \   00000080   0x1C76             ADDS     R6,R6,#+1
   \   00000082   0x42B2             CMP      R2,R6
   \   00000084   0xDAD2             BGE.N    ??ExposureDataTrans_square_1
   \   00000086   0xF5B2 0x7F34      CMP      R2,#+720
   \   0000008A   0xDAF2             BGE.N    ??ExposureDataTrans_square_4
   \   0000008C   0x2601             MOVS     R6,#+1
   \   0000008E   0x701E             STRB     R6,[R3, #+0]
   \   00000090   0xE7F2             B.N      ??ExposureDataTrans_square_5
   \                     ??ExposureDataTrans_square_2: (+1)
   \   00000092   0x....             LDR.N    R0,??DataTable170_2
   \   00000094   0xF990 0x0035      LDRSB    R0,[R0, #+53]
   \   00000098   0x2802             CMP      R0,#+2
   \   0000009A   0xD0FA             BEQ.N    ??ExposureDataTrans_square_2
   \   0000009C   0x2001             MOVS     R0,#+1
   \   0000009E   0x....             LDR.N    R1,??DataTable170_3  ;; 0x4240029c
   \   000000A0   0x6008             STR      R0,[R1, #+0]
   \   000000A2   0x4603             MOV      R3,R0
   \   000000A4   0xF44F 0x62D2      MOV      R2,#+1680
   \   000000A8   0x4601             MOV      R1,R0
   \   000000AA   0x4620             MOV      R0,R4
   \   000000AC   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   000000B0   0x.... 0x....      B.W      _ZN7MKS_DLP18line_fill_all_zeroEcth

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::ExposureTest()
   \                     _ZN7MKS_DLP12ExposureTestEv: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0x.... 0x....      BL       exposure_msg_display
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       _ZN7MKS_DLP23ExposureData2TFT_circleEv
   \   00000010   0x20B4             MOVS     R0,#+180
   \   00000012   0x9000             STR      R0,[SP, #+0]
   \   00000014   0xF44F 0x73A0      MOV      R3,#+320
   \   00000018   0x2214             MOVS     R2,#+20
   \   0000001A   0x2150             MOVS     R1,#+80
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable194_1
   \   00000020   0x.... 0x....      BL       layer_pic_display
   \   00000024   0x2301             MOVS     R3,#+1
   \   00000026   0x461A             MOV      R2,R3
   \   00000028   0x4611             MOV      R1,R2
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       _ZN7MKS_DLP16bank2disp_enableEhhh
   \   00000030   0xF204 0x25F2      ADDW     R5,R4,#+754
   \   00000034   0x4628             MOV      R0,R5
   \   00000036   0x.... 0x....      BL       _ZN7SSD28289sleep_outEv
   \   0000003A   0x.... 0x....      LDR.W    R6,??DataTable194_2  ;; 0x42420288
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x6030             STR      R0,[R6, #+0]
   \   00000042   0xF504 0x77F2      ADD      R7,R4,#+484
   \   00000046   0x7138             STRB     R0,[R7, #+4]
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable194_3
   \   0000004E   0x6008             STR      R0,[R1, #+0]
   \   00000050   0x.... 0x....      BL       _Z10clr_ticketv
   \   00000054   0xE001             B.N      ??ExposureTest_0
   \                     ??ExposureTest_1: (+1)
   \   00000056   0x.... 0x....      BL       _Z4idlev
   \                     ??ExposureTest_0: (+1)
   \   0000005A   0xF8D4 0x02D8      LDR      R0,[R4, #+728]
   \   0000005E   0xF8D4 0x11E4      LDR      R1,[R4, #+484]
   \   00000062   0x4288             CMP      R0,R1
   \   00000064   0xD3F7             BCC.N    ??ExposureTest_1
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x6030             STR      R0,[R6, #+0]
   \   0000006A   0x7138             STRB     R0,[R7, #+4]
   \   0000006C   0x2301             MOVS     R3,#+1
   \   0000006E   0x461A             MOV      R2,R3
   \   00000070   0x2102             MOVS     R1,#+2
   \   00000072   0x4620             MOV      R0,R4
   \   00000074   0x.... 0x....      BL       _ZN7MKS_DLP16bank2disp_enableEhhh
   \   00000078   0x4628             MOV      R0,R5
   \   0000007A   0x.... 0x....      BL       _ZN7SSD28288sleep_inEv
   \   0000007E   0x2014             MOVS     R0,#+20
   \   00000080   0x.... 0x....      BL       HAL_Delay
   \   00000084   0x2300             MOVS     R3,#+0
   \   00000086   0x461A             MOV      R2,R3
   \   00000088   0x2102             MOVS     R1,#+2
   \   0000008A   0x4620             MOV      R0,R4
   \   0000008C   0x.... 0x....      BL       _ZN7MKS_DLP16bank2disp_enableEhhh
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable195
   \   00000094   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000098   0x2823             CMP      R0,#+35
   \   0000009A   0xD10D             BNE.N    ??ExposureTest_2
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0x9000             STR      R0,[SP, #+0]
   \   000000A0   0x23B4             MOVS     R3,#+180
   \   000000A2   0xF44F 0x72A0      MOV      R2,#+320
   \   000000A6   0x2114             MOVS     R1,#+20
   \   000000A8   0x2050             MOVS     R0,#+80
   \   000000AA   0x.... 0x....      BL       layer_pic_clean
   \   000000AE   0x2003             MOVS     R0,#+3
   \   000000B0   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   000000B4   0x.... 0x....      B.W      exposure_msg_display
   \                     ??ExposureTest_2: (+1)
   \   000000B8   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::ExposureAll_on()
   \                     _ZN7MKS_DLP14ExposureAll_onEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x.... 0x....      BL       _ZN7MKS_DLP17line_fill_all_oneEh
   \   0000000A   0x2301             MOVS     R3,#+1
   \   0000000C   0x461A             MOV      R2,R3
   \   0000000E   0x4611             MOV      R1,R2
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       _ZN7MKS_DLP16bank2disp_enableEhhh
   \   00000016   0xF204 0x20F2      ADDW     R0,R4,#+754
   \   0000001A   0x.... 0x....      BL       _ZN7SSD28289sleep_outEv
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable194_2  ;; 0x42420288
   \   00000024   0x6008             STR      R0,[R1, #+0]
   \   00000026   0xF884 0x01E8      STRB     R0,[R4, #+488]
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::ExposureAll_off()
   \                     _ZN7MKS_DLP15ExposureAll_offEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable194_2  ;; 0x42420288
   \   0000000A   0x6008             STR      R0,[R1, #+0]
   \   0000000C   0xF884 0x01E8      STRB     R0,[R4, #+488]
   \   00000010   0x2301             MOVS     R3,#+1
   \   00000012   0x461A             MOV      R2,R3
   \   00000014   0x2102             MOVS     R1,#+2
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       _ZN7MKS_DLP16bank2disp_enableEhhh
   \   0000001C   0xF204 0x20F2      ADDW     R0,R4,#+754
   \   00000020   0x.... 0x....      BL       _ZN7SSD28288sleep_inEv
   \   00000024   0x2014             MOVS     R0,#+20
   \   00000026   0x.... 0x....      BL       HAL_Delay
   \   0000002A   0x2300             MOVS     R3,#+0
   \   0000002C   0x461A             MOV      R2,R3
   \   0000002E   0x2102             MOVS     R1,#+2
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       _ZN7MKS_DLP16bank2disp_enableEhhh
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       _ZN7MKS_DLP24ExposureDataTrans_circleEv
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000042   0x.... 0x....      B.W      _ZN7MKS_DLP14CleanDataTransEv

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::led_on()
   \                     _ZN7MKS_DLP6led_onEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xF204 0x20F2      ADDW     R0,R4,#+754
   \   0000000A   0x.... 0x....      BL       _ZN7SSD28289sleep_outEv
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable194_2  ;; 0x42420288
   \   00000014   0x6008             STR      R0,[R1, #+0]
   \   00000016   0xF884 0x01E8      STRB     R0,[R4, #+488]
   \   0000001A   0x.... 0x....      ADR.W    R0,`?<Constant "led on:">`
   \   0000001E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable195_1
   \   00000026   0x.... 0x....      BL       _ZN7MKS_DLP16get_currentLayerEv
   \   0000002A   0x220A             MOVS     R2,#+10
   \   0000002C   0x4601             MOV      R1,R0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable195_2
   \   00000032   0x.... 0x....      BL       _ZN5Print5printEii
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable195
   \   0000003A   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   0000003E   0x2803             CMP      R0,#+3
   \   00000040   0xD113             BNE.N    ??led_on_0
   \   00000042   0x20B4             MOVS     R0,#+180
   \   00000044   0x9000             STR      R0,[SP, #+0]
   \   00000046   0xF44F 0x73A0      MOV      R3,#+320
   \   0000004A   0x220F             MOVS     R2,#+15
   \   0000004C   0x211E             MOVS     R1,#+30
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable194_1
   \   00000052   0x.... 0x....      BL       layer_pic_display
   \   00000056   0x.... 0x....      BL       draw_status_clear
   \   0000005A   0x.... 0x....      BL       display_print_statue
   \   0000005E   0x.... 0x....      BL       setProBarRate
   \   00000062   0xE8BD 0x4013      POP      {R0,R1,R4,LR}
   \   00000066   0x.... 0x....      B.W      GUI_Exec
   \                     ??led_on_0: (+1)
   \   0000006A   0xBD13             POP      {R0,R1,R4,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::led_off()
   \                     _ZN7MKS_DLP7led_offEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable194_2  ;; 0x42420288
   \   0000000C   0x6008             STR      R0,[R1, #+0]
   \   0000000E   0xF884 0x01E8      STRB     R0,[R4, #+488]
   \   00000012   0x2301             MOVS     R3,#+1
   \   00000014   0x461A             MOV      R2,R3
   \   00000016   0x2102             MOVS     R1,#+2
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       _ZN7MKS_DLP16bank2disp_enableEhhh
   \   0000001E   0xF204 0x20F2      ADDW     R0,R4,#+754
   \   00000022   0x.... 0x....      BL       _ZN7SSD28288sleep_inEv
   \   00000026   0x200A             MOVS     R0,#+10
   \   00000028   0x.... 0x....      BL       HAL_Delay
   \   0000002C   0x2300             MOVS     R3,#+0
   \   0000002E   0x461A             MOV      R2,R3
   \   00000030   0x2102             MOVS     R1,#+2
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       _ZN7MKS_DLP16bank2disp_enableEhhh
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable195
   \   0000003C   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000040   0x2803             CMP      R0,#+3
   \   00000042   0xD108             BNE.N    ??led_off_0
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x9000             STR      R0,[SP, #+0]
   \   00000048   0x23B4             MOVS     R3,#+180
   \   0000004A   0xF44F 0x72A0      MOV      R2,#+320
   \   0000004E   0x210F             MOVS     R1,#+15
   \   00000050   0x201E             MOVS     R0,#+30
   \   00000052   0x.... 0x....      BL       layer_pic_clean
   \                     ??led_off_0: (+1)
   \   00000056   0xBD13             POP      {R0,R1,R4,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::power_on()
   \                     _ZN7MKS_DLP8power_onEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable196  ;; 0x42408284
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x6020             STR      R0,[R4, #+0]
   \   0000000A   0x20C8             MOVS     R0,#+200
   \   0000000C   0x.... 0x....      BL       HAL_Delay
   \   00000010   0x.... 0x....      LDR.W    R5,??DataTable197  ;; 0x42400290
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x6028             STR      R0,[R5, #+0]
   \   00000018   0x20C8             MOVS     R0,#+200
   \   0000001A   0x.... 0x....      BL       HAL_Delay
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x6068             STR      R0,[R5, #+4]
   \   00000022   0x2032             MOVS     R0,#+50
   \   00000024   0x.... 0x....      BL       HAL_Delay
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x6020             STR      R0,[R4, #+0]
   \   0000002C   0x2064             MOVS     R0,#+100
   \   0000002E   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000032   0x.... 0x....      B.W      HAL_Delay

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::power_off()
   \                     _ZN7MKS_DLP9power_offEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable196  ;; 0x42408284
   \   00000008   0x6008             STR      R0,[R1, #+0]
   \   0000000A   0x2005             MOVS     R0,#+5
   \   0000000C   0x.... 0x....      BL       HAL_Delay
   \   00000010   0x.... 0x....      LDR.W    R4,??DataTable197  ;; 0x42400290
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x6060             STR      R0,[R4, #+4]
   \   00000018   0x20C8             MOVS     R0,#+200
   \   0000001A   0x.... 0x....      BL       HAL_Delay
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x6020             STR      R0,[R4, #+0]
   \   00000022   0x2064             MOVS     R0,#+100
   \   00000024   0xE8BD 0x4010      POP      {R4,LR}
   \   00000028   0x.... 0x....      B.W      HAL_Delay

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp uint8_t MKS_DLP::bank2disp_enable_gray(uint8_t, uint8_t, uint8_t, uint8_t)
   \                     _ZN7MKS_DLP21bank2disp_enable_grayEhhhh: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF884 0x01F0      STRB     R0,[R4, #+496]
   \   0000000A   0xF504 0x75F8      ADD      R5,R4,#+496
   \   0000000E   0x9806             LDR      R0,[SP, #+24]
   \   00000010   0x7068             STRB     R0,[R5, #+1]
   \   00000012   0x0198             LSLS     R0,R3,#+6
   \   00000014   0xEA40 0x10C2      ORR      R0,R0,R2, LSL #+7
   \   00000018   0xEA40 0x1001      ORR      R0,R0,R1, LSL #+4
   \   0000001C   0x70A8             STRB     R0,[R5, #+2]
   \   0000001E   0x2600             MOVS     R6,#+0
   \   00000020   0xE000             B.N      ??bank2disp_enable_gray_0
   \                     ??bank2disp_enable_gray_1: (+1)
   \   00000022   0x1C76             ADDS     R6,R6,#+1
   \                     ??bank2disp_enable_gray_0: (+1)
   \   00000024   0xB2F6             UXTB     R6,R6
   \   00000026   0x2E05             CMP      R6,#+5
   \   00000028   0xDA19             BGE.N    ??bank2disp_enable_gray_2
   \   0000002A   0x.... 0x....      LDR.W    R7,??DataTable198  ;; 0x4240029c
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x6038             STR      R0,[R7, #+0]
   \   00000032   0xF894 0x01F0      LDRB     R0,[R4, #+496]
   \   00000036   0x.... 0x....      BL       SPI1_ReadWriteByte
   \   0000003A   0x7868             LDRB     R0,[R5, #+1]
   \   0000003C   0x.... 0x....      BL       SPI1_ReadWriteByte
   \   00000040   0x78A8             LDRB     R0,[R5, #+2]
   \   00000042   0x.... 0x....      BL       SPI1_ReadWriteByte
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0x6038             STR      R0,[R7, #+0]
   \   0000004A   0x78AF             LDRB     R7,[R5, #+2]
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0x.... 0x....      BL       _ZN7MKS_DLP14bank2disp_readEv
   \   00000052   0xF000 0x00F0      AND      R0,R0,#0xF0
   \   00000056   0x4287             CMP      R7,R0
   \   00000058   0xD1E3             BNE.N    ??bank2disp_enable_gray_1
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??bank2disp_enable_gray_2: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xBDF2             POP      {R1,R4-R7,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::grag_test()
   \                     _ZN7MKS_DLP9grag_testEv: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x2500             MOVS     R5,#+0
   \   0000000A   0xF504 0x76F2      ADD      R6,R4,#+484
   \   0000000E   0xF204 0x27F2      ADDW     R7,R4,#+754
   \   00000012   0x.... 0x....      LDR.W    R8,??DataTable194_2  ;; 0x42420288
   \   00000016   0xE03E             B.N      ??grag_test_0
   \                     ??grag_test_1: (+1)
   \   00000018   0x.... 0x....      BL       _Z4idlev
   \                     ??grag_test_2: (+1)
   \   0000001C   0xF8D4 0x02D8      LDR      R0,[R4, #+728]
   \   00000020   0xF8D4 0x11E4      LDR      R1,[R4, #+484]
   \   00000024   0x4288             CMP      R0,R1
   \   00000026   0xD3F7             BCC.N    ??grag_test_1
   \   00000028   0xF44F 0x60FA      MOV      R0,#+2000
   \   0000002C   0x.... 0x....      BL       HAL_Delay
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xF8C8 0x0000      STR      R0,[R8, #+0]
   \   00000036   0x7130             STRB     R0,[R6, #+4]
   \   00000038   0x2301             MOVS     R3,#+1
   \   0000003A   0x461A             MOV      R2,R3
   \   0000003C   0x2102             MOVS     R1,#+2
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0x.... 0x....      BL       _ZN7MKS_DLP16bank2disp_enableEhhh
   \   00000044   0x4638             MOV      R0,R7
   \   00000046   0x.... 0x....      BL       _ZN7SSD28288sleep_inEv
   \   0000004A   0x2014             MOVS     R0,#+20
   \   0000004C   0x.... 0x....      BL       HAL_Delay
   \   00000050   0x2300             MOVS     R3,#+0
   \   00000052   0x461A             MOV      R2,R3
   \   00000054   0x2102             MOVS     R1,#+2
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0x.... 0x....      BL       _ZN7MKS_DLP16bank2disp_enableEhhh
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable195
   \   00000060   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000064   0x2823             CMP      R0,#+35
   \   00000066   0xD10B             BNE.N    ??grag_test_3
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x9000             STR      R0,[SP, #+0]
   \   0000006C   0x23B4             MOVS     R3,#+180
   \   0000006E   0xF44F 0x72A0      MOV      R2,#+320
   \   00000072   0x2114             MOVS     R1,#+20
   \   00000074   0x2050             MOVS     R0,#+80
   \   00000076   0x.... 0x....      BL       layer_pic_clean
   \   0000007A   0x2003             MOVS     R0,#+3
   \   0000007C   0x.... 0x....      BL       exposure_msg_display
   \                     ??grag_test_3: (+1)
   \   00000080   0xF44F 0x60FA      MOV      R0,#+2000
   \   00000084   0x.... 0x....      BL       HAL_Delay
   \   00000088   0x1C68             ADDS     R0,R5,#+1
   \   0000008A   0x1081             ASRS     R1,R0,#+2
   \   0000008C   0xEB00 0x7151      ADD      R1,R0,R1, LSR #+29
   \   00000090   0x10C9             ASRS     R1,R1,#+3
   \   00000092   0xEBA0 0x05C1      SUB      R5,R0,R1, LSL #+3
   \                     ??grag_test_0: (+1)
   \   00000096   0x2002             MOVS     R0,#+2
   \   00000098   0x.... 0x....      BL       exposure_msg_display
   \   0000009C   0x4620             MOV      R0,R4
   \   0000009E   0x.... 0x....      BL       _ZN7MKS_DLP23ExposureData2TFT_circleEv
   \   000000A2   0x20B4             MOVS     R0,#+180
   \   000000A4   0x9000             STR      R0,[SP, #+0]
   \   000000A6   0xF44F 0x73A0      MOV      R3,#+320
   \   000000AA   0x2214             MOVS     R2,#+20
   \   000000AC   0x2150             MOVS     R1,#+80
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable194_1
   \   000000B2   0x.... 0x....      BL       layer_pic_display
   \   000000B6   0xB2ED             UXTB     R5,R5
   \   000000B8   0x9500             STR      R5,[SP, #+0]
   \   000000BA   0x2301             MOVS     R3,#+1
   \   000000BC   0x461A             MOV      R2,R3
   \   000000BE   0x4611             MOV      R1,R2
   \   000000C0   0x4620             MOV      R0,R4
   \   000000C2   0x.... 0x....      BL       _ZN7MKS_DLP21bank2disp_enable_grayEhhhh
   \   000000C6   0x4638             MOV      R0,R7
   \   000000C8   0x.... 0x....      BL       _ZN7SSD28289sleep_outEv
   \   000000CC   0x2001             MOVS     R0,#+1
   \   000000CE   0xF8C8 0x0000      STR      R0,[R8, #+0]
   \   000000D2   0x7130             STRB     R0,[R6, #+4]
   \   000000D4   0x2000             MOVS     R0,#+0
   \   000000D6   0x.... 0x....      LDR.W    R1,??DataTable194_3
   \   000000DA   0x6008             STR      R0,[R1, #+0]
   \   000000DC   0x.... 0x....      BL       _Z10clr_ticketv
   \   000000E0   0xE79C             B.N      ??grag_test_2

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::dlp_start()
   \                     _ZN7MKS_DLP9dlp_startEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xF204 0x20F2      ADDW     R0,R4,#+754
   \   00000008   0x.... 0x....      BL       _ZN7SSD28284initEv
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD103             BNE.N    ??dlp_start_0
   \   00000010   0x.... 0x....      ADR.W    R0,`?<Constant "ssd dev is error!\\r\\n\\n">`
   \   00000014   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \                     ??dlp_start_0: (+1)
   \   00000018   0x.... 0x....      ADR.W    R0,`?<Constant "CPLD VER:">`
   \   0000001C   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       _ZN7MKS_DLP12get_cpld_verEv
   \   00000026   0x220A             MOVS     R2,#+10
   \   00000028   0x4601             MOV      R1,R0
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable195_2
   \   0000002E   0x.... 0x....      BL       _ZN5Print5printEhi
   \   00000032   0x2201             MOVS     R2,#+1
   \   00000034   0xF504 0x713C      ADD      R1,R4,#+752
   \   00000038   0xF240 0x603A      MOVW     R0,#+1594
   \   0000003C   0x.... 0x....      BL       AT24CXX_Read
   \   00000040   0xF894 0x02F0      LDRB     R0,[R4, #+752]
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable201
   \   00000048   0xF881 0x0278      STRB     R0,[R1, #+632]
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0x.... 0x....      BL       _ZN7MKS_DLP24ExposureDataTrans_circleEv
   \   00000052   0x4620             MOV      R0,R4
   \   00000054   0x.... 0x....      BL       _ZN7MKS_DLP14CleanDataTransEv
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable201_1  ;; 0x4242028c
   \   0000005C   0x2101             MOVS     R1,#+1
   \   0000005E   0x6041             STR      R1,[R0, #+4]
   \   00000060   0x6001             STR      R1,[R0, #+0]
   \   00000062   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::set_LedOnTime(uint16_t)
   \                     _ZN7MKS_DLP13set_LedOnTimeEt: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4606             MOV      R6,R0
   \   00000004   0xF44F 0x707A      MOV      R0,#+1000
   \   00000008   0x4348             MULS     R0,R0,R1
   \   0000000A   0x62B0             STR      R0,[R6, #+40]
   \   0000000C   0xF240 0x4407      MOVW     R4,#+1031
   \   00000010   0x2204             MOVS     R2,#+4
   \   00000012   0xF106 0x0128      ADD      R1,R6,#+40
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       epr_write_data
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x62B0             STR      R0,[R6, #+40]
   \   00000020   0x2204             MOVS     R2,#+4
   \   00000022   0xF106 0x0128      ADD      R1,R6,#+40
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       epr_read_data
   \   0000002C   0x6AB0             LDR      R0,[R6, #+40]
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable201_2
   \   00000032   0xF8D1 0x7DEC      LDR      R7,[R1, #+3564]
   \   00000036   0x2F02             CMP      R7,#+2
   \   00000038   0xDB15             BLT.N    ??set_LedOnTime_0

  		head.LedOnTime_bak=(head.LedOnTime*1.0/cbddlp_file_header.antiAliasingLevel+0.5);
  		                  ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",1505  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \   0000003A   0x.... 0x....      BL       __aeabi_ui2d
   \   0000003E   0x4604             MOV      R4,R0
   \   00000040   0x460D             MOV      R5,R1
   \   00000042   0x4638             MOV      R0,R7
   \   00000044   0x.... 0x....      BL       __aeabi_i2d
   \   00000048   0x4602             MOV      R2,R0
   \   0000004A   0x460B             MOV      R3,R1
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0x4629             MOV      R1,R5
   \   00000050   0x.... 0x....      BL       __aeabi_ddiv
   \   00000054   0x2200             MOVS     R2,#+0
   \   00000056   0x.... 0x....      LDR.W    R3,??DataTable201_3  ;; 0x3fe00000
   \   0000005A   0x.... 0x....      BL       __aeabi_dadd
   \   0000005E   0x.... 0x....      BL       __aeabi_d2uiz
   \   00000062   0x63B0             STR      R0,[R6, #+56]
   \   00000064   0xBDF1             POP      {R0,R4-R7,PC}
   \                     ??set_LedOnTime_0: (+1)
   \   00000066   0x63B0             STR      R0,[R6, #+56]
   \   00000068   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::set_LedOffTime(uint16_t)
   \                     _ZN7MKS_DLP14set_LedOffTimeEt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xF44F 0x707A      MOV      R0,#+1000
   \   00000008   0x4348             MULS     R0,R0,R1
   \   0000000A   0x62E0             STR      R0,[R4, #+44]
   \   0000000C   0xF240 0x450B      MOVW     R5,#+1035
   \   00000010   0x2204             MOVS     R2,#+4
   \   00000012   0xF104 0x012C      ADD      R1,R4,#+44
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0x.... 0x....      BL       epr_write_data
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x62E0             STR      R0,[R4, #+44]
   \   00000020   0x2204             MOVS     R2,#+4
   \   00000022   0xF104 0x012C      ADD      R1,R4,#+44
   \   00000026   0x4628             MOV      R0,R5
   \   00000028   0xE8BD 0x4038      POP      {R3-R5,LR}
   \   0000002C   0x.... 0x....      B.W      epr_read_data

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::set_Bottomlayers(uint16_t)
   \                     _ZN7MKS_DLP16set_BottomlayersEt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xF8B4 0x01DC      LDRH     R0,[R4, #+476]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD112             BNE.N    ??set_Bottomlayers_0
   \   0000000C   0x86A1             STRH     R1,[R4, #+52]
   \   0000000E   0xF240 0x4513      MOVW     R5,#+1043
   \   00000012   0x2202             MOVS     R2,#+2
   \   00000014   0xF104 0x0134      ADD      R1,R4,#+52
   \   00000018   0x4628             MOV      R0,R5
   \   0000001A   0x.... 0x....      BL       epr_write_data
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x86A0             STRH     R0,[R4, #+52]
   \   00000022   0x2202             MOVS     R2,#+2
   \   00000024   0xF104 0x0134      ADD      R1,R4,#+52
   \   00000028   0x4628             MOV      R0,R5
   \   0000002A   0xE8BD 0x4038      POP      {R3-R5,LR}
   \   0000002E   0x.... 0x....      B.W      epr_read_data
   \                     ??set_Bottomlayers_0: (+1)
   \   00000032   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::set_BottomLedOnTime(uint16_t)
   \                     _ZN7MKS_DLP19set_BottomLedOnTimeEt: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4606             MOV      R6,R0
   \   00000004   0xF44F 0x707A      MOV      R0,#+1000
   \   00000008   0x4348             MULS     R0,R0,R1
   \   0000000A   0x6330             STR      R0,[R6, #+48]
   \   0000000C   0xF240 0x440F      MOVW     R4,#+1039
   \   00000010   0x2204             MOVS     R2,#+4
   \   00000012   0xF106 0x0130      ADD      R1,R6,#+48
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       epr_write_data
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x6330             STR      R0,[R6, #+48]
   \   00000020   0x2204             MOVS     R2,#+4
   \   00000022   0xF106 0x0130      ADD      R1,R6,#+48
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       epr_read_data
   \   0000002C   0x6B30             LDR      R0,[R6, #+48]
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable201_2
   \   00000032   0xF8D1 0x7DEC      LDR      R7,[R1, #+3564]
   \   00000036   0x2F02             CMP      R7,#+2
   \   00000038   0xDB15             BLT.N    ??set_BottomLedOnTime_0
   \   0000003A   0x.... 0x....      BL       __aeabi_ui2d
   \   0000003E   0x4604             MOV      R4,R0
   \   00000040   0x460D             MOV      R5,R1
   \   00000042   0x4638             MOV      R0,R7
   \   00000044   0x.... 0x....      BL       __aeabi_i2d
   \   00000048   0x4602             MOV      R2,R0
   \   0000004A   0x460B             MOV      R3,R1
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0x4629             MOV      R1,R5
   \   00000050   0x.... 0x....      BL       __aeabi_ddiv
   \   00000054   0x2200             MOVS     R2,#+0
   \   00000056   0x.... 0x....      LDR.W    R3,??DataTable201_3  ;; 0x3fe00000
   \   0000005A   0x.... 0x....      BL       __aeabi_dadd
   \   0000005E   0x.... 0x....      BL       __aeabi_d2uiz
   \   00000062   0x63F0             STR      R0,[R6, #+60]
   \   00000064   0xBDF1             POP      {R0,R4-R7,PC}
   \                     ??set_BottomLedOnTime_0: (+1)
   \   00000066   0x63F0             STR      R0,[R6, #+60]
   \   00000068   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp uint16_t MKS_DLP::get_LedOnTime()
   \                     _ZN7MKS_DLP13get_LedOnTimeEv: (+1)
   \   00000000   0x6A80             LDR      R0,[R0, #+40]
   \   00000002   0xF44F 0x717A      MOV      R1,#+1000
   \   00000006   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000000A   0xB280             UXTH     R0,R0
   \   0000000C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp uint16_t MKS_DLP::get_LedOffTime()
   \                     _ZN7MKS_DLP14get_LedOffTimeEv: (+1)
   \   00000000   0x6AC0             LDR      R0,[R0, #+44]
   \   00000002   0xF44F 0x717A      MOV      R1,#+1000
   \   00000006   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000000A   0xB280             UXTH     R0,R0
   \   0000000C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp uint16_t MKS_DLP::get_Bottomlayers()
   \                     _ZN7MKS_DLP16get_BottomlayersEv: (+1)
   \   00000000   0x8E80             LDRH     R0,[R0, #+52]
   \   00000002   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp uint32_t MKS_DLP::get_BottomLedOnTime()
   \                     _ZN7MKS_DLP19get_BottomLedOnTimeEv: (+1)
   \   00000000   0x6B00             LDR      R0,[R0, #+48]
   \   00000002   0xF44F 0x717A      MOV      R1,#+1000
   \   00000006   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::set_test_exposure_time(uint16_t)
   \                     _ZN7MKS_DLP22set_test_exposure_timeEt: (+1)
   \   00000000   0xF44F 0x727A      MOV      R2,#+1000
   \   00000004   0x4351             MULS     R1,R2,R1
   \   00000006   0xF8C0 0x11E4      STR      R1,[R0, #+484]
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::set_Zoffset()
   \                     _ZN7MKS_DLP11set_ZoffsetEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      BL       _Z18axis_unhomed_errorb
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD105             BNE.N    ??set_Zoffset_0
   \   0000000C   0x.... 0x....      BL       _Z10gcode_M428v
   \   00000010   0xE8BD 0x4001      POP      {R0,LR}
   \   00000014   0x.... 0x....      B.W      _Z10gcode_M500v
   \                     ??set_Zoffset_0: (+1)
   \   00000018   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp uint16_t MKS_DLP::get_totalLayers()
   \                     _ZN7MKS_DLP15get_totalLayersEv: (+1)
   \   00000000   0x8981             LDRH     R1,[R0, #+12]
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable201_2
   \   00000006   0xF892 0x2CB7      LDRB     R2,[R2, #+3255]
   \   0000000A   0x2A01             CMP      R2,#+1
   \   0000000C   0xD104             BNE.N    ??get_totalLayers_0
   \   0000000E   0x8E80             LDRH     R0,[R0, #+52]
   \   00000010   0x1840             ADDS     R0,R0,R1
   \   00000012   0x1E40             SUBS     R0,R0,#+1
   \   00000014   0xB280             UXTH     R0,R0
   \   00000016   0x4770             BX       LR
   \                     ??get_totalLayers_0: (+1)
   \   00000018   0x4608             MOV      R0,R1
   \   0000001A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp uint16_t MKS_DLP::get_currentLayer()
   \                     _ZN7MKS_DLP16get_currentLayerEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x.... 0x....      BL       _ZN7MKS_DLP15get_totalLayersEv
   \   00000008   0xF894 0x11DE      LDRB     R1,[R4, #+478]
   \   0000000C   0xF8B4 0x21DC      LDRH     R2,[R4, #+476]
   \   00000010   0x1851             ADDS     R1,R2,R1
   \   00000012   0xB289             UXTH     R1,R1
   \   00000014   0x4288             CMP      R0,R1
   \   00000016   0xD900             BLS.N    ??get_currentLayer_0
   \   00000018   0x4608             MOV      R0,R1
   \                     ??get_currentLayer_0: (+1)
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \   __interwork __softfp uint32_t MKS_DLP::get_totalPrintTime()
   \                     _ZN7MKS_DLP18get_totalPrintTimeEv: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4607             MOV      R7,R0
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable201_5
   \   00000008   0x8841             LDRH     R1,[R0, #+2]
   \   0000000A   0xF44F 0x6261      MOV      R2,#+3600
   \   0000000E   0x7903             LDRB     R3,[R0, #+4]
   \   00000010   0xEBC3 0x1403      RSB      R4,R3,R3, LSL #+4
   \   00000014   0x00A3             LSLS     R3,R4,#+2
   \   00000016   0xFB02 0x3101      MLA      R1,R2,R1,R3
   \   0000001A   0xF990 0x0005      LDRSB    R0,[R0, #+5]
   \   0000001E   0xFA41 0xF480      SXTAB    R4,R1,R0
   \   00000022   0x4638             MOV      R0,R7
   \   00000024   0x.... 0x....      BL       _ZN7MKS_DLP15get_totalLayersEv
   \   00000028   0x4605             MOV      R5,R0
   \   0000002A   0x4638             MOV      R0,R7
   \   0000002C   0x.... 0x....      BL       _ZN7MKS_DLP16get_currentLayerEv
   \   00000030   0x1A28             SUBS     R0,R5,R0
   \   00000032   0xB280             UXTH     R0,R0
   \   00000034   0xF107 0x0124      ADD      R1,R7,#+36
   \   00000038   0x684A             LDR      R2,[R1, #+4]
   \   0000003A   0x8A0B             LDRH     R3,[R1, #+16]
   \   0000003C   0xF897 0x51DE      LDRB     R5,[R7, #+478]
   \   00000040   0x462E             MOV      R6,R5
   \   00000042   0x429E             CMP      R6,R3
   \   00000044   0xD211             BCS.N    ??get_totalPrintTime_0
   \   00000046   0x68CE             LDR      R6,[R1, #+12]
   \   00000048   0x42B2             CMP      R2,R6
   \   0000004A   0xD20E             BCS.N    ??get_totalPrintTime_0
   \   0000004C   0xFB02 0xFC00      MUL      R12,R2,R0
   \   00000050   0xF44F 0x7E7A      MOV      LR,#+1000
   \   00000054   0xFBBC 0xFCFE      UDIV     R12,R12,LR
   \   00000058   0x1B5B             SUBS     R3,R3,R5
   \   0000005A   0x1AB2             SUBS     R2,R6,R2
   \   0000005C   0x435A             MULS     R2,R2,R3
   \   0000005E   0x4673             MOV      R3,LR
   \   00000060   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   00000064   0xEB02 0x050C      ADD      R5,R2,R12
   \   00000068   0xE004             B.N      ??get_totalPrintTime_1
   \                     ??get_totalPrintTime_0: (+1)
   \   0000006A   0x4342             MULS     R2,R2,R0
   \   0000006C   0xF44F 0x737A      MOV      R3,#+1000
   \   00000070   0xFBB2 0xF5F3      UDIV     R5,R2,R3
   \                     ??get_totalPrintTime_1: (+1)
   \   00000074   0x6889             LDR      R1,[R1, #+8]
   \   00000076   0x4341             MULS     R1,R1,R0
   \   00000078   0x461A             MOV      R2,R3
   \   0000007A   0xFBB1 0xF6F2      UDIV     R6,R1,R2

  	totalMoveTime = remainLayer*(2*home_bump_mm_P[2]-head.thickness)/PRINT_FEEDRATE; 
  	              ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",1624  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \   0000007E   0x4601             MOV      R1,R0
   \   00000080   0xEE00 0x1A10      VMOV     S0,R1
   \   00000084   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   00000088   0x.... 0x....      LDR.W    R1,??DataTable201_6
   \   0000008C   0xEDD1 0x0A1A      VLDR     S1,[R1, #+104]
   \   00000090   0xEEB0 0x1A00      VMOV.F32 S2,#2.0
   \   00000094   0xEE60 0x0A81      VMUL.F32 S1,S1,S2
   \   00000098   0xED97 0x1A09      VLDR     S2,[R7, #+36]
   \   0000009C   0xEE70 0x0AC1      VSUB.F32 S1,S1,S2
   \   000000A0   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   000000A4   0x.... 0x....      LDR.W    R1,??DataTable201_7
   \   000000A8   0xEDD1 0x0A04      VLDR     S1,[R1, #+16]
   \   000000AC   0xED9F 0x....      VLDR.W   S2,??DataTable189  ;; 0x42f00000
   \   000000B0   0xEEC0 0x0A81      VDIV.F32 S1,S1,S2
   \   000000B4   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   000000B8   0xEEBC 0x0AC0      VCVT.U32.F32 S0,S0
   \   000000BC   0xEE10 0x7A10      VMOV     R7,S0

  	totalWastageTime = remainLayer*0.5;
  	                 ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",1625  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \   000000C0   0x.... 0x....      BL       __aeabi_ui2d
   \   000000C4   0x2200             MOVS     R2,#+0
   \   000000C6   0x.... 0x....      LDR.W    R3,??DataTable201_3  ;; 0x3fe00000
   \   000000CA   0x.... 0x....      BL       __aeabi_dmul
   \   000000CE   0x.... 0x....      BL       __aeabi_d2uiz
   \   000000D2   0x42B7             CMP      R7,R6
   \   000000D4   0xD200             BCS.N    ??get_totalPrintTime_2
   \   000000D6   0x4637             MOV      R7,R6
   \                     ??get_totalPrintTime_2: (+1)
   \   000000D8   0x1940             ADDS     R0,R0,R5
   \   000000DA   0x1838             ADDS     R0,R7,R0
   \   000000DC   0x1900             ADDS     R0,R0,R4
   \   000000DE   0xBDF2             POP      {R1,R4-R7,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \   __interwork __softfp uint32_t MKS_DLP::get_currentPrintTime()
   \                     _ZN7MKS_DLP20get_currentPrintTimeEv: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xF104 0x0524      ADD      R5,R4,#+36
   \   00000008   0xF894 0x01DE      LDRB     R0,[R4, #+478]
   \   0000000C   0x68E9             LDR      R1,[R5, #+12]
   \   0000000E   0x4348             MULS     R0,R1,R0
   \   00000010   0xF44F 0x717A      MOV      R1,#+1000
   \   00000014   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000018   0xF8B4 0x11DC      LDRH     R1,[R4, #+476]
   \   0000001C   0x686A             LDR      R2,[R5, #+4]
   \   0000001E   0x4351             MULS     R1,R2,R1
   \   00000020   0xF44F 0x727A      MOV      R2,#+1000
   \   00000024   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   00000028   0x180E             ADDS     R6,R1,R0
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       _ZN7MKS_DLP16get_currentLayerEv
   \   00000030   0x68A9             LDR      R1,[R5, #+8]
   \   00000032   0x4348             MULS     R0,R1,R0
   \   00000034   0xF44F 0x717A      MOV      R1,#+1000
   \   00000038   0xFBB0 0xF5F1      UDIV     R5,R0,R1

  	curMoveTime= get_currentLayer()*(2*home_bump_mm_P[2]-head.thickness)/PRINT_FEEDRATE; 
  	           ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",1638  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0x.... 0x....      BL       _ZN7MKS_DLP16get_currentLayerEv
   \   00000042   0xEE00 0x0A10      VMOV     S0,R0
   \   00000046   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable201_6
   \   0000004E   0xEDD0 0x0A1A      VLDR     S1,[R0, #+104]
   \   00000052   0xEEB0 0x1A00      VMOV.F32 S2,#2.0
   \   00000056   0xEE60 0x0A81      VMUL.F32 S1,S1,S2
   \   0000005A   0xED94 0x1A09      VLDR     S2,[R4, #+36]
   \   0000005E   0xEE70 0x0AC1      VSUB.F32 S1,S1,S2
   \   00000062   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable201_7
   \   0000006A   0xEDD0 0x0A04      VLDR     S1,[R0, #+16]
   \   0000006E   0xED9F 0x....      VLDR.W   S2,??DataTable189  ;; 0x42f00000
   \   00000072   0xEEC0 0x0A81      VDIV.F32 S1,S1,S2
   \   00000076   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   0000007A   0xEEBC 0x0AC0      VCVT.U32.F32 S0,S0
   \   0000007E   0xEE10 0x0A10      VMOV     R0,S0
   \   00000082   0x42A8             CMP      R0,R5
   \   00000084   0xD200             BCS.N    ??get_currentPrintTime_0
   \   00000086   0x4628             MOV      R0,R5
   \                     ??get_currentPrintTime_0: (+1)
   \   00000088   0x1980             ADDS     R0,R0,R6
   \   0000008A   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __vfp float MKS_DLP::get_Height()
   \                     _ZN7MKS_DLP10get_HeightEv: (+1)
   \   00000000   0xF890 0x11DE      LDRB     R1,[R0, #+478]
   \   00000004   0xF8B0 0x21DC      LDRH     R2,[R0, #+476]
   \   00000008   0x1851             ADDS     R1,R2,R1
   \   0000000A   0xEE00 0x1A10      VMOV     S0,R1
   \   0000000E   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000012   0xEDD0 0x0A09      VLDR     S1,[R0, #+36]
   \   00000016   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   0000001A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp char MKS_DLP::get_ttfStatus_OFF()
   \                     _ZN7MKS_DLP17get_ttfStatus_OFFEv: (+1)
   \   00000000   0xF990 0x11F4      LDRSB    R1,[R0, #+500]
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD004             BEQ.N    ??get_ttfStatus_OFF_0
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0xF880 0x11F4      STRB     R1,[R0, #+500]
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x4770             BX       LR
   \                     ??get_ttfStatus_OFF_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp char MKS_DLP::get_ttfStatus_ON()
   \                     _ZN7MKS_DLP16get_ttfStatus_ONEv: (+1)
   \   00000000   0xF990 0x11F3      LDRSB    R1,[R0, #+499]
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD004             BEQ.N    ??get_ttfStatus_ON_0
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0xF880 0x11F3      STRB     R1,[R0, #+499]
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x4770             BX       LR
   \                     ??get_ttfStatus_ON_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp uint8_t MKS_DLP::get_cpld_ver()
   \                     _ZN7MKS_DLP12get_cpld_verEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       _ZN7MKS_DLP14bank2disp_readEv
   \   00000006   0xF000 0x000F      AND      R0,R0,#0xF
   \   0000000A   0x210A             MOVS     R1,#+10
   \   0000000C   0xFB90 0xF1F1      SDIV     R1,R0,R1
   \   00000010   0xEB01 0x0281      ADD      R2,R1,R1, LSL #+2
   \   00000014   0xEBA0 0x0042      SUB      R0,R0,R2, LSL #+1
   \   00000018   0xB2C0             UXTB     R0,R0
   \   0000001A   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::buzzer_enable(uint8_t)
   \                     _ZN7MKS_DLP13buzzer_enableEh: (+1)
   \   00000000   0xB502             PUSH     {R1,LR}
   \   00000002   0xF880 0x12F0      STRB     R1,[R0, #+752]
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xA900             ADD      R1,SP,#+0
   \   0000000A   0xF240 0x603A      MOVW     R0,#+1594
   \   0000000E   0x.... 0x....      BL       AT24CXX_Write
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable201_2
   \   00000016   0xF890 0x0CB4      LDRB     R0,[R0, #+3252]
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable201
   \   0000001E   0xF881 0x0278      STRB     R0,[R1, #+632]
   \   00000022   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \   __interwork __softfp void MKS_DLP::buzzer_tone(uint16_t, uint16_t, uint8_t)
   \                     _ZN7MKS_DLP11buzzer_toneEtth: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0xF890 0x42F0      LDRB     R4,[R0, #+752]
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD00F             BEQ.N    ??buzzer_tone_0
   \   0000000A   0x2B06             CMP      R3,#+6
   \   0000000C   0xDB00             BLT.N    ??buzzer_tone_1
   \   0000000E   0x2305             MOVS     R3,#+5
   \                     ??buzzer_tone_1: (+1)
   \   00000010   0xB672             cpsid i
   \   00000012   0x2400             MOVS     R4,#+0
   \   00000014   0xE006             B.N      ??buzzer_tone_2
   \                     ??buzzer_tone_3: (+1)
   \   00000016   0xEB00 0x0584      ADD      R5,R0,R4, LSL #+2
   \   0000001A   0xF8A5 0x12DC      STRH     R1,[R5, #+732]
   \   0000001E   0xF8A5 0x22DE      STRH     R2,[R5, #+734]
   \   00000022   0x1C64             ADDS     R4,R4,#+1
   \                     ??buzzer_tone_2: (+1)
   \   00000024   0x429C             CMP      R4,R3
   \   00000026   0xDBF6             BLT.N    ??buzzer_tone_3
   \   00000028   0xB662             cpsie i
   \                     ??buzzer_tone_0: (+1)
   \   0000002A   0xBC30             POP      {R4,R5}
   \   0000002C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::buzzer_polling()
   \                     _ZN7MKS_DLP14buzzer_pollingEv: (+1)
   \   00000000   0xF890 0x12F0      LDRB     R1,[R0, #+752]
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD01B             BEQ.N    ??buzzer_polling_0
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0xE000             B.N      ??buzzer_polling_1
   \                     ??buzzer_polling_2: (+1)
   \   0000000C   0x1C49             ADDS     R1,R1,#+1
   \                     ??buzzer_polling_1: (+1)
   \   0000000E   0x2905             CMP      R1,#+5
   \   00000010   0xDA16             BGE.N    ??buzzer_polling_0
   \   00000012   0xEB00 0x0281      ADD      R2,R0,R1, LSL #+2
   \   00000016   0xF8B2 0x32DC      LDRH     R3,[R2, #+732]
   \   0000001A   0x2B00             CMP      R3,#+0
   \   0000001C   0xD009             BEQ.N    ??buzzer_polling_3
   \   0000001E   0x1E58             SUBS     R0,R3,#+1
   \   00000020   0xF8A2 0x02DC      STRH     R0,[R2, #+732]
   \   00000024   0xB280             UXTH     R0,R0
   \   00000026   0xF000 0x0001      AND      R0,R0,#0x1
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable204_4  ;; 0x424082b4
   \   0000002E   0x6008             STR      R0,[R1, #+0]
   \   00000030   0x4770             BX       LR
   \                     ??buzzer_polling_3: (+1)
   \   00000032   0xF502 0x7237      ADD      R2,R2,#+732
   \   00000036   0x8853             LDRH     R3,[R2, #+2]
   \   00000038   0x2B00             CMP      R3,#+0
   \   0000003A   0xD0E7             BEQ.N    ??buzzer_polling_2
   \   0000003C   0x1E58             SUBS     R0,R3,#+1
   \   0000003E   0x8050             STRH     R0,[R2, #+2]
   \                     ??buzzer_polling_0: (+1)
   \   00000040   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp uint8_t MKS_DLP::get_buzzer_status()
   \                     _ZN7MKS_DLP17get_buzzer_statusEv: (+1)
   \   00000000   0xF890 0x02F0      LDRB     R0,[R0, #+752]
   \   00000004   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::printingHasFinished()
   \                     _ZN7MKS_DLP19printingHasFinishedEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x461A             MOV      R2,R3
   \   0000000A   0x2102             MOVS     R1,#+2
   \   0000000C   0x.... 0x....      BL       _ZN7MKS_DLP16bank2disp_enableEhhh
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       _ZN7MKS_DLP7led_offEv
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable201_2
   \   0000001A   0x.... 0x....      BL       _ZN10CardReader19printingHasFinishedEv
   \   0000001E   0x20A6             MOVS     R0,#+166
   \   00000020   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000024   0x2201             MOVS     R2,#+1
   \   00000026   0xA900             ADD      R1,SP,#+0
   \   00000028   0xF44F 0x707A      MOV      R0,#+1000
   \   0000002C   0x.... 0x....      BL       epr_write_data
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       _ZN7MKS_DLP9moveMax_ZEv
   \   00000036   0x2201             MOVS     R2,#+1
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable204
   \   0000003C   0x8881             LDRH     R1,[R0, #+4]
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable204_1
   \   00000042   0x6880             LDR      R0,[R0, #+8]
   \   00000044   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable201_6
   \   0000004E   0x7288             STRB     R0,[R1, #+10]
   \   00000050   0x2305             MOVS     R3,#+5
   \   00000052   0xF44F 0x62FA      MOV      R2,#+2000
   \   00000056   0xF44F 0x717A      MOV      R1,#+1000
   \   0000005A   0x4620             MOV      R0,R4
   \   0000005C   0x.... 0x....      BL       _ZN7MKS_DLP11buzzer_toneEtth
   \   00000060   0x.... 0x....      BL       _Z10clr_ticketv
   \   00000064   0xBD13             POP      {R0,R1,R4,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::PrintStatePolling()
   \                     _ZN7MKS_DLP17PrintStatePollingEv: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable201_2
   \   00000004   0xF891 0x29B8      LDRB     R2,[R1, #+2488]
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD000             BEQ.N    ??PrintStatePolling_0
   \   0000000C   0x4770             BX       LR
   \                     ??PrintStatePolling_0: (+1)
   \   0000000E   0xB580             PUSH     {R7,LR}
   \   00000010   0xF890 0x21EA      LDRB     R2,[R0, #+490]
   \   00000014   0x2A00             CMP      R2,#+0
   \   00000016   0xD116             BNE.N    ??PrintStatePolling_1
   \   00000018   0xF891 0x1D10      LDRB     R1,[R1, #+3344]
   \   0000001C   0x29A8             CMP      R1,#+168
   \   0000001E   0xD001             BEQ.N    ??PrintStatePolling_2
   \   00000020   0x29AC             CMP      R1,#+172
   \   00000022   0xD110             BNE.N    ??PrintStatePolling_1
   \                     ??PrintStatePolling_2: (+1)
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0xF880 0x11EA      STRB     R1,[R0, #+490]
   \   0000002A   0x.... 0x....      BL       _ZN7Planner13blocks_queuedEv
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD105             BNE.N    ??PrintStatePolling_3
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable205
   \   00000036   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD003             BEQ.N    ??PrintStatePolling_1
   \                     ??PrintStatePolling_3: (+1)
   \   0000003E   0xE8BD 0x4001      POP      {R0,LR}
   \   00000042   0x.... 0x....      B.W      _Z17quickstop_stepperv
   \                     ??PrintStatePolling_1: (+1)
   \   00000046   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp bool MKS_DLP::pausePrint()
   \                     _ZN7MKS_DLP10pausePrintEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xF500 0x74EE      ADD      R4,R0,#+476
   \   00000006   0xF8B0 0x11DC      LDRH     R1,[R0, #+476]
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD004             BEQ.N    ??pausePrint_0
   \   0000000E   0x7B21             LDRB     R1,[R4, #+12]
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD001             BEQ.N    ??pausePrint_0
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x7361             STRB     R1,[R4, #+13]
   \                     ??pausePrint_0: (+1)
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x70E1             STRB     R1,[R4, #+3]
   \   0000001C   0x.... 0x....      BL       _ZN7MKS_DLP7led_offEv
   \   00000020   0x7B20             LDRB     R0,[R4, #+12]
   \   00000022   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \   __interwork __softfp void MKS_DLP::resumePrint()
   \                     _ZN7MKS_DLP11resumePrintEv: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xF104 0x0524      ADD      R5,R4,#+36
   \   00000008   0xF504 0x70EE      ADD      R0,R4,#+476
   \   0000000C   0x7B41             LDRB     R1,[R0, #+13]
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD013             BEQ.N    ??resumePrint_0
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x7341             STRB     R1,[R0, #+13]
   \   00000016   0x7881             LDRB     R1,[R0, #+2]
   \   00000018   0x460A             MOV      R2,R1
   \   0000001A   0x8A2B             LDRH     R3,[R5, #+16]
   \   0000001C   0x429A             CMP      R2,R3
   \   0000001E   0xD207             BCS.N    ??resumePrint_1
   \   00000020   0x1E49             SUBS     R1,R1,#+1
   \   00000022   0x7081             STRB     R1,[R0, #+2]
   \   00000024   0xB2C9             UXTB     R1,R1
   \   00000026   0x2902             CMP      R1,#+2
   \   00000028   0xDA07             BGE.N    ??resumePrint_0
   \   0000002A   0x2101             MOVS     R1,#+1
   \   0000002C   0x7081             STRB     R1,[R0, #+2]
   \   0000002E   0xE004             B.N      ??resumePrint_0
   \                     ??resumePrint_1: (+1)
   \   00000030   0xF8B4 0x01DC      LDRH     R0,[R4, #+476]
   \   00000034   0x1E40             SUBS     R0,R0,#+1
   \   00000036   0xF8A4 0x01DC      STRH     R0,[R4, #+476]
   \                     ??resumePrint_0: (+1)
   \   0000003A   0x20A6             MOVS     R0,#+166
   \   0000003C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000040   0xF240 0x4623      MOVW     R6,#+1059
   \   00000044   0x2201             MOVS     R2,#+1
   \   00000046   0xA900             ADD      R1,SP,#+0
   \   00000048   0x4630             MOV      R0,R6
   \   0000004A   0x.... 0x....      BL       epr_write_data
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x.... 0x....      BL       _ZN7MKS_DLP16get_currentLayerEv
   \   00000054   0x.... 0x....      LDR.W    R2,??DataTable201_6
   \   00000058   0xEE00 0x0A10      VMOV     S0,R0
   \   0000005C   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   00000060   0xEDD4 0x0A09      VLDR     S1,[R4, #+36]
   \   00000064   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000068   0xED82 0x0A0F      VSTR     S0,[R2, #+60]
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable201_7
   \   00000070   0xED90 0x0A04      VLDR     S0,[R0, #+16]
   \   00000074   0xEDDF 0x....      VLDR.W   S1,??DataTable194  ;; 0x42f00000
   \   00000078   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   0000007C   0xED8D 0x0A01      VSTR     S0,[SP, #+4]
   \   00000080   0xA901             ADD      R1,SP,#+4
   \   00000082   0xF102 0x003C      ADD      R0,R2,#+60
   \   00000086   0x.... 0x....      BL       _Z21do_blocking_move_to_zRKfS0_
   \   0000008A   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   \   0000008E   0x20A7             MOVS     R0,#+167
   \   00000090   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000094   0x2201             MOVS     R2,#+1
   \   00000096   0xA900             ADD      R1,SP,#+0
   \   00000098   0x4630             MOV      R0,R6
   \   0000009A   0x.... 0x....      BL       epr_write_data
   \   0000009E   0x.... 0x....      ADR.W    R0,`?<Constant "resume:">`
   \   000000A2   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   000000A6   0x.... 0x....      BL       _Z23report_current_positionv
   \   000000AA   0x68A8             LDR      R0,[R5, #+8]
   \   000000AC   0x1C40             ADDS     R0,R0,#+1
   \   000000AE   0xF8C4 0x02D8      STR      R0,[R4, #+728]
   \   000000B2   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::stopPrint()
   \                     _ZN7MKS_DLP9stopPrintEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable201_2
   \   00000008   0xF8D0 0x0DEC      LDR      R0,[R0, #+3564]
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xDB05             BLT.N    ??stopPrint_0
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       _ZN7MKS_DLP24ExposureDataTrans_circleEv
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       _ZN7MKS_DLP14CleanDataTransEv
   \                     ??stopPrint_0: (+1)
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       _ZN7MKS_DLP7led_offEv
   \   00000022   0xE8BD 0x4010      POP      {R4,LR}
   \   00000026   0x.... 0x....      B.W      _Z17quickstop_stepperv

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::write_Information_paused()
   \                     _ZN7MKS_DLP24write_Information_pausedEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0xF500 0x71EE      ADD      R1,R0,#+476
   \   00000008   0x7B4A             LDRB     R2,[R1, #+13]
   \   0000000A   0x2A00             CMP      R2,#+0
   \   0000000C   0xD013             BEQ.N    ??write_Information_paused_0
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0x734A             STRB     R2,[R1, #+13]
   \   00000012   0x788A             LDRB     R2,[R1, #+2]
   \   00000014   0x4613             MOV      R3,R2
   \   00000016   0x8E84             LDRH     R4,[R0, #+52]
   \   00000018   0x42A3             CMP      R3,R4
   \   0000001A   0xD207             BCS.N    ??write_Information_paused_1
   \   0000001C   0x1E52             SUBS     R2,R2,#+1
   \   0000001E   0x708A             STRB     R2,[R1, #+2]
   \   00000020   0xB2D2             UXTB     R2,R2
   \   00000022   0x2A02             CMP      R2,#+2
   \   00000024   0xDA07             BGE.N    ??write_Information_paused_0
   \   00000026   0x2201             MOVS     R2,#+1
   \   00000028   0x708A             STRB     R2,[R1, #+2]
   \   0000002A   0xE004             B.N      ??write_Information_paused_0
   \                     ??write_Information_paused_1: (+1)
   \   0000002C   0xF8B0 0x11DC      LDRH     R1,[R0, #+476]
   \   00000030   0x1E49             SUBS     R1,R1,#+1
   \   00000032   0xF8A0 0x11DC      STRH     R1,[R0, #+476]
   \                     ??write_Information_paused_0: (+1)
   \   00000036   0x.... 0x....      BL       _ZN7MKS_DLP16get_currentLayerEv
   \   0000003A   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   0000003E   0x.... 0x....      LDR.W    R4,??DataTable201_2
   \   00000042   0x2204             MOVS     R2,#+4
   \   00000044   0xF604 0x5114      ADDW     R1,R4,#+3348
   \   00000048   0xF240 0x401D      MOVW     R0,#+1053
   \   0000004C   0x.... 0x....      BL       epr_write_data
   \   00000050   0x2202             MOVS     R2,#+2
   \   00000052   0xA900             ADD      R1,SP,#+0
   \   00000054   0xF240 0x4021      MOVW     R0,#+1057
   \   00000058   0x.... 0x....      BL       epr_write_data
   \   0000005C   0x2204             MOVS     R2,#+4
   \   0000005E   0xF604 0x41F8      ADDW     R1,R4,#+3320
   \   00000062   0xF240 0x4015      MOVW     R0,#+1045
   \   00000066   0x.... 0x....      BL       epr_write_data
   \   0000006A   0x.... 0x....      LDR.W    R4,??DataTable201_5
   \   0000006E   0x2202             MOVS     R2,#+2
   \   00000070   0x1CA1             ADDS     R1,R4,#+2
   \   00000072   0xF240 0x4019      MOVW     R0,#+1049
   \   00000076   0x.... 0x....      BL       epr_write_data
   \   0000007A   0x2201             MOVS     R2,#+1
   \   0000007C   0x1D21             ADDS     R1,R4,#+4
   \   0000007E   0xF240 0x401B      MOVW     R0,#+1051
   \   00000082   0x.... 0x....      BL       epr_write_data
   \   00000086   0x2201             MOVS     R2,#+1
   \   00000088   0x1D61             ADDS     R1,R4,#+5
   \   0000008A   0xF240 0x401C      MOVW     R0,#+1052
   \   0000008E   0x.... 0x....      BL       epr_write_data
   \   00000092   0xBD13             POP      {R0,R1,R4,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::read_Information_paused()
   \                     _ZN7MKS_DLP23read_Information_pausedEv: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0

  	uint32_t time_sec;
  	         ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",1897  Warning[Pe177]: 
          variable "time_sec" was declared but never referenced
   \   00000006   0x.... 0x....      LDR.W    R5,??DataTable201_2
   \   0000000A   0x221E             MOVS     R2,#+30
   \   0000000C   0xF605 0x41CC      ADDW     R1,R5,#+3276
   \   00000010   0xF240 0x30E9      MOVW     R0,#+1001
   \   00000014   0x.... 0x....      BL       epr_read_data
   \   00000018   0x2204             MOVS     R2,#+4
   \   0000001A   0xF605 0x5114      ADDW     R1,R5,#+3348
   \   0000001E   0xF240 0x401D      MOVW     R0,#+1053
   \   00000022   0x.... 0x....      BL       epr_read_data
   \   00000026   0xF104 0x0628      ADD      R6,R4,#+40
   \   0000002A   0x2204             MOVS     R2,#+4
   \   0000002C   0x4631             MOV      R1,R6
   \   0000002E   0xF240 0x4007      MOVW     R0,#+1031
   \   00000032   0x.... 0x....      BL       epr_read_data
   \   00000036   0x2204             MOVS     R2,#+4
   \   00000038   0xF104 0x012C      ADD      R1,R4,#+44
   \   0000003C   0xF240 0x400B      MOVW     R0,#+1035
   \   00000040   0x.... 0x....      BL       epr_read_data
   \   00000044   0x2202             MOVS     R2,#+2
   \   00000046   0xF104 0x0134      ADD      R1,R4,#+52
   \   0000004A   0xF240 0x4013      MOVW     R0,#+1043
   \   0000004E   0x.... 0x....      BL       epr_read_data
   \   00000052   0x2204             MOVS     R2,#+4
   \   00000054   0xF104 0x0130      ADD      R1,R4,#+48
   \   00000058   0xF240 0x400F      MOVW     R0,#+1039
   \   0000005C   0x.... 0x....      BL       epr_read_data
   \   00000060   0x6AA0             LDR      R0,[R4, #+40]
   \   00000062   0x6130             STR      R0,[R6, #+16]
   \   00000064   0x68B0             LDR      R0,[R6, #+8]
   \   00000066   0x6170             STR      R0,[R6, #+20]
   \   00000068   0x2202             MOVS     R2,#+2
   \   0000006A   0xA900             ADD      R1,SP,#+0
   \   0000006C   0xF240 0x4021      MOVW     R0,#+1057
   \   00000070   0x.... 0x....      BL       epr_read_data
   \   00000074   0x89B0             LDRH     R0,[R6, #+12]
   \   00000076   0xF504 0x71EE      ADD      R1,R4,#+476
   \   0000007A   0xF8BD 0x2000      LDRH     R2,[SP, #+0]
   \   0000007E   0x4290             CMP      R0,R2
   \   00000080   0xD305             BCC.N    ??read_Information_paused_0
   \   00000082   0x4610             MOV      R0,R2
   \   00000084   0x7088             STRB     R0,[R1, #+2]
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0xF8A4 0x01DC      STRH     R0,[R4, #+476]
   \   0000008C   0xE006             B.N      ??read_Information_paused_1
   \                     ??read_Information_paused_0: (+1)
   \   0000008E   0x7088             STRB     R0,[R1, #+2]
   \   00000090   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000094   0x89B1             LDRH     R1,[R6, #+12]
   \   00000096   0x1A40             SUBS     R0,R0,R1
   \   00000098   0xF8A4 0x01DC      STRH     R0,[R4, #+476]
   \                     ??read_Information_paused_1: (+1)
   \   0000009C   0x2204             MOVS     R2,#+4
   \   0000009E   0xF605 0x41F8      ADDW     R1,R5,#+3320
   \   000000A2   0xF240 0x4015      MOVW     R0,#+1045
   \   000000A6   0x.... 0x....      BL       epr_read_data
   \   000000AA   0x.... 0x....      BL       mks_setPositionZ
   \   000000AE   0x.... 0x....      LDR.W    R4,??DataTable201_5
   \   000000B2   0x2202             MOVS     R2,#+2
   \   000000B4   0x1CA1             ADDS     R1,R4,#+2
   \   000000B6   0xF240 0x4019      MOVW     R0,#+1049
   \   000000BA   0x.... 0x....      BL       epr_read_data
   \   000000BE   0x2201             MOVS     R2,#+1
   \   000000C0   0x1D21             ADDS     R1,R4,#+4
   \   000000C2   0xF240 0x401B      MOVW     R0,#+1051
   \   000000C6   0x.... 0x....      BL       epr_read_data
   \   000000CA   0x2201             MOVS     R2,#+1
   \   000000CC   0x1D61             ADDS     R1,R4,#+5
   \   000000CE   0xF240 0x401C      MOVW     R0,#+1052
   \   000000D2   0x.... 0x....      BL       epr_read_data
   \   000000D6   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return

   \                                 In section .text, align 4, keep-with-next
   \   __interwork __softfp void MKS_DLP::contiuePrint_paused()
   \                     _ZN7MKS_DLP19contiuePrint_pausedEv: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0

  		char string[20];
  		     ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",1941  Warning[Pe177]: 
          variable "string" was declared but never referenced
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable201_2
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xF885 0x09B8      STRB     R0,[R5, #+2488]
   \   0000000E   0xF895 0x0CB7      LDRB     R0,[R5, #+3255]
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD10B             BNE.N    ??contiuePrint_paused_0
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       _ZN7MKS_DLP8getHead1Ev
   \   0000001C   0xF8D5 0x1D14      LDR      R1,[R5, #+3348]
   \   00000020   0x4628             MOV      R0,R5
   \   00000022   0x.... 0x....      BL       _ZN10CardReader8setIndexEl
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       _ZN7MKS_DLP15get_sdcard_bmpsEv
   \   0000002C   0xE024             B.N      ??contiuePrint_paused_1
   \                     ??contiuePrint_paused_0: (+1)
   \   0000002E   0xF8B4 0x11DC      LDRH     R1,[R4, #+476]
   \   00000032   0x2900             CMP      R1,#+0
   \   00000034   0xD020             BEQ.N    ??contiuePrint_paused_1
   \   00000036   0xF605 0x56D4      ADDW     R6,R5,#+3540
   \   0000003A   0x69B0             LDR      R0,[R6, #+24]
   \   0000003C   0x2802             CMP      R0,#+2
   \   0000003E   0xDB17             BLT.N    ??contiuePrint_paused_2
   \   00000040   0x.... 0x....      LDR.W    R7,??DataTable201_6
   \   00000044   0x7E78             LDRB     R0,[R7, #+25]
   \   00000046   0x1C40             ADDS     R0,R0,#+1
   \   00000048   0x7678             STRB     R0,[R7, #+25]
   \   0000004A   0x2700             MOVS     R7,#+0
   \                     ??contiuePrint_paused_3: (+1)
   \   0000004C   0xB2FF             UXTB     R7,R7
   \   0000004E   0x4638             MOV      R0,R7
   \   00000050   0x69B1             LDR      R1,[R6, #+24]
   \   00000052   0x4288             CMP      R0,R1
   \   00000054   0xDA10             BGE.N    ??contiuePrint_paused_1
   \   00000056   0x463A             MOV      R2,R7
   \   00000058   0xF8B4 0x11DC      LDRH     R1,[R4, #+476]
   \   0000005C   0xF8D5 0x3DD4      LDR      R3,[R5, #+3540]
   \   00000060   0x4358             MULS     R0,R3,R0
   \   00000062   0xFA10 0xF181      UXTAH    R1,R0,R1
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0x.... 0x....      BL       _ZN7MKS_DLP21decode_layer_from_rleEjh
   \   0000006C   0x1C7F             ADDS     R7,R7,#+1
   \   0000006E   0xE7ED             B.N      ??contiuePrint_paused_3
   \                     ??contiuePrint_paused_2: (+1)
   \   00000070   0x2200             MOVS     R2,#+0
   \   00000072   0x4620             MOV      R0,R4
   \   00000074   0x.... 0x....      BL       _ZN7MKS_DLP21decode_layer_from_rleEjh
   \                     ??contiuePrint_paused_1: (+1)
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xF884 0x01DF      STRB     R0,[R4, #+479]
   \   0000007E   0x6AE0             LDR      R0,[R4, #+44]
   \   00000080   0x1C40             ADDS     R0,R0,#+1
   \   00000082   0xF8C4 0x02D8      STR      R0,[R4, #+728]
   \   00000086   0x.... 0x....      LDR.W    R7,??DataTable201_6
   \   0000008A   0x4620             MOV      R0,R4
   \   0000008C   0x.... 0x....      BL       _ZN7MKS_DLP10get_HeightEv
   \   00000090   0xED87 0x0A0F      VSTR     S0,[R7, #+60]
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable201_7
   \   00000098   0xED90 0x0A04      VLDR     S0,[R0, #+16]
   \   0000009C   0xEDDF 0x....      VLDR.W   S1,??DataTable194  ;; 0x42f00000
   \   000000A0   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   000000A4   0xED8D 0x0A00      VSTR     S0,[SP, #+0]
   \   000000A8   0xA900             ADD      R1,SP,#+0
   \   000000AA   0xF107 0x003C      ADD      R0,R7,#+60
   \   000000AE   0x.... 0x....      BL       _Z21do_blocking_move_to_zRKfS0_
   \   000000B2   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   \   000000B6   0x.... 0x....      BL       _Z23report_current_positionv
   \   000000BA   0x20A7             MOVS     R0,#+167
   \   000000BC   0xF885 0x0D10      STRB     R0,[R5, #+3344]
   \   000000C0   0x.... 0x....      BL       _Z9gcode_M24v
   \   000000C4   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp bool MKS_DLP::Is_Paused_Finished()
   \                     _ZN7MKS_DLP18Is_Paused_FinishedEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0xA900             ADD      R1,SP,#+0
   \   00000006   0xF240 0x4023      MOVW     R0,#+1059
   \   0000000A   0x.... 0x....      BL       epr_read_data
   \   0000000E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000012   0x28A6             CMP      R0,#+166
   \   00000014   0xD101             BNE.N    ??Is_Paused_Finished_0
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xBD02             POP      {R1,PC}
   \                     ??Is_Paused_Finished_0: (+1)
   \   0000001A   0x28A7             CMP      R0,#+167
   \   0000001C   0xD101             BNE.N    ??Is_Paused_Finished_1
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xBD02             POP      {R1,PC}
   \                     ??Is_Paused_Finished_1: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::clean_Information_layer()
   \                     _ZN7MKS_DLP23clean_Information_layerEv: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x9001             STR      R0,[SP, #+4]
   \   00000008   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]

  	uint32_t cseconds = 0;
  	         ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",2003  Warning[Pe177]: 
          variable "cseconds" was declared but never referenced
   \   00000010   0x4605             MOV      R5,R0
   \   00000012   0xE025             B.N      ??clean_Information_layer_0
   \                     ??clean_Information_layer_1: (+1)
   \   00000014   0x2014             MOVS     R0,#+20
   \   00000016   0xFB95 0xF0F0      SDIV     R0,R5,R0
   \   0000001A   0xEB00 0x0180      ADD      R1,R0,R0, LSL #+2
   \   0000001E   0xEBA5 0x0081      SUB      R0,R5,R1, LSL #+2
   \   00000022   0x210B             MOVS     R1,#+11
   \   00000024   0xFB10 0xF001      SMULBB   R0,R0,R1
   \   00000028   0xF200 0x462B      ADDW     R6,R0,#+1067
   \   0000002C   0xB2B6             UXTH     R6,R6
   \   0000002E   0x2204             MOVS     R2,#+4
   \   00000030   0xA901             ADD      R1,SP,#+4
   \   00000032   0x4630             MOV      R0,R6
   \   00000034   0x.... 0x....      BL       epr_write_data
   \   00000038   0x2202             MOVS     R2,#+2
   \   0000003A   0xF10D 0x0102      ADD      R1,SP,#+2
   \   0000003E   0x1D30             ADDS     R0,R6,#+4
   \   00000040   0xB280             UXTH     R0,R0
   \   00000042   0x.... 0x....      BL       epr_write_data
   \   00000046   0x2201             MOVS     R2,#+1
   \   00000048   0xA900             ADD      R1,SP,#+0
   \   0000004A   0x1DB0             ADDS     R0,R6,#+6
   \   0000004C   0xB280             UXTH     R0,R0
   \   0000004E   0x.... 0x....      BL       epr_write_data
   \   00000052   0x2204             MOVS     R2,#+4
   \   00000054   0xA900             ADD      R1,SP,#+0
   \   00000056   0x1DF0             ADDS     R0,R6,#+7
   \   00000058   0xB280             UXTH     R0,R0
   \   0000005A   0x.... 0x....      BL       epr_write_data
   \   0000005E   0x1C6D             ADDS     R5,R5,#+1
   \                     ??clean_Information_layer_0: (+1)
   \   00000060   0x2D14             CMP      R5,#+20
   \   00000062   0xDBD7             BLT.N    ??clean_Information_layer_1
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xE010             B.N      ??clean_Information_layer_2
   \                     ??clean_Information_layer_3: (+1)
   \   00000068   0xEB04 0x0180      ADD      R1,R4,R0, LSL #+2
   \   0000006C   0x2200             MOVS     R2,#+0
   \   0000006E   0xF8C1 0x21F8      STR      R2,[R1, #+504]
   \   00000072   0xEB04 0x0340      ADD      R3,R4,R0, LSL #+1
   \   00000076   0xF8A3 0x2248      STRH     R2,[R3, #+584]
   \   0000007A   0x22A6             MOVS     R2,#+166
   \   0000007C   0x1903             ADDS     R3,R0,R4
   \   0000007E   0xF883 0x2270      STRB     R2,[R3, #+624]
   \   00000082   0x2200             MOVS     R2,#+0
   \   00000084   0xF8C1 0x2284      STR      R2,[R1, #+644]
   \   00000088   0x1C40             ADDS     R0,R0,#+1
   \                     ??clean_Information_layer_2: (+1)
   \   0000008A   0x2814             CMP      R0,#+20
   \   0000008C   0xDBEC             BLT.N    ??clean_Information_layer_3
   \   0000008E   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::write_Information_layer(DLP_MOVE_STATUS)
   \                     _ZN7MKS_DLP23write_Information_layerE15DLP_MOVE_STATUS: (+1)
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x.... 0x....      BL       _ZN7MKS_DLP16get_currentLayerEv
   \   0000000A   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   0000000E   0x2514             MOVS     R5,#+20
   \   00000010   0x4629             MOV      R1,R5
   \   00000012   0xFB90 0xF1F1      SDIV     R1,R0,R1
   \   00000016   0xFB05 0x0011      MLS      R0,R5,R1,R0
   \   0000001A   0x210B             MOVS     R1,#+11
   \   0000001C   0x4348             MULS     R0,R1,R0
   \   0000001E   0xF200 0x402B      ADDW     R0,R0,#+1067
   \   00000022   0xF8A4 0x02D4      STRH     R0,[R4, #+724]
   \   00000026   0x.... 0x....      LDR.W    R6,??DataTable201_2
   \   0000002A   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   0000002E   0x28A7             CMP      R0,#+167
   \   00000030   0xD11E             BNE.N    ??write_Information_layer_0
   \   00000032   0x2204             MOVS     R2,#+4
   \   00000034   0xF606 0x5114      ADDW     R1,R6,#+3348
   \   00000038   0xF8B4 0x02D4      LDRH     R0,[R4, #+724]
   \   0000003C   0x.... 0x....      BL       epr_write_data
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable201_5
   \   00000044   0x8841             LDRH     R1,[R0, #+2]
   \   00000046   0xF44F 0x6261      MOV      R2,#+3600
   \   0000004A   0x7903             LDRB     R3,[R0, #+4]
   \   0000004C   0xEBC3 0x1703      RSB      R7,R3,R3, LSL #+4
   \   00000050   0x00BB             LSLS     R3,R7,#+2
   \   00000052   0xFB02 0x3101      MLA      R1,R2,R1,R3
   \   00000056   0xF990 0x0005      LDRSB    R0,[R0, #+5]
   \   0000005A   0xFA41 0xF080      SXTAB    R0,R1,R0
   \   0000005E   0x9001             STR      R0,[SP, #+4]
   \   00000060   0x2204             MOVS     R2,#+4
   \   00000062   0xA901             ADD      R1,SP,#+4
   \   00000064   0xF8B4 0x02D4      LDRH     R0,[R4, #+724]
   \   00000068   0x1DC0             ADDS     R0,R0,#+7
   \   0000006A   0xB280             UXTH     R0,R0
   \   0000006C   0x.... 0x....      BL       epr_write_data
   \                     ??write_Information_layer_0: (+1)
   \   00000070   0x2202             MOVS     R2,#+2
   \   00000072   0xA900             ADD      R1,SP,#+0
   \   00000074   0xF8B4 0x02D4      LDRH     R0,[R4, #+724]
   \   00000078   0x1D00             ADDS     R0,R0,#+4
   \   0000007A   0xB280             UXTH     R0,R0
   \   0000007C   0x.... 0x....      BL       epr_write_data
   \   00000080   0x2201             MOVS     R2,#+1
   \   00000082   0xA902             ADD      R1,SP,#+8
   \   00000084   0xF8B4 0x02D4      LDRH     R0,[R4, #+724]
   \   00000088   0x1D80             ADDS     R0,R0,#+6
   \   0000008A   0xB280             UXTH     R0,R0
   \   0000008C   0x.... 0x....      BL       epr_write_data
   \   00000090   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000094   0x4629             MOV      R1,R5
   \   00000096   0xFB90 0xF1F1      SDIV     R1,R0,R1
   \   0000009A   0xFB05 0x0011      MLS      R0,R5,R1,R0
   \   0000009E   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   000000A2   0xF8D6 0x1D14      LDR      R1,[R6, #+3348]
   \   000000A6   0xF8C0 0x11F8      STR      R1,[R0, #+504]
   \   000000AA   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   000000AE   0x4629             MOV      R1,R5
   \   000000B0   0xFB90 0xF1F1      SDIV     R1,R0,R1
   \   000000B4   0xFB05 0x0011      MLS      R0,R5,R1,R0
   \   000000B8   0xEB04 0x0040      ADD      R0,R4,R0, LSL #+1
   \   000000BC   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   000000C0   0xF8A0 0x1248      STRH     R1,[R0, #+584]
   \   000000C4   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   000000C8   0x4629             MOV      R1,R5
   \   000000CA   0xFB90 0xF1F1      SDIV     R1,R0,R1
   \   000000CE   0xFB05 0x0011      MLS      R0,R5,R1,R0
   \   000000D2   0x1900             ADDS     R0,R0,R4
   \   000000D4   0xF89D 0x1008      LDRB     R1,[SP, #+8]
   \   000000D8   0xF880 0x1270      STRB     R1,[R0, #+624]
   \   000000DC   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   000000E0   0x4629             MOV      R1,R5
   \   000000E2   0xFB90 0xF1F1      SDIV     R1,R0,R1
   \   000000E6   0xFB05 0x0011      MLS      R0,R5,R1,R0
   \   000000EA   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   000000EE   0x9901             LDR      R1,[SP, #+4]
   \   000000F0   0xF8C0 0x1284      STR      R1,[R0, #+644]
   \   000000F4   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp uint16_t MKS_DLP::Can_Resume_Print()
   \                     _ZN7MKS_DLP16Can_Resume_PrintEv: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x2400             MOVS     R4,#+0

  	DLP_MOVE_STATUS max_status;
  	                ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",2050  Warning[Pe177]: 
          variable "max_status" was declared but never referenced
   \   00000008   0x4627             MOV      R7,R4
   \   0000000A   0xE034             B.N      ??Can_Resume_Print_0
   \                     ??Can_Resume_Print_1: (+1)
   \   0000000C   0x2014             MOVS     R0,#+20
   \   0000000E   0xFB97 0xF0F0      SDIV     R0,R7,R0
   \   00000012   0xEB00 0x0180      ADD      R1,R0,R0, LSL #+2
   \   00000016   0xEBA7 0x0081      SUB      R0,R7,R1, LSL #+2
   \   0000001A   0x210B             MOVS     R1,#+11
   \   0000001C   0xFB10 0xF001      SMULBB   R0,R0,R1
   \   00000020   0xF200 0x482B      ADDW     R8,R0,#+1067
   \   00000024   0xFA1F 0xF888      UXTH     R8,R8
   \   00000028   0xEB05 0x0987      ADD      R9,R5,R7, LSL #+2
   \   0000002C   0x2204             MOVS     R2,#+4
   \   0000002E   0xF509 0x71FC      ADD      R1,R9,#+504
   \   00000032   0x4640             MOV      R0,R8
   \   00000034   0x.... 0x....      BL       epr_read_data
   \   00000038   0xEB05 0x0A47      ADD      R10,R5,R7, LSL #+1
   \   0000003C   0x2202             MOVS     R2,#+2
   \   0000003E   0xF50A 0x7112      ADD      R1,R10,#+584
   \   00000042   0xF108 0x0004      ADD      R0,R8,#+4
   \   00000046   0x.... 0x....      BL       epr_read_data
   \   0000004A   0x2201             MOVS     R2,#+1
   \   0000004C   0x1978             ADDS     R0,R7,R5
   \   0000004E   0xF500 0x711C      ADD      R1,R0,#+624
   \   00000052   0xF108 0x0006      ADD      R0,R8,#+6
   \   00000056   0x.... 0x....      BL       epr_read_data
   \   0000005A   0x2204             MOVS     R2,#+4
   \   0000005C   0xF509 0x7121      ADD      R1,R9,#+644
   \   00000060   0xF108 0x0007      ADD      R0,R8,#+7
   \   00000064   0x.... 0x....      BL       epr_read_data
   \   00000068   0xF8BA 0x0248      LDRH     R0,[R10, #+584]
   \   0000006C   0x4284             CMP      R4,R0
   \   0000006E   0xD201             BCS.N    ??Can_Resume_Print_2
   \   00000070   0x4604             MOV      R4,R0
   \   00000072   0x463E             MOV      R6,R7
   \                     ??Can_Resume_Print_2: (+1)
   \   00000074   0x1C7F             ADDS     R7,R7,#+1
   \                     ??Can_Resume_Print_0: (+1)
   \   00000076   0x2F14             CMP      R7,#+20
   \   00000078   0xDBC8             BLT.N    ??Can_Resume_Print_1
   \   0000007A   0xB2F6             UXTB     R6,R6
   \   0000007C   0x1970             ADDS     R0,R6,R5
   \   0000007E   0xF890 0x0270      LDRB     R0,[R0, #+624]
   \   00000082   0x28A7             CMP      R0,#+167
   \   00000084   0xD12B             BNE.N    ??Can_Resume_Print_3
   \   00000086   0xEB05 0x0086      ADD      R0,R5,R6, LSL #+2
   \   0000008A   0xF8D0 0x11F8      LDR      R1,[R0, #+504]
   \   0000008E   0x....             LDR.N    R2,??DataTable201_2
   \   00000090   0xF8C2 0x1D14      STR      R1,[R2, #+3348]
   \   00000094   0x....             LDR.N    R1,??DataTable201_5
   \   00000096   0xF8D0 0x2284      LDR      R2,[R0, #+644]
   \   0000009A   0xF44F 0x6361      MOV      R3,#+3600
   \   0000009E   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   000000A2   0x804A             STRH     R2,[R1, #+2]
   \   000000A4   0xF8D0 0x2284      LDR      R2,[R0, #+644]
   \   000000A8   0x461D             MOV      R5,R3
   \   000000AA   0xFBB2 0xF5F5      UDIV     R5,R2,R5
   \   000000AE   0xFB03 0x2215      MLS      R2,R3,R5,R2
   \   000000B2   0x253C             MOVS     R5,#+60
   \   000000B4   0xFBB2 0xF2F5      UDIV     R2,R2,R5
   \   000000B8   0x710A             STRB     R2,[R1, #+4]
   \   000000BA   0xF8D0 0x0284      LDR      R0,[R0, #+644]
   \   000000BE   0x461A             MOV      R2,R3
   \   000000C0   0xFBB0 0xF2F2      UDIV     R2,R0,R2
   \   000000C4   0xFB03 0x0012      MLS      R0,R3,R2,R0
   \   000000C8   0x462A             MOV      R2,R5
   \   000000CA   0xFBB0 0xF2F2      UDIV     R2,R0,R2
   \   000000CE   0xEBC2 0x1302      RSB      R3,R2,R2, LSL #+4
   \   000000D2   0xEBA0 0x0083      SUB      R0,R0,R3, LSL #+2
   \   000000D6   0x7148             STRB     R0,[R1, #+5]
   \   000000D8   0x1C60             ADDS     R0,R4,#+1
   \   000000DA   0xB280             UXTH     R0,R0
   \   000000DC   0xE000             B.N      ??Can_Resume_Print_4
   \                     ??Can_Resume_Print_3: (+1)
   \   000000DE   0x2000             MOVS     R0,#+0
   \                     ??Can_Resume_Print_4: (+1)
   \   000000E0   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp bool MKS_DLP::read_Information_layer()
   \                     _ZN7MKS_DLP22read_Information_layerEv: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0

  		uint32_t time_sec;
  		         ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",2086  Warning[Pe177]: 
          variable "time_sec" was declared but never referenced
   \   00000004   0x.... 0x....      BL       _ZN7MKS_DLP16Can_Resume_PrintEv
   \   00000008   0x0005             MOVS     R5,R0
   \   0000000A   0xD101             BNE.N    ??read_Information_layer_0
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBD70             POP      {R4-R6,PC}
   \                     ??read_Information_layer_0: (+1)
   \   00000010   0x221E             MOVS     R2,#+30
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable210
   \   00000016   0xF240 0x30E9      MOVW     R0,#+1001
   \   0000001A   0x.... 0x....      BL       epr_read_data
   \   0000001E   0xF104 0x0628      ADD      R6,R4,#+40
   \   00000022   0x2204             MOVS     R2,#+4
   \   00000024   0x4631             MOV      R1,R6
   \   00000026   0xF240 0x4007      MOVW     R0,#+1031
   \   0000002A   0x.... 0x....      BL       epr_read_data
   \   0000002E   0x2204             MOVS     R2,#+4
   \   00000030   0xF104 0x012C      ADD      R1,R4,#+44
   \   00000034   0xF240 0x400B      MOVW     R0,#+1035
   \   00000038   0x.... 0x....      BL       epr_read_data
   \   0000003C   0x2202             MOVS     R2,#+2
   \   0000003E   0xF104 0x0134      ADD      R1,R4,#+52
   \   00000042   0xF240 0x4013      MOVW     R0,#+1043
   \   00000046   0x.... 0x....      BL       epr_read_data
   \   0000004A   0x2204             MOVS     R2,#+4
   \   0000004C   0xF104 0x0130      ADD      R1,R4,#+48
   \   00000050   0xF240 0x400F      MOVW     R0,#+1039
   \   00000054   0x.... 0x....      BL       epr_read_data
   \   00000058   0x6AA0             LDR      R0,[R4, #+40]
   \   0000005A   0x6130             STR      R0,[R6, #+16]
   \   0000005C   0x68B0             LDR      R0,[R6, #+8]
   \   0000005E   0x6170             STR      R0,[R6, #+20]
   \   00000060   0x89B0             LDRH     R0,[R6, #+12]
   \   00000062   0xF504 0x71EE      ADD      R1,R4,#+476
   \   00000066   0x42A8             CMP      R0,R5
   \   00000068   0xDB04             BLT.N    ??read_Information_layer_1
   \   0000006A   0x708D             STRB     R5,[R1, #+2]
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xF8A4 0x01DC      STRH     R0,[R4, #+476]
   \   00000072   0xE00A             B.N      ??read_Information_layer_2
   \                     ??read_Information_layer_1: (+1)
   \   00000074   0x7088             STRB     R0,[R1, #+2]
   \   00000076   0x89B0             LDRH     R0,[R6, #+12]
   \   00000078   0x1A28             SUBS     R0,R5,R0
   \   0000007A   0xF8A4 0x01DC      STRH     R0,[R4, #+476]
   \   0000007E   0xB280             UXTH     R0,R0
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD002             BEQ.N    ??read_Information_layer_2
   \   00000084   0x1E40             SUBS     R0,R0,#+1
   \   00000086   0xF8A4 0x01DC      STRH     R0,[R4, #+476]
   \                     ??read_Information_layer_2: (+1)
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \   __interwork __softfp void MKS_DLP::contiuePrint_Pwdwn()
   \                     _ZN7MKS_DLP18contiuePrint_PwdwnEv: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x4605             MOV      R5,R0

  	char string[20];
  	     ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",2130  Warning[Pe177]: 
          variable "string" was declared but never referenced
   \   00000006   0x....             LDR.N    R4,??DataTable201_2
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xF884 0x09B8      STRB     R0,[R4, #+2488]
   \   0000000E   0xF894 0x0CB7      LDRB     R0,[R4, #+3255]
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD10C             BNE.N    ??contiuePrint_Pwdwn_0
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0x.... 0x....      BL       _ZN7MKS_DLP8getHead1Ev
   \   0000001C   0xF604 0x40F8      ADDW     R0,R4,#+3320
   \   00000020   0x69C1             LDR      R1,[R0, #+28]
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       _ZN10CardReader8setIndexEl
   \   00000028   0x4628             MOV      R0,R5
   \   0000002A   0x.... 0x....      BL       _ZN7MKS_DLP15get_sdcard_bmpsEv
   \   0000002E   0xE023             B.N      ??contiuePrint_Pwdwn_1
   \                     ??contiuePrint_Pwdwn_0: (+1)
   \   00000030   0xF8B5 0x11DC      LDRH     R1,[R5, #+476]
   \   00000034   0x2900             CMP      R1,#+0
   \   00000036   0xD01F             BEQ.N    ??contiuePrint_Pwdwn_1
   \   00000038   0xF604 0x56D4      ADDW     R6,R4,#+3540
   \   0000003C   0x69B0             LDR      R0,[R6, #+24]
   \   0000003E   0x2802             CMP      R0,#+2
   \   00000040   0xDB16             BLT.N    ??contiuePrint_Pwdwn_2
   \   00000042   0x....             LDR.N    R7,??DataTable201_6
   \   00000044   0x7E78             LDRB     R0,[R7, #+25]
   \   00000046   0x1C40             ADDS     R0,R0,#+1
   \   00000048   0x7678             STRB     R0,[R7, #+25]
   \   0000004A   0x2700             MOVS     R7,#+0
   \                     ??contiuePrint_Pwdwn_3: (+1)
   \   0000004C   0xB2FF             UXTB     R7,R7
   \   0000004E   0x4638             MOV      R0,R7
   \   00000050   0x69B1             LDR      R1,[R6, #+24]
   \   00000052   0x4288             CMP      R0,R1
   \   00000054   0xDA10             BGE.N    ??contiuePrint_Pwdwn_1
   \   00000056   0x463A             MOV      R2,R7
   \   00000058   0xF8B5 0x11DC      LDRH     R1,[R5, #+476]
   \   0000005C   0xF8D4 0x3DD4      LDR      R3,[R4, #+3540]
   \   00000060   0x4358             MULS     R0,R3,R0
   \   00000062   0xFA10 0xF181      UXTAH    R1,R0,R1
   \   00000066   0x4628             MOV      R0,R5
   \   00000068   0x.... 0x....      BL       _ZN7MKS_DLP21decode_layer_from_rleEjh
   \   0000006C   0x1C7F             ADDS     R7,R7,#+1
   \   0000006E   0xE7ED             B.N      ??contiuePrint_Pwdwn_3
   \                     ??contiuePrint_Pwdwn_2: (+1)
   \   00000070   0x2200             MOVS     R2,#+0
   \   00000072   0x4628             MOV      R0,R5
   \   00000074   0x.... 0x....      BL       _ZN7MKS_DLP21decode_layer_from_rleEjh
   \                     ??contiuePrint_Pwdwn_1: (+1)
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xF885 0x01DF      STRB     R0,[R5, #+479]
   \   0000007E   0x6AE8             LDR      R0,[R5, #+44]
   \   00000080   0x1C40             ADDS     R0,R0,#+1
   \   00000082   0xF8C5 0x02D8      STR      R0,[R5, #+728]
   \   00000086   0x4628             MOV      R0,R5
   \   00000088   0x.... 0x....      BL       _ZN7MKS_DLP10get_HeightEv
   \   0000008C   0xF604 0x40F8      ADDW     R0,R4,#+3320
   \   00000090   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   00000094   0x.... 0x....      BL       mks_setPositionZ
   \   00000098   0x....             LDR.N    R7,??DataTable201_6
   \   0000009A   0xED97 0x0A0B      VLDR     S0,[R7, #+44]
   \   0000009E   0xEDD7 0x0A1A      VLDR     S1,[R7, #+104]
   \   000000A2   0xEE30 0x0A20      VADD.F32 S0,S0,S1
   \   000000A6   0xED87 0x0A0F      VSTR     S0,[R7, #+60]
   \   000000AA   0x....             LDR.N    R5,??DataTable201_7
   \   000000AC   0xED95 0x0A04      VLDR     S0,[R5, #+16]
   \   000000B0   0xEDDF 0x....      VLDR.W   S1,??DataTable201_4  ;; 0x42f00000
   \   000000B4   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   000000B8   0xED8D 0x0A01      VSTR     S0,[SP, #+4]
   \   000000BC   0xA901             ADD      R1,SP,#+4
   \   000000BE   0xF107 0x003C      ADD      R0,R7,#+60
   \   000000C2   0x.... 0x....      BL       _Z21do_blocking_move_to_zRKfS0_
   \   000000C6   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   \   000000CA   0x.... 0x....      BL       _Z23report_current_positionv
   \   000000CE   0xED97 0x0A0B      VLDR     S0,[R7, #+44]
   \   000000D2   0xEDD7 0x0A1A      VLDR     S1,[R7, #+104]
   \   000000D6   0xEE30 0x0A60      VSUB.F32 S0,S0,S1
   \   000000DA   0xED87 0x0A0F      VSTR     S0,[R7, #+60]
   \   000000DE   0xED95 0x0A04      VLDR     S0,[R5, #+16]
   \   000000E2   0xEDDF 0x....      VLDR.W   S1,??DataTable201_4  ;; 0x42f00000
   \   000000E6   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   000000EA   0xED8D 0x0A00      VSTR     S0,[SP, #+0]
   \   000000EE   0xA900             ADD      R1,SP,#+0
   \   000000F0   0xF107 0x003C      ADD      R0,R7,#+60
   \   000000F4   0x.... 0x....      BL       _Z21do_blocking_move_to_zRKfS0_
   \   000000F8   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   \   000000FC   0x.... 0x....      BL       _Z23report_current_positionv
   \   00000100   0x20A7             MOVS     R0,#+167
   \   00000102   0xF604 0x41F8      ADDW     R1,R4,#+3320
   \   00000106   0x7608             STRB     R0,[R1, #+24]
   \   00000108   0x.... 0x....      BL       _Z9gcode_M24v
   \   0000010C   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::quick_stop()
   \                     _ZN7MKS_DLP10quick_stopEv: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF880 0x12F1      STRB     R1,[R0, #+753]
   \   00000006   0x.... 0x....      B.W      _Z17quickstop_stepperv

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::TFT_display_test()
   \                     _ZN7MKS_DLP16TFT_display_testEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable210_1
   \   00000008   0xF44F 0x5200      MOV      R2,#+8192
   \   0000000C   0x2155             MOVS     R1,#+85
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       memset
   \   00000014   0x20B4             MOVS     R0,#+180
   \   00000016   0x9000             STR      R0,[SP, #+0]
   \   00000018   0xF44F 0x73A0      MOV      R3,#+320
   \   0000001C   0x2214             MOVS     R2,#+20
   \   0000001E   0x2150             MOVS     R1,#+80
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       layer_pic_display
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0x.... 0x....      BL       exposure_msg_display
   \                     ??TFT_display_test_0: (+1)
   \   0000002C   0x.... 0x....      BL       _Z4idlev
   \   00000030   0xE7FC             B.N      ??TFT_display_test_0

  	mksdlp.set_test_exposure_time(key_set_value);
  	^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",2201  Warning[Pe111]: 
          statement is unreachable

  	mksdlp.set_test_exposure_time(key_set_value);
  	                              ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",2201  Warning[Pa093]: 
          implicit conversion from floating point to integer

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::draw_return_printing_ui()
   \                     _ZN7MKS_DLP23draw_return_printing_uiEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       display_print_statue
   \   00000006   0x.... 0x....      BL       setProBarRate
   \   0000000A   0x.... 0x....      BL       GUI_Exec
   \   0000000E   0x....             LDR.N    R0,??DataTable201_2
   \   00000010   0xF890 0x0BAC      LDRB     R0,[R0, #+2988]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD009             BEQ.N    ??draw_return_printing_ui_0
   \   00000018   0x20B4             MOVS     R0,#+180
   \   0000001A   0x9000             STR      R0,[SP, #+0]
   \   0000001C   0xF44F 0x73A0      MOV      R3,#+320
   \   00000020   0x220F             MOVS     R2,#+15
   \   00000022   0x211E             MOVS     R1,#+30
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable210_1
   \   00000028   0x.... 0x....      BL       layer_pic_display
   \                     ??draw_return_printing_ui_0: (+1)
   \   0000002C   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::draw_printing()
   \                     _ZN7MKS_DLP13draw_printingEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable210_2
   \   00000006   0xF894 0x1CB7      LDRB     R1,[R4, #+3255]
   \   0000000A   0x2901             CMP      R1,#+1
   \   0000000C   0xD102             BNE.N    ??draw_printing_0
   \   0000000E   0x.... 0x....      BL       _ZN7MKS_DLP8getHead1Ev
   \   00000012   0xE001             B.N      ??draw_printing_1
   \                     ??draw_printing_0: (+1)
   \   00000014   0x.... 0x....      BL       _ZN7MKS_DLP22get_cbddlp_file_headerEv
   \                     ??draw_printing_1: (+1)
   \   00000018   0x.... 0x....      BL       draw_status_clear
   \   0000001C   0x.... 0x....      BL       display_print_statue
   \   00000020   0x.... 0x....      BL       setProBarRate
   \   00000024   0x.... 0x....      BL       GUI_Exec
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0xE8BD 0x4010      POP      {R4,LR}
   \   00000030   0x.... 0x....      B.W      _ZN10CardReader8setIndexEl

   \                                 In section .bss, align 4
   \                     card:
   \   00000000                      DS8 2500
   \   __absolute MKS_DLP mksdlp
   \                     mksdlp:
   \   000009C4                      DS8 756
   \   __absolute DATA_REPRINT_ITMES mksReprint
   \                     mksReprint:
   \   00000CB8                      DS8 216
   \   __absolute cbddlp_file_head_t cbddlp_file_header
   \                     cbddlp_file_header:
   \   00000D90                      DS8 112
   \                     print_job_timer:
   \   00000E00                      DS8 16
   \   __absolute uint8_t Line_Pixel[1536]
   \                     Line_Pixel:
   \   00000E10                      DS8 1536

   \                                 In section .bss, align 4
   \                     injected_commands_P:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     fanSpeeds:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     serial_count:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     wifi_read_count:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     previous_cmd_ms:
   \   00000000                      DS8 4
   \   00000004                      DS8 4
   \   00000008                      DS8 4

   \                                 In section .bss, align 4
   \                     cartes:
   \   00000000                      DS8 12

   \                                 In section .bss, align 4
   \                     _ZZ19get_serial_commandsvE18serial_line_buffer:
   \   00000000                      DS8 96

   \                                 In section .bss, align 1
   \                     _ZZ19get_serial_commandsvE19serial_comment_mode:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \                     _ZZ19get_serial_commandsvE14last_wait_time:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     _ZZ17get_wifi_commandsvE16wifi_line_buffer:
   \   00000000                      DS8 96

   \                                 In section .bss, align 1
   \                     _ZZ17get_wifi_commandsvE17wifi_comment_mode:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     wifi_init_state:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \   __absolute uint8_t continue_print_error_flg
   \                     continue_print_error_flg:
   \   00000000                      DS8 1
   \   __absolute MKS_PRINTER_STATE volatile ctemp
   \                     ctemp:
   \   00000001                      DS8 1

   \                                 In section .bss, align 4
   \   __absolute uint32_t t1
   \                     t1:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute uint32_t t2
   \                     t2:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute char t12[10]
   \                     t12:
   \   00000000                      DS8 12

   \                                 In section .bss, align 4
   \   __absolute uint8_t Line_Pixel_TFT[180]
   \                     Line_Pixel_TFT:
   \   00000000                      DS8 180

   \                                 In section .bss, align 4
   \   __absolute print_parameters print_para
   \                     print_para:
   \   00000000                      DS8 60

   \                                 In section .bss, align 4
   \   __absolute layer_definition layer_def
   \                     layer_def:
   \   00000000                      DS8 36

   \                                 In section .bss, align 4
   \   __absolute preview_pic_def preview_pic1
   \                     preview_pic1:
   \   00000000                      DS8 16
   \   __absolute preview_pic_def preview_pic2
   \                     preview_pic2:
   \   00000010                      DS8 16

   \                                 In section .text, align 4, keep-with-next
   \   __interwork __softfp void MKS_DLP::get_cbddlp_file_header()
   \                     _ZN7MKS_DLP22get_cbddlp_file_headerEv: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xED2D 0x8B04      VPUSH    {D8-D9}
   \   00000008   0xB084             SUB      SP,SP,#+16
   \   0000000A   0x4606             MOV      R6,R0
   \   0000000C   0x.... 0x....      LDR.W    R4,??DataTable210_2
   \   00000010   0x2204             MOVS     R2,#+4
   \   00000012   0xA901             ADD      R1,SP,#+4
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   0000001A   0x2204             MOVS     R2,#+4
   \   0000001C   0xA901             ADD      R1,SP,#+4
   \   0000001E   0xF504 0x6059      ADD      R0,R4,#+3472
   \   00000022   0x.... 0x....      BL       memcpy
   \   00000026   0x2204             MOVS     R2,#+4
   \   00000028   0xA900             ADD      R1,SP,#+0
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000030   0x9800             LDR      R0,[SP, #+0]
   \   00000032   0xF8C4 0x0D94      STR      R0,[R4, #+3476]
   \   00000036   0x2204             MOVS     R2,#+4
   \   00000038   0xA902             ADD      R1,SP,#+8
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000040   0xF604 0x5794      ADDW     R7,R4,#+3476
   \   00000044   0x9802             LDR      R0,[SP, #+8]
   \   00000046   0x6078             STR      R0,[R7, #+4]
   \   00000048   0x2204             MOVS     R2,#+4
   \   0000004A   0xA902             ADD      R1,SP,#+8
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000052   0x9802             LDR      R0,[SP, #+8]
   \   00000054   0x60B8             STR      R0,[R7, #+8]
   \   00000056   0x2204             MOVS     R2,#+4
   \   00000058   0xA902             ADD      R1,SP,#+8
   \   0000005A   0x4620             MOV      R0,R4
   \   0000005C   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000060   0x9802             LDR      R0,[SP, #+8]
   \   00000062   0x60F8             STR      R0,[R7, #+12]
   \   00000064   0x2204             MOVS     R2,#+4
   \   00000066   0xA901             ADD      R1,SP,#+4
   \   00000068   0x4620             MOV      R0,R4
   \   0000006A   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   0000006E   0x2204             MOVS     R2,#+4
   \   00000070   0xA901             ADD      R1,SP,#+4
   \   00000072   0xF604 0x50A4      ADDW     R0,R4,#+3492
   \   00000076   0x.... 0x....      BL       memcpy
   \   0000007A   0x2204             MOVS     R2,#+4
   \   0000007C   0xA901             ADD      R1,SP,#+4
   \   0000007E   0x4620             MOV      R0,R4
   \   00000080   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000084   0x2204             MOVS     R2,#+4
   \   00000086   0xA901             ADD      R1,SP,#+4
   \   00000088   0xF604 0x50A8      ADDW     R0,R4,#+3496
   \   0000008C   0x.... 0x....      BL       memcpy
   \   00000090   0x2204             MOVS     R2,#+4
   \   00000092   0xA901             ADD      R1,SP,#+4
   \   00000094   0x4620             MOV      R0,R4
   \   00000096   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   0000009A   0x2204             MOVS     R2,#+4
   \   0000009C   0xA901             ADD      R1,SP,#+4
   \   0000009E   0xF604 0x50AC      ADDW     R0,R4,#+3500
   \   000000A2   0x.... 0x....      BL       memcpy
   \   000000A6   0x2204             MOVS     R2,#+4
   \   000000A8   0xA902             ADD      R1,SP,#+8
   \   000000AA   0x4620             MOV      R0,R4
   \   000000AC   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   000000B0   0x9802             LDR      R0,[SP, #+8]
   \   000000B2   0x61F8             STR      R0,[R7, #+28]
   \   000000B4   0x2204             MOVS     R2,#+4
   \   000000B6   0xA902             ADD      R1,SP,#+8
   \   000000B8   0x4620             MOV      R0,R4
   \   000000BA   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   000000BE   0x9802             LDR      R0,[SP, #+8]
   \   000000C0   0x6238             STR      R0,[R7, #+32]
   \   000000C2   0x2204             MOVS     R2,#+4
   \   000000C4   0xA902             ADD      R1,SP,#+8
   \   000000C6   0x4620             MOV      R0,R4
   \   000000C8   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   000000CC   0x9802             LDR      R0,[SP, #+8]
   \   000000CE   0x6278             STR      R0,[R7, #+36]
   \   000000D0   0x2204             MOVS     R2,#+4
   \   000000D2   0xA902             ADD      R1,SP,#+8
   \   000000D4   0x4620             MOV      R0,R4
   \   000000D6   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   000000DA   0x9802             LDR      R0,[SP, #+8]
   \   000000DC   0x62B8             STR      R0,[R7, #+40]
   \   000000DE   0x2204             MOVS     R2,#+4
   \   000000E0   0xA900             ADD      R1,SP,#+0
   \   000000E2   0x4620             MOV      R0,R4
   \   000000E4   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   000000E8   0x9800             LDR      R0,[SP, #+0]
   \   000000EA   0x62F8             STR      R0,[R7, #+44]
   \   000000EC   0x2204             MOVS     R2,#+4
   \   000000EE   0xA900             ADD      R1,SP,#+0
   \   000000F0   0x4620             MOV      R0,R4
   \   000000F2   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   000000F6   0x9800             LDR      R0,[SP, #+0]
   \   000000F8   0x6338             STR      R0,[R7, #+48]
   \   000000FA   0x2204             MOVS     R2,#+4
   \   000000FC   0xA900             ADD      R1,SP,#+0
   \   000000FE   0x4620             MOV      R0,R4
   \   00000100   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000104   0x9800             LDR      R0,[SP, #+0]
   \   00000106   0x6378             STR      R0,[R7, #+52]
   \   00000108   0x2204             MOVS     R2,#+4
   \   0000010A   0xA900             ADD      R1,SP,#+0
   \   0000010C   0x4620             MOV      R0,R4
   \   0000010E   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000112   0x9800             LDR      R0,[SP, #+0]
   \   00000114   0x63B8             STR      R0,[R7, #+56]
   \   00000116   0x2204             MOVS     R2,#+4
   \   00000118   0xA900             ADD      R1,SP,#+0
   \   0000011A   0x4620             MOV      R0,R4
   \   0000011C   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000120   0x9800             LDR      R0,[SP, #+0]
   \   00000122   0x63F8             STR      R0,[R7, #+60]
   \   00000124   0x2204             MOVS     R2,#+4
   \   00000126   0xA900             ADD      R1,SP,#+0
   \   00000128   0x4620             MOV      R0,R4
   \   0000012A   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   0000012E   0x9800             LDR      R0,[SP, #+0]
   \   00000130   0x6438             STR      R0,[R7, #+64]
   \   00000132   0x2204             MOVS     R2,#+4
   \   00000134   0xA900             ADD      R1,SP,#+0
   \   00000136   0x4620             MOV      R0,R4
   \   00000138   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   0000013C   0x9800             LDR      R0,[SP, #+0]
   \   0000013E   0x6478             STR      R0,[R7, #+68]
   \   00000140   0xF8D4 0x0D94      LDR      R0,[R4, #+3476]
   \   00000144   0x2802             CMP      R0,#+2
   \   00000146   0xDB06             BLT.N    ??get_cbddlp_file_header_0
   \   00000148   0x2204             MOVS     R2,#+4
   \   0000014A   0xA900             ADD      R1,SP,#+0
   \   0000014C   0x4620             MOV      R0,R4
   \   0000014E   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000152   0x9800             LDR      R0,[SP, #+0]
   \   00000154   0x64B8             STR      R0,[R7, #+72]
   \                     ??get_cbddlp_file_header_0: (+1)
   \   00000156   0x2204             MOVS     R2,#+4
   \   00000158   0xA900             ADD      R1,SP,#+0
   \   0000015A   0x4620             MOV      R0,R4
   \   0000015C   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000160   0x9800             LDR      R0,[SP, #+0]
   \   00000162   0x64F8             STR      R0,[R7, #+76]
   \   00000164   0xF8D4 0x0D94      LDR      R0,[R4, #+3476]
   \   00000168   0x2802             CMP      R0,#+2
   \   0000016A   0xDB2D             BLT.N    ??get_cbddlp_file_header_1
   \   0000016C   0x2204             MOVS     R2,#+4
   \   0000016E   0xA900             ADD      R1,SP,#+0
   \   00000170   0x4620             MOV      R0,R4
   \   00000172   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000176   0x9800             LDR      R0,[SP, #+0]
   \   00000178   0x6538             STR      R0,[R7, #+80]
   \   0000017A   0x2204             MOVS     R2,#+4
   \   0000017C   0xA900             ADD      R1,SP,#+0
   \   0000017E   0x4620             MOV      R0,R4
   \   00000180   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000184   0x9800             LDR      R0,[SP, #+0]
   \   00000186   0x6578             STR      R0,[R7, #+84]
   \   00000188   0x2204             MOVS     R2,#+4
   \   0000018A   0xA900             ADD      R1,SP,#+0
   \   0000018C   0x4620             MOV      R0,R4
   \   0000018E   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000192   0x9800             LDR      R0,[SP, #+0]
   \   00000194   0x65B8             STR      R0,[R7, #+88]
   \   00000196   0x2202             MOVS     R2,#+2
   \   00000198   0xA901             ADD      R1,SP,#+4
   \   0000019A   0x4620             MOV      R0,R4
   \   0000019C   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   000001A0   0xAD01             ADD      R5,SP,#+4
   \   000001A2   0x7868             LDRB     R0,[R5, #+1]
   \   000001A4   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   000001A8   0xEA41 0x2000      ORR      R0,R1,R0, LSL #+8
   \   000001AC   0xF8A4 0x0DF0      STRH     R0,[R4, #+3568]
   \   000001B0   0x2202             MOVS     R2,#+2
   \   000001B2   0xA901             ADD      R1,SP,#+4
   \   000001B4   0x4620             MOV      R0,R4
   \   000001B6   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   000001BA   0x7868             LDRB     R0,[R5, #+1]
   \   000001BC   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   000001C0   0xEA41 0x2000      ORR      R0,R1,R0, LSL #+8
   \   000001C4   0xF8A4 0x0DF2      STRH     R0,[R4, #+3570]
   \                     ??get_cbddlp_file_header_1: (+1)
   \   000001C8   0x2204             MOVS     R2,#+4
   \   000001CA   0xA901             ADD      R1,SP,#+4
   \   000001CC   0x4620             MOV      R0,R4
   \   000001CE   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   000001D2   0x2204             MOVS     R2,#+4
   \   000001D4   0xA901             ADD      R1,SP,#+4
   \   000001D6   0xF604 0x50F4      ADDW     R0,R4,#+3572
   \   000001DA   0x.... 0x....      BL       memcpy
   \   000001DE   0x2204             MOVS     R2,#+4
   \   000001E0   0xA901             ADD      R1,SP,#+4
   \   000001E2   0x4620             MOV      R0,R4
   \   000001E4   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   000001E8   0x2204             MOVS     R2,#+4
   \   000001EA   0xA901             ADD      R1,SP,#+4
   \   000001EC   0xF604 0x50F8      ADDW     R0,R4,#+3576
   \   000001F0   0x.... 0x....      BL       memcpy
   \   000001F4   0x2204             MOVS     R2,#+4
   \   000001F6   0xA901             ADD      R1,SP,#+4
   \   000001F8   0x4620             MOV      R0,R4
   \   000001FA   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   000001FE   0x2204             MOVS     R2,#+4
   \   00000200   0xA901             ADD      R1,SP,#+4
   \   00000202   0xF604 0x50FC      ADDW     R0,R4,#+3580
   \   00000206   0x.... 0x....      BL       memcpy
   \   0000020A   0x6AF8             LDR      R0,[R7, #+44]
   \   0000020C   0x86B0             STRH     R0,[R6, #+52]
   \   0000020E   0x6C38             LDR      R0,[R7, #+64]
   \   00000210   0x81B0             STRH     R0,[R6, #+12]
   \   00000212   0x69F8             LDR      R0,[R7, #+28]
   \   00000214   0x6270             STR      R0,[R6, #+36]

  		head.LedOnTime=cbddlp_file_header.exposureTimeSeconds*1000;
  		              ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",2351  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \   00000216   0xED9F 0x....      VLDR.W   S0,??DataTable204_2  ;; 0x447a0000
   \   0000021A   0xEDD7 0x0A08      VLDR     S1,[R7, #+32]
   \   0000021E   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000222   0xEEFC 0x0AE0      VCVT.U32.F32 S1,S1
   \   00000226   0xEDC6 0x0A0A      VSTR     S1,[R6, #+40]

  		head.LedOffTime=cbddlp_file_header.offTimeSeconds*1000;
  		               ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",2352  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \   0000022A   0xEDD7 0x0A0A      VLDR     S1,[R7, #+40]
   \   0000022E   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000232   0xEEFC 0x0AE0      VCVT.U32.F32 S1,S1
   \   00000236   0xEDC6 0x0A0B      VSTR     S1,[R6, #+44]

  		head.BottomLedOnTime=cbddlp_file_header.exposureBottomTimeSeconds*1000;
  		                    ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",2353  Warning[Pa093]: 
          implicit conversion from floating point to integer

  		uint8_t rc;
  		        ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",2256  Warning[Pe550]: 
          variable "rc" was set but never used

  		long index=0;
  		     ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",2257  Warning[Pe177]: 
          variable "index" was declared but never referenced
   \   0000023A   0xEDD7 0x0A09      VLDR     S1,[R7, #+36]
   \   0000023E   0xEE20 0x0A80      VMUL.F32 S0,S1,S0
   \   00000242   0xEEBC 0x0AC0      VCVT.U32.F32 S0,S0
   \   00000246   0xED86 0x0A0C      VSTR     S0,[R6, #+48]
   \   0000024A   0x6DB8             LDR      R0,[R7, #+88]
   \   0000024C   0x2805             CMP      R0,#+5
   \   0000024E   0xDB01             BLT.N    ??get_cbddlp_file_header_2
   \   00000250   0x2004             MOVS     R0,#+4
   \   00000252   0x65B8             STR      R0,[R7, #+88]
   \                     ??get_cbddlp_file_header_2: (+1)
   \   00000254   0xF8D7 0x8058      LDR      R8,[R7, #+88]
   \   00000258   0xF1B8 0x0F02      CMP      R8,#+2
   \   0000025C   0xDB36             BLT.N    ??get_cbddlp_file_header_3
   \   0000025E   0xED9F 0x....      VLDR.W   D8,??DataTable204_3
   \   00000262   0xED9F 0x....      VLDR.W   D9,??DataTable204_5
   \   00000266   0x6A38             LDR      R0,[R7, #+32]
   \   00000268   0x.... 0x....      BL       __aeabi_f2d
   \   0000026C   0xEC53 0x2B19      VMOV     R2,R3,D9
   \   00000270   0x.... 0x....      BL       __aeabi_dmul
   \   00000274   0x4604             MOV      R4,R0
   \   00000276   0x460D             MOV      R5,R1
   \   00000278   0x4640             MOV      R0,R8
   \   0000027A   0x.... 0x....      BL       __aeabi_i2d
   \   0000027E   0x4602             MOV      R2,R0
   \   00000280   0x460B             MOV      R3,R1
   \   00000282   0x4620             MOV      R0,R4
   \   00000284   0x4629             MOV      R1,R5
   \   00000286   0x.... 0x....      BL       __aeabi_ddiv
   \   0000028A   0xEC53 0x2B18      VMOV     R2,R3,D8
   \   0000028E   0x.... 0x....      BL       __aeabi_dadd
   \   00000292   0x.... 0x....      BL       __aeabi_d2uiz
   \   00000296   0x63B0             STR      R0,[R6, #+56]
   \   00000298   0x6A78             LDR      R0,[R7, #+36]
   \   0000029A   0x.... 0x....      BL       __aeabi_f2d
   \   0000029E   0xEC53 0x2B19      VMOV     R2,R3,D9
   \   000002A2   0x.... 0x....      BL       __aeabi_dmul
   \   000002A6   0x4604             MOV      R4,R0
   \   000002A8   0x460D             MOV      R5,R1
   \   000002AA   0x6DB8             LDR      R0,[R7, #+88]
   \   000002AC   0x.... 0x....      BL       __aeabi_i2d
   \   000002B0   0x4602             MOV      R2,R0
   \   000002B2   0x460B             MOV      R3,R1
   \   000002B4   0x4620             MOV      R0,R4
   \   000002B6   0x4629             MOV      R1,R5
   \   000002B8   0x.... 0x....      BL       __aeabi_ddiv
   \   000002BC   0xEC53 0x2B18      VMOV     R2,R3,D8
   \   000002C0   0x.... 0x....      BL       __aeabi_dadd
   \   000002C4   0x.... 0x....      BL       __aeabi_d2uiz
   \   000002C8   0x63F0             STR      R0,[R6, #+60]
   \   000002CA   0xE003             B.N      ??get_cbddlp_file_header_4
   \                     ??get_cbddlp_file_header_3: (+1)
   \   000002CC   0x6AB0             LDR      R0,[R6, #+40]
   \   000002CE   0x63B0             STR      R0,[R6, #+56]
   \   000002D0   0x6B30             LDR      R0,[R6, #+48]
   \   000002D2   0x63F0             STR      R0,[R6, #+60]
   \                     ??get_cbddlp_file_header_4: (+1)
   \   000002D4   0xB004             ADD      SP,SP,#+16
   \   000002D6   0xECBD 0x8B04      VPOP     {D8-D9}
   \   000002DA   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::get_cbddlp_preview1_info()
   \                     _ZN7MKS_DLP24get_cbddlp_preview1_infoEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}

  	BYTE sd_char[4];
  	     ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",2373  Warning[Pe177]: 
          variable "sd_char" was declared but never referenced

  	uint8_t rc;
  	        ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",2374  Warning[Pe550]: 
          variable "rc" was set but never used
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable210_2
   \   00000006   0xF8D4 0x1DCC      LDR      R1,[R4, #+3532]
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       _ZN10CardReader8setIndexEl
   \   00000010   0x2204             MOVS     R2,#+4
   \   00000012   0xA900             ADD      R1,SP,#+0
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   0000001A   0x.... 0x....      LDR.W    R5,??DataTable210_3
   \   0000001E   0x9800             LDR      R0,[SP, #+0]
   \   00000020   0x6028             STR      R0,[R5, #+0]
   \   00000022   0x2204             MOVS     R2,#+4
   \   00000024   0xA900             ADD      R1,SP,#+0
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   0000002C   0x9800             LDR      R0,[SP, #+0]
   \   0000002E   0x6068             STR      R0,[R5, #+4]
   \   00000030   0x2204             MOVS     R2,#+4
   \   00000032   0xA900             ADD      R1,SP,#+0
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   0000003A   0x9800             LDR      R0,[SP, #+0]
   \   0000003C   0x60A8             STR      R0,[R5, #+8]
   \   0000003E   0x2204             MOVS     R2,#+4
   \   00000040   0xA900             ADD      R1,SP,#+0
   \   00000042   0x4620             MOV      R0,R4
   \   00000044   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000048   0x9800             LDR      R0,[SP, #+0]
   \   0000004A   0x60E8             STR      R0,[R5, #+12]
   \   0000004C   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::get_cbddlp_preview2_info()
   \                     _ZN7MKS_DLP24get_cbddlp_preview2_infoEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}

  	BYTE sd_char[4];
  	     ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",2402  Warning[Pe177]: 
          variable "sd_char" was declared but never referenced

  	uint8_t rc;
  	        ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",2403  Warning[Pe550]: 
          variable "rc" was set but never used
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable210_2
   \   00000006   0xF8D4 0x1DD8      LDR      R1,[R4, #+3544]
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       _ZN10CardReader8setIndexEl
   \   00000010   0x2204             MOVS     R2,#+4
   \   00000012   0xA900             ADD      R1,SP,#+0
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   0000001A   0x.... 0x....      LDR.W    R5,??DataTable210_3
   \   0000001E   0x9800             LDR      R0,[SP, #+0]
   \   00000020   0x6128             STR      R0,[R5, #+16]
   \   00000022   0x2204             MOVS     R2,#+4
   \   00000024   0xA900             ADD      R1,SP,#+0
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   0000002C   0x9800             LDR      R0,[SP, #+0]
   \   0000002E   0x6168             STR      R0,[R5, #+20]
   \   00000030   0x2204             MOVS     R2,#+4
   \   00000032   0xA900             ADD      R1,SP,#+0
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   0000003A   0x9800             LDR      R0,[SP, #+0]
   \   0000003C   0x61A8             STR      R0,[R5, #+24]
   \   0000003E   0x2204             MOVS     R2,#+4
   \   00000040   0xA900             ADD      R1,SP,#+0
   \   00000042   0x4620             MOV      R0,R4
   \   00000044   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000048   0x9800             LDR      R0,[SP, #+0]
   \   0000004A   0x61E8             STR      R0,[R5, #+28]
   \   0000004C   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \   __interwork __softfp void get_pic_display(uint8_t)
   \                     get_pic_display: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xF5AD 0x6D7C      SUB      SP,SP,#+4032

  	uint8_t rc;
  	        ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",2446  Warning[Pe550]: 
          variable "rc" was set but never used

  	hex_to_int temp_int;
  	           ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",2448  Warning[Pe177]: 
          variable "temp_int" was declared but never referenced
   \   00000008   0x2400             MOVS     R4,#+0
   \   0000000A   0x4625             MOV      R5,R4
   \   0000000C   0x4626             MOV      R6,R4
   \   0000000E   0x4627             MOV      R7,R4

  	int32_t resolutionX,resolutionY,ofs_image,imge_data_len;
  	                    ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",2456  Warning[Pe550]: 
          variable "resolutionY" was set but never used
   \   00000010   0x46A0             MOV      R8,R4
   \   00000012   0x.... 0x....      LDR.W    R10,??DataTable210_3
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD13D             BNE.N    ??get_pic_display_0
   \   0000001A   0xF44F 0x7991      MOV      R9,#+290
   \   0000001E   0xED9A 0x0A00      VLDR     S0,[R10, #0]
   \   00000022   0xEEF8 0x0AC0      VCVT.F32.S32 S1,S0
   \   00000026   0xED9F 0x....      VLDR.W   S2,??DataTable207  ;; 0x43910000
   \   0000002A   0xEEC0 0x0A81      VDIV.F32 S1,S1,S2
   \   0000002E   0xEDCD 0x0A03      VSTR     S1,[SP, #+12]
   \   00000032   0xEDDA 0x0A01      VLDR     S1,[R10, #+4]
   \   00000036   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   0000003A   0xEEC0 0x0A81      VDIV.F32 S1,S1,S2
   \   0000003E   0xEDCD 0x0A02      VSTR     S1,[SP, #+8]
   \   00000042   0xED8D 0x0A00      VSTR     S0,[SP, #+0]
   \   00000046   0xF8DA 0x1008      LDR      R1,[R10, #+8]
   \   0000004A   0xF8DA 0x000C      LDR      R0,[R10, #+12]
   \   0000004E   0x9005             STR      R0,[SP, #+20]
   \   00000050   0x9800             LDR      R0,[SP, #+0]
   \   00000052   0xF5B0 0x7FFA      CMP      R0,#+500
   \   00000056   0xDB16             BLT.N    ??get_pic_display_1
   \   00000058   0xED9A 0x0A04      VLDR     S0,[R10, #+16]
   \   0000005C   0xEEF8 0x0AC0      VCVT.F32.S32 S1,S0
   \   00000060   0xEEC0 0x0A81      VDIV.F32 S1,S1,S2
   \   00000064   0xEDCD 0x0A03      VSTR     S1,[SP, #+12]
   \   00000068   0xEDDA 0x0A05      VLDR     S1,[R10, #+20]
   \   0000006C   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   00000070   0xEEC0 0x0A81      VDIV.F32 S1,S1,S2
   \   00000074   0xEDCD 0x0A02      VSTR     S1,[SP, #+8]
   \   00000078   0xED8D 0x0A00      VSTR     S0,[SP, #+0]
   \   0000007C   0xF8DA 0x1018      LDR      R1,[R10, #+24]
   \   00000080   0xF8DA 0x001C      LDR      R0,[R10, #+28]
   \   00000084   0x9005             STR      R0,[SP, #+20]
   \                     ??get_pic_display_1: (+1)
   \   00000086   0x9800             LDR      R0,[SP, #+0]
   \   00000088   0xF5B0 0x7FFA      CMP      R0,#+500
   \   0000008C   0xDB2C             BLT.N    ??get_pic_display_2
   \   0000008E   0xF44F 0x70FA      MOV      R0,#+500
   \   00000092   0x9000             STR      R0,[SP, #+0]
   \   00000094   0xE028             B.N      ??get_pic_display_2
   \                     ??get_pic_display_0: (+1)
   \   00000096   0xF44F 0x4200      MOV      R2,#+32768
   \   0000009A   0x4621             MOV      R1,R4
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable210_4
   \   000000A0   0x.... 0x....      BL       memset
   \   000000A4   0xF04F 0x0974      MOV      R9,#+116
   \   000000A8   0xED9A 0x0A04      VLDR     S0,[R10, #+16]
   \   000000AC   0xEEF8 0x0AC0      VCVT.F32.S32 S1,S0
   \   000000B0   0xED9F 0x....      VLDR.W   S2,??DataTable207_1  ;; 0x42e80000
   \   000000B4   0xEEC0 0x0A81      VDIV.F32 S1,S1,S2
   \   000000B8   0xEDCD 0x0A03      VSTR     S1,[SP, #+12]
   \   000000BC   0xEDDA 0x0A05      VLDR     S1,[R10, #+20]
   \   000000C0   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   000000C4   0xEEC0 0x0A81      VDIV.F32 S1,S1,S2
   \   000000C8   0xEDCD 0x0A02      VSTR     S1,[SP, #+8]
   \   000000CC   0xED8D 0x0A00      VSTR     S0,[SP, #+0]
   \   000000D0   0xF8DA 0x1018      LDR      R1,[R10, #+24]
   \   000000D4   0xF8DA 0x001C      LDR      R0,[R10, #+28]
   \   000000D8   0x9005             STR      R0,[SP, #+20]
   \   000000DA   0x9800             LDR      R0,[SP, #+0]
   \   000000DC   0xF5B0 0x7FFA      CMP      R0,#+500
   \   000000E0   0xDB02             BLT.N    ??get_pic_display_2
   \   000000E2   0xF44F 0x70FA      MOV      R0,#+500
   \   000000E6   0x9000             STR      R0,[SP, #+0]
   \                     ??get_pic_display_2: (+1)
   \   000000E8   0x.... 0x....      LDR.W    R0,??DataTable210_2
   \   000000EC   0x.... 0x....      BL       _ZN10CardReader8setIndexEl
   \   000000F0   0x46A2             MOV      R10,R4
   \   000000F2   0xE002             B.N      ??get_pic_display_3
   \                     ??get_pic_display_4: (+1)
   \   000000F4   0x9804             LDR      R0,[SP, #+16]
   \   000000F6   0xF100 0x0A01      ADD      R10,R0,#+1
   \                     ??get_pic_display_3: (+1)
   \   000000FA   0x9805             LDR      R0,[SP, #+20]
   \   000000FC   0x4582             CMP      R10,R0
   \   000000FE   0xF280 0x80A9      BGE.W    ??get_pic_display_5
   \   00000102   0x2202             MOVS     R2,#+2
   \   00000104   0xA901             ADD      R1,SP,#+4
   \   00000106   0x.... 0x....      LDR.W    R0,??DataTable210_2
   \   0000010A   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   0000010E   0xF10A 0x0001      ADD      R0,R10,#+1
   \   00000112   0x9004             STR      R0,[SP, #+16]
   \   00000114   0xF10D 0x0B04      ADD      R11,SP,#+4
   \   00000118   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000011C   0xF89B 0x1001      LDRB     R1,[R11, #+1]
   \   00000120   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   00000124   0x9006             STR      R0,[SP, #+24]
   \   00000126   0xF04F 0x0A01      MOV      R10,#+1
   \   0000012A   0x0680             LSLS     R0,R0,#+26
   \   0000012C   0xD543             BPL.N    ??get_pic_display_6
   \   0000012E   0x2202             MOVS     R2,#+2
   \   00000130   0xA901             ADD      R1,SP,#+4
   \   00000132   0x.... 0x....      LDR.W    R0,??DataTable210_2
   \   00000136   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   0000013A   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000013E   0xF89B 0x1001      LDRB     R1,[R11, #+1]
   \   00000142   0xF001 0x010F      AND      R1,R1,#0xF
   \   00000146   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   0000014A   0xF100 0x0A01      ADD      R10,R0,#+1
   \   0000014E   0x9804             LDR      R0,[SP, #+16]
   \   00000150   0x1C80             ADDS     R0,R0,#+2
   \   00000152   0x9004             STR      R0,[SP, #+16]
   \   00000154   0xE02F             B.N      ??get_pic_display_6
   \                     ??get_pic_display_7: (+1)
   \   00000156   0xEE00 0x1A10      VMOV     S0,R1
   \   0000015A   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000015E   0xEDDD 0x0A03      VLDR     S1,[SP, #+12]
   \   00000162   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000166   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   0000016A   0xEE10 0x0A10      VMOV     R0,S0
   \   0000016E   0xF85B 0x0020      LDR      R0,[R11, R0, LSL #+2]
   \   00000172   0xAA07             ADD      R2,SP,#+28
   \   00000174   0xF842 0x0021      STR      R0,[R2, R1, LSL #+2]
   \   00000178   0x.... 0x....      LDR.W    R2,??DataTable210_4
   \   0000017C   0xF808 0x0002      STRB     R0,[R8, R2]
   \   00000180   0xF108 0x0301      ADD      R3,R8,#+1
   \   00000184   0x1200             ASRS     R0,R0,#+8
   \   00000186   0x5498             STRB     R0,[R3, R2]
   \   00000188   0xF103 0x0801      ADD      R8,R3,#+1
   \   0000018C   0x1C49             ADDS     R1,R1,#+1
   \                     ??get_pic_display_8: (+1)
   \   0000018E   0x4549             CMP      R1,R9
   \   00000190   0xDBE1             BLT.N    ??get_pic_display_7
   \   00000192   0x1C7F             ADDS     R7,R7,#+1
   \   00000194   0xEE00 0x7A10      VMOV     S0,R7
   \   00000198   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000019C   0xEDDD 0x0A02      VLDR     S1,[SP, #+8]
   \   000001A0   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   000001A4   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   000001A8   0xEE10 0x6A10      VMOV     R6,S0
   \                     ??get_pic_display_9: (+1)
   \   000001AC   0x42AE             CMP      R6,R5
   \   000001AE   0xD012             BEQ.N    ??get_pic_display_10
   \                     ??get_pic_display_11: (+1)
   \   000001B0   0x1C6D             ADDS     R5,R5,#+1
   \                     ??get_pic_display_12: (+1)
   \   000001B2   0xF1AA 0x0A01      SUB      R10,R10,#+1
   \                     ??get_pic_display_6: (+1)
   \   000001B6   0xF1BA 0x0F01      CMP      R10,#+1
   \   000001BA   0xDB9B             BLT.N    ??get_pic_display_4
   \   000001BC   0xF240 0x7BEC      MOVW     R11,#+2028
   \   000001C0   0x44EB             ADD      R11,R11,SP
   \   000001C2   0x9806             LDR      R0,[SP, #+24]
   \   000001C4   0xF84B 0x0024      STR      R0,[R11, R4, LSL #+2]
   \   000001C8   0x1C64             ADDS     R4,R4,#+1
   \   000001CA   0x9800             LDR      R0,[SP, #+0]
   \   000001CC   0x4284             CMP      R4,R0
   \   000001CE   0xD1F0             BNE.N    ??get_pic_display_12
   \   000001D0   0x2400             MOVS     R4,#+0
   \   000001D2   0x42AE             CMP      R6,R5
   \   000001D4   0xD1EC             BNE.N    ??get_pic_display_11
   \                     ??get_pic_display_10: (+1)
   \   000001D6   0xF89D 0x0FC0      LDRB     R0,[SP, #+4032]
   \   000001DA   0x2801             CMP      R0,#+1
   \   000001DC   0xD138             BNE.N    ??get_pic_display_13
   \   000001DE   0x4620             MOV      R0,R4
   \   000001E0   0xAA07             ADD      R2,SP,#+28
   \   000001E2   0xE010             B.N      ??get_pic_display_14
   \                     ??get_pic_display_15: (+1)
   \   000001E4   0xEE00 0x0A10      VMOV     S0,R0
   \   000001E8   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   000001EC   0xEDDD 0x0A03      VLDR     S1,[SP, #+12]
   \   000001F0   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   000001F4   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   000001F8   0xEE10 0x1A10      VMOV     R1,S0
   \   000001FC   0xF85B 0x1021      LDR      R1,[R11, R1, LSL #+2]
   \   00000200   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \   00000204   0x1C40             ADDS     R0,R0,#+1
   \                     ??get_pic_display_14: (+1)
   \   00000206   0x4548             CMP      R0,R9
   \   00000208   0xDBEC             BLT.N    ??get_pic_display_15
   \   0000020A   0x2301             MOVS     R3,#+1
   \   0000020C   0x464A             MOV      R2,R9
   \   0000020E   0xF107 0x010F      ADD      R1,R7,#+15
   \   00000212   0xB289             UXTH     R1,R1
   \   00000214   0x2028             MOVS     R0,#+40
   \   00000216   0x.... 0x....      BL       LCD_setWindowArea
   \   0000021A   0x.... 0x....      BL       LCD_WriteRAM_Prepare
   \   0000021E   0x4626             MOV      R6,R4
   \   00000220   0xE006             B.N      ??get_pic_display_16
   \                     ??get_pic_display_17: (+1)
   \   00000222   0xA807             ADD      R0,SP,#+28
   \   00000224   0xF850 0x0026      LDR      R0,[R0, R6, LSL #+2]
   \   00000228   0xB280             UXTH     R0,R0
   \   0000022A   0x.... 0x....      BL       LCD_WriteRAM
   \   0000022E   0x1C76             ADDS     R6,R6,#+1
   \                     ??get_pic_display_16: (+1)
   \   00000230   0x454E             CMP      R6,R9
   \   00000232   0xDBF6             BLT.N    ??get_pic_display_17
   \   00000234   0x1C7F             ADDS     R7,R7,#+1
   \   00000236   0xEE00 0x7A10      VMOV     S0,R7
   \   0000023A   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000023E   0xEDDD 0x0A02      VLDR     S1,[SP, #+8]
   \   00000242   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000246   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   0000024A   0xEE10 0x6A10      VMOV     R6,S0
   \   0000024E   0xE7AD             B.N      ??get_pic_display_9
   \                     ??get_pic_display_13: (+1)
   \   00000250   0x4621             MOV      R1,R4
   \   00000252   0xE79C             B.N      ??get_pic_display_8
   \                     ??get_pic_display_5: (+1)
   \   00000254   0x....             LDR.N    R0,??DataTable210_2
   \   00000256   0x.... 0x....      BL       _ZN10CardReader14close_CBD_FileEv
   \   0000025A   0xF60D 0x7DC4      ADDW     SP,SP,#+4036
   \   0000025E   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void get_pic_info(char *)
   \                     get_pic_info: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x....             LDR.N    R4,??DataTable210_2
   \   00000004   0x4601             MOV      R1,R0
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0x.... 0x....      BL       _ZN10CardReader13open_CBD_FileEPc
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD00B             BEQ.N    ??get_pic_info_0
   \   00000010   0xF604 0x14C4      ADDW     R4,R4,#+2500
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       _ZN7MKS_DLP22get_cbddlp_file_headerEv
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       _ZN7MKS_DLP24get_cbddlp_preview1_infoEv
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0xE8BD 0x4010      POP      {R4,LR}
   \   00000026   0x....             B.N      _ZN7MKS_DLP24get_cbddlp_preview2_infoEv
   \                     ??get_pic_info_0: (+1)
   \   00000028   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::get_cbddlp_print_para_info()
   \                     _ZN7MKS_DLP26get_cbddlp_print_para_infoEv: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12

  	BYTE sd_char[4];
  	     ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",2590  Warning[Pe177]: 
          variable "sd_char" was declared but never referenced

  	uint8_t rc;
  	        ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",2593  Warning[Pe550]: 
          variable "rc" was set but never used
   \   00000004   0x....             LDR.N    R4,??DataTable210_2
   \   00000006   0xF8D4 0x1DE4      LDR      R1,[R4, #+3556]
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       _ZN10CardReader8setIndexEl
   \   00000010   0x2204             MOVS     R2,#+4
   \   00000012   0xA900             ADD      R1,SP,#+0
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   0000001A   0x....             LDR.N    R5,??DataTable210_5
   \   0000001C   0x9800             LDR      R0,[SP, #+0]
   \   0000001E   0x6028             STR      R0,[R5, #+0]
   \   00000020   0x2204             MOVS     R2,#+4
   \   00000022   0xA900             ADD      R1,SP,#+0
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   0000002A   0x9800             LDR      R0,[SP, #+0]
   \   0000002C   0x6068             STR      R0,[R5, #+4]
   \   0000002E   0x2204             MOVS     R2,#+4
   \   00000030   0xA900             ADD      R1,SP,#+0
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000038   0x9800             LDR      R0,[SP, #+0]
   \   0000003A   0x60A8             STR      R0,[R5, #+8]
   \   0000003C   0x2204             MOVS     R2,#+4
   \   0000003E   0xA900             ADD      R1,SP,#+0
   \   00000040   0x4620             MOV      R0,R4
   \   00000042   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000046   0x9800             LDR      R0,[SP, #+0]
   \   00000048   0x60E8             STR      R0,[R5, #+12]
   \   0000004A   0x2204             MOVS     R2,#+4
   \   0000004C   0xA900             ADD      R1,SP,#+0
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000054   0x9800             LDR      R0,[SP, #+0]
   \   00000056   0x6128             STR      R0,[R5, #+16]
   \   00000058   0x2204             MOVS     R2,#+4
   \   0000005A   0xA900             ADD      R1,SP,#+0
   \   0000005C   0x4620             MOV      R0,R4
   \   0000005E   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000062   0x9800             LDR      R0,[SP, #+0]
   \   00000064   0x6168             STR      R0,[R5, #+20]
   \   00000066   0x2204             MOVS     R2,#+4
   \   00000068   0xA900             ADD      R1,SP,#+0
   \   0000006A   0x4620             MOV      R0,R4
   \   0000006C   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000070   0x9800             LDR      R0,[SP, #+0]
   \   00000072   0x61A8             STR      R0,[R5, #+24]
   \   00000074   0x2204             MOVS     R2,#+4
   \   00000076   0xA900             ADD      R1,SP,#+0
   \   00000078   0x4620             MOV      R0,R4
   \   0000007A   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   0000007E   0x9800             LDR      R0,[SP, #+0]
   \   00000080   0x61E8             STR      R0,[R5, #+28]
   \   00000082   0x2204             MOVS     R2,#+4
   \   00000084   0xA900             ADD      R1,SP,#+0
   \   00000086   0x4620             MOV      R0,R4
   \   00000088   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   0000008C   0x9800             LDR      R0,[SP, #+0]
   \   0000008E   0x6228             STR      R0,[R5, #+32]
   \   00000090   0x2204             MOVS     R2,#+4
   \   00000092   0xA900             ADD      R1,SP,#+0
   \   00000094   0x4620             MOV      R0,R4
   \   00000096   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   0000009A   0x9800             LDR      R0,[SP, #+0]
   \   0000009C   0x6268             STR      R0,[R5, #+36]
   \   0000009E   0x2204             MOVS     R2,#+4
   \   000000A0   0xA901             ADD      R1,SP,#+4
   \   000000A2   0x4620             MOV      R0,R4
   \   000000A4   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   000000A8   0x9801             LDR      R0,[SP, #+4]
   \   000000AA   0x62A8             STR      R0,[R5, #+40]
   \   000000AC   0x2204             MOVS     R2,#+4
   \   000000AE   0xA900             ADD      R1,SP,#+0
   \   000000B0   0x4620             MOV      R0,R4
   \   000000B2   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   000000B6   0x9800             LDR      R0,[SP, #+0]
   \   000000B8   0x62E8             STR      R0,[R5, #+44]
   \   000000BA   0x2204             MOVS     R2,#+4
   \   000000BC   0xA900             ADD      R1,SP,#+0
   \   000000BE   0x4620             MOV      R0,R4
   \   000000C0   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   000000C4   0x9800             LDR      R0,[SP, #+0]
   \   000000C6   0x6328             STR      R0,[R5, #+48]
   \   000000C8   0x2204             MOVS     R2,#+4
   \   000000CA   0xA900             ADD      R1,SP,#+0
   \   000000CC   0x4620             MOV      R0,R4
   \   000000CE   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   000000D2   0x9800             LDR      R0,[SP, #+0]
   \   000000D4   0x6368             STR      R0,[R5, #+52]
   \   000000D6   0x2204             MOVS     R2,#+4
   \   000000D8   0xA900             ADD      R1,SP,#+0
   \   000000DA   0x4620             MOV      R0,R4
   \   000000DC   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   000000E0   0x9800             LDR      R0,[SP, #+0]
   \   000000E2   0x63A8             STR      R0,[R5, #+56]
   \   000000E4   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::get_cbddlp_cur_layer_def(uint32_t)
   \                     _ZN7MKS_DLP24get_cbddlp_cur_layer_defEj: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44

  	uint8_t rc;
  	        ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",2649  Warning[Pe550]: 
          variable "rc" was set but never used
   \   00000004   0x....             LDR.N    R4,??DataTable210_2
   \   00000006   0xF8D4 0x0DD0      LDR      R0,[R4, #+3536]
   \   0000000A   0xEB01 0x02C1      ADD      R2,R1,R1, LSL #+3
   \   0000000E   0xEB00 0x0182      ADD      R1,R0,R2, LSL #+2
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       _ZN10CardReader8setIndexEl
   \   00000018   0x2204             MOVS     R2,#+4
   \   0000001A   0xA900             ADD      R1,SP,#+0
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000022   0x....             LDR.N    R5,??DataTable210_6
   \   00000024   0x9800             LDR      R0,[SP, #+0]
   \   00000026   0x6028             STR      R0,[R5, #+0]
   \   00000028   0x2204             MOVS     R2,#+4
   \   0000002A   0xA900             ADD      R1,SP,#+0
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000032   0x9800             LDR      R0,[SP, #+0]
   \   00000034   0x6068             STR      R0,[R5, #+4]
   \   00000036   0x2204             MOVS     R2,#+4
   \   00000038   0xA900             ADD      R1,SP,#+0
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000040   0x9800             LDR      R0,[SP, #+0]
   \   00000042   0x60A8             STR      R0,[R5, #+8]
   \   00000044   0x2204             MOVS     R2,#+4
   \   00000046   0xA901             ADD      R1,SP,#+4
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   0000004E   0x9801             LDR      R0,[SP, #+4]
   \   00000050   0x60E8             STR      R0,[R5, #+12]
   \   00000052   0x2204             MOVS     R2,#+4
   \   00000054   0xA901             ADD      R1,SP,#+4
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   0000005C   0x9801             LDR      R0,[SP, #+4]
   \   0000005E   0x6128             STR      R0,[R5, #+16]
   \   00000060   0x2204             MOVS     R2,#+4
   \   00000062   0xA902             ADD      R1,SP,#+8
   \   00000064   0x4620             MOV      R0,R4
   \   00000066   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   0000006A   0x2204             MOVS     R2,#+4
   \   0000006C   0xA902             ADD      R1,SP,#+8
   \   0000006E   0xF105 0x0014      ADD      R0,R5,#+20
   \   00000072   0x.... 0x....      BL       memcpy
   \   00000076   0x2204             MOVS     R2,#+4
   \   00000078   0xA902             ADD      R1,SP,#+8
   \   0000007A   0x4620             MOV      R0,R4
   \   0000007C   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000080   0x2204             MOVS     R2,#+4
   \   00000082   0xA902             ADD      R1,SP,#+8
   \   00000084   0xF105 0x0018      ADD      R0,R5,#+24
   \   00000088   0x.... 0x....      BL       memcpy
   \   0000008C   0x2204             MOVS     R2,#+4
   \   0000008E   0xA902             ADD      R1,SP,#+8
   \   00000090   0x4620             MOV      R0,R4
   \   00000092   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   00000096   0x2204             MOVS     R2,#+4
   \   00000098   0xA902             ADD      R1,SP,#+8
   \   0000009A   0xF105 0x001C      ADD      R0,R5,#+28
   \   0000009E   0x.... 0x....      BL       memcpy
   \   000000A2   0x2204             MOVS     R2,#+4
   \   000000A4   0xA902             ADD      R1,SP,#+8
   \   000000A6   0x4620             MOV      R0,R4
   \   000000A8   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   000000AC   0x2204             MOVS     R2,#+4
   \   000000AE   0xA902             ADD      R1,SP,#+8
   \   000000B0   0xF105 0x0020      ADD      R0,R5,#+32
   \   000000B4   0x.... 0x....      BL       memcpy
   \   000000B8   0xB00B             ADD      SP,SP,#+44
   \   000000BA   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::startFileprint_cbd()
   \                     _ZN7MKS_DLP18startFileprint_cbdEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x....             LDR.N    R0,??DataTable210_7
   \   00000006   0x.... 0x....      BL       _ZN7SSD28284initEv
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       _ZN7MKS_DLP22get_cbddlp_file_headerEv
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       _ZN7MKS_DLP24get_cbddlp_preview1_infoEv
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       _ZN7MKS_DLP24get_cbddlp_preview2_infoEv
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       _ZN7MKS_DLP26get_cbddlp_print_para_infoEv
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       _ZN7MKS_DLP23clean_Information_layerEv
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       _ZN7MKS_DLP11status_initEv
   \   0000002E   0x.... 0x....      BL       draw_status_clear
   \   00000032   0x.... 0x....      BL       display_print_statue
   \   00000036   0x.... 0x....      BL       GUI_Exec
   \   0000003A   0x.... 0x....      ADR.W    R0,`?<Constant "G28 Z0">`
   \   0000003E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000042   0x.... 0x....      B.W      _Z7mks_G28Pc

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void MKS_DLP::decode_layer_from_rle(uint32_t, uint8_t)
   \                     _ZN7MKS_DLP21decode_layer_from_rleEjh: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x4614             MOV      R4,R2
   \   00000008   0x.... 0x....      BL       _ZN7MKS_DLP24get_cbddlp_cur_layer_defEj
   \   0000000C   0x....             LDR.N    R5,??DataTable210_2
   \   0000000E   0x....             LDR.N    R0,??DataTable210_6
   \   00000010   0x68C1             LDR      R1,[R0, #+12]
   \   00000012   0x4628             MOV      R0,R5
   \   00000014   0x.... 0x....      BL       _ZN10CardReader8setIndexEl
   \   00000018   0xF605 0x6010      ADDW     R0,R5,#+3600
   \   0000001C   0x9000             STR      R0,[SP, #+0]
   \   0000001E   0xF44F 0x62C0      MOV      R2,#+1536
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x.... 0x....      BL       memset

  	if((work_bank==BANK_USED_ID0)||work_bank==WORK_USED_BANK)
  	                             ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",2720  Warning[Pa134]: 
          left and right operands are identical
   \   00000028   0x2C00             CMP      R4,#+0
   \   0000002A   0xD000             BEQ.N    ??decode_layer_from_rle_0
   \   0000002C   0xD105             BNE.N    ??decode_layer_from_rle_1
   \                     ??decode_layer_from_rle_0: (+1)
   \   0000002E   0xF44F 0x52E6      MOV      R2,#+7360
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0x....             LDR.N    R0,??DataTable210_1
   \   00000036   0x.... 0x....      BL       memset
   \                     ??decode_layer_from_rle_1: (+1)
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xF8A5 0x0A0E      STRH     R0,[R5, #+2574]
   \   00000040   0x9E00             LDR      R6,[SP, #+0]
   \   00000042   0x4607             MOV      R7,R0
   \   00000044   0x4680             MOV      R8,R0
   \   00000046   0xE007             B.N      ??decode_layer_from_rle_2

  				if((work_bank==BANK_USED_ID0)||work_bank==WORK_USED_BANK)
  				                             ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",2749  Warning[Pa134]: 
          left and right operands are identical

  	uint8_t rc;
  	        ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",2703  Warning[Pe550]: 
          variable "rc" was set but never used

  	uint16_t length,length_sum;
  	                ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_dlp_main.cpp",2707  Warning[Pe177]: 
          variable "length_sum" was declared but never referenced

  static uint32_t After_finish_print_time = 0;
                  ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\Marlin_main.cpp",299  Warning[Pe177]: 
          variable "After_finish_print_time" was declared but never referenced

  static long gcode_N, gcode_LastN, Stopped_gcode_LastN = 0;
                                    ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\Marlin_main.cpp",445  Warning[Pe550]: 
          variable "Stopped_gcode_LastN" was set but never used

  static inline signed char pgm_read_any(const signed char *p) { return (*(const signed char *)(p)); }
                            ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\Marlin_main.cpp",782  Warning[Pe177]: 
          function "pgm_read_any(signed char const *)" was declared but never
          referenced

  static inline float pgm_read_any(const float *p) { return (*(const float *)(p)); }
                      ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\Marlin_main.cpp",781  Warning[Pe177]: 
          function "pgm_read_any(float const *)" was declared but never
          referenced

    constexpr bool g29_in_progress = false;
                   ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\Marlin_main.cpp",4354  Warning[Pe177]: 
          variable "g29_in_progress" was declared but never referenced

      static bool blocks_queued() { return (block_buffer_head != block_buffer_tail); }
                                    ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\planner.h",504  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement
   \                     ??decode_layer_from_rle_3: (+1)
   \   00000048   0xF806 0x9B01      STRB     R9,[R6], #+1
   \   0000004C   0x1C7F             ADDS     R7,R7,#+1
   \   0000004E   0x1C40             ADDS     R0,R0,#+1
   \                     ??decode_layer_from_rle_4: (+1)
   \   00000050   0x4288             CMP      R0,R1
   \   00000052   0xDBF9             BLT.N    ??decode_layer_from_rle_3
   \                     ??decode_layer_from_rle_5: (+1)
   \   00000054   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??decode_layer_from_rle_2: (+1)
   \   00000058   0x....             LDR.N    R0,??DataTable210_6
   \   0000005A   0x6900             LDR      R0,[R0, #+16]
   \   0000005C   0x4580             CMP      R8,R0
   \   0000005E   0xDA43             BGE.N    ??decode_layer_from_rle_6
   \   00000060   0x2201             MOVS     R2,#+1
   \   00000062   0xA901             ADD      R1,SP,#+4
   \   00000064   0x4628             MOV      R0,R5
   \   00000066   0x.... 0x....      BL       _ZN10CardReader4getsEPhj
   \   0000006A   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000006E   0xEA4F 0x19D0      LSR      R9,R0,#+7
   \   00000072   0xF000 0x0A7F      AND      R10,R0,#0x7F
   \   00000076   0xF04F 0x0B00      MOV      R11,#+0
   \   0000007A   0xE001             B.N      ??decode_layer_from_rle_7
   \                     ??decode_layer_from_rle_8: (+1)
   \   0000007C   0xF10B 0x0B01      ADD      R11,R11,#+1
   \                     ??decode_layer_from_rle_7: (+1)
   \   00000080   0x45D3             CMP      R11,R10
   \   00000082   0xDAE7             BGE.N    ??decode_layer_from_rle_5
   \   00000084   0xB2BF             UXTH     R7,R7
   \   00000086   0xF5B7 0x7F34      CMP      R7,#+720
   \   0000008A   0xDA02             BGE.N    ??decode_layer_from_rle_9
   \   0000008C   0xF886 0x9000      STRB     R9,[R6, #+0]
   \   00000090   0xE001             B.N      ??decode_layer_from_rle_10
   \                     ??decode_layer_from_rle_9: (+1)
   \   00000092   0xF886 0x9030      STRB     R9,[R6, #+48]
   \                     ??decode_layer_from_rle_10: (+1)
   \   00000096   0x1C76             ADDS     R6,R6,#+1
   \   00000098   0x1C7F             ADDS     R7,R7,#+1
   \   0000009A   0xF8D5 0x0DC4      LDR      R0,[R5, #+3524]
   \   0000009E   0xB2BF             UXTH     R7,R7
   \   000000A0   0x42B8             CMP      R0,R7
   \   000000A2   0xDAEB             BGE.N    ??decode_layer_from_rle_8
   \   000000A4   0xF605 0x16C4      ADDW     R6,R5,#+2500
   \   000000A8   0x4622             MOV      R2,R4
   \   000000AA   0xF8B5 0x1A0E      LDRH     R1,[R5, #+2574]
   \   000000AE   0x4630             MOV      R0,R6
   \   000000B0   0x.... 0x....      BL       _ZN7MKS_DLP13line_gen_dataEth
   \   000000B4   0x2C00             CMP      R4,#+0
   \   000000B6   0xD000             BEQ.N    ??decode_layer_from_rle_11
   \   000000B8   0xD104             BNE.N    ??decode_layer_from_rle_12
   \                     ??decode_layer_from_rle_11: (+1)
   \   000000BA   0xF8B5 0x1A0E      LDRH     R1,[R5, #+2574]
   \   000000BE   0x4630             MOV      R0,R6
   \   000000C0   0x.... 0x....      BL       _ZN7MKS_DLP17line_gen_data_TFTEt
   \                     ??decode_layer_from_rle_12: (+1)
   \   000000C4   0xF8B5 0x0A0E      LDRH     R0,[R5, #+2574]
   \   000000C8   0x1C40             ADDS     R0,R0,#+1
   \   000000CA   0xF8A5 0x0A0E      STRH     R0,[R5, #+2574]
   \   000000CE   0x2700             MOVS     R7,#+0
   \   000000D0   0xF44F 0x62C0      MOV      R2,#+1536
   \   000000D4   0x4639             MOV      R1,R7
   \   000000D6   0x9800             LDR      R0,[SP, #+0]
   \   000000D8   0x.... 0x....      BL       memset
   \   000000DC   0x9E00             LDR      R6,[SP, #+0]
   \   000000DE   0xEBAA 0x010B      SUB      R1,R10,R11
   \   000000E2   0xB2C9             UXTB     R1,R1
   \   000000E4   0x4638             MOV      R0,R7
   \   000000E6   0xE7B3             B.N      ??decode_layer_from_rle_4
   \                     ??decode_layer_from_rle_6: (+1)
   \   000000E8   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "mks_pft.sys">`:
   \   00000000   0x6D 0x6B          DC8 "mks_pft.sys"
   \              0x73 0x5F    
   \              0x70 0x66    
   \              0x74 0x2E    
   \              0x73 0x79    
   \              0x73 0x00    

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "Z">`:
   \   00000000   0x5A 0x00          DC8 "Z"

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {(0.0F), (0.0F)}>`:
   \   00000000   0x00000000         DC32 0H, 0H
   \              0x00000000   

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant " Z:">`:
   \   00000000   0x20 0x5A          DC8 " Z:"
   \              0x3A 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "X:">`:
   \   00000000   0x58 0x3A          DC8 "X:"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant " Y:">`:
   \   00000000   0x20 0x59          DC8 " Y:"
   \              0x3A 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant " E:">`:
   \   00000000   0x20 0x45          DC8 " E:"
   \              0x3A 0x00    

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant ":">`:
   \   00000000   0x3A 0x00          DC8 ":"

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "ok">`:
   \   00000000   0x6F 0x6B          DC8 "ok"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "M29">`:
   \   00000000   0x4D 0x32          DC8 "M29"
   \              0x39 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "%f">`:
   \   00000000   0x25 0x66          DC8 "%f"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant " Y">`:
   \   00000000   0x20 0x59          DC8 " Y"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "G28">`:
   \   00000000   0x47 0x32          DC8 "G28"
   \              0x38 0x00    

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "/">`:
   \   00000000   0x2F 0x00          DC8 "/"

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp MKS_DLP::subobject MKS_DLP()
   \                     _ZN7MKS_DLPC2Ev: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN7MKS_DLPC1Ev

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "enqueueing \\"">`:
   \   00000000   0x65 0x6E          DC8 "enqueueing \""
   \              0x71 0x75    
   \              0x65 0x75    
   \              0x65 0x69    
   \              0x6E 0x67    
   \              0x20 0x22    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Invalid extruder ">`:
   \   00000000   0x20 0x49          DC8 " Invalid extruder "
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x65    
   \              0x78 0x74    
   \              0x72 0x75    
   \              0x64 0x65    
   \              0x72 0x20    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable88:
   \   00000000   0x43480000         DC32     0x43480000

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Home ">`:
   \   00000000   0x48 0x6F          DC8 "Home "
   \              0x6D 0x65    
   \              0x20 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " first\\n">`:
   \   00000000   0x20 0x66          DC8 " first\012"
   \              0x69 0x72    
   \              0x73 0x74    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Layer:">`:
   \   00000000   0x4C 0x61          DC8 "Layer:"
   \              0x79 0x65    
   \              0x72 0x3A    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable103:
   \   00000000   0x5A 0x00          DC8      "Z",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable103_1:
   \   00000000   0x00000000         DC32     0x0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Cap:">`:
   \   00000000   0x43 0x61          DC8 "Cap:"
   \              0x70 0x3A    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable104:
   \   00000000   0x42700000         DC32     0x42700000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable104_1:
   \   00000000   0x20 0x5A          DC8      " Z:"
   \              0x3A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable104_2:
   \   00000000   0x58 0x3A          DC8      0x58, 0x3A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable104_3:
   \   00000000   0x20 0x59          DC8      " Y:"
   \              0x3A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable104_4:
   \   00000000   0x20 0x45          DC8      " E:"
   \              0x3A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable104_5:
   \   00000000   0x3A 0x00          DC8      ":",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable104_6:
   \   00000000   0x........         DC32     card

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable104_7:
   \   00000000   0x........         DC32     home_dir_P

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable104_8:
   \   00000000   0x........         DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable104_9:
   \   00000000   0x........         DC32     soft_endstops_enabled

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Active Extruder: ">`:
   \   00000000   0x41 0x63          DC8 "Active Extruder: "
   \              0x74 0x69    
   \              0x76 0x65    
   \              0x20 0x45    
   \              0x78 0x74    
   \              0x72 0x75    
   \              0x64 0x65    
   \              0x72 0x3A    
   \              0x20 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable107:
   \   00000000   0x........         DC32     axis_relative_modes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable107_1:
   \   00000000   0x........         DC32     injected_commands_P

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable107_2:
   \   00000000   0x........         DC32     echomagic

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable107_3:
   \   00000000   0x........         DC32     errormagic

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Resend: ">`:
   \   00000000   0x52 0x65          DC8 "Resend: "
   \              0x73 0x65    
   \              0x6E 0x64    
   \              0x3A 0x20    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable109:
   \   00000000   0x........         DC32     Serial6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable111:
   \   00000000   0x........         DC32     serial_count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable111_1:
   \   00000000   0x........         DC32     axis_relative_modes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable111_2:
   \   00000000   0x43055555         DC32     0x43055555

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable111_3:
   \   00000000   0x6F 0x6B          DC8      0x6F, 0x6B, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable111_4:
   \   00000000   0x........         DC32     axis_relative_modes+0x2C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable111_5:
   \   00000000   0x43480001         DC32     0x43480001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable111_6:
   \   00000000   0x3FF80000         DC32     0x3ff80000

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " too long extrusion p...">`:
   \   00000000   0x20 0x74          DC8 " too long extrusion prevented\012"
   \              0x6F 0x6F    
   \              0x20 0x6C    
   \              0x6F 0x6E    
   \              0x67 0x20    
   \              0x65 0x78    
   \              0x74 0x72    
   \              0x75 0x73    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x70 0x72    
   \              0x65 0x76    
   \              0x65 0x6E    
   \              0x74 0x65    
   \              0x64 0x0A    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable115:
   \   00000000   0x40C90FDB         DC32     0x40c90fdb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable115_1:
   \   00000000   0x........         DC32     card+0x9C4

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "KILL caused by too mu...">`:
   \   00000000   0x4B 0x49          DC8 4BH, 49H, 4CH, 4CH, 20H, 63H, 61H, 75H
   \              0x4C 0x4C    
   \              0x20 0x63    
   \              0x61 0x75    
   \   00000008   0x73 0x65          DC8 73H, 65H, 64H, 20H, 62H, 79H, 20H, 74H
   \              0x64 0x20    
   \              0x62 0x79    
   \              0x20 0x74    
   \   00000010   0x6F 0x6F          DC8 6FH, 6FH, 20H, 6DH, 75H, 63H, 68H, 20H
   \              0x20 0x6D    
   \              0x75 0x63    
   \              0x68 0x20    
   \   00000018   0x69 0x6E          DC8 69H, 6EH, 61H, 63H, 74H, 69H, 76H, 65H
   \              0x61 0x63    
   \              0x74 0x69    
   \              0x76 0x65    
   \   00000020   0x20 0x74          DC8 20H, 74H, 69H, 6DH, 65H, 20H, 2DH, 20H
   \              0x69 0x6D    
   \              0x65 0x20    
   \              0x2D 0x20    
   \   00000028   0x63 0x75          DC8 63H, 75H, 72H, 72H, 65H, 6EH, 74H, 20H
   \              0x72 0x72    
   \              0x65 0x6E    
   \              0x74 0x20    
   \   00000030   0x63 0x6F          DC8 63H, 6FH, 6DH, 6DH, 61H, 6EH, 64H, 3AH
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x3A    
   \   00000038   0x20 0x00          DC8 20H, 0
   \   0000003A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "KILLED. ">`:
   \   00000000   0x4B 0x49          DC8 "KILLED. "
   \              0x4C 0x4C    
   \              0x45 0x44    
   \              0x2E 0x20    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable116:
   \   00000000   0x3A83126F         DC32     0x3a83126f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable118:
   \   00000000   0x........         DC32     previous_cmd_ms

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Error">`:
   \   00000000   0x45 0x72          DC8 "Error"
   \              0x72 0x6F    
   \              0x72 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Printer halted. kill(...">`:
   \   00000000   0x50 0x72          DC8 "Printer halted. kill() called!\012"
   \              0x69 0x6E    
   \              0x74 0x65    
   \              0x72 0x20    
   \              0x68 0x61    
   \              0x6C 0x74    
   \              0x65 0x64    
   \              0x2E 0x20    
   \              0x6B 0x69    
   \              0x6C 0x6C    
   \              0x28 0x29    
   \              0x20 0x63    
   \              0x61 0x6C    
   \              0x6C 0x65    
   \              0x64 0x21    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable121:
   \   00000000   0x........         DC32     _ZN11GCodeParser14command_letterE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable121_1:
   \   00000000   0x........         DC32     _ZN11GCodeParser7codenumE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable121_2:
   \   00000000   0x........         DC32     gCfgItems

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Printer stopped due t...">`:
   \   00000000   0x50 0x72          DC8 50H, 72H, 69H, 6EH, 74H, 65H, 72H, 20H
   \              0x69 0x6E    
   \              0x74 0x65    
   \              0x72 0x20    
   \   00000008   0x73 0x74          DC8 73H, 74H, 6FH, 70H, 70H, 65H, 64H, 20H
   \              0x6F 0x70    
   \              0x70 0x65    
   \              0x64 0x20    
   \   00000010   0x64 0x75          DC8 64H, 75H, 65H, 20H, 74H, 6FH, 20H, 65H
   \              0x65 0x20    
   \              0x74 0x6F    
   \              0x20 0x65    
   \   00000018   0x72 0x72          DC8 72H, 72H, 6FH, 72H, 73H, 2EH, 20H, 46H
   \              0x6F 0x72    
   \              0x73 0x2E    
   \              0x20 0x46    
   \   00000020   0x69 0x78          DC8 69H, 78H, 20H, 74H, 68H, 65H, 20H, 65H
   \              0x20 0x74    
   \              0x68 0x65    
   \              0x20 0x65    
   \   00000028   0x72 0x72          DC8 72H, 72H, 6FH, 72H, 20H, 61H, 6EH, 64H
   \              0x6F 0x72    
   \              0x20 0x61    
   \              0x6E 0x64    
   \   00000030   0x20 0x75          DC8 20H, 75H, 73H, 65H, 20H, 4DH, 39H, 39H
   \              0x73 0x65    
   \              0x20 0x4D    
   \              0x39 0x39    
   \   00000038   0x39 0x20          DC8 39H, 20H, 74H, 6FH, 20H, 72H, 65H, 73H
   \              0x74 0x6F    
   \              0x20 0x72    
   \              0x65 0x73    
   \   00000040   0x74 0x61          DC8 74H, 61H, 72H, 74H, 2EH, 20H, 28H, 54H
   \              0x72 0x74    
   \              0x2E 0x20    
   \              0x28 0x54    
   \   00000048   0x65 0x6D          DC8 65H, 6DH, 70H, 65H, 72H, 61H, 74H, 75H
   \              0x70 0x65    
   \              0x72 0x61    
   \              0x74 0x75    
   \   00000050   0x72 0x65          DC8 72H, 65H, 20H, 69H, 73H, 20H, 72H, 65H
   \              0x20 0x69    
   \              0x73 0x20    
   \              0x72 0x65    
   \   00000058   0x73 0x65          DC8 73H, 65H, 74H, 2EH, 20H, 53H, 65H, 74H
   \              0x74 0x2E    
   \              0x20 0x53    
   \              0x65 0x74    
   \   00000060   0x20 0x69          DC8 20H, 69H, 74H, 20H, 61H, 66H, 74H, 65H
   \              0x74 0x20    
   \              0x61 0x66    
   \              0x74 0x65    
   \   00000068   0x72 0x20          DC8 72H, 20H, 72H, 65H, 73H, 74H, 61H, 72H
   \              0x72 0x65    
   \              0x73 0x74    
   \              0x61 0x72    
   \   00000070   0x74 0x69          DC8 74H, 69H, 6EH, 67H, 29H, 0AH, 0
   \              0x6E 0x67    
   \              0x29 0x0A    
   \              0x00         
   \   00000077   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "STOPPED. ">`:
   \   00000000   0x53 0x54          DC8 "STOPPED. "
   \              0x4F 0x50    
   \              0x50 0x45    
   \              0x44 0x2E    
   \              0x20 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable122:
   \   00000000   0x........         DC32     card

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable122_1:
   \   00000000   0x........         DC32     curFileName

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "MKS DLP">`:
   \   00000000   0x4D 0x4B          DC8 "MKS DLP"
   \              0x53 0x20    
   \              0x44 0x4C    
   \              0x50 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "1.0.0\\n">`:
   \   00000000   0x31 0x2E          DC8 "1.0.0\012"
   \              0x30 0x2E    
   \              0x30 0x0A    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Last Updated: ">`:
   \   00000000   0x20 0x4C          DC8 " Last Updated: "
   \              0x61 0x73    
   \              0x74 0x20    
   \              0x55 0x70    
   \              0x64 0x61    
   \              0x74 0x65    
   \              0x64 0x3A    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "2017-12-25 12:00">`:
   \   00000000   0x32 0x30          DC8 "2017-12-25 12:00"
   \              0x31 0x37    
   \              0x2D 0x31    
   \              0x32 0x2D    
   \              0x32 0x35    
   \              0x20 0x31    
   \              0x32 0x3A    
   \              0x30 0x30    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " | Author: (none, def...">`:
   \   00000000   0x20 0x7C          DC8 " | Author: (none, default config)\012"
   \              0x20 0x41    
   \              0x75 0x74    
   \              0x68 0x6F    
   \              0x72 0x3A    
   \              0x20 0x28    
   \              0x6E 0x6F    
   \              0x6E 0x65    
   \              0x2C 0x20    
   \              0x64 0x65    
   \              0x66 0x61    
   \              0x75 0x6C    
   \              0x74 0x20    
   \              0x63 0x6F    
   \              0x6E 0x66    
   \              0x69 0x67    
   \              0x29 0x0A    
   \              0x00         
   \   00000023   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Compiled: Apr 16 2020\\n">`:
   \   00000000   0x43 0x6F          DC8 "Compiled: Apr 16 2020\012"
   \              0x6D 0x70    
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x3A 0x20    
   \              0x41 0x70    
   \              0x72 0x20    
   \              0x31 0x36    
   \              0x20 0x32    
   \              0x30 0x32    
   \              0x30 0x0A    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Free Memory: ">`:
   \   00000000   0x20 0x46          DC8 " Free Memory: "
   \              0x72 0x65    
   \              0x65 0x20    
   \              0x4D 0x65    
   \              0x6D 0x6F    
   \              0x72 0x79    
   \              0x3A 0x20    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "  PlannerBufferBytes: ">`:
   \   00000000   0x20 0x20          DC8 "  PlannerBufferBytes: "
   \              0x50 0x6C    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x72 0x42    
   \              0x75 0x66    
   \              0x66 0x65    
   \              0x72 0x42    
   \              0x79 0x74    
   \              0x65 0x73    
   \              0x3A 0x20    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable123:
   \   00000000   0x........         DC32     from_flash_pic

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Done saving file.\\n">`:
   \   00000000   0x44 0x6F          DC8 "Done saving file.\012"
   \              0x6E 0x65    
   \              0x20 0x73    
   \              0x61 0x76    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x66 0x69    
   \              0x6C 0x65    
   \              0x2E 0x0A    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable124:
   \   00000000   0x........         DC32     flash_preview_begin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable124_1:
   \   00000000   0x........         DC32     default_preview_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable125:
   \   00000000   0x4D 0x32          DC8      "M29"
   \              0x39 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable125_1:
   \   00000000   0x........         DC32     parser

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable125_2:
   \   00000000   0x........         DC32     soft_endstops_enabled

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable126:
   \   00000000   0x........         DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable126_1:
   \   00000000   0x........         DC32     cartes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable126_2:
   \   00000000   0x........         DC32     _ZN7Planner8e_factorE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable127:
   \   00000000   0x........         DC32     echomagic

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable127_1:
   \   00000000   0x........         DC32     axis_relative_modes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable127_2:
   \   00000000   0x54442D18         DC32     0x54442d18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable127_3:
   \   00000000   0x401921FB         DC32     0x401921fb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable127_4:
   \   00000000   0xC01921FB         DC32     0xc01921fb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable127_5:
   \   00000000   0x3FE00000         DC32     0x3fe00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable127_6:
   \   00000000   0x3FF00000         DC32     0x3ff00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable127_7:
   \   00000000   0x47AE147B         DC32     0x47ae147b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable128:
   \   00000000   0x........         DC32     gArrayGpioPin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable128_1:
   \   00000000   0x........         DC32     gArrayGpioPort

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable128_2:
   \   00000000   0x........         DC32     axis_relative_modes

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "0.000">`:
   \   00000000   0x30 0x2E          DC8 "0.000"
   \              0x30 0x30    
   \              0x30 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "TP-LINK_MKS">`:
   \   00000000   0x54 0x50          DC8 "TP-LINK_MKS"
   \              0x2D 0x4C    
   \              0x49 0x4E    
   \              0x4B 0x5F    
   \              0x4D 0x4B    
   \              0x53 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "makerbase">`:
   \   00000000   0x6D 0x61          DC8 "makerbase"
   \              0x6B 0x65    
   \              0x72 0x62    
   \              0x61 0x73    
   \              0x65 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "192.168.3.100">`:
   \   00000000   0x31 0x39          DC8 "192.168.3.100"
   \              0x32 0x2E    
   \              0x31 0x36    
   \              0x38 0x2E    
   \              0x33 0x2E    
   \              0x31 0x30    
   \              0x30 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "255.255.255.0">`:
   \   00000000   0x32 0x35          DC8 "255.255.255.0"
   \              0x35 0x2E    
   \              0x32 0x35    
   \              0x35 0x2E    
   \              0x32 0x35    
   \              0x35 0x2E    
   \              0x30 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "192.168.3.1">`:
   \   00000000   0x31 0x39          DC8 "192.168.3.1"
   \              0x32 0x2E    
   \              0x31 0x36    
   \              0x38 0x2E    
   \              0x33 0x2E    
   \              0x31 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "192.168.3.255">`:
   \   00000000   0x31 0x39          DC8 "192.168.3.255"
   \              0x32 0x2E    
   \              0x31 0x36    
   \              0x38 0x2E    
   \              0x33 0x2E    
   \              0x32 0x35    
   \              0x35 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "baizhongyun.cn">`:
   \   00000000   0x62 0x61          DC8 "baizhongyun.cn"
   \              0x69 0x7A    
   \              0x68 0x6F    
   \              0x6E 0x67    
   \              0x79 0x75    
   \              0x6E 0x2E    
   \              0x63 0x6E    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable130:
   \   00000000   0x........         DC32     _ZN11GCodeParser11command_ptrE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable130_1:
   \   00000000   0x........         DC32     Serial6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable131:
   \   00000000   0x3F847AE1         DC32     0x3f847ae1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable132:
   \   00000000   0x........         DC32     errormagic

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable132_1:
   \   00000000   0x........         DC32     wifi_link_state

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable132_2:
   \   00000000   0x........         DC32     preview_no_display

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "paused:">`:
   \   00000000   0x70 0x61          DC8 "paused:"
   \              0x75 0x73    
   \              0x65 0x64    
   \              0x3A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "G92 Z">`:
   \   00000000   0x47 0x39          DC8 "G92 Z"
   \              0x32 0x20    
   \              0x5A 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable135:
   \   00000000   0x........         DC32     card+0x9C4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable136:
   \   00000000   0x........         DC32     TFT_screen

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable136_1:
   \   00000000   0x42F00000         DC32     0x42f00000

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "G1 X">`:
   \   00000000   0x47 0x31          DC8 "G1 X"
   \              0x20 0x58    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "G1 Z">`:
   \   00000000   0x47 0x31          DC8 "G1 Z"
   \              0x20 0x5A    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable138:
   \   00000000   0x........         DC32     gCfgItems

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "G1 Z0">`:
   \   00000000   0x47 0x31          DC8 "G1 Z0"
   \              0x20 0x5A    
   \              0x30 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable141:
   \   00000000   0x........         DC32     printing_rate_update_flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable142:
   \   00000000   0x........         DC32     thermalManager

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable142_1:
   \   00000000   0x25 0x66          DC8      0x25, 0x66, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable142_2:
   \   00000000   0x........         DC32     card

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable142_3:
   \   00000000   0x........         DC32     clean_time_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable142_4:
   \   00000000   0x........         DC32     time_1s_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable142_5:
   \   00000000   0x........         DC32     temperature_change_frequency

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable142_6:
   \   00000000   0x........         DC32     print_time

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable142_7:
   \   00000000   0x........         DC32     poweroff_det_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable142_8:
   \   00000000   0x........         DC32     poweroff_det_cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable142_9:
   \   00000000   0x........         DC32     filament_det1_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable142_10:
   \   00000000   0x........         DC32     filament_det1_cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable143:
   \   00000000   0x20 0x59          DC8      0x20, 0x59, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable143_1:
   \   00000000   0x424082B4         DC32     0x424082b4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable143_2:
   \   00000000   0x........         DC32     filament_det1_low_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable143_3:
   \   00000000   0x........         DC32     filament_det1_low_cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable143_4:
   \   00000000   0x........         DC32     filament_det1_high_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable143_5:
   \   00000000   0x........         DC32     filament_det1_high_cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable143_6:
   \   00000000   0x........         DC32     filament_det2_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable143_7:
   \   00000000   0x........         DC32     filament_det2_cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable143_8:
   \   00000000   0x........         DC32     filament_det2_low_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable143_9:
   \   00000000   0x........         DC32     filament_det2_low_cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable143_10:
   \   00000000   0x........         DC32     filament_det2_high_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable143_11:
   \   00000000   0x........         DC32     filament_det2_high_cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable143_12:
   \   00000000   0x........         DC32     poweroff_det_low_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable143_13:
   \   00000000   0x........         DC32     poweroff_det_low_cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable143_14:
   \   00000000   0x........         DC32     poweroff_det_high_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable143_15:
   \   00000000   0x........         DC32     poweroff_det_high_cnt

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Resume print?">`:
   \   00000000   0x52 0x65          DC8 "Resume print?"
   \              0x73 0x75    
   \              0x6D 0x65    
   \              0x20 0x70    
   \              0x72 0x69    
   \              0x6E 0x74    
   \              0x3F 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant ".cbddlp">`:
   \   00000000   0x2E 0x63          DC8 ".cbddlp"
   \              0x62 0x64    
   \              0x64 0x6C    
   \              0x70 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant ".CBDDLP">`:
   \   00000000   0x2E 0x43          DC8 ".CBDDLP"
   \              0x42 0x44    
   \              0x44 0x4C    
   \              0x50 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant ".photon">`:
   \   00000000   0x2E 0x70          DC8 ".photon"
   \              0x68 0x6F    
   \              0x74 0x6F    
   \              0x6E 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant ".PHOTON">`:
   \   00000000   0x2E 0x50          DC8 ".PHOTON"
   \              0x48 0x4F    
   \              0x54 0x4F    
   \              0x4E 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable144:
   \   00000000   0x47 0x32          DC8      "G28"
   \              0x38 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable144_1:
   \   00000000   0x........         DC32     wifi_check_time

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable145:
   \   00000000   0x00000000         DC32     0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable146:
   \   00000000   0x2F 0x00          DC8      "/",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable147:
   \   00000000   0x76313030         DC32     0x76313030

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "totalTime(s):">`:
   \   00000000   0x74 0x6F          DC8 "totalTime(s):"
   \              0x74 0x61    
   \              0x6C 0x54    
   \              0x69 0x6D    
   \              0x65 0x28    
   \              0x73 0x29    
   \              0x3A 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable150:
   \   00000000   0x008DB937         DC32     0x8db937

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable150_1:
   \   00000000   0x0043CDFF         DC32     0x43cdff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable150_2:
   \   00000000   0x00AAAAAA         DC32     0xaaaaaa

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Move Z offset:">`:
   \   00000000   0x4D 0x6F          DC8 "Move Z offset:"
   \              0x76 0x65    
   \              0x20 0x5A    
   \              0x20 0x6F    
   \              0x66 0x66    
   \              0x73 0x65    
   \              0x74 0x3A    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Reset Z:">`:
   \   00000000   0x52 0x65          DC8 "Reset Z:"
   \              0x73 0x65    
   \              0x74 0x20    
   \              0x5A 0x3A    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable151:
   \   00000000   0x........         DC32     wifiPara

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable151_1:
   \   00000000   0x........         DC32     ipPara

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "print end.\\n">`:
   \   00000000   0x70 0x72          DC8 "print end.\012"
   \              0x69 0x6E    
   \              0x74 0x20    
   \              0x65 0x6E    
   \              0x64 0x2E    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable152:
   \   00000000   0x........         DC32     BMP_PIC_X

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable152_1:
   \   00000000   0x........         DC32     card

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable153:
   \   00000000   0x42F00000         DC32     0x42f00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable153_1:
   \   00000000   0x........         DC32     BMP_PIC_Y

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable153_2:
   \   00000000   0x........         DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "MKSDLP">`:
   \   00000000   0x4D 0x4B          DC8 "MKSDLP"
   \              0x53 0x44    
   \              0x4C 0x50    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable156:
   \   00000000   0x........         DC32     pause_resum

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable157:
   \   00000000   0x........         DC32     axis_relative_modes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable157_1:
   \   00000000   0x........         DC32     gArrayGpioPin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable157_2:
   \   00000000   0x........         DC32     gArrayGpioPort

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable159:
   \   00000000   0x........         DC32     soft_endstops_enabled

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable160:
   \   00000000   0x........         DC32     leveling_first_time

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable161:
   \   00000000   0x........         DC32     card+0xCCC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable162:
   \   00000000   0x........         DC32     curFileName

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable163:
   \   00000000   0x........         DC32     logo_tick2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable163_1:
   \   00000000   0x........         DC32     logo_tick1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable163_2:
   \   00000000   0x........         DC32     gCfgItems

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable163_3:
   \   00000000   0x........         DC32     from_flash_pic

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable163_4:
   \   00000000   0x........         DC32     flash_preview_begin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable163_5:
   \   00000000   0x........         DC32     default_preview_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable163_6:
   \   00000000   0x........         DC32     continue_print_error_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable164:
   \   00000000   0x........         DC32     card+0xE00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable164_1:
   \   00000000   0x........         DC32     Serial6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable165:
   \   00000000   0x........         DC32     card

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable165_1:
   \   00000000   0x42F00000         DC32     0x42f00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable165_2:
   \   00000000   0x000186AF         DC32     0x186af

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable167:
   \   00000000   0x0002FA37         DC32     0x2fa37

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable168:
   \   00000000   0x42F00000         DC32     0x42f00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable169:
   \   00000000   0x........         DC32     `?<Constant "G28 Z0">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable169_1:
   \   00000000   0x4240029C         DC32     0x4240029c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable169_2:
   \   00000000   0x........         DC32     reTransmission_zero_cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable169_3:
   \   00000000   0x........         DC32     hspi1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable169_4:
   \   00000000   0x........         DC32     hdma_spi1_tx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable169_5:
   \   00000000   0x42408200         DC32     0x42408200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable169_6:
   \   00000000   0x........         DC32     card+0xE10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable169_7:
   \   00000000   0x........         DC32     bmp_layer_buf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable169_8:
   \   00000000   0x........         DC32     axis_relative_modes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable169_9:
   \   00000000   0x........         DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable169_10:
   \   00000000   0x........         DC32     card+0xDD4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable169_11:
   \   00000000   0x42420288         DC32     0x42420288

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable169_12:
   \   00000000   0x........         DC32     card

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable170:
   \   00000000   0x........         DC32     bmp_layer_buf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable170_1:
   \   00000000   0x........         DC32     card

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable170_2:
   \   00000000   0x........         DC32     hdma_spi1_tx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable170_3:
   \   00000000   0x4240029C         DC32     0x4240029c

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "led on:">`:
   \   00000000   0x6C 0x65          DC8 "led on:"
   \              0x64 0x20    
   \              0x6F 0x6E    
   \              0x3A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "ssd dev is error!\\r\\n\\n">`:
   \   00000000   0x73 0x73          DC8 "ssd dev is error!\015\012\012"
   \              0x64 0x20    
   \              0x64 0x65    
   \              0x76 0x20    
   \              0x69 0x73    
   \              0x20 0x65    
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x21 0x0D    
   \              0x0A 0x0A    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "CPLD VER:">`:
   \   00000000   0x43 0x50          DC8 "CPLD VER:"
   \              0x4C 0x44    
   \              0x20 0x56    
   \              0x45 0x52    
   \              0x3A 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable189:
   \   00000000   0x42F00000         DC32     0x42f00000

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "resume:">`:
   \   00000000   0x72 0x65          DC8 "resume:"
   \              0x73 0x75    
   \              0x6D 0x65    
   \              0x3A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable194:
   \   00000000   0x42F00000         DC32     0x42f00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable194_1:
   \   00000000   0x........         DC32     bmp_layer_buf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable194_2:
   \   00000000   0x42420288         DC32     0x42420288

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable194_3:
   \   00000000   0x........         DC32     mipi_te_cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable195:
   \   00000000   0x........         DC32     disp_state

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable195_1:
   \   00000000   0x........         DC32     card+0x9C4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable195_2:
   \   00000000   0x........         DC32     Serial6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable196:
   \   00000000   0x42408284         DC32     0x42408284

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable197:
   \   00000000   0x42400290         DC32     0x42400290

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable198:
   \   00000000   0x4240029C         DC32     0x4240029c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable201:
   \   00000000   0x........         DC32     gCfgItems

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable201_1:
   \   00000000   0x4242028C         DC32     0x4242028c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable201_2:
   \   00000000   0x........         DC32     card

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable201_3:
   \   00000000   0x3FE00000         DC32     0x3fe00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable201_4:
   \   00000000   0x42F00000         DC32     0x42f00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable201_5:
   \   00000000   0x........         DC32     print_time

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable201_6:
   \   00000000   0x........         DC32     axis_relative_modes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable201_7:
   \   00000000   0x........         DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable204:
   \   00000000   0x........         DC32     gArrayGpioPin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable204_1:
   \   00000000   0x........         DC32     gArrayGpioPort

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable204_2:
   \   00000000   0x447A0000         DC32     0x447a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable204_3:
   \   00000000   0x00000000         DC32     0x0,0x3FE00000
   \              0x3FE00000   

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable204_4:
   \   00000000   0x424082B4         DC32     0x424082b4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable204_5:
   \   00000000   0x00000000         DC32     0x0,0x408F4000
   \              0x408F4000   

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable205:
   \   00000000   0x........         DC32     _ZN7Stepper23cleaning_buffer_counterE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable207:
   \   00000000   0x43910000         DC32     0x43910000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable207_1:
   \   00000000   0x42E80000         DC32     0x42e80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable210:
   \   00000000   0x........         DC32     card+0xCCC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable210_1:
   \   00000000   0x........         DC32     bmp_layer_buf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable210_2:
   \   00000000   0x........         DC32     card

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable210_3:
   \   00000000   0x........         DC32     preview_pic1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable210_4:
   \   00000000   0x........         DC32     bmp_public_buf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable210_5:
   \   00000000   0x........         DC32     print_para

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable210_6:
   \   00000000   0x........         DC32     layer_def

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable210_7:
   \   00000000   0x........         DC32     card+0xCB6

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "G28 Z0">`:
   \   00000000   0x47 0x32          DC8 "G28 Z0"
   \              0x38 0x20    
   \              0x5A 0x30    
   \              0x00         
   \   00000007   0x00               DC8 0
  15513          
  15514          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   CRC16_XMODEM(unsigned char *, unsigned int)
       0   CardReader::eof()
      16   CardReader::gets(BYTE *, UINT)
        16   -> f_read
       0   CardReader::isFileOpen()
       0   CardReader::setIndex(long)
         0   -> f_lseek
       0   EXTI9_5_IRQHandler
       0   Endstops::enable(bool)
       0   Endstops::enable_globally(bool)
       0   Endstops::hit_on_purpose()
       0   Endstops::not_homing()
       8   FlushSerialRequestResend()
         8   -> Print::print(long, int)
         8   -> USARTClass::flush()
         8   -> USARTClass::write(uint8_t)
         0   -> ok_to_send()
         8   -> serialprintPGM(char const *)
       8   GCodeParser::boolval(char)
         0   -> GCodeParser::seen(char)
         8   -> GCodeParser::seenval(char)
         0   -> GCodeParser::value_bool()
       8   GCodeParser::byteval(char, uint8_t)
         8   -> GCodeParser::seenval(char)
         8   -> GCodeParser::value_byte()
      16   GCodeParser::celsiusval(char, float)
        16   -> GCodeParser::seenval(char)
        16   -> GCodeParser::value_celsius()
       0   GCodeParser::has_value()
       8   GCodeParser::intval(char, int16_t)
         8   -> GCodeParser::seenval(char)
         8   -> GCodeParser::value_int()
      16   GCodeParser::linearval(char, float)
        16   -> GCodeParser::seenval(char)
        16   -> GCodeParser::value_linear_units()
       0   GCodeParser::seen(char)
       8   GCodeParser::seenval(char)
         0   -> GCodeParser::has_value()
         8   -> GCodeParser::seen(char)
       8   GCodeParser::ushortval(char, uint16_t)
         8   -> GCodeParser::seenval(char)
         8   -> GCodeParser::value_ushort()
       0   GCodeParser::value_axis_units(AxisEnum)
         0   -> GCodeParser::value_float()
       8   GCodeParser::value_bool()
         8   -> GCodeParser::has_value()
         8   -> GCodeParser::value_byte()
       8   GCodeParser::value_byte()
         8   -> GCodeParser::value_long()
       0   GCodeParser::value_celsius()
         0   -> GCodeParser::value_float()
       0   GCodeParser::value_feedrate()
         0   -> GCodeParser::value_linear_units()
      16   GCodeParser::value_float()
        16   -> __aeabi_d2f
        16   -> strtod
       8   GCodeParser::value_int()
         8   -> GCodeParser::value_long()
       0   GCodeParser::value_linear_units()
         0   -> GCodeParser::value_float()
       0   GCodeParser::value_long()
         0   -> strtol
       0   GCodeParser::value_millis()
         0   -> GCodeParser::value_ulong()
       8   GCodeParser::value_millis_from_seconds()
         8   -> GCodeParser::value_float()
       0   GCodeParser::value_per_axis_unit(AxisEnum)
         0   -> GCodeParser::value_float()
       0   GCodeParser::value_ulong()
         0   -> strtoul
       8   GCodeParser::value_ushort()
         8   -> GCodeParser::value_long()
      12   InvertUint16(unsigned short *, unsigned short *)
      12   InvertUint8(unsigned char *, unsigned char *)
       0   IsRunning()
       0   IsStopped()
      32   MKS_DLP::Can_Resume_Print()
        32   -> epr_read_data
       8   MKS_DLP::CleanDataTrans()
         8   -> MKS_DLP::bank2disp_enable(uint8_t, uint8_t, uint8_t)
         0   -> MKS_DLP::line_fill_all_zero(char, uint16_t, uint8_t)
       8   MKS_DLP::ExposureAll_off()
         8   -> HAL_Delay
         0   -> MKS_DLP::CleanDataTrans()
         8   -> MKS_DLP::ExposureDataTrans_circle()
         8   -> MKS_DLP::bank2disp_enable(uint8_t, uint8_t, uint8_t)
         8   -> SSD2828::sleep_in()
       8   MKS_DLP::ExposureAll_on()
         8   -> MKS_DLP::bank2disp_enable(uint8_t, uint8_t, uint8_t)
         8   -> MKS_DLP::line_fill_all_one(uint8_t)
         8   -> SSD2828::sleep_out()
      16   MKS_DLP::ExposureData2TFT_circle()
        16   -> MKS_DLP::line_fill_all_zero(char, uint16_t, uint8_t)
        16   -> MKS_DLP::line_gen_data_TFT(uint16_t)
        16   -> memset
      16   MKS_DLP::ExposureDataTrans_circle()
        16   -> MKS_DLP::bank2disp_enable(uint8_t, uint8_t, uint8_t)
         0   -> MKS_DLP::line_fill_all_zero(char, uint16_t, uint8_t)
        16   -> MKS_DLP::line_fill_all_zero(char, uint16_t, uint8_t)
        16   -> MKS_DLP::line_gen_data(uint16_t, uint8_t)
        16   -> MKS_DLP::line_gen_data_TFT(uint16_t)
        16   -> memset
      16   MKS_DLP::ExposureDataTrans_square()
        16   -> MKS_DLP::bank2disp_enable(uint8_t, uint8_t, uint8_t)
         0   -> MKS_DLP::line_fill_all_zero(char, uint16_t, uint8_t)
        16   -> MKS_DLP::line_fill_all_zero(char, uint16_t, uint8_t)
        16   -> MKS_DLP::line_gen_data(uint16_t, uint8_t)
        16   -> MKS_DLP::line_gen_data_TFT(uint16_t)
        16   -> memset
      24   MKS_DLP::ExposureTest()
        24   -> HAL_Delay
        24   -> MKS_DLP::ExposureData2TFT_circle()
        24   -> MKS_DLP::bank2disp_enable(uint8_t, uint8_t, uint8_t)
        24   -> SSD2828::sleep_in()
        24   -> SSD2828::sleep_out()
        24   -> clr_ticket()
         0   -> exposure_msg_display
        24   -> exposure_msg_display
        24   -> idle()
        24   -> layer_pic_clean
        24   -> layer_pic_display
      32   MKS_DLP::GeneralLayersPrint()
        32   -> MKS_DLP::CleanDataTrans()
        32   -> MKS_DLP::ExposureDataTrans_circle()
        32   -> MKS_DLP::bank2disp_enable(uint8_t, uint8_t, uint8_t)
        32   -> MKS_DLP::led_off()
        32   -> MKS_DLP::led_on()
        32   -> MKS_DLP::moveRelativeZandGetBmp(float, float)
        32   -> MKS_DLP::moveRelative_Z(float, float)
        32   -> MKS_DLP::printingHasFinished()
        32   -> MKS_DLP::write_Information_layer(DLP_MOVE_STATUS)
        32   -> clr_ticket()
        32   -> report_mksdlp_position()
       8   MKS_DLP::Is_Paused_Finished()
         8   -> epr_read_data
       8   MKS_DLP::MKS_DLP()
         8   -> SSD2828::SSD2828()
       8   MKS_DLP::PrintStatePolling()
         8   -> Planner::blocks_queued()
         0   -> quickstop_stepper()
      16   MKS_DLP::TFT_display_test()
        16   -> exposure_msg_display
        16   -> idle()
        16   -> layer_pic_display
        16   -> memset
      24   MKS_DLP::bank2disp_enable(uint8_t, uint8_t, uint8_t)
        24   -> MKS_DLP::bank2disp_read()
        24   -> SPI1_ReadWriteByte
      24   MKS_DLP::bank2disp_enable_gray(uint8_t, uint8_t, uint8_t, uint8_t)
        24   -> MKS_DLP::bank2disp_read()
        24   -> SPI1_ReadWriteByte
       8   MKS_DLP::bank2disp_read()
         8   -> SPI1_ReadWriteByte
      32   MKS_DLP::bottomLayerPrint()
        32   -> MKS_DLP::CleanDataTrans()
        32   -> MKS_DLP::GeneralLayersPrint()
        32   -> MKS_DLP::bank2disp_enable(uint8_t, uint8_t, uint8_t)
        32   -> MKS_DLP::decode_layer_from_rle(uint32_t, uint8_t)
        32   -> MKS_DLP::get_sdcard_bmps()
        32   -> MKS_DLP::led_off()
        32   -> MKS_DLP::led_on()
        32   -> MKS_DLP::moveRelative_Z(float, float)
        32   -> MKS_DLP::write_Information_layer(DLP_MOVE_STATUS)
        32   -> Stepper::synchronize()
        32   -> clr_ticket()
        32   -> do_blocking_move_to_z(float const &, float const &)
        32   -> report_current_position()
        32   -> report_mksdlp_position()
       8   MKS_DLP::buzzer_enable(uint8_t)
         8   -> AT24CXX_Write
       0   MKS_DLP::buzzer_polling()
       8   MKS_DLP::buzzer_tone(uint16_t, uint16_t, uint8_t)
      24   MKS_DLP::clean_Information_layer()
        24   -> epr_write_data
      32   MKS_DLP::contiuePrint_Pwdwn()
        32   -> CardReader::setIndex(long)
        32   -> MKS_DLP::decode_layer_from_rle(uint32_t, uint8_t)
        32   -> MKS_DLP::getHead1()
        32   -> MKS_DLP::get_Height()
        32   -> MKS_DLP::get_sdcard_bmps()
        32   -> Stepper::synchronize()
        32   -> do_blocking_move_to_z(float const &, float const &)
        32   -> gcode_M24()
        32   -> mks_setPositionZ
        32   -> report_current_position()
      24   MKS_DLP::contiuePrint_paused()
        24   -> CardReader::setIndex(long)
        24   -> MKS_DLP::decode_layer_from_rle(uint32_t, uint8_t)
        24   -> MKS_DLP::getHead1()
        24   -> MKS_DLP::get_Height()
        24   -> MKS_DLP::get_sdcard_bmps()
        24   -> Stepper::synchronize()
        24   -> do_blocking_move_to_z(float const &, float const &)
        24   -> gcode_M24()
        24   -> report_current_position()
      48   MKS_DLP::decode_layer_from_rle(uint32_t, uint8_t)
        48   -> CardReader::gets(BYTE *, UINT)
        48   -> CardReader::setIndex(long)
        48   -> MKS_DLP::get_cbddlp_cur_layer_def(uint32_t)
        48   -> MKS_DLP::line_gen_data(uint16_t, uint8_t)
        48   -> MKS_DLP::line_gen_data_TFT(uint16_t)
        48   -> memset
       8   MKS_DLP::dlp_start()
         8   -> AT24CXX_Read
         8   -> MKS_DLP::CleanDataTrans()
         8   -> MKS_DLP::ExposureDataTrans_circle()
         8   -> MKS_DLP::get_cpld_ver()
         8   -> Print::print(unsigned char, int)
         8   -> SSD2828::init()
         8   -> serialprintPGM(char const *)
       8   MKS_DLP::draw_printing()
         0   -> CardReader::setIndex(long)
         8   -> GUI_Exec
         8   -> MKS_DLP::getHead1()
         8   -> MKS_DLP::get_cbddlp_file_header()
         8   -> display_print_statue
         8   -> draw_status_clear
         8   -> setProBarRate
       8   MKS_DLP::draw_return_printing_ui()
         8   -> GUI_Exec
         8   -> display_print_statue
         8   -> layer_pic_display
         8   -> setProBarRate
      48   MKS_DLP::getHead()
        48   -> CardReader::gets(BYTE *, UINT)
        48   -> CardReader::printingHasFinished()
        48   -> CardReader::setIndex(long)
        48   -> MKS_DLP::set_BottomLedOnTime(uint16_t)
        48   -> MKS_DLP::set_Bottomlayers(uint16_t)
        48   -> MKS_DLP::set_LedOffTime(uint16_t)
        48   -> MKS_DLP::set_LedOnTime(uint16_t)
        48   -> MKS_DLP::status_init()
        48   -> memcpy
        48   -> strstr(char *, char const *)
        48   -> strting2float(BYTE *, BYTE)
      48   MKS_DLP::getHead1()
        48   -> CardReader::gets(BYTE *, UINT)
        48   -> CardReader::printingHasFinished()
        48   -> CardReader::setIndex(long)
        48   -> memcpy
        48   -> strstr(char *, char const *)
        48   -> strting2float(BYTE *, BYTE)
      48   MKS_DLP::getHead2()
        48   -> CardReader::gets(BYTE *, UINT)
        48   -> MKS_DLP::set_BottomLedOnTime(uint16_t)
        48   -> MKS_DLP::set_Bottomlayers(uint16_t)
        48   -> MKS_DLP::set_LedOffTime(uint16_t)
        48   -> MKS_DLP::set_LedOnTime(uint16_t)
       0   MKS_DLP::get_BottomLedOnTime()
       0   MKS_DLP::get_Bottomlayers()
       0   MKS_DLP::get_Height()
       0   MKS_DLP::get_LedOffTime()
       0   MKS_DLP::get_LedOnTime()
      16   MKS_DLP::get_available_bmps()
        16   -> CardReader::eof()
         0   -> MKS_DLP::GeneralLayersPrint()
         0   -> MKS_DLP::bottomLayerPrint()
         0   -> MKS_DLP::printingHasFinished()
       0   MKS_DLP::get_buzzer_status()
      56   MKS_DLP::get_cbddlp_cur_layer_def(uint32_t)
        56   -> CardReader::gets(BYTE *, UINT)
        56   -> CardReader::setIndex(long)
        56   -> memcpy
      56   MKS_DLP::get_cbddlp_file_header()
        56   -> CardReader::gets(BYTE *, UINT)
        56   -> __aeabi_d2uiz
        56   -> __aeabi_dadd
        56   -> __aeabi_ddiv
        56   -> __aeabi_dmul
        56   -> __aeabi_f2d
        56   -> __aeabi_i2d
        56   -> memcpy
      16   MKS_DLP::get_cbddlp_preview1_info()
        16   -> CardReader::gets(BYTE *, UINT)
        16   -> CardReader::setIndex(long)
      16   MKS_DLP::get_cbddlp_preview2_info()
        16   -> CardReader::gets(BYTE *, UINT)
        16   -> CardReader::setIndex(long)
      24   MKS_DLP::get_cbddlp_print_para_info()
        24   -> CardReader::gets(BYTE *, UINT)
        24   -> CardReader::setIndex(long)
       8   MKS_DLP::get_cpld_ver()
         8   -> MKS_DLP::bank2disp_read()
       8   MKS_DLP::get_currentLayer()
         8   -> MKS_DLP::get_totalLayers()
      16   MKS_DLP::get_currentPrintTime()
        16   -> MKS_DLP::get_currentLayer()
      64   MKS_DLP::get_sdcard_bmps()
        64   -> CardReader::eof()
        64   -> CardReader::gets(BYTE *, UINT)
        64   -> CardReader::getsdpos()
        64   -> MKS_DLP::line_fill_all_zero(char, uint16_t, uint8_t)
        64   -> MKS_DLP::line_fill_zero(uint16_t, uint8_t)
        64   -> MKS_DLP::line_gen_data(uint16_t, uint8_t)
        64   -> MKS_DLP::line_gen_data_TFT(uint16_t)
        64   -> find_next_bmp()
        64   -> memset
       0   MKS_DLP::get_totalLayers()
      24   MKS_DLP::get_totalPrintTime()
        24   -> MKS_DLP::get_currentLayer()
        24   -> MKS_DLP::get_totalLayers()
        24   -> __aeabi_d2uiz
        24   -> __aeabi_dmul
        24   -> __aeabi_ui2d
       0   MKS_DLP::get_ttfStatus_OFF()
       0   MKS_DLP::get_ttfStatus_ON()
      32   MKS_DLP::grag_test()
        32   -> HAL_Delay
        32   -> MKS_DLP::ExposureData2TFT_circle()
        32   -> MKS_DLP::bank2disp_enable(uint8_t, uint8_t, uint8_t)
        32   -> MKS_DLP::bank2disp_enable_gray(uint8_t, uint8_t, uint8_t, uint8_t)
        32   -> SSD2828::sleep_in()
        32   -> SSD2828::sleep_out()
        32   -> clr_ticket()
        32   -> exposure_msg_display
        32   -> idle()
        32   -> layer_pic_clean
        32   -> layer_pic_display
      16   MKS_DLP::led_off()
        16   -> HAL_Delay
        16   -> MKS_DLP::bank2disp_enable(uint8_t, uint8_t, uint8_t)
        16   -> SSD2828::sleep_in()
        16   -> layer_pic_clean
      16   MKS_DLP::led_on()
         0   -> GUI_Exec
        16   -> MKS_DLP::get_currentLayer()
        16   -> Print::print(int, int)
        16   -> SSD2828::sleep_out()
        16   -> display_print_statue
        16   -> draw_status_clear
        16   -> layer_pic_display
        16   -> serialprintPGM(char const *)
        16   -> setProBarRate
      32   MKS_DLP::line_fill_all_one(uint8_t)
        32   -> CRC16_XMODEM(unsigned char *, unsigned int)
        32   -> HAL_SPI_Transmit_DMA
        32   -> MKS_DLP::reTransmission()
        32   -> memcpy
        32   -> memset
      32   MKS_DLP::line_fill_all_zero(char, uint16_t, uint8_t)
        32   -> CRC16_XMODEM(unsigned char *, unsigned int)
        32   -> HAL_SPI_Transmit_DMA
        32   -> MKS_DLP::reTransmission()
        32   -> memcpy
        32   -> memset
      16   MKS_DLP::line_fill_zero(uint16_t, uint8_t)
        16   -> CRC16_XMODEM(unsigned char *, unsigned int)
        16   -> HAL_SPI_Transmit_DMA
        16   -> MKS_DLP::reTransmission()
        16   -> memcpy
        16   -> memset
      24   MKS_DLP::line_gen_data(uint16_t, uint8_t)
        24   -> CRC16_XMODEM(unsigned char *, unsigned int)
        24   -> HAL_SPI_Transmit_DMA
        24   -> MKS_DLP::reTransmission()
        24   -> memcpy
        24   -> memset
      12   MKS_DLP::line_gen_data_TFT(uint16_t)
      24   MKS_DLP::moveFistLayer_Z()
        24   -> Print::print(double, int)
        24   -> Stepper::report_positions()
        24   -> Stepper::synchronize()
        24   -> __aeabi_f2d
        24   -> do_blocking_move_to_z(float const &, float const &)
        24   -> serialprintPGM(char const *)
       8   MKS_DLP::moveMax_Z()
         8   -> Stepper::synchronize()
         8   -> do_blocking_move_to_z(float const &, float const &)
         8   -> report_current_position()
         8   -> serialprintPGM(char const *)
      24   MKS_DLP::moveRelativeZandGetBmp(float, float)
        24   -> MKS_DLP::decode_layer_from_rle(uint32_t, uint8_t)
        24   -> MKS_DLP::get_sdcard_bmps()
        24   -> Stepper::synchronize()
        24   -> do_blocking_move_to_z_nowait(float const &, float const &)
       8   MKS_DLP::moveRelative_Z(float, float)
         8   -> Stepper::synchronize()
         8   -> do_blocking_move_to_z(float const &, float const &)
       8   MKS_DLP::pausePrint()
         8   -> MKS_DLP::led_off()
       8   MKS_DLP::power_off()
         0   -> HAL_Delay
         8   -> HAL_Delay
      16   MKS_DLP::power_on()
         0   -> HAL_Delay
        16   -> HAL_Delay
      16   MKS_DLP::printingHasFinished()
        16   -> CardReader::printingHasFinished()
        16   -> HAL_GPIO_WritePin
        16   -> MKS_DLP::bank2disp_enable(uint8_t, uint8_t, uint8_t)
        16   -> MKS_DLP::buzzer_tone(uint16_t, uint16_t, uint8_t)
        16   -> MKS_DLP::led_off()
        16   -> MKS_DLP::moveMax_Z()
        16   -> clr_ticket()
        16   -> epr_write_data
       0   MKS_DLP::quick_stop()
         0   -> quickstop_stepper()
      24   MKS_DLP::reTransmission()
        24   -> HAL_SPI_Transmit_DMA
      16   MKS_DLP::read_Information_layer()
        16   -> MKS_DLP::Can_Resume_Print()
        16   -> epr_read_data
      24   MKS_DLP::read_Information_paused()
        24   -> epr_read_data
        24   -> mks_setPositionZ
      24   MKS_DLP::resumePrint()
        24   -> MKS_DLP::get_currentLayer()
        24   -> Stepper::synchronize()
        24   -> do_blocking_move_to_z(float const &, float const &)
        24   -> epr_write_data
        24   -> report_current_position()
        24   -> serialprintPGM(char const *)
      24   MKS_DLP::set_BottomLedOnTime(uint16_t)
        24   -> __aeabi_d2uiz
        24   -> __aeabi_dadd
        24   -> __aeabi_ddiv
        24   -> __aeabi_i2d
        24   -> __aeabi_ui2d
        24   -> epr_read_data
        24   -> epr_write_data
      16   MKS_DLP::set_Bottomlayers(uint16_t)
         0   -> epr_read_data
        16   -> epr_write_data
      16   MKS_DLP::set_LedOffTime(uint16_t)
         0   -> epr_read_data
        16   -> epr_write_data
      24   MKS_DLP::set_LedOnTime(uint16_t)
        24   -> __aeabi_d2uiz
        24   -> __aeabi_dadd
        24   -> __aeabi_ddiv
        24   -> __aeabi_i2d
        24   -> __aeabi_ui2d
        24   -> epr_read_data
        24   -> epr_write_data
       8   MKS_DLP::set_Zoffset()
         8   -> axis_unhomed_error(bool)
         8   -> gcode_M428()
         0   -> gcode_M500()
       0   MKS_DLP::set_test_exposure_time(uint16_t)
       8   MKS_DLP::startFileprint()
         8   -> GUI_Exec
         8   -> MKS_DLP::clean_Information_layer()
         8   -> MKS_DLP::getHead1()
         8   -> MKS_DLP::getHead2()
         8   -> MKS_DLP::status_init()
         8   -> SSD2828::init()
         8   -> display_print_statue
         8   -> draw_status_clear
         0   -> mks_G28(char *)
       8   MKS_DLP::startFileprint_cbd()
         8   -> GUI_Exec
         8   -> MKS_DLP::clean_Information_layer()
         8   -> MKS_DLP::get_cbddlp_file_header()
         8   -> MKS_DLP::get_cbddlp_preview1_info()
         8   -> MKS_DLP::get_cbddlp_preview2_info()
         8   -> MKS_DLP::get_cbddlp_print_para_info()
         8   -> MKS_DLP::status_init()
         8   -> SSD2828::init()
         8   -> display_print_statue
         8   -> draw_status_clear
         0   -> mks_G28(char *)
       8   MKS_DLP::status_init()
         8   -> MKS_DLP::get_totalPrintTime()
         0   -> Print::print(unsigned int, int)
         8   -> Stopwatch::start()
         8   -> clr_ticket()
         8   -> serialprintPGM(char const *)
       8   MKS_DLP::stopPrint()
         8   -> MKS_DLP::CleanDataTrans()
         8   -> MKS_DLP::ExposureDataTrans_circle()
         8   -> MKS_DLP::led_off()
         0   -> quickstop_stepper()
       0   MKS_DLP::subobject MKS_DLP()
         0   -> MKS_DLP::MKS_DLP()
      32   MKS_DLP::write_Information_layer(DLP_MOVE_STATUS)
        32   -> MKS_DLP::get_currentLayer()
        32   -> epr_write_data
      16   MKS_DLP::write_Information_paused()
        16   -> MKS_DLP::get_currentLayer()
        16   -> epr_write_data
       0   Planner::blocks_queued()
      24   Planner::buffer_line(float, float, float, float const &, float const &, uint8_t)
        24   -> Planner::buffer_segment(float const &, float const &, float const &, float const &, float const &, uint8_t)
      16   Planner::buffer_line_kinematic(float const (&)[4], float const &, uint8_t)
        16   -> Planner::buffer_segment(float const &, float const &, float const &, float const &, float const &, uint8_t)
      16   Planner::refresh_e_factor(uint8_t)
        16   -> __aeabi_d2f
        16   -> __aeabi_dmul
        16   -> __aeabi_f2d
        16   -> __aeabi_i2d
       0   Planner::set_e_position_mm(float const &)
         0   -> Planner::set_position_mm(AxisEnum, float const &)
       0   Planner::set_filament_size(uint8_t, float const &)
      16   Planner::set_position_mm(float, float, float, float const &)
        16   -> Planner::_set_position_mm(float const &, float const &, float const &, float const &)
       8   SysTick_Handler_User()
         8   -> mksBeeperAlarm()
       0   Temperature::degHotend(uint8_t)
       0   Temperature::degTargetHotend(uint8_t)
       0   Temperature::isCoolingHotend(uint8_t)
       0   Temperature::setTargetBed(float)
       0   Temperature::setTargetHotend(float, uint8_t)
         0   -> Temperature::start_watching_heater(uint8_t)
       0   Temperature::updatePID()
       8   __sti__routine()
         8   -> CardReader::CardReader()
         0   -> MKS_DLP::MKS_DLP()
         8   -> Stopwatch::Stopwatch()
       0   _commit_command(bool)
       8   _enqueuecommand(char const *, bool)
         8   -> _commit_command(bool)
         8   -> strcpy
       8   axis_unhomed_error(bool)
         8   -> serialprintPGM(char const *)
       0   base_home_pos(AxisEnum)
       0   base_max_pos(AxisEnum)
       0   base_min_pos(AxisEnum)
       0   btn_beeper
       0   buffer_line_to_current_position()
         0   -> Planner::buffer_line(float, float, float, float const &, float const &, uint8_t)
       8   buffer_line_to_destination(float)
         8   -> Planner::buffer_line(float, float, float, float const &, float const &, uint8_t)
      16   cap_line(char const *, bool)
        16   -> Print::print(int, int)
         0   -> USARTClass::write(uint8_t)
        16   -> serialprintPGM(char const *)
       0   clamp_to_software_endstops(float *)
       0   clean_up_after_endstop_or_probe_move()
         0   -> refresh_cmd_timeout()
       0   clear_command_queue()
       0   clr_ticket()
       8   disable_all_steppers()
         8   -> HAL_GPIO_WritePin
         0   -> disable_e_steppers()
       0   disable_e_steppers()
       8   display_temper_error()
         8   -> GUI_DispStringAt
         8   -> GUI_SetBkColor
         0   -> GUI_SetColor
         8   -> GUI_SetColor
      32   do_blocking_move_to(float const &, float const &, float const &, float const &)
        32   -> Stepper::synchronize()
        32   -> buffer_line_to_current_position()
      32   do_blocking_move_to_nowait(float const &, float const &, float const &, float const &)
        32   -> buffer_line_to_current_position()
       8   do_blocking_move_to_x(float const &, float const &)
         0   -> do_blocking_move_to(float const &, float const &, float const &, float const &)
       0   do_blocking_move_to_xy(float const &, float const &, float const &)
         0   -> do_blocking_move_to(float const &, float const &, float const &, float const &)
       8   do_blocking_move_to_z(float const &, float const &)
         0   -> do_blocking_move_to(float const &, float const &, float const &, float const &)
       8   do_blocking_move_to_z_nowait(float const &, float const &)
         0   -> do_blocking_move_to_nowait(float const &, float const &, float const &, float const &)
      32   do_homing_move(AxisEnum, float, float)
        32   -> Endstops::hit_on_purpose()
        32   -> Planner::buffer_line(float, float, float, float const &, float const &, uint8_t)
        32   -> Stepper::synchronize()
        32   -> sync_plan_position()
      48   drain_injected_commands_P()
        48   -> enqueue_and_echo_command(char const *, bool)
        48   -> strncpy
       8   duration_t::day() const
         8   -> duration_t::hour() const
       0   duration_t::duration_t(uint32_t const &)
       8   duration_t::hour() const
         8   -> duration_t::minute() const
       8   duration_t::minute() const
         8   -> duration_t::second() const
       0   duration_t::second() const
      48   duration_t::toString(char *) const
        48   -> duration_t::day() const
        48   -> duration_t::hour() const
        48   -> duration_t::minute() const
        48   -> duration_t::second() const
        48   -> duration_t::year() const
         0   -> sprintf
        48   -> sprintf
       8   duration_t::year() const
         8   -> duration_t::day() const
       8   dwell(millis_t)
         8   -> HAL_GetTick
         8   -> idle()
         8   -> refresh_cmd_timeout()
       0   enable_all_steppers()
         0   -> HAL_GPIO_WritePin
       8   enqueue_and_echo_command(char const *, bool)
         8   -> USARTClass::write(uint8_t)
         8   -> _enqueuecommand(char const *, bool)
         8   -> serial_echopair_P(char const *, char const *)
         8   -> serialprintPGM(char const *)
       0   enqueue_and_echo_commands_P(char const *)
         0   -> drain_injected_commands_P()
      48   find_next_bmp()
        48   -> CardReader::eof()
        48   -> CardReader::gets(BYTE *, UINT)
       0   freeMemory()
       8   gcode_G0_G1()
         8   -> IsRunning()
         8   -> gcode_get_destination()
         0   -> prepare_move_to_destination()
      32   gcode_G28(bool)
        32   -> Endstops::enable(bool)
        32   -> Endstops::not_homing()
        32   -> GCodeParser::seen(char)
        32   -> Stepper::synchronize()
        32   -> clean_up_after_endstop_or_probe_move()
        32   -> do_blocking_move_to_z(float const &, float const &)
        32   -> homeaxis(AxisEnum)
        32   -> lcd_refresh()
        32   -> report_current_position()
        32   -> set_destination_from_current()
        32   -> setup_for_endstop_or_probe_move()
        32   -> sync_plan_position()
      80   gcode_G2_G3(bool)
        80   -> GCodeParser::seenval(char)
        80   -> GCodeParser::value_linear_units()
        80   -> IsRunning()
        80   -> __aeabi_d2f
        80   -> __aeabi_dmul
        80   -> __aeabi_dsub
        80   -> __aeabi_f2d
        80   -> gcode_get_destination()
        80   -> plan_arc(float const (&)[4], float const (&)[2], bool)
        80   -> refresh_cmd_timeout()
        80   -> serialprintPGM(char const *)
        80   -> sqrt
        80   -> sqrtf
       8   gcode_G4()
         8   -> GCodeParser::seenval(char)
         8   -> GCodeParser::value_millis()
         8   -> GCodeParser::value_millis_from_seconds()
         8   -> Stepper::synchronize()
         0   -> dwell(millis_t)
         8   -> lcd_hasstatus()
         8   -> lcd_setstatusPGM(char const *, int8_t)
      16   gcode_G92()
        16   -> GCodeParser::seenval(char)
        16   -> GCodeParser::value_axis_units(AxisEnum)
        16   -> Stepper::synchronize()
         0   -> report_current_position()
        16   -> sync_plan_position()
        16   -> sync_plan_position_e()
      16   gcode_M104()
        16   -> GCodeParser::seenval(char)
        16   -> GCodeParser::value_celsius()
         0   -> Planner::autotemp_M104_M109()
        16   -> Stopwatch::stop()
        16   -> Temperature::degHotend(uint8_t)
        16   -> Temperature::setTargetHotend(float, uint8_t)
        16   -> get_target_extruder_from_command(uint16_t)
        16   -> lcd_setstatusPGM(char const *, int8_t)
       8   gcode_M105()
         0   -> USARTClass::write(uint8_t)
         8   -> get_target_extruder_from_command(uint16_t)
         8   -> serialprintPGM(char const *)
       8   gcode_M106()
         8   -> GCodeParser::byteval(char, uint8_t)
         8   -> GCodeParser::ushortval(char, uint16_t)
       8   gcode_M107()
         8   -> GCodeParser::ushortval(char, uint16_t)
       0   gcode_M108()
      48   gcode_M109()
        48   -> GCodeParser::seenval(char)
        48   -> GCodeParser::value_celsius()
        48   -> HAL_GetTick
        48   -> Planner::autotemp_M104_M109()
        48   -> Print::print(long, int)
        48   -> Stopwatch::start()
        48   -> Stopwatch::stop()
        48   -> Temperature::degHotend(uint8_t)
        48   -> Temperature::degTargetHotend(uint8_t)
        48   -> Temperature::isCoolingHotend(uint8_t)
        48   -> Temperature::setTargetHotend(float, uint8_t)
        48   -> USARTClass::write(uint8_t)
        48   -> get_target_extruder_from_command(uint16_t)
        48   -> idle()
         0   -> lcd_setstatusPGM(char const *, int8_t)
        48   -> lcd_setstatusPGM(char const *, int8_t)
        48   -> refresh_cmd_timeout()
        48   -> serialprintPGM(char const *)
       8   gcode_M110()
         8   -> GCodeParser::seenval(char)
         8   -> GCodeParser::value_long()
      16   gcode_M111()
        16   -> GCodeParser::byteval(char, uint8_t)
        16   -> GCodeParser::seen(char)
         0   -> USARTClass::write(uint8_t)
        16   -> USARTClass::write(uint8_t)
        16   -> serialprintPGM(char const *)
       0   gcode_M112()
         0   -> kill(char const *)
       8   gcode_M114()
         8   -> Stepper::synchronize()
         0   -> report_current_position()
       8   gcode_M115()
         0   -> cap_line(char const *, bool)
         8   -> cap_line(char const *, bool)
         8   -> serialprintPGM(char const *)
       0   gcode_M117()
         0   -> lcd_setstatus(char const *, bool)
       8   gcode_M118()
         8   -> GCodeParser::boolval(char)
         8   -> Print::print(char const *)
         0   -> USARTClass::write(uint8_t)
         8   -> serialprintPGM(char const *)
       0   gcode_M119()
         0   -> Endstops::M119()
       0   gcode_M120()
         0   -> Endstops::enable_globally(bool)
       0   gcode_M121()
         0   -> Endstops::enable_globally(bool)
       8   gcode_M140()
         8   -> GCodeParser::seenval(char)
         8   -> GCodeParser::value_celsius()
         0   -> Temperature::setTargetBed(float)
       8   gcode_M17()
         0   -> enable_all_steppers()
         8   -> lcd_setstatusPGM(char const *, int8_t)
       8   gcode_M18_M84()
         8   -> GCodeParser::seen(char)
         8   -> GCodeParser::seenval(char)
         8   -> GCodeParser::value_millis_from_seconds()
         8   -> HAL_GPIO_WritePin
         0   -> Stepper::finish_and_disable()
         8   -> Stepper::synchronize()
       8   gcode_M20()
         8   -> CardReader::ls()
         0   -> serialprintPGM(char const *)
         8   -> serialprintPGM(char const *)
      16   gcode_M200()
        16   -> GCodeParser::seen(char)
        16   -> GCodeParser::value_linear_units()
        16   -> Planner::calculate_volumetric_multipliers()
        16   -> Planner::set_filament_size(uint8_t, float const &)
        16   -> get_target_extruder_from_command(uint16_t)
      16   gcode_M201()
        16   -> GCodeParser::seen(char)
        16   -> GCodeParser::value_axis_units(AxisEnum)
         0   -> Planner::reset_acceleration_rates()
      16   gcode_M203()
        16   -> GCodeParser::seen(char)
        16   -> GCodeParser::value_axis_units(AxisEnum)
       8   gcode_M204()
         8   -> GCodeParser::seen(char)
         8   -> GCodeParser::value_linear_units()
         0   -> USARTClass::write(uint8_t)
         8   -> USARTClass::write(uint8_t)
         8   -> serial_echopair_P(char const *, float)
       8   gcode_M205()
         8   -> GCodeParser::seen(char)
         8   -> GCodeParser::value_linear_units()
         8   -> GCodeParser::value_ulong()
       8   gcode_M206()
         8   -> GCodeParser::seen(char)
         8   -> GCodeParser::value_linear_units()
         0   -> report_current_position()
         8   -> set_home_offset(AxisEnum, float)
      24   gcode_M211()
        24   -> GCodeParser::seen(char)
        24   -> GCodeParser::value_bool()
         0   -> USARTClass::write(uint8_t)
        24   -> serial_echopair_P(char const *, float)
        24   -> serialprintPGM(char const *)
       0   gcode_M22()
         0   -> CardReader::release()
       8   gcode_M220()
         8   -> GCodeParser::seenval(char)
         8   -> GCodeParser::value_int()
       8   gcode_M221()
         8   -> GCodeParser::seenval(char)
         8   -> GCodeParser::value_int()
         0   -> Planner::refresh_e_factor(uint8_t)
         8   -> get_target_extruder_from_command(uint16_t)
      16   gcode_M226()
        16   -> GCodeParser::intval(char, int16_t)
        16   -> GCodeParser::seen(char)
        16   -> GCodeParser::value_int()
        16   -> HAL_GPIO_ReadPin
        16   -> Stepper::synchronize()
        16   -> idle()
        16   -> pin_is_protected(int8_t)
       8   gcode_M23()
         8   -> CardReader::openFile(char *, bool, bool)
         0   -> strcpy
       8   gcode_M24()
         8   -> CardReader::startFileprint()
         0   -> Stopwatch::start()
         8   -> mks_resumePrint
       8   gcode_M25()
         8   -> CardReader::pauseSDPrint()
         8   -> Stopwatch::pause()
       8   gcode_M26()
         0   -> CardReader::setIndex(long)
         8   -> GCodeParser::seenval(char)
         8   -> GCodeParser::value_long()
       0   gcode_M27()
         0   -> CardReader::getStatus()
       0   gcode_M28()
         0   -> CardReader::openFile(char *, bool, bool)
       0   gcode_M29()
       8   gcode_M30()
         8   -> CardReader::closefile(bool)
         0   -> CardReader::removeFile(char *)
       8   gcode_M301()
         8   -> GCodeParser::byteval(char, uint8_t)
         8   -> GCodeParser::seen(char)
         8   -> GCodeParser::value_float()
         8   -> Print::print(char const *)
         8   -> Temperature::updatePID()
         0   -> USARTClass::write(uint8_t)
         8   -> __aeabi_d2f
         8   -> __aeabi_ddiv
         8   -> __aeabi_dmul
         8   -> __aeabi_f2d
         8   -> serial_echopair_P(char const *, double)
         8   -> serial_echopair_P(char const *, float)
         8   -> serialprintPGM(char const *)
      16   gcode_M303()
        16   -> GCodeParser::boolval(char)
        16   -> GCodeParser::celsiusval(char, float)
        16   -> GCodeParser::intval(char, int16_t)
         0   -> Temperature::PID_autotune(float, int8_t, int8_t, bool)
      40   gcode_M31()
        40   -> Stopwatch::duration()
        40   -> USARTClass::write(uint8_t)
        40   -> duration_t::duration_t(uint32_t const &)
        40   -> duration_t::toString(char *) const
        40   -> lcd_setstatus(char const *, bool)
        40   -> serial_echopair_P(char const *, char const *)
        40   -> serialprintPGM(char const *)
      16   gcode_M32()
        16   -> CardReader::openFile(char *, bool, bool)
        16   -> CardReader::setIndex(long)
        16   -> CardReader::startFileprint()
        16   -> GCodeParser::boolval(char)
        16   -> GCodeParser::seenval(char)
        16   -> GCodeParser::value_long()
        16   -> Stepper::synchronize()
         0   -> Stopwatch::start()
       8   gcode_M355()
         0   -> serialprintPGM(char const *)
         8   -> serialprintPGM(char const *)
       0   gcode_M400()
         0   -> Stepper::synchronize()
       0   gcode_M410()
         0   -> quickstop_stepper()
      16   gcode_M42()
        16   -> GCodeParser::intval(char, int16_t)
        16   -> GCodeParser::seenval(char)
        16   -> GCodeParser::value_byte()
        16   -> HAL_GPIO_WritePin
        16   -> pin_is_protected(int8_t)
         0   -> serialprintPGM(char const *)
        16   -> serialprintPGM(char const *)
      40   gcode_M428()
        40   -> axis_unhomed_error(bool)
        40   -> base_home_pos(AxisEnum)
        40   -> home_dir(AxisEnum)
        40   -> lcd_setalertstatusPGM(char const *)
        40   -> lcd_setstatusPGM(char const *, int8_t)
        40   -> report_current_position()
        40   -> serialprintPGM(char const *)
        40   -> set_home_offset(AxisEnum, float)
       0   gcode_M500()
         0   -> MarlinSettings::save()
       0   gcode_M501()
         0   -> MarlinSettings::load()
       0   gcode_M502()
         0   -> MarlinSettings::reset()
       8   gcode_M503()
         8   -> GCodeParser::seen(char)
         8   -> GCodeParser::value_bool()
         0   -> MarlinSettings::report(bool)
       0   gcode_M75()
         0   -> Stopwatch::start()
       0   gcode_M76()
         0   -> Stopwatch::pause()
       0   gcode_M77()
         0   -> Stopwatch::stop()
       8   gcode_M81()
         8   -> Stepper::finish_and_disable()
         8   -> Temperature::disable_all_heaters()
         0   -> safe_delay(millis_t)
       0   gcode_M82()
       0   gcode_M83()
       8   gcode_M85()
         8   -> GCodeParser::seen(char)
         8   -> GCodeParser::value_millis_from_seconds()
       0   gcode_M907()
      16   gcode_M92()
        16   -> GCodeParser::seen(char)
        16   -> GCodeParser::value_per_axis_unit(AxisEnum)
         0   -> Planner::refresh_positioning()
       0   gcode_M928()
         0   -> CardReader::openLogFile(char *)
       8   gcode_M998()
         8   -> CardReader::stopSDPrint()
         8   -> Stopwatch::stop()
         8   -> Temperature::disable_all_heaters()
         8   -> clear_command_queue()
         8   -> epr_write_data
         8   -> quickstop_stepper()
       8   gcode_M999()
         0   -> FlushSerialRequestResend()
         8   -> GCodeParser::boolval(char)
         8   -> lcd_reset_alert_level()
       0   gcode_T(uint8_t)
         0   -> tool_change(uint8_t, float, bool)
      16   gcode_get_destination()
        16   -> GCodeParser::linearval(char, float)
        16   -> GCodeParser::seen(char)
        16   -> GCodeParser::value_axis_units(AxisEnum)
        16   -> GCodeParser::value_feedrate()
      16   gcode_line_error(char const *, bool)
        16   -> FlushSerialRequestResend()
        16   -> Print::print(long, int)
        16   -> USARTClass::write(uint8_t)
        16   -> serialprintPGM(char const *)
       8   get_available_commands()
         8   -> drain_injected_commands_P()
         8   -> get_serial_commands()
         0   -> get_wifi_commands()
       8   get_cartesian_from_steppers()
         8   -> Stepper::get_axis_position_mm(AxisEnum)
      32   get_homing_bump_feedrate(AxisEnum)
        32   -> serialprintPGM(char const *)
    4072   get_pic_display
      4072   -> CardReader::close_CBD_File()
      4072   -> CardReader::gets(BYTE *, UINT)
      4072   -> CardReader::setIndex(long)
      4072   -> LCD_WriteRAM
      4072   -> LCD_WriteRAM_Prepare
      4072   -> LCD_setWindowArea
      4072   -> memset
       8   get_pic_info
         8   -> CardReader::open_CBD_File(char *)
         8   -> MKS_DLP::get_cbddlp_file_header()
         8   -> MKS_DLP::get_cbddlp_preview1_info()
         0   -> MKS_DLP::get_cbddlp_preview2_info()
      24   get_serial_commands()
        24   -> HAL_GetTick
        24   -> IsStopped()
        24   -> USARTClass::available()
        24   -> USARTClass::read()
        24   -> _enqueuecommand(char const *, bool)
         0   -> gcode_line_error(char const *, bool)
        24   -> kill(char const *)
        24   -> lcd_setstatusPGM(char const *, int8_t)
        24   -> quickstop_stepper()
        24   -> serialprintPGM(char const *)
        24   -> strchr(char *, int)
        24   -> strcmp
        24   -> strrchr(char *, int)
        24   -> strstr(char *, char const *)
        24   -> strtol
      16   get_target_extruder_from_command(uint16_t)
        16   -> GCodeParser::seenval(char)
        16   -> GCodeParser::value_byte()
        16   -> Print::print(int, int)
        16   -> USARTClass::write(uint8_t)
        16   -> serial_echopair_P(char const *, int)
        16   -> serialprintPGM(char const *)
      16   get_wifi_commands()
        16   -> IsStopped()
        16   -> _enqueuecommand(char const *, bool)
        16   -> kill(char const *)
        16   -> lcd_setstatusPGM(char const *, int8_t)
        16   -> quickstop_stepper()
        16   -> serialprintPGM(char const *)
        16   -> strchr(char *, int)
        16   -> strcmp
        16   -> strtol
       0   home_all_axes()
         0   -> gcode_G28(bool)
       0   home_bump_mm(AxisEnum)
       0   home_dir(AxisEnum)
      40   homeaxis(AxisEnum)
        40   -> MKS_DLP::buzzer_tone(uint16_t, uint16_t, uint8_t)
        40   -> __aeabi_d2f
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_i2d
        40   -> do_homing_move(AxisEnum, float, float)
        40   -> get_homing_bump_feedrate(AxisEnum)
        40   -> home_bump_mm(AxisEnum)
        40   -> home_dir(AxisEnum)
        40   -> max_length(AxisEnum)
        40   -> set_axis_is_at_home(AxisEnum)
        40   -> sync_plan_position()
       8   idle()
         8   -> GUI_Exec
         8   -> GUI_RefreshPage
         8   -> GUI_TOUCH_Exec
         0   -> MKS_DLP::PrintStatePolling()
         8   -> disp_pre_gcode
         8   -> manage_inactivity(bool)
         8   -> wifi_looping()
      16   invalid_extruder_error(uint8_t)
        16   -> Print::print(char const *)
        16   -> Print::print(unsigned char, int)
         0   -> USARTClass::write(uint8_t)
        16   -> USARTClass::write(uint8_t)
        16   -> serialprintPGM(char const *)
       8   kill(char const *)
         8   -> HAL_Delay
         8   -> Temperature::disable_all_heaters()
         8   -> disable_all_steppers()
         8   -> serialprintPGM(char const *)
         8   -> suicide()
       8   kill_c
         8   -> HAL_Delay
         8   -> Temperature::disable_all_heaters()
         8   -> disable_all_steppers()
         8   -> serialprintPGM(char const *)
         8   -> suicide()
       0   lcd_hasstatus()
       0   lcd_init()
       0   lcd_refresh()
       0   lcd_reset_alert_level()
       0   lcd_setalertstatusPGM(char const *)
       0   lcd_setstatus(char const *, bool)
       0   lcd_setstatusPGM(char const *, int8_t)
      16   loop
        16   -> CardReader::checkFilesys(unsigned char)
        16   -> CardReader::closefile(bool)
        16   -> CardReader::write_command(char *)
        16   -> Endstops::report_state()
        16   -> MKS_DLP::get_available_bmps()
        16   -> get_available_commands()
        16   -> idle()
         0   -> mks_PrintStatePolling
        16   -> ok_to_send()
        16   -> process_next_command()
        16   -> serialprintPGM(char const *)
        16   -> strstr(char *, char const *)
      24   manage_inactivity(bool)
        24   -> HAL_GPIO_WritePin
        24   -> HAL_GetTick
        24   -> Planner::blocks_queued()
         0   -> Planner::check_axes_activity()
        24   -> USARTClass::write(uint8_t)
        24   -> disable_e_steppers()
        24   -> get_available_commands()
        24   -> kill(char const *)
        24   -> serial_echopair_P(char const *, char const *)
        24   -> serialprintPGM(char const *)
       0   max_length(AxisEnum)
      16   mks_G28(char *)
        16   -> GCodeParser::parse(char *)
         0   -> gcode_G28(bool)
        16   -> memset
        16   -> strcpy
      16   mks_PrintStatePolling
        16   -> CardReader::startFileprint()
        16   -> HAL_GPIO_WritePin
        16   -> MKS_DLP::buzzer_tone(uint16_t, uint16_t, uint8_t)
         0   -> MKS_DLP::contiuePrint_Pwdwn()
         0   -> MKS_DLP::contiuePrint_paused()
        16   -> MKS_DLP::moveRelative_Z(float, float)
        16   -> MKS_DLP::pausePrint()
        16   -> MKS_DLP::resumePrint()
        16   -> MKS_DLP::stopPrint()
        16   -> MKS_DLP::write_Information_paused()
        16   -> Stopwatch::start()
        16   -> Stopwatch::stop()
        16   -> clear_command_queue()
        16   -> epr_write_data
        16   -> mks_pausePrint
        16   -> report_current_position()
        16   -> serialprintPGM(char const *)
       8   mks_ReadFromEpr
         0   -> epr_read_data
         8   -> epr_read_data
       0   mks_ReadFromEpr_pwroff()
       0   mks_ReadFromFile
       0   mks_WriteToEpr()
       0   mks_WriteToEpr_pwroff()
       0   mks_WriteToFile
      40   mks_clearDir
        40   -> strcpy
        40   -> strstr(char *, char const *)
       0   mks_clearFile
       8   mks_contiuePrintDelta
         0   -> gcode_M24()
         8   -> mks_moveZ
       8   mks_contiuePrintPause
         0   -> gcode_M24()
         8   -> mks_moveZ
         8   -> mks_setPositionZ
       0   mks_contiuePrintPwdwn
      16   mks_contiuePrint_UI
        16   -> AT24CXX_Read
        16   -> CardReader::isFileOpen()
        16   -> CardReader::openFile(char *, bool, bool)
         0   -> MKS_DLP::draw_printing()
         0   -> draw_dialog
        16   -> draw_printing
        16   -> epr_write_data
        16   -> getTick
        16   -> getTickDiff
        16   -> lcd_setstatus(char const *, bool)
        16   -> mks_clearDir
        16   -> strcpy
        16   -> strstr(char *, char const *)
       4   mks_getPositionXYZE
       0   mks_get_commands()
      16   mks_initPrint
        16   -> memset
      16   mks_manual_leveling
         0   -> enqueue_and_echo_commands_P(char const *)
        16   -> mks_G28(char *)
        16   -> mks_moveXY
        16   -> mks_moveZ
      48   mks_moveXY
        48   -> GCodeParser::parse(char *)
        48   -> Stepper::synchronize()
        48   -> __aeabi_f2d
        48   -> __aeabi_memcpy4
        48   -> gcode_G0_G1()
        48   -> memset
        48   -> sprintf
        48   -> strcat
      48   mks_moveZ
        48   -> GCodeParser::parse(char *)
        48   -> Stepper::synchronize()
        48   -> __aeabi_f2d
        48   -> __aeabi_memcpy4
        48   -> gcode_G0_G1()
        48   -> memset
        48   -> sprintf
        48   -> strcat
      16   mks_pausePrint
        16   -> MKS_DLP::moveRelative_Z(float, float)
        16   -> Stepper::synchronize()
        16   -> epr_write_data
       0   mks_preExtrude
      24   mks_rePrintCheck
        24   -> MKS_DLP::Is_Paused_Finished()
        24   -> MKS_DLP::read_Information_layer()
        24   -> MKS_DLP::read_Information_paused()
         0   -> draw_ready_print
        24   -> epr_read_data
        24   -> epr_write_data
        24   -> getTick
        24   -> getTickDiff
        24   -> mks_contiuePrint_UI
       8   mks_resumePrint
         8   -> MKS_DLP::resumePrint()
         8   -> lcd_setstatus(char const *, bool)
      16   mks_saveFileName
         0   -> epr_write_data
        16   -> memset
        16   -> strcpy
       0   mks_setFeedrate()
      32   mks_setPositionZ
        32   -> GCodeParser::parse(char *)
        32   -> __aeabi_f2d
        32   -> __aeabi_memcpy4
        32   -> gcode_G92()
        32   -> memset
        32   -> sprintf
        32   -> strcat
       0   mks_setTemperature()
      32   mkstft_ui_init
        32   -> __aeabi_memcpy
        32   -> __aeabi_memcpy4
        32   -> memset
        32   -> mkstft_ui_set_epr()
       8   mkstft_ui_load
         0   -> epr_read_data
         8   -> epr_read_data
         8   -> epr_write_data
      24   mkstft_ui_set_epr()
        24   -> epr_read_data
        24   -> epr_write_data
       8   ok_to_send()
         0   -> USARTClass::write(uint8_t)
         8   -> refresh_cmd_timeout()
         8   -> serialprintPGM(char const *)
       0   pft_get()
       0   pin_is_protected(int8_t)
     104   plan_arc(float const (&)[4], float const (&)[2], bool)
       104   -> HAL_GetTick
       104   -> Planner::buffer_line_kinematic(float const (&)[4], float const &, uint8_t)
       104   -> Temperature::manage_heater()
       104   -> __aeabi_d2f
       104   -> __aeabi_dadd
       104   -> __aeabi_dmul
       104   -> __aeabi_dsub
       104   -> __aeabi_f2d
       104   -> atan2f
       104   -> clamp_to_software_endstops(float *)
       104   -> cosf
       104   -> floorf
       104   -> idle()
       104   -> set_current_from_destination()
       104   -> sinf
       104   -> sqrtf
       8   prepare_move_to_destination()
         8   -> clamp_to_software_endstops(float *)
         8   -> prepare_move_to_destination_cartesian()
         8   -> refresh_cmd_timeout()
         8   -> serialprintPGM(char const *)
         0   -> set_current_from_destination()
       8   prepare_move_to_destination_cartesian()
         8   -> __aeabi_d2f
         8   -> __aeabi_dmul
         8   -> __aeabi_f2d
         8   -> buffer_line_to_destination(float)
      16   process_next_command()
        16   -> GCodeParser::parse(char *)
        16   -> Print::print(char const *)
        16   -> USARTClass::write(uint8_t)
         0   -> process_parsed_command()
        16   -> serialprintPGM(char const *)
       8   process_parsed_command()
         8   -> CardReader::pauseSDPrint()
         8   -> GCodeParser::unknown_command_error()
         8   -> MKS_DLP::bank2disp_enable(uint8_t, uint8_t, uint8_t)
         8   -> MKS_DLP::buzzer_enable(uint8_t)
         8   -> MKS_DLP::buzzer_tone(uint16_t, uint16_t, uint8_t)
         8   -> Stopwatch::pause()
         8   -> clear_cur_ui
         8   -> draw_printing
         8   -> gcode_G0_G1()
         8   -> gcode_G28(bool)
         8   -> gcode_G2_G3(bool)
         8   -> gcode_G4()
         8   -> gcode_G92()
         8   -> gcode_M104()
         0   -> gcode_M105()
         8   -> gcode_M106()
         8   -> gcode_M107()
         8   -> gcode_M108()
         8   -> gcode_M109()
         8   -> gcode_M110()
         8   -> gcode_M111()
         8   -> gcode_M112()
         8   -> gcode_M114()
         8   -> gcode_M115()
         8   -> gcode_M117()
         8   -> gcode_M118()
         8   -> gcode_M119()
         8   -> gcode_M120()
         8   -> gcode_M121()
         8   -> gcode_M140()
         8   -> gcode_M17()
         8   -> gcode_M18_M84()
         8   -> gcode_M20()
         8   -> gcode_M200()
         8   -> gcode_M201()
         8   -> gcode_M203()
         8   -> gcode_M204()
         8   -> gcode_M205()
         8   -> gcode_M206()
         8   -> gcode_M211()
         8   -> gcode_M22()
         8   -> gcode_M220()
         8   -> gcode_M221()
         8   -> gcode_M226()
         8   -> gcode_M23()
         8   -> gcode_M24()
         8   -> gcode_M25()
         8   -> gcode_M26()
         8   -> gcode_M27()
         8   -> gcode_M28()
         8   -> gcode_M29()
         8   -> gcode_M30()
         8   -> gcode_M301()
         8   -> gcode_M303()
         8   -> gcode_M31()
         8   -> gcode_M32()
         8   -> gcode_M355()
         8   -> gcode_M400()
         8   -> gcode_M410()
         8   -> gcode_M42()
         8   -> gcode_M428()
         8   -> gcode_M500()
         8   -> gcode_M501()
         8   -> gcode_M502()
         8   -> gcode_M503()
         8   -> gcode_M75()
         8   -> gcode_M76()
         8   -> gcode_M77()
         8   -> gcode_M81()
         8   -> gcode_M82()
         8   -> gcode_M83()
         8   -> gcode_M85()
         8   -> gcode_M907()
         8   -> gcode_M92()
         8   -> gcode_M928()
         8   -> gcode_M998()
         8   -> gcode_M999()
         8   -> gcode_T(uint8_t)
         0   -> ok_to_send()
         8   -> preview_gcode_prehandle
         8   -> reset_file_info
         8   -> reset_print_time
         8   -> start_print_time
         8   -> stop_print_time
       8   quickstop_stepper()
         8   -> Stepper::quick_stop()
         8   -> Stepper::synchronize()
         8   -> set_current_from_steppers_for_axis(AxisEnum)
         0   -> sync_plan_position()
       8   refresh_cmd_timeout()
         8   -> HAL_GetTick
      16   report_current_position()
        16   -> Print::print(double, int)
         0   -> Stepper::report_positions()
        16   -> __aeabi_f2d
        16   -> serialprintPGM(char const *)
      16   report_mksdlp_position()
        16   -> MKS_DLP::get_currentLayer()
        16   -> Print::print(double, int)
        16   -> Print::print(int, int)
         0   -> Stepper::report_positions()
        16   -> __aeabi_f2d
        16   -> serialprintPGM(char const *)
       8   serialprintPGM(char const *)
         8   -> USARTClass::write(uint8_t)
       0   servo_init()
      16   set_axis_is_at_home(AxisEnum)
        16   -> base_home_pos(AxisEnum)
        16   -> update_software_endstops(AxisEnum)
       0   set_current_from_destination()
         0   -> memcpy
       8   set_current_from_steppers_for_axis(AxisEnum)
         8   -> get_cartesian_from_steppers()
         0   -> memcpy
       0   set_destination_from_current()
         0   -> memcpy
       0   set_home_offset(AxisEnum, float)
         0   -> update_software_endstops(AxisEnum)
      16   setup
        16   -> MarlinSettings::load()
        16   -> Stepper::init()
        16   -> Temperature::init()
        16   -> USARTClass::write(uint8_t)
        16   -> freeMemory()
         0   -> lcd_init()
        16   -> memcpy
        16   -> serial_echopair_P(char const *, int)
        16   -> serialprintPGM(char const *)
        16   -> servo_init()
        16   -> setup_killpin()
        16   -> soft_endstop_min_init()
        16   -> sync_plan_position()
       0   setup_for_endstop_or_probe_move()
         0   -> refresh_cmd_timeout()
       0   setup_killpin()
       0   setup_powerhold()
       0   soft_endstop_min_init()
       8   stop()
         8   -> IsRunning()
         8   -> Temperature::disable_all_heaters()
         8   -> lcd_setstatusPGM(char const *, int8_t)
         8   -> safe_delay(millis_t)
         8   -> serialprintPGM(char const *)
       0   strchr(char *, int)
         0   -> __iar_Strchr
       0   strrchr(char *, int)
         0   -> __iar_Strrchr
       0   strstr(char *, char const *)
         0   -> __iar_Strstr
      32   strting2float(BYTE *, BYTE)
        32   -> __aeabi_d2f
        32   -> atof
        32   -> memset
       0   suicide()
       0   sync_plan_position()
         0   -> Planner::set_position_mm(float, float, float, float const &)
       0   sync_plan_position_e()
         0   -> Planner::set_e_position_mm(float const &)
       8   temper_error_kill()
         8   -> HAL_Delay
         8   -> Temperature::disable_all_heaters()
         8   -> disable_all_steppers()
         8   -> serialprintPGM(char const *)
       8   tool_change(uint8_t, float, bool)
         0   -> USARTClass::write(uint8_t)
         0   -> invalid_extruder_error(uint8_t)
         8   -> serial_echopair_P(char const *, int)
         8   -> serialprintPGM(char const *)
      16   update_software_endstops(AxisEnum)
        16   -> base_max_pos(AxisEnum)
        16   -> base_min_pos(AxisEnum)


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      24  ?<Constant "  PlannerBufferBytes: ">
       4  ?<Constant " E:">
      16  ?<Constant " Free Memory: ">
      20  ?<Constant " Invalid extruder ">
      16  ?<Constant " Last Updated: ">
       4  ?<Constant " Y">
       4  ?<Constant " Y:">
       4  ?<Constant " Z:">
       8  ?<Constant " first\n">
      32  ?<Constant " too long extrusion p...">
      36  ?<Constant " | Author: (none, def...">
       4  ?<Constant "%f">
       8  ?<Constant ".CBDDLP">
       8  ?<Constant ".PHOTON">
       8  ?<Constant ".cbddlp">
       8  ?<Constant ".photon">
       2  ?<Constant "/">
       8  ?<Constant "0.000">
       8  ?<Constant "1.0.0\n">
      12  ?<Constant "192.168.3.1">
      16  ?<Constant "192.168.3.100">
      16  ?<Constant "192.168.3.255">
      20  ?<Constant "2017-12-25 12:00">
      16  ?<Constant "255.255.255.0">
       2  ?<Constant ":">
      20  ?<Constant "Active Extruder: ">
      12  ?<Constant "CPLD VER:">
       8  ?<Constant "Cap:">
      24  ?<Constant "Compiled: Apr 16 2020\n">
      20  ?<Constant "Done saving file.\n">
       8  ?<Constant "Error">
       8  ?<Constant "G1 X">
       8  ?<Constant "G1 Z">
       8  ?<Constant "G1 Z0">
       8  ?<Constant "G28 Z0">
       4  ?<Constant "G28">
       8  ?<Constant "G92 Z">
       8  ?<Constant "Home ">
      60  ?<Constant "KILL caused by too mu...">
      12  ?<Constant "KILLED. ">
       8  ?<Constant "Layer:">
       4  ?<Constant "M29">
       8  ?<Constant "MKS DLP">
       8  ?<Constant "MKSDLP">
      16  ?<Constant "Move Z offset:">
      32  ?<Constant "Printer halted. kill(...">
     120  ?<Constant "Printer stopped due t...">
      12  ?<Constant "Resend: ">
      12  ?<Constant "Reset Z:">
      16  ?<Constant "Resume print?">
      12  ?<Constant "STOPPED. ">
      12  ?<Constant "TP-LINK_MKS">
       4  ?<Constant "X:">
       2  ?<Constant "Z">
      16  ?<Constant "baizhongyun.cn">
      16  ?<Constant "enqueueing \"">
       8  ?<Constant "led on:">
      12  ?<Constant "makerbase">
      12  ?<Constant "mks_pft.sys">
       4  ?<Constant "ok">
       8  ?<Constant "paused:">
      12  ?<Constant "print end.\n">
       8  ?<Constant "resume:">
      24  ?<Constant "ssd dev is error!\r\n\n">
      16  ?<Constant "totalTime(s):">
       8  ?<Constant {(0.0F), (0.0F)}>
       4  ??DataTable103
       4  ??DataTable103_1
       4  ??DataTable104
       4  ??DataTable104_1
       4  ??DataTable104_2
       4  ??DataTable104_3
       4  ??DataTable104_4
       4  ??DataTable104_5
       4  ??DataTable104_6
       4  ??DataTable104_7
       4  ??DataTable104_8
       4  ??DataTable104_9
       4  ??DataTable107
       4  ??DataTable107_1
       4  ??DataTable107_2
       4  ??DataTable107_3
       4  ??DataTable109
       4  ??DataTable111
       4  ??DataTable111_1
       4  ??DataTable111_2
       4  ??DataTable111_3
       4  ??DataTable111_4
       4  ??DataTable111_5
       4  ??DataTable111_6
       4  ??DataTable115
       4  ??DataTable115_1
       4  ??DataTable116
       4  ??DataTable118
       4  ??DataTable121
       4  ??DataTable121_1
       4  ??DataTable121_2
       4  ??DataTable122
       4  ??DataTable122_1
       4  ??DataTable123
       4  ??DataTable124
       4  ??DataTable124_1
       4  ??DataTable125
       4  ??DataTable125_1
       4  ??DataTable125_2
       4  ??DataTable126
       4  ??DataTable126_1
       4  ??DataTable126_2
       4  ??DataTable127
       4  ??DataTable127_1
       4  ??DataTable127_2
       4  ??DataTable127_3
       4  ??DataTable127_4
       4  ??DataTable127_5
       4  ??DataTable127_6
       4  ??DataTable127_7
       4  ??DataTable128
       4  ??DataTable128_1
       4  ??DataTable128_2
       4  ??DataTable130
       4  ??DataTable130_1
       4  ??DataTable131
       4  ??DataTable132
       4  ??DataTable132_1
       4  ??DataTable132_2
       4  ??DataTable135
       4  ??DataTable136
       4  ??DataTable136_1
       4  ??DataTable138
       4  ??DataTable141
       4  ??DataTable142
       4  ??DataTable142_1
       4  ??DataTable142_10
       4  ??DataTable142_2
       4  ??DataTable142_3
       4  ??DataTable142_4
       4  ??DataTable142_5
       4  ??DataTable142_6
       4  ??DataTable142_7
       4  ??DataTable142_8
       4  ??DataTable142_9
       4  ??DataTable143
       4  ??DataTable143_1
       4  ??DataTable143_10
       4  ??DataTable143_11
       4  ??DataTable143_12
       4  ??DataTable143_13
       4  ??DataTable143_14
       4  ??DataTable143_15
       4  ??DataTable143_2
       4  ??DataTable143_3
       4  ??DataTable143_4
       4  ??DataTable143_5
       4  ??DataTable143_6
       4  ??DataTable143_7
       4  ??DataTable143_8
       4  ??DataTable143_9
       4  ??DataTable144
       4  ??DataTable144_1
       4  ??DataTable145
       4  ??DataTable146
       4  ??DataTable147
       4  ??DataTable150
       4  ??DataTable150_1
       4  ??DataTable150_2
       4  ??DataTable151
       4  ??DataTable151_1
       4  ??DataTable152
       4  ??DataTable152_1
       4  ??DataTable153
       4  ??DataTable153_1
       4  ??DataTable153_2
       4  ??DataTable156
       4  ??DataTable157
       4  ??DataTable157_1
       4  ??DataTable157_2
       4  ??DataTable159
       4  ??DataTable160
       4  ??DataTable161
       4  ??DataTable162
       4  ??DataTable163
       4  ??DataTable163_1
       4  ??DataTable163_2
       4  ??DataTable163_3
       4  ??DataTable163_4
       4  ??DataTable163_5
       4  ??DataTable163_6
       4  ??DataTable164
       4  ??DataTable164_1
       4  ??DataTable165
       4  ??DataTable165_1
       4  ??DataTable165_2
       4  ??DataTable167
       4  ??DataTable168
       4  ??DataTable169
       4  ??DataTable169_1
       4  ??DataTable169_10
       4  ??DataTable169_11
       4  ??DataTable169_12
       4  ??DataTable169_2
       4  ??DataTable169_3
       4  ??DataTable169_4
       4  ??DataTable169_5
       4  ??DataTable169_6
       4  ??DataTable169_7
       4  ??DataTable169_8
       4  ??DataTable169_9
       4  ??DataTable170
       4  ??DataTable170_1
       4  ??DataTable170_2
       4  ??DataTable170_3
       4  ??DataTable189
       4  ??DataTable194
       4  ??DataTable194_1
       4  ??DataTable194_2
       4  ??DataTable194_3
       4  ??DataTable195
       4  ??DataTable195_1
       4  ??DataTable195_2
       4  ??DataTable196
       4  ??DataTable197
       4  ??DataTable198
       4  ??DataTable201
       4  ??DataTable201_1
       4  ??DataTable201_2
       4  ??DataTable201_3
       4  ??DataTable201_4
       4  ??DataTable201_5
       4  ??DataTable201_6
       4  ??DataTable201_7
       4  ??DataTable204
       4  ??DataTable204_1
       4  ??DataTable204_2
       8  ??DataTable204_3
       4  ??DataTable204_4
       8  ??DataTable204_5
       4  ??DataTable205
       4  ??DataTable207
       4  ??DataTable207_1
       4  ??DataTable210
       4  ??DataTable210_1
       4  ??DataTable210_2
       4  ??DataTable210_3
       4  ??DataTable210_4
       4  ??DataTable210_5
       4  ??DataTable210_6
       4  ??DataTable210_7
       4  ??DataTable88
      66  CRC16_XMODEM(unsigned char *, unsigned int)
      18  CardReader::eof()
      44  CardReader::gets(BYTE *, UINT)
      16  CardReader::isFileOpen()
       8  CardReader::setIndex(long)
       2  EXTI9_5_IRQHandler
      12  Endstops::enable(bool)
      20  Endstops::enable_globally(bool)
      12  Endstops::hit_on_purpose()
      20  Endstops::not_homing()
      44  FlushSerialRequestResend()
      30  GCodeParser::boolval(char)
      22  GCodeParser::byteval(char, uint8_t)
      36  GCodeParser::celsiusval(char, float)
      20  GCodeParser::has_value()
      22  GCodeParser::intval(char, int16_t)
      36  GCodeParser::linearval(char, float)
      76  GCodeParser::seen(char)
      22  GCodeParser::seenval(char)
      22  GCodeParser::ushortval(char, uint16_t)
       4  GCodeParser::value_axis_units(AxisEnum)
      28  GCodeParser::value_bool()
      34  GCodeParser::value_byte()
       4  GCodeParser::value_celsius()
       4  GCodeParser::value_feedrate()
     100  GCodeParser::value_float()
      10  GCodeParser::value_int()
       4  GCodeParser::value_linear_units()
      24  GCodeParser::value_long()
       4  GCodeParser::value_millis()
      28  GCodeParser::value_millis_from_seconds()
       4  GCodeParser::value_per_axis_unit(AxisEnum)
      24  GCodeParser::value_ulong()
      10  GCodeParser::value_ushort()
      42  InvertUint16(unsigned short *, unsigned short *)
      42  InvertUint8(unsigned char *, unsigned char *)
      12  IsRunning()
      16  IsStopped()
     180  Line_Pixel_TFT
     228  MKS_DLP::Can_Resume_Print()
      32  MKS_DLP::CleanDataTrans()
      70  MKS_DLP::ExposureAll_off()
      44  MKS_DLP::ExposureAll_on()
     140  MKS_DLP::ExposureData2TFT_circle()
     180  MKS_DLP::ExposureDataTrans_circle()
     180  MKS_DLP::ExposureDataTrans_square()
     186  MKS_DLP::ExposureTest()
     552  MKS_DLP::GeneralLayersPrint()
      38  MKS_DLP::Is_Paused_Finished()
      94  MKS_DLP::MKS_DLP()
      72  MKS_DLP::PrintStatePolling()
      50  MKS_DLP::TFT_display_test()
      96  MKS_DLP::bank2disp_enable(uint8_t, uint8_t, uint8_t)
      98  MKS_DLP::bank2disp_enable_gray(uint8_t, uint8_t, uint8_t, uint8_t)
      34  MKS_DLP::bank2disp_read()
     712  MKS_DLP::bottomLayerPrint()
      36  MKS_DLP::buzzer_enable(uint8_t)
      66  MKS_DLP::buzzer_polling()
      46  MKS_DLP::buzzer_tone(uint16_t, uint16_t, uint8_t)
     144  MKS_DLP::clean_Information_layer()
     270  MKS_DLP::contiuePrint_Pwdwn()
     198  MKS_DLP::contiuePrint_paused()
     236  MKS_DLP::decode_layer_from_rle(uint32_t, uint8_t)
     100  MKS_DLP::dlp_start()
      52  MKS_DLP::draw_printing()
      46  MKS_DLP::draw_return_printing_ui()
     372  MKS_DLP::getHead()
     264  MKS_DLP::getHead1()
     128  MKS_DLP::getHead2()
      12  MKS_DLP::get_BottomLedOnTime()
       4  MKS_DLP::get_Bottomlayers()
      28  MKS_DLP::get_Height()
      14  MKS_DLP::get_LedOffTime()
      14  MKS_DLP::get_LedOnTime()
      86  MKS_DLP::get_available_bmps()
       6  MKS_DLP::get_buzzer_status()
     188  MKS_DLP::get_cbddlp_cur_layer_def(uint32_t)
     734  MKS_DLP::get_cbddlp_file_header()
      78  MKS_DLP::get_cbddlp_preview1_info()
      78  MKS_DLP::get_cbddlp_preview2_info()
     230  MKS_DLP::get_cbddlp_print_para_info()
      28  MKS_DLP::get_cpld_ver()
      28  MKS_DLP::get_currentLayer()
     140  MKS_DLP::get_currentPrintTime()
     538  MKS_DLP::get_sdcard_bmps()
      28  MKS_DLP::get_totalLayers()
     224  MKS_DLP::get_totalPrintTime()
      22  MKS_DLP::get_ttfStatus_OFF()
      22  MKS_DLP::get_ttfStatus_ON()
     226  MKS_DLP::grag_test()
      88  MKS_DLP::led_off()
     108  MKS_DLP::led_on()
     180  MKS_DLP::line_fill_all_one(uint8_t)
     200  MKS_DLP::line_fill_all_zero(char, uint16_t, uint8_t)
     144  MKS_DLP::line_fill_zero(uint16_t, uint8_t)
     194  MKS_DLP::line_gen_data(uint16_t, uint8_t)
      94  MKS_DLP::line_gen_data_TFT(uint16_t)
     138  MKS_DLP::moveFistLayer_Z()
      62  MKS_DLP::moveMax_Z()
     138  MKS_DLP::moveRelativeZandGetBmp(float, float)
      42  MKS_DLP::moveRelative_Z(float, float)
      36  MKS_DLP::pausePrint()
      44  MKS_DLP::power_off()
      54  MKS_DLP::power_on()
     102  MKS_DLP::printingHasFinished()
      10  MKS_DLP::quick_stop()
     126  MKS_DLP::reTransmission()
     142  MKS_DLP::read_Information_layer()
     216  MKS_DLP::read_Information_paused()
     180  MKS_DLP::resumePrint()
     106  MKS_DLP::set_BottomLedOnTime(uint16_t)
      52  MKS_DLP::set_Bottomlayers(uint16_t)
      48  MKS_DLP::set_LedOffTime(uint16_t)
     106  MKS_DLP::set_LedOnTime(uint16_t)
      26  MKS_DLP::set_Zoffset()
      12  MKS_DLP::set_test_exposure_time(uint16_t)
      70  MKS_DLP::startFileprint()
      70  MKS_DLP::startFileprint_cbd()
      66  MKS_DLP::status_init()
      42  MKS_DLP::stopPrint()
       4  MKS_DLP::subobject MKS_DLP()
     246  MKS_DLP::write_Information_layer(DLP_MOVE_STATUS)
     148  MKS_DLP::write_Information_paused()
      28  Planner::blocks_queued()
      30  Planner::buffer_line(float, float, float, float const &, float const &, uint8_t)
      24  Planner::buffer_line_kinematic(float const (&)[4], float const &, uint8_t)
      76  Planner::refresh_e_factor(uint8_t)
       8  Planner::set_e_position_mm(float const &)
      48  Planner::set_filament_size(uint8_t, float const &)
      20  Planner::set_position_mm(float, float, float, float const &)
     478  SysTick_Handler_User()
      12  Temperature::degHotend(uint8_t)
      16  Temperature::degTargetHotend(uint8_t)
      44  Temperature::isCoolingHotend(uint8_t)
       2  Temperature::setTargetBed(float)
      20  Temperature::setTargetHotend(float, uint8_t)
       2  Temperature::updatePID()
      90  __sti__routine()
      36  _commit_command(bool)
      56  _enqueuecommand(char const *, bool)
       4  axis_codes
     524  axis_relative_modes
          axis_homed
          axis_known_position
          temper_error_flg
          mks_heating_busy
          Running
          marlin_debug_flags
          commands_in_queue
          cmd_queue_index_r
          cmd_queue_index_w
          active_extruder
          relative_mode
          wait_for_heatup
          target_extruder
          serial_wait_tick
          from_wifi_flag
          aalay_cnt
          send_ok
          feedrate_percentage
          saved_feedrate_percentage
          current_position
          destination
          homing_feedrate_mm_s
          home_offset
          home_bump_mm_P
          gcode_N
          gcode_LastN
          Stopped_gcode_LastN
          feedrate_mm_s
          saved_feedrate_mm_s
          position_shift
          command_queue
      66  axis_unhomed_error(bool)
      14  base_home_pos(AxisEnum)
      14  base_max_pos(AxisEnum)
      14  base_min_pos(AxisEnum)
      20  btn_beeper
      32  buffer_line_to_current_position()
      40  buffer_line_to_destination(float)
      52  cap_line(char const *, bool)
    5136  card
          mksdlp
          mksReprint
          cbddlp_file_header
          print_job_timer
          Line_Pixel
      12  cartes
     172  clamp_to_software_endstops(float *)
      16  clean_up_after_endstop_or_probe_move()
      14  clear_command_queue()
      20  clr_ticket()
       2  continue_print_error_flg
          ctemp
      20  debug_strings
      34  disable_all_steppers()
       2  disable_e_steppers()
      72  display_temper_error()
     156  do_blocking_move_to(float const &, float const &, float const &, float const &)
     152  do_blocking_move_to_nowait(float const &, float const &, float const &, float const &)
      22  do_blocking_move_to_x(float const &, float const &)
       8  do_blocking_move_to_xy(float const &, float const &, float const &)
      24  do_blocking_move_to_z(float const &, float const &)
      24  do_blocking_move_to_z_nowait(float const &, float const &)
      96  do_homing_move(AxisEnum, float, float)
      88  drain_injected_commands_P()
      16  duration_t::day() const
       6  duration_t::duration_t(uint32_t const &)
      14  duration_t::hour() const
      14  duration_t::minute() const
       4  duration_t::second() const
     232  duration_t::toString(char *) const
      18  duration_t::year() const
      32  dwell(millis_t)
      18  enable_all_steppers()
      58  enqueue_and_echo_command(char const *, bool)
       8  enqueue_and_echo_commands_P(char const *)
    6000  exposure_bmp_data_circle
    4800  exposure_bmp_data_square
       4  fanSpeeds
      62  find_next_bmp()
       6  freeMemory()
      24  gcode_G0_G1()
     232  gcode_G28(bool)
     528  gcode_G2_G3(bool)
      72  gcode_G4()
     160  gcode_G92()
     236  gcode_M104()
      52  gcode_M105()
      60  gcode_M106()
      36  gcode_M107()
      12  gcode_M108()
     576  gcode_M109()
      28  gcode_M110()
     136  gcode_M111()
      12  gcode_M112()
      14  gcode_M114()
     184  gcode_M115()
      16  gcode_M117()
      76  gcode_M118()
       4  gcode_M119()
       6  gcode_M120()
       6  gcode_M121()
      40  gcode_M140()
      24  gcode_M17()
     148  gcode_M18_M84()
      36  gcode_M20()
      88  gcode_M200()
      64  gcode_M201()
      56  gcode_M203()
     184  gcode_M204()
     160  gcode_M205()
      48  gcode_M206()
     232  gcode_M211()
      12  gcode_M22()
      28  gcode_M220()
      56  gcode_M221()
     148  gcode_M226()
      68  gcode_M23()
      44  gcode_M24()
      32  gcode_M25()
      44  gcode_M26()
      12  gcode_M27()
      24  gcode_M28()
       2  gcode_M29()
      44  gcode_M30()
     272  gcode_M301()
     112  gcode_M303()
      76  gcode_M31()
     104  gcode_M32()
      28  gcode_M355()
       4  gcode_M400()
       4  gcode_M410()
     124  gcode_M42()
     268  gcode_M428()
       4  gcode_M500()
       4  gcode_M501()
       4  gcode_M502()
      36  gcode_M503()
      12  gcode_M75()
      12  gcode_M76()
      12  gcode_M77()
      44  gcode_M81()
      12  gcode_M82()
      12  gcode_M83()
      28  gcode_M85()
       2  gcode_M907()
     160  gcode_M92()
      20  gcode_M928()
     116  gcode_M998()
      36  gcode_M999()
      16  gcode_T(uint8_t)
     114  gcode_get_destination()
      64  gcode_line_error(char const *, bool)
      24  get_available_commands()
      38  get_cartesian_from_steppers()
      80  get_homing_bump_feedrate(AxisEnum)
     610  get_pic_display
      42  get_pic_info
     540  get_serial_commands()
      98  get_target_extruder_from_command(uint16_t)
     284  get_wifi_commands()
       6  home_all_axes()
      14  home_bump_mm(AxisEnum)
       8  home_dir(AxisEnum)
      52  home_dir_P
          base_min_pos_P
          base_max_pos_P
          base_home_pos_P
          max_length_P
     266  homeaxis(AxisEnum)
      66  idle()
       4  injected_commands_P
      72  invalid_extruder_error(uint8_t)
      52  kill(char const *)
      52  kill_c
       4  last_wait_time
      36  layer_def
       4  lcd_hasstatus()
       2  lcd_init()
       2  lcd_refresh()
       2  lcd_reset_alert_level()
       2  lcd_setalertstatusPGM(char const *)
       2  lcd_setstatus(char const *, bool)
       2  lcd_setstatusPGM(char const *, int8_t)
     178  loop
     140  manage_inactivity(bool)
      14  max_length(AxisEnum)
      48  mks_G28(char *)
     344  mks_PrintStatePolling
      38  mks_ReadFromEpr
       2  mks_ReadFromEpr_pwroff()
       2  mks_ReadFromFile
       2  mks_WriteToEpr()
       2  mks_WriteToEpr_pwroff()
       2  mks_WriteToFile
      42  mks_clearDir
       2  mks_clearFile
      44  mks_contiuePrintDelta
      36  mks_contiuePrintPause
       2  mks_contiuePrintPwdwn
     252  mks_contiuePrint_UI
      12  mks_getPositionXYZE
       4  mks_get_commands()
      64  mks_initPrint
      78  mks_manual_leveling
     154  mks_moveXY
     114  mks_moveZ
      90  mks_pausePrint
       4  mks_pft_name
       2  mks_preExtrude
     182  mks_rePrintCheck
      54  mks_resumePrint
      48  mks_saveFileName
      16  mks_setFeedrate()
      94  mks_setPositionZ
       2  mks_setTemperature()
     510  mkstft_ui_init
     378  mkstft_ui_load
     354  mkstft_ui_set_epr()
      38  ok_to_send()
       2  pft_get()
      30  pin_is_protected(int8_t)
     784  plan_arc(float const (&)[4], float const (&)[2], bool)
     118  prepare_move_to_destination()
      68  prepare_move_to_destination_cartesian()
       1  preview_no_display
      32  preview_pic1
          preview_pic2
      12  previous_cmd_ms
          max_inactive_time
          stepper_inactive_time
      60  print_para
      20  printing_rate_update_flag
          wifi_init_flg
          wifi_refresh_flg
          cloud_refresh_flg
          waiting_wifi_time
          btn_flg
          z_high_count
          temperature_change_frequency_cnt
          TimeIncrease
          btn_beep_cnt
      60  process_next_command()
    1124  process_parsed_command()
      22  quickstop_stepper()
      16  reTransmission_zero_cnt
          reTransmission_data_cnt
          reTransmission_all_cnt
          spi1_hdmatx_CR
      16  refresh_cmd_timeout()
     118  report_current_position()
      72  report_mksdlp_position()
      40  sensitive_pins
       1  serial_comment_mode
       4  serial_count
      96  serial_line_buffer
      28  serialprintPGM(char const *)
       2  servo_init()
      48  set_axis_is_at_home(AxisEnum)
      20  set_current_from_destination()
      42  set_current_from_steppers_for_axis(AxisEnum)
      20  set_destination_from_current()
      14  set_home_offset(AxisEnum, float)
     204  setup
      20  setup_for_endstop_or_probe_move()
       2  setup_killpin()
       2  setup_powerhold()
      36  soft_endstop_min_init()
      40  soft_endstops_enabled
          workspace_offset
          soft_endstop_min
          soft_endstop_max
      62  stop()
       8  str_debug_1
      16  str_debug_16
       8  str_debug_2
       8  str_debug_4
       8  str_debug_8
       4  strchr(char *, int)
       4  strrchr(char *, int)
       4  strstr(char *, char const *)
      64  strting2float(BYTE *, BYTE)
       2  suicide()
      24  sync_plan_position()
      12  sync_plan_position_e()
       4  t1
      12  t12
       4  t2
      44  temper_error_kill()
      54  tool_change(uint8_t, float, bool)
      58  update_software_endstops(AxisEnum)
       1  wifi_comment_mode
       1  wifi_init_state
      96  wifi_line_buffer
       4  wifi_loop_cycle
       4  wifi_read_count
    1695  -- Other

 
  5 726 bytes in section .bss
    640 bytes in section .data
      4 bytes in section .init_array
  1 821 bytes in section .rodata
 41 366 bytes in section .text
 
 32 986 bytes of CODE  memory (+ 8 384 bytes shared)
     62 bytes of CONST memory (+ 1 759 bytes shared)
  6 168 bytes of DATA  memory (+   198 bytes shared)

Errors: none
Warnings: 164
