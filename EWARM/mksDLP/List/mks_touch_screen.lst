###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        16/Apr/2020  18:39:06
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_touch_screen.c
#    Command line =  
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_touch_screen.c -D
#        USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -D USE_STM32F407VET -lC
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM\mksDLP/List\ -lA
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM\mksDLP/Obj\ --no_unroll
#        --no_inline --no_tbaa --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp --dlib_config
#        "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Inc\ -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Src\ -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/BSP/variant\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/BSP/Components/lcd\
#        -I D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/libstmf4\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/libstmf4/include\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../User/ui\ -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../User/ui/Multi_language\
#        -I D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../User/ui/QRENCODE\
#        -I D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Middlewares/GUI\
#        -Om --use_c++_inline -I "D:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM\mksDLP/List\mks_touch_screen.lst
#    Object file  =  
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM\mksDLP/Obj\mks_touch_screen.o
#
###############################################################################

D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_touch_screen.c
      1          /******************** (C) COPYRIGHT 2009 www.armjishu.com ************************
      2          * File Name          : ARMJISHU_TouchScreen_ADS7843.c
      3          * Author             : www.armjishu.com Team
      4          * Version            : V3.0.1
      5          * Date               : 03/20/2010
      6          * Description        : 
      7                                  ADS7843_CS   is PB1
      8                                  ADS7843_INT  is PC1
      9          *******************************************************************************/
     10          #include "mks_touch_screen.h"
     11          //#include "stm32f10x.h"
     12          #include "stm32f4xx.h" //skyblue 2006-12-13
     13          #include <stdio.h>
     14          //#include "stm32f10x_exti.h"   //skyblue 2006-12-13
     15          #include "stm32f4xx_it.h"
     16          #include "ili9320.h"
     17          //#include "stm32f10x_tim.h"    //skyblue 2006-12-13
     18          #include "tim.h"
     19          #include "stm32f4xx_spi.h"

  #define IS_SPI_MODE(MODE) (((MODE) == SPI_Mode_Master) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",173  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_MODE" (declared at line
          511 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_DATASIZE(DATASIZE) (((DATASIZE) == SPI_DataSize_16b) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",185  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_DATASIZE" (declared at
          line 523 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_CPOL(CPOL) (((CPOL) == SPI_CPOL_Low) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",197  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_CPOL" (declared at line
          526 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_CPHA(CPHA) (((CPHA) == SPI_CPHA_1Edge) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",209  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_CPHA" (declared at line
          529 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_NSS(NSS) (((NSS) == SPI_NSS_Soft) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",221  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_NSS" (declared at line
          532 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_BAUDRATE_PRESCALER(PRESCALER) (((PRESCALER) == SPI_BaudRatePrescaler_2) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",239  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_BAUDRATE_PRESCALER"
          (declared at line 536 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_FIRST_BIT(BIT) (((BIT) == SPI_FirstBit_MSB) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",257  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_FIRST_BIT" (declared at
          line 545 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_DIRECTION(DIRECTION) (((DIRECTION) == SPI_Direction_Rx) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",400  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_DIRECTION" (declared at
          line 514 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define SPI_FLAG_CRCERR                 ((uint16_t)0x0010)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",442  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_FLAG_CRCERR" (declared at
          line 293 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define SPI_FLAG_MODF                   ((uint16_t)0x0020)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",443  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_FLAG_MODF" (declared at line
          294 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_CRC_POLYNOMIAL(POLYNOMIAL) ((POLYNOMIAL) >= 0x1)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",462  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_CRC_POLYNOMIAL" (declared
          at line 554 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define SPI_IT_TXE                   SPI_I2S_IT_TXE
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",473  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_IT_TXE" (declared at line
          280 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define SPI_IT_RXNE                  SPI_I2S_IT_RXNE
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",474  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_IT_RXNE" (declared at line
          281 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define SPI_IT_ERR                   SPI_I2S_IT_ERR
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",475  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_IT_ERR" (declared at line
          282 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define SPI_FLAG_RXNE                SPI_I2S_FLAG_RXNE
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",477  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_FLAG_RXNE" (declared at line
          290 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define SPI_FLAG_TXE                 SPI_I2S_FLAG_TXE
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",478  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_FLAG_TXE" (declared at line
          291 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define SPI_FLAG_OVR                 SPI_I2S_FLAG_OVR
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",479  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_FLAG_OVR" (declared at line
          295 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define SPI_FLAG_BSY                 SPI_I2S_FLAG_BSY
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",480  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_FLAG_BSY" (declared at line
          292 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")
     20          #include "spi_flash.h"
     21          
     22          extern u16 DeviceCode;
     23          
     24          
     25          /*#define  EVENT_FIFO_DEPTH	20
     26          typedef struct
     27          {	
     28          	TOUCH_EVENT event[EVENT_FIFO_DEPTH];
     29          	int8_t  r_idx;
     30          	int8_t  w_idx;
     31          	
     32          } EVENT_FIFO;
     33          
     34          static EVENT_FIFO  touch_event_fifo;*/
     35          

   \                                 In section .bss, align 4
     36          static int16_t x_touch,  y_touch;
   \                     x_touch:
   \   00000000                      DS8 2
   \   00000002                      DS8 2
   \   00000004                      DS8 4
     37          
     38          static int32_t touch_time = 0;
     39          
     40          static uint8_t lastTouchState = PEN_UP;
     41          
     42          //static TOUCH_EVENT  TouchEvent;
     43          
     44          #define  times  4
     45          
     46          
     47          // A/D 通道选择命令字和工作寄存器
     48          #define	CHX 	0x90//0x90 	//通道Y+的选择控制字	//0x94
     49          #define	CHY 	0xD0//0xd0	//通道X+的选择控制字	//0xD4
     50          
     51          //#define ADS7843_WrCmd  SPI1_SendByte
     52          //#define ADS7843_Read   SPI1_RecvByte
     53          

   \                                 In section .text, align 2, keep-with-next
     54          void ADS7843_CS_config(void)
     55          {
     56          #if 0   //skyblue 2016-12-13  
     57            GPIO_InitTypeDef GPIO_InitStructure;
     58            /* Enable GPIOB, GPIOC and AFIO clock */
     59            RCC_APB2PeriphClockCmd(RCC_ADS7843_CS , ENABLE);  //RCC_APB2Periph_AFIO
     60            
     61            /* LEDs pins configuration */
     62            GPIO_InitStructure.GPIO_Pin = GPIO_ADS7843_CS;
     63            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     64            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
     65            GPIO_Init(GPIO_ADS7843_CS_PORT, &GPIO_InitStructure);
     66          #endif    //skyblue 2016-12-13  
     67          }
   \                     ADS7843_CS_config: (+1)
   \   00000000   0x4770             BX       LR               ;; return
     68          
     69          static void ADS7843_INT_config(void)
     70          {
     71            #if 0   //skyblue 2016-12-13  
     72            GPIO_InitTypeDef GPIO_InitStructure;
     73            /* Enable GPIOB, GPIOC and AFIO clock */
     74            RCC_APB2PeriphClockCmd(RCC_ADS7843_INT , ENABLE);  //RCC_APB2Periph_AFIO
     75            
     76            /* LEDs pins configuration */
     77            GPIO_InitStructure.GPIO_Pin = GPIO_ADS7843_INT;
     78            //GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     79            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
     80            GPIO_Init(GPIO_ADS7843_INT_PORT, &GPIO_InitStructure);
     81            #endif    //skyblue 2016-12-13  
     82          }
     83          
     84          static void ADS7843_INT_EXIT_Init(void)
     85          {
     86           #if 0   //skyblue 2016-12-13  
     87              EXTI_InitTypeDef EXTI_InitStructure;
     88          
     89              /* Connect Button EXTI Line to Button GPIO Pin */
     90              GPIO_EXTILineConfig(GPIO_ADS7843_EXTI_PORT_SOURCE, GPIO_ADS7843_EXTI_PIN_SOURCE);  
     91          
     92              /* Configure Button EXTI line */
     93              EXTI_InitStructure.EXTI_Line = GPIO_ADS7843_EXTI_LINE;
     94              EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
     95              EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;  
     96              EXTI_InitStructure.EXTI_LineCmd = ENABLE;
     97              EXTI_Init(&EXTI_InitStructure);
     98          #endif    //skyblue 2016-12-13  
     99          }
    100          
    101          
    102          /*******************************************************************************
    103          * Function Name  : InterruptConfig
    104          * Description    : Configures the used IRQ Channels and sets their priority.NVIC_Configuration
    105          * Input          : None
    106          * Output         : None
    107          * Return         : None
    108          *******************************************************************************/
    109          static void ADS7843_InterruptConfig(void)
    110          { 
    111           #if 0   //skyblue 2016-12-13   
    112            NVIC_InitTypeDef NVIC_InitStructure;
    113            
    114            /* Set the Vector Table base address at 0x08000000 */
    115            NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0000);
    116            
    117            /* Configure the Priority Group to 2 bits */
    118            NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
    119          
    120            /* Enable the EXTI5 Interrupt */
    121            NVIC_InitStructure.NVIC_IRQChannel = GPIO_ADS7843_EXTI_IRQn;
    122            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    123            NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    124            NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    125            NVIC_Init(&NVIC_InitStructure);
    126          #endif    //skyblue 2016-12-13    
    127          }
    128          
    129          
    130          static void LCD_BIG_POINT(u16 xScreen, u16 yScreen)
    131           {
    132             ili9320_SetPoint(xScreen, yScreen, Magenta);
    133             ili9320_SetPoint(xScreen-1, yScreen, Magenta);
    134             ili9320_SetPoint(xScreen+1, yScreen, Magenta);
    135             ili9320_SetPoint(xScreen, yScreen-1, Magenta);
    136             ili9320_SetPoint(xScreen, yScreen+1, Magenta);
    137             ili9320_SetPoint(xScreen-1, yScreen-1, Magenta);
    138             ili9320_SetPoint(xScreen-1, yScreen+1, Magenta);
    139             ili9320_SetPoint(xScreen+1, yScreen-1, Magenta);
    140             ili9320_SetPoint(xScreen+1, yScreen+1, Magenta);
    141          
    142            }
    143          
    144          /*=====================================================================*/

   \                                 In section .text, align 2, keep-with-next
    145          u16 _AD2Y(u16 adx) //240
    146          {
    147            u16 sx=0;
    148            int r = adx - 200;
    149            r *= 240;
    150            sx=r / (4000 - 280);
   \                     _AD2Y: (+1)
   \   00000000   0x38C8             SUBS     R0,R0,#+200
   \   00000002   0xEBC0 0x1100      RSB      R1,R0,R0, LSL #+4
   \   00000006   0x0108             LSLS     R0,R1,#+4
   \   00000008   0xF640 0x6188      MOVW     R1,#+3720
   \   0000000C   0xFB90 0xF0F1      SDIV     R0,R0,R1
    151            if (sx<=0 || sx>240)
   \   00000010   0xB280             UXTH     R0,R0
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD001             BEQ.N    ??_AD2Y_0
   \   00000016   0x28F1             CMP      R0,#+241
   \   00000018   0xDB00             BLT.N    ??_AD2Y_1
    152              return 0;
   \                     ??_AD2Y_0: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
    153            return sx;
   \                     ??_AD2Y_1: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
    154          }
    155          
    156          

   \                                 In section .text, align 2, keep-with-next
    157          u16 _AD2X(u16 ady) //320
    158          {
    159            u16 sy=0;
    160            int r = ady - 260;
    161            r *= 320;
    162            sy=r/(3960 - 360);
   \                     _AD2X: (+1)
   \   00000000   0xF5A0 0x7082      SUB      R0,R0,#+260
   \   00000004   0xEB00 0x0180      ADD      R1,R0,R0, LSL #+2
   \   00000008   0x0188             LSLS     R0,R1,#+6
   \   0000000A   0xF44F 0x6161      MOV      R1,#+3600
   \   0000000E   0xFB90 0xF0F1      SDIV     R0,R0,R1
    163            if (sy<=0 || sy>320)
   \   00000012   0xB280             UXTH     R0,R0
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD002             BEQ.N    ??_AD2X_0
   \   00000018   0xF5B0 0x7FA0      CMP      R0,#+320
   \   0000001C   0xDD00             BLE.N    ??_AD2X_1
    164              return 0;
   \                     ??_AD2X_0: (+1)
   \   0000001E   0x2000             MOVS     R0,#+0
    165            return sy;
   \                     ??_AD2X_1: (+1)
   \   00000020   0x4770             BX       LR               ;; return
    166          }
    167          
    168          
    169          
    170          
    171          
    172          
    173          /*=====================================================================*/
    174          /*=====================================================================*/
    175          /*=====================================================================*/
    176          /*=====================================================================*/
    177          // A/D 通道选择命令字和工作寄存器
    178          //#define	CHX 	0x90 	//通道Y+的选择控制字	//0x94
    179          //#define	CHY 	0xd0	//通道X+的选择控制字	//0xD4
    180          
    181          
    182          
    183          //读ADS7843的IO控制口
    184          	
    185          /*=====================================================================*/
    186          

   \                                 In section .text, align 2, keep-with-next
    187          void ADS7843_Init(void)
    188          {
    189           #if 0   //skyblue 2016-12-13    
    190              ADS7843_CS_config();     // 使能LCD
    191              ADS7843_CS_HIGH() ;     // 关闭LCD
    192              SPI1_Config();
    193              SPI1_Init_For_Byte();
    194              SPI1_MOSI_HIGH();
    195              SPI1_SCK_LOW();
    196             // ADS7843_INT_config();
    197             // ADS7843_INT_EXIT_Init();
    198             // ADS7843_InterruptConfig();
    199          
    200          	// touch_event_fifo.r_idx = 0;
    201            //  touch_event_fifo.w_idx = 0;
    202            //  memset(touch_event_fifo.event, 0, sizeof(touch_event_fifo.event));
    203          
    204             lastTouchState = PEN_UP;
    205          #endif    //skyblue 2016-12-13      
    206          }
   \                     ADS7843_Init: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    207          /*=====================================================================*/
    208          /*=====================================================================*/
    209          
    210          

   \                                 In section .text, align 2, keep-with-next
    211          void SPI1_Config(void)
    212          {
    213           #if 0   //skyblue 2016-12-13  
    214            GPIO_InitTypeDef GPIO_InitStructure;
    215              
    216            // Set as Output push-pull - SCK and MOSI
    217            RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
    218            
    219            GPIO_InitStructure.GPIO_Pin = SPI1_SCK | SPI1_MOSI;
    220            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    221            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    222            GPIO_Init(SPI1_PORT, &GPIO_InitStructure);
    223            
    224            //SPI_MISO
    225            GPIO_InitStructure.GPIO_Pin = SPI1_MISO;
    226            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    227            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    228            GPIO_Init(SPI1_PORT, &GPIO_InitStructure);
    229          #endif    //skyblue 2016-12-13    
    230          
    231          }
   \                     SPI1_Config: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    232          
    233          /*=====================================================================*/

   \                                 In section .text, align 2, keep-with-next
    234          void SPI1_Init_For_Byte(void)
    235          {
    236          
    237          }
   \                     SPI1_Init_For_Byte: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    238          
    239          /*=====================================================================*/
    240          static void ADS7843_SPI_Start( void )
    241          {
    242           #if 0   //skyblue 2016-12-13   
    243              ADS7843_CS_HIGH();
    244              SPI1_MOSI_HIGH();
    245              SPI1_SCK_LOW();
    246              ADS7843_CS_LOW();	      		//芯片允许
    247          #endif    //skyblue 2016-12-13     
    248          }
    249          
    250          /*=====================================================================*/
    251          static void SPI_MOSI(u8 data)
    252          {
    253           #if 0   //skyblue 2016-12-13    
    254              if(data)
    255                  SPI1_MOSI_HIGH();
    256              else
    257                  SPI1_MOSI_LOW();
    258          #endif    //skyblue 2016-12-13     
    259          }
    260          
    261          /*=====================================================================*/
    262          /*
    263          #define ShortDelayTime 1
    264          #define LongDelayTime (ShortDelayTime*2)
    265          SPI1_Delay_Short()
    266          {
    267              __IO uint32_t nCount;
    268              
    269              for( nCount= 0; nCount < ShortDelayTime; nCount++ );
    270          }
    271          */
    272          /*=====================================================================*/
    273          
    274          
    275          /*=====================================================================*/
    276          static void ADS7843_WrCmd(u8 cmd)
    277          {
    278          #if 0   //skyblue 2016-12-13    
    279              u8 buf, i;
    280          
    281              for( i = 0; i < 8; i++ )
    282              {
    283                  buf = (cmd >> (7-i)) & 0x1 ;	//MSB在前,LSB在后
    284                  SPI_MOSI(buf);	 	//时钟上升沿锁存DIN
    285                  SPI1_SCK_HIGH();			//时钟脉冲，一共8个
    286                  SPI1_SCK_LOW();			//开始发送命令字
    287              }
    288          #endif    //skyblue 2016-12-13 	
    289          }
    290          
    291          /*=====================================================================*/
    292          static u16 ADS7843_Read(void)
    293          {
    294          #if 0   //skyblue 2016-12-13    
    295          	u16 buf = 0 ;
    296          	u8 i;
    297          
    298              SPI1_SCK_HIGH(); //wait busy
    299          	SPI1_SCK_LOW();	
    300          	for( i = 0; i < 12; i++ )
    301          	{
    302          		buf = buf << 1 ;
    303          		SPI1_SCK_HIGH();
    304          		if ( SPI1_MISO_READ() )	
    305          		{
    306          			buf = buf + 1 ;
    307          		}
    308          		SPI1_SCK_LOW();			
    309          	}
    310          
    311          	for( i = 0; i < 3; i++ )
    312          	{
    313          		SPI1_SCK_HIGH();
    314          		SPI1_SCK_LOW();			
    315          	}
    316              
    317          	return( buf ) ;
    318          #endif    //skyblue 2016-12-13 	        
    319          }
                 ^
Warning[Pe940]: missing return statement at end of non-void function
          "ADS7843_Read"
    320          
    321          /*=====================================================================*/
    322          

   \                                 In section .text, align 2, keep-with-next
    323          static void ADS7843_Rd_Addata(u16 *X_Addata,u16 *Y_Addata)
    324          {
   \                     ADS7843_Rd_Addata: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    325          
    326          	u16		i,j,k,x_addata[times],y_addata[times];
    327              int result;
                         ^
Warning[Pe550]: variable "result" was set but never used
    328          
    329                  
    330          	for(i=0;i<times;i++)					//采样4次.
   \   00000008   0x2600             MOVS     R6,#+0
   \   0000000A   0x....             LDR.N    R7,??DataTable1  ;; 0x424182ac
   \   0000000C   0xE014             B.N      ??ADS7843_Rd_Addata_0
    331          	{
    332          #if defined(MKS_DLP_BOARD)  	
    333          		ADS7843_CS = 0;
   \                     ??ADS7843_Rd_Addata_1: (+1)
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x6038             STR      R0,[R7, #+0]
    334          		SPI2_ReadWriteByte(CHX);
   \   00000012   0x2090             MOVS     R0,#+144
   \   00000014   0x.... 0x....      BL       SPI2_ReadWriteByte
    335          		y_addata[i] = SPI2_ReadWrite2Bytes();
   \   00000018   0x.... 0x....      BL       SPI2_ReadWrite2Bytes
   \   0000001C   0xA900             ADD      R1,SP,#+0
   \   0000001E   0xF821 0x0016      STRH     R0,[R1, R6, LSL #+1]
    336          		SPI2_ReadWriteByte(CHY);
   \   00000022   0x20D0             MOVS     R0,#+208
   \   00000024   0x.... 0x....      BL       SPI2_ReadWriteByte
    337          		x_addata[i] = SPI2_ReadWrite2Bytes(); 
   \   00000028   0x.... 0x....      BL       SPI2_ReadWrite2Bytes
   \   0000002C   0xA902             ADD      R1,SP,#+8
   \   0000002E   0xF821 0x0016      STRH     R0,[R1, R6, LSL #+1]
    338          		ADS7843_CS = 1;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x6038             STR      R0,[R7, #+0]
    339          #endif
    340          	}
   \   00000036   0x1C76             ADDS     R6,R6,#+1
   \                     ??ADS7843_Rd_Addata_0: (+1)
   \   00000038   0x2E04             CMP      R6,#+4
   \   0000003A   0xDBE8             BLT.N    ??ADS7843_Rd_Addata_1
    341          
    342          	result = x_addata[0];
    343          	for(i=0;i<times;i++)					
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xA902             ADD      R1,SP,#+8
   \   00000040   0xE00E             B.N      ??ADS7843_Rd_Addata_2
    344          	{
    345          		for(j = i + 1; j < times; j++)
    346          		{
    347          			if(x_addata[j] > x_addata[i])
   \                     ??ADS7843_Rd_Addata_3: (+1)
   \   00000042   0xF831 0x2013      LDRH     R2,[R1, R3, LSL #+1]
   \   00000046   0xF831 0x6010      LDRH     R6,[R1, R0, LSL #+1]
   \   0000004A   0x4296             CMP      R6,R2
   \   0000004C   0xD203             BCS.N    ??ADS7843_Rd_Addata_4
    348          			{
    349          				k = x_addata[j];
    350          				x_addata[j] = x_addata[i];
   \   0000004E   0xF821 0x6013      STRH     R6,[R1, R3, LSL #+1]
    351          				x_addata[i] = k;
   \   00000052   0xF821 0x2010      STRH     R2,[R1, R0, LSL #+1]
    352          			}
    353          		}
   \                     ??ADS7843_Rd_Addata_4: (+1)
   \   00000056   0x1C5B             ADDS     R3,R3,#+1
   \   00000058   0xB29B             UXTH     R3,R3
   \                     ??ADS7843_Rd_Addata_5: (+1)
   \   0000005A   0x2B04             CMP      R3,#+4
   \   0000005C   0xDBF1             BLT.N    ??ADS7843_Rd_Addata_3
   \   0000005E   0x4638             MOV      R0,R7
   \                     ??ADS7843_Rd_Addata_2: (+1)
   \   00000060   0x2804             CMP      R0,#+4
   \   00000062   0xDA03             BGE.N    ??ADS7843_Rd_Addata_6
   \   00000064   0x1C47             ADDS     R7,R0,#+1
   \   00000066   0xB2BF             UXTH     R7,R7
   \   00000068   0x463B             MOV      R3,R7
   \   0000006A   0xE7F6             B.N      ??ADS7843_Rd_Addata_5
    354          	}
    355          	if(x_addata[times / 2 -1] - x_addata[times / 2 ] > 50)
   \                     ??ADS7843_Rd_Addata_6: (+1)
   \   0000006C   0x8888             LDRH     R0,[R1, #+4]
   \   0000006E   0x8849             LDRH     R1,[R1, #+2]
   \   00000070   0x1A0A             SUBS     R2,R1,R0
   \   00000072   0x2A33             CMP      R2,#+51
   \   00000074   0xDA21             BGE.N    ??ADS7843_Rd_Addata_7
    356          	{
    357                      *X_Addata = 0;
    358                      *Y_Addata = 0;
    359                      return ;
    360                  }
    361          
    362          	*X_Addata = (x_addata[times / 2 -1] + x_addata[times / 2 ]) /2;
   \   00000076   0x1840             ADDS     R0,R0,R1
   \   00000078   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   0000007C   0x1040             ASRS     R0,R0,#+1
   \   0000007E   0x8020             STRH     R0,[R4, #+0]
    363          
    364          	
    365          	result = y_addata[0];
    366          	for(i=0;i<times;i++)					
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xA900             ADD      R1,SP,#+0
   \   00000084   0xE00E             B.N      ??ADS7843_Rd_Addata_8
    367          	{
    368          		for(j = i + 1; j < times; j++)
    369          		{
    370          			if(y_addata[j] > y_addata[i])
   \                     ??ADS7843_Rd_Addata_9: (+1)
   \   00000086   0xF831 0x2013      LDRH     R2,[R1, R3, LSL #+1]
   \   0000008A   0xF831 0x6010      LDRH     R6,[R1, R0, LSL #+1]
   \   0000008E   0x4296             CMP      R6,R2
   \   00000090   0xD203             BCS.N    ??ADS7843_Rd_Addata_10
    371          			{
    372          				k = y_addata[j];
    373          				y_addata[j] = y_addata[i];
   \   00000092   0xF821 0x6013      STRH     R6,[R1, R3, LSL #+1]
    374          				y_addata[i] = k;
   \   00000096   0xF821 0x2010      STRH     R2,[R1, R0, LSL #+1]
    375          			}
    376          		}
   \                     ??ADS7843_Rd_Addata_10: (+1)
   \   0000009A   0x1C5B             ADDS     R3,R3,#+1
   \   0000009C   0xB29B             UXTH     R3,R3
   \                     ??ADS7843_Rd_Addata_11: (+1)
   \   0000009E   0x2B04             CMP      R3,#+4
   \   000000A0   0xDBF1             BLT.N    ??ADS7843_Rd_Addata_9
   \   000000A2   0x4638             MOV      R0,R7
   \                     ??ADS7843_Rd_Addata_8: (+1)
   \   000000A4   0x2804             CMP      R0,#+4
   \   000000A6   0xDA03             BGE.N    ??ADS7843_Rd_Addata_12
   \   000000A8   0x1C47             ADDS     R7,R0,#+1
   \   000000AA   0xB2BF             UXTH     R7,R7
   \   000000AC   0x463B             MOV      R3,R7
   \   000000AE   0xE7F6             B.N      ??ADS7843_Rd_Addata_11
    377          	}
    378          
    379          	
    380          	if(y_addata[times / 2 -1] - y_addata[times / 2 ] > 50)
   \                     ??ADS7843_Rd_Addata_12: (+1)
   \   000000B0   0x8888             LDRH     R0,[R1, #+4]
   \   000000B2   0x8849             LDRH     R1,[R1, #+2]
   \   000000B4   0x1A0A             SUBS     R2,R1,R0
   \   000000B6   0x2A33             CMP      R2,#+51
   \   000000B8   0xDB03             BLT.N    ??ADS7843_Rd_Addata_13
    381          	{
    382                      *X_Addata = 0;
   \                     ??ADS7843_Rd_Addata_7: (+1)
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x8020             STRH     R0,[R4, #+0]
    383                      *Y_Addata = 0;
   \   000000BE   0x8028             STRH     R0,[R5, #+0]
    384                      return ;
   \   000000C0   0xE004             B.N      ??ADS7843_Rd_Addata_14
    385                  }
    386          
    387          	*Y_Addata = (y_addata[times / 2 -1] + y_addata[times / 2 ]) /2;
   \                     ??ADS7843_Rd_Addata_13: (+1)
   \   000000C2   0x1840             ADDS     R0,R0,R1
   \   000000C4   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   000000C8   0x1040             ASRS     R0,R0,#+1
   \   000000CA   0x8028             STRH     R0,[R5, #+0]
    388          	
    389          	
    390          }
   \                     ??ADS7843_Rd_Addata_14: (+1)
   \   000000CC   0xB005             ADD      SP,SP,#+20
   \   000000CE   0xBDF0             POP      {R4-R7,PC}       ;; return
    391          
    392          /*=====================================================================*/
    393          /*=====================================================================*/
    394          /*=====================================================================*/

   \                                 In section .text, align 2, keep-with-next
    395          u16 distence(u16 data1,u16 data2)
    396          {
    397              if((data1 > data2) && (data1 > data2 + 10))
   \                     distence: (+1)
   \   00000000   0x4281             CMP      R1,R0
   \   00000002   0xD204             BCS.N    ??distence_0
   \   00000004   0x310A             ADDS     R1,R1,#+10
   \   00000006   0x4281             CMP      R1,R0
   \   00000008   0xDA01             BGE.N    ??distence_0
    398              {
    399                  return 0;
    400              }
    401          
    402              if((data2 > data2) && (data2 > data2 + 10))
    403              {
    404                  return 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x4770             BX       LR
    405              }
    406          
    407              return 1;    
   \                     ??distence_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x4770             BX       LR               ;; return
    408          }
    409          
    410          /*=====================================================================*/
    411          extern uint32_t TSC_Value_X;
    412          extern uint32_t TSC_Value_Y;

   \                                 In section .text, align 2, keep-with-next
    413          void ARMJISHU_TouchScreen_ADS7843(void)
    414          {
    415          #if 0   //skyblue 2016-12-13    
    416            u16 xdata, ydata;
    417            u32 xScreen, yScreen;
    418          
    419              static u16 sDataX,sDataY;
    420              
    421           // printf("\n\r ARMJISHU_TouchScreen_ADS7843 \n\r");
    422            ADS7843_Rd_Addata(&xdata, &ydata);
    423            xScreen = _AD2X(ydata);
    424            yScreen = _AD2Y(xdata);
    425          
    426             //xScreen = 320 - ((ydata*320)>>12);
    427             //yScreen = (xdata*240)>>12;
    428          
    429           
    430            //printf("\n\r (0x%x, 0x%x), (%d, %d)", xdata, ydata, xScreen, yScreen);
    431            if((xScreen>1)&&(yScreen>1)&&(xScreen<320-1)&&(yScreen<240-1))
    432            {
    433                 printf("\n\r%d,%d", xScreen, yScreen);
    434                if((GPIO_ADS7843_INT_VALID) && distence(sDataX,xScreen) && distence(sDataY,yScreen))
    435                  {
    436          //             LCD_BIG_POINT(xScreen, yScreen);
    437          //			 printf("\n\r%d,%d", xScreen, yScreen);
    438          		        TSC_Value_X = xScreen;
    439          				if(DeviceCode==0x9325)
    440          					TSC_Value_Y = 240-yScreen;
    441          				else
    442          					TSC_Value_Y = yScreen;
    443                  }
    444                sDataX = xScreen;
    445                sDataY = yScreen;
    446            }
    447          #endif    //skyblue 2016-12-13     
    448          }
   \                     ARMJISHU_TouchScreen_ADS7843: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    449          
    450          #define ADC_VALID_OFFSET	10
    451          

   \                                 In section .text, align 2, keep-with-next
    452          static uint8_t	TOUCH_PressValid(uint16_t _usX, uint16_t _usY)
    453          {
    454          	if ((_usX <= ADC_VALID_OFFSET) || (_usY <= ADC_VALID_OFFSET)
    455          		|| (_usX >= 4095 - ADC_VALID_OFFSET)
    456          		|| (_usY >= 4095 - ADC_VALID_OFFSET))
   \                     TOUCH_PressValid: (+1)
   \   00000000   0x280B             CMP      R0,#+11
   \   00000002   0xDB07             BLT.N    ??TOUCH_PressValid_0
   \   00000004   0x290B             CMP      R1,#+11
   \   00000006   0xDB05             BLT.N    ??TOUCH_PressValid_0
   \   00000008   0xF640 0x72F5      MOVW     R2,#+4085
   \   0000000C   0x4290             CMP      R0,R2
   \   0000000E   0xDA01             BGE.N    ??TOUCH_PressValid_0
   \   00000010   0x4291             CMP      R1,R2
   \   00000012   0xDB01             BLT.N    ??TOUCH_PressValid_1
    457          	{
    458          		return 0;
   \                     ??TOUCH_PressValid_0: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x4770             BX       LR
    459          	}
    460          	else
    461          	{
    462          		return 1;
   \                     ??TOUCH_PressValid_1: (+1)
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x4770             BX       LR               ;; return
    463          	}
    464          }
    465          
    466          #if 1

   \                                 In section .text, align 2, keep-with-next
    467          void getTouchEvent(TOUCH_EVENT *pTouchEvent)
    468          {
   \                     getTouchEvent: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
    469          	uint32_t tmpTime, diffTime = 0;
    470          	int16_t x, y;
    471          	
    472          	tmpTime = getTick();
   \   00000006   0x.... 0x....      BL       getTick
   \   0000000A   0x4605             MOV      R5,R0
    473          
    474          	diffTime = getTickDiff(tmpTime, touch_time);
    475          
    476          	if(diffTime > 20)
   \   0000000C   0x....             LDR.N    R6,??DataTable1_1
   \   0000000E   0x6871             LDR      R1,[R6, #+4]
   \   00000010   0x.... 0x....      BL       getTickDiff
   \   00000014   0x2815             CMP      R0,#+21
   \   00000016   0xD32E             BCC.N    ??getTouchEvent_0
    477          	{
    478          		x = x_touch;
   \   00000018   0xF9B6 0x8000      LDRSH    R8,[R6, #+0]
    479          		y = y_touch;
   \   0000001C   0xF9B6 0x7002      LDRSH    R7,[R6, #+2]
    480          			
    481          		ADS7843_Rd_Addata(&x_touch, &y_touch);
                 		                  ^
Warning[Pe167]: argument of type "int16_t *" is incompatible with parameter of
          type "u16 *"

  		ADS7843_Rd_Addata(&x_touch, &y_touch);
  		                            ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_touch_screen.c",481  Warning[Pe167]: 
          argument of type "int16_t *" is incompatible with parameter of type
          "u16 *"
   \   00000020   0x1CB1             ADDS     R1,R6,#+2
   \   00000022   0x4630             MOV      R0,R6
   \   00000024   0x.... 0x....      BL       ADS7843_Rd_Addata
    482          		if(TOUCH_PressValid(x_touch, y_touch))
   \   00000028   0xF9B6 0x9000      LDRSH    R9,[R6, #+0]
   \   0000002C   0x8871             LDRH     R1,[R6, #+2]
   \   0000002E   0x4648             MOV      R0,R9
   \   00000030   0xB280             UXTH     R0,R0
   \   00000032   0x.... 0x....      BL       TOUCH_PressValid
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD01B             BEQ.N    ??getTouchEvent_1
    483          		{			
    484          			if(abs(x - x_touch) > 50 || abs(y-y_touch) > 50)
                 			   ^
Warning[Pe223]: function "abs" declared implicitly

  static void ADS7843_INT_EXIT_Init(void)
              ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_touch_screen.c",84  Warning[Pe177]: 
          function "ADS7843_INT_EXIT_Init" was declared but never referenced

  static void ADS7843_INT_config(void)
              ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_touch_screen.c",69  Warning[Pe177]: 
          function "ADS7843_INT_config" was declared but never referenced

  static void ADS7843_InterruptConfig(void)
              ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_touch_screen.c",109  Warning[Pe177]: 
          function "ADS7843_InterruptConfig" was declared but never referenced

  static uint8_t lastTouchState = PEN_UP;
                 ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_touch_screen.c",40  Warning[Pe177]: 
          variable "lastTouchState" was declared but never referenced

  static void LCD_BIG_POINT(u16 xScreen, u16 yScreen)
              ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_touch_screen.c",130  Warning[Pe177]: 
          function "LCD_BIG_POINT" was declared but never referenced

  static void ADS7843_SPI_Start( void )
              ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_touch_screen.c",240  Warning[Pe177]: 
          function "ADS7843_SPI_Start" was declared but never referenced

  static void SPI_MOSI(u8 data)
              ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_touch_screen.c",251  Warning[Pe177]: 
          function "SPI_MOSI" was declared but never referenced

  static void ADS7843_WrCmd(u8 cmd)
              ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_touch_screen.c",276  Warning[Pe177]: 
          function "ADS7843_WrCmd" was declared but never referenced

  static u16 ADS7843_Read(void)
             ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Src\mks_touch_screen.c",292  Warning[Pe177]: 
          function "ADS7843_Read" was declared but never referenced
   \   0000003A   0xEBA8 0x0009      SUB      R0,R8,R9
   \   0000003E   0x.... 0x....      BL       abs
   \   00000042   0x2833             CMP      R0,#+51
   \   00000044   0xDA17             BGE.N    ??getTouchEvent_0
   \   00000046   0xF9B6 0x0002      LDRSH    R0,[R6, #+2]
   \   0000004A   0x1A38             SUBS     R0,R7,R0
   \   0000004C   0x.... 0x....      BL       abs
   \   00000050   0x2833             CMP      R0,#+51
   \   00000052   0xDA10             BGE.N    ??getTouchEvent_0
    485          			{
    486          				//pTouchEvent->state = PEN_NONE;
    487          				return;
    488          			}
    489          		
    490          			pTouchEvent->x  = (x + x_touch) >> 1;
   \   00000054   0xF9B6 0x0000      LDRSH    R0,[R6, #+0]
   \   00000058   0xFA08 0xF080      SXTAH    R0,R8,R0
   \   0000005C   0x1040             ASRS     R0,R0,#+1
   \   0000005E   0x8020             STRH     R0,[R4, #+0]
    491          			pTouchEvent->y = (y + y_touch) >> 1;
   \   00000060   0xF9B6 0x0002      LDRSH    R0,[R6, #+2]
   \   00000064   0x1838             ADDS     R0,R7,R0
   \   00000066   0x1040             ASRS     R0,R0,#+1
   \   00000068   0x8060             STRH     R0,[R4, #+2]
    492          			pTouchEvent->state = PEN_DOWN;
   \   0000006A   0x2001             MOVS     R0,#+1
   \   0000006C   0x7120             STRB     R0,[R4, #+4]
    493          			
    494          			touch_time = tmpTime;
   \   0000006E   0x6075             STR      R5,[R6, #+4]
   \   00000070   0xE001             B.N      ??getTouchEvent_0
    495          
    496          
    497          		}
    498          		else
    499          		{
    500          			pTouchEvent->state = PEN_UP;
   \                     ??getTouchEvent_1: (+1)
   \   00000072   0x2002             MOVS     R0,#+2
   \   00000074   0x7120             STRB     R0,[R4, #+4]
    501          		}
    502          	}
    503          	else
    504          	{
    505          		//pTouchEvent->state = PEN_NONE;
    506          	}
    507          	
    508          
    509          	#if 0
    510          			
    511          	tmpTime = getTick();
    512          
    513          	diffTime = getTickDiff(tmpTime, touch_time);
    514          		
    515          	//if(diffTime > 10 && diffTime < 2000)	//按下时间限制在10ms到2s
    516          	if(diffTime > 20)
    517          	{
    518          		x = x_touch;
    519          		y = y_touch;
    520          
    521          		ADS7843_Rd_Addata(&x_touch, &y_touch);
    522          	//	x_touch = ADS_Read_X();
    523          	//	y_touch = ADS_Read_Y();
    524          
    525          		
    526          		if(TOUCH_PressValid(x_touch, y_touch))
    527          		{
    528          			//if(x - x_touch >50 || x_touch - x >50 || y - y_touch >50 || y_touch - y >50)
    529          			if(abs(x - x_touch) > 50 || abs(y-y_touch) > 50)
    530          			{
    531          				return 0;
    532          			}
    533          		
    534          			TouchEvent.x  = (x + x_touch) >> 1;
    535          			TouchEvent.y = (y + y_touch) >> 1;
    536          			
    537          			touch_time = tmpTime;
    538          		}
    539          		else
    540          			return 0;
    541          
    542          	}
    543          	else
    544          	{
    545          		return 0;
    546          	}
    547          	
    548          	return &TouchEvent;
    549          #endif
    550          }
   \                     ??getTouchEvent_0: (+1)
   \   00000076   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x424182AC         DC32     0x424182ac

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x........         DC32     x_touch
    551          #else
    552          TOUCH_EVENT *getTouchEvent()
    553          {
    554          	uint32_t tmpTime, diffTime = 0;
    555          	int16_t x, y;
    556          
    557          	
    558          	//tan 20160830
    559          	ADS7843_Init();
    560          
    561          	tmpTime = getTick();
    562          
    563          	diffTime = getTickDiff(tmpTime, touch_time);
    564          		
    565          	//if(diffTime > 10 && diffTime < 2000)	//涓堕撮跺10ms2s
    566          	if(diffTime > 20)
    567          	{
    568          		x = x_touch;
    569          		y = y_touch;
    570          
    571          		ADS7843_Rd_Addata(&x_touch, &y_touch);
    572          	//	x_touch = ADS_Read_X();
    573          	//	y_touch = ADS_Read_Y();
    574          
    575          		touch_time = tmpTime;
    576          		
    577          		//if(x - x_touch >50 || x_touch - x >50 || y - y_touch >50 || y_touch - y >50)
    578          		if(abs(x - x_touch) > 50 || abs(y-y_touch) > 50)
    579          		{
    580          			return 0;
    581          		}
    582          
    583          		TouchEvent.x  = (x + x_touch) >> 1;
    584          		TouchEvent.y = (y + y_touch) >> 1;
    585          
    586          	}
    587          	else
    588          	{
    589          		return 0;
    590          	}
    591          	
    592          	return &TouchEvent;
    593          
    594          }
    595          #endif
    596          /*=====================================================================*/
    597          /*=====================================================================*/
    598          /*=====================================================================*/
    599          /*=====================================================================*/
    600          /*=====================================================================*/
    601          /*=====================================================================*/
    602          /*=====================================================================*/
    603          /*=====================================================================*/
    604          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   ADS7843_CS_config
       0   ADS7843_Init
      40   ADS7843_Rd_Addata
        40   -> SPI2_ReadWrite2Bytes
        40   -> SPI2_ReadWriteByte
       0   ARMJISHU_TouchScreen_ADS7843
       0   SPI1_Config
       0   SPI1_Init_For_Byte
       0   TOUCH_PressValid
       0   _AD2X
       0   _AD2Y
       0   distence
      32   getTouchEvent
        32   -> ADS7843_Rd_Addata
        32   -> TOUCH_PressValid
        32   -> abs
        32   -> getTick
        32   -> getTickDiff


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       2  ADS7843_CS_config
       2  ADS7843_Init
     208  ADS7843_Rd_Addata
       2  ARMJISHU_TouchScreen_ADS7843
       2  SPI1_Config
       2  SPI1_Init_For_Byte
      28  TOUCH_PressValid
      34  _AD2X
      30  _AD2Y
      18  distence
     122  getTouchEvent
       8  x_touch
          y_touch
          touch_time

 
   8 bytes in section .bss
 458 bytes in section .text
 
 458 bytes of CODE memory
   8 bytes of DATA memory

Errors: none
Warnings: 32
