///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM       16/Apr/2020  18:39:02
// Copyright 1999-2014 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\Marlin_main.cpp
//    Command line =  
//        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\Marlin_main.cpp
//        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
//        MKS_DLP_BOARD -D TFT35 -D USE_STM32F407VET -lC
//        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM\mksDLP/List\ -lA
//        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM\mksDLP/List\
//        --diag_suppress Pa050 -o
//        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM\mksDLP/Obj\ --no_unroll
//        --no_inline --no_tbaa --no_scheduling --debug --endian=little
//        --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp --dlib_config
//        "D:\Program Files (x86)\IAR Systems\Embedded Workbench
//        7.0\arm\INC\c\DLib_Config_Full.h" -I
//        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Inc\ -I
//        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Src\ -I
//        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
//        -I
//        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
//        -I
//        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
//        -I
//        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
//        -I
//        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
//        -I
//        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
//        -I
//        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Middlewares/Third_Party/FatFs/src\
//        -I
//        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Middlewares/Third_Party/Marlin\
//        -I
//        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/CMSIS/Include\
//        -I
//        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/BSP/variant\
//        -I
//        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/BSP/Components/at24cxx\
//        -I
//        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/BSP/Components/w25qxx\
//        -I
//        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/BSP/Components/ssd2828\
//        -I
//        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/BSP/Components/lcd\
//        -I D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/libstmf4\
//        -I
//        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/libstmf4/include\
//        -I
//        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Middlewares/arduino/stm32/cores/arduino\
//        -I D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../User/ui\ -I
//        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../User/ui/Multi_language\
//        -I D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../User/ui/QRENCODE\
//        -I D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Middlewares/GUI\
//        -Om --eec++ -I "D:\Program Files (x86)\IAR Systems\Embedded Workbench
//        7.0\arm\CMSIS\Include\"
//    List file    =  
//        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM\mksDLP/List\Marlin_main.s
//
///////////////////////////////////////////////////////////////////////////////

        RTMODEL "__CPP_Language", "EC++"
        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__dlib_file_descriptor", "1"
        RTMODEL "__dlib_full_locale_support", "1"
        RTMODEL "__iar_require _Printf", "floats,int_specials"
        AAPCS BASE,INTERWORK,VFP
        PRESERVE8
        REQUIRE8

        #define SHT_PROGBITS 0x1
        #define SHT_INIT_ARRAY 0xe

        EXTERN AT24CXX_Read
        EXTERN AT24CXX_Write
        EXTERN BMP_PIC_X
        EXTERN BMP_PIC_Y
        EXTERN GUI_DispStringAt
        EXTERN GUI_Exec
        EXTERN GUI_RefreshPage
        EXTERN GUI_SetBkColor
        EXTERN GUI_SetColor
        EXTERN GUI_TOUCH_Exec
        EXTERN HAL_Delay
        EXTERN HAL_GPIO_ReadPin
        EXTERN HAL_GPIO_WritePin
        EXTERN HAL_GetTick
        EXTERN HAL_SPI_Transmit_DMA
        EXTERN LCD_WriteRAM
        EXTERN LCD_WriteRAM_Prepare
        EXTERN LCD_setWindowArea
        EXTERN SPI1_ReadWriteByte
        EXTERN Serial6
        EXTERN TFT_screen
        EXTERN _Z10safe_delaym
        EXTERN _Z12wifi_loopingv
        EXTERN _Z14mksBeeperAlarmv
        EXTERN _Z17serial_echopair_PPKcS0_
        EXTERN _Z17serial_echopair_PPKcd
        EXTERN _Z17serial_echopair_PPKcf
        EXTERN _Z17serial_echopair_PPKci
        EXTERN _ZN10CardReader10removeFileEPc
        EXTERN _ZN10CardReader11openLogFileEPc
        EXTERN _ZN10CardReader11stopSDPrintEv
        EXTERN _ZN10CardReader12checkFilesysEh
        EXTERN _ZN10CardReader12pauseSDPrintEv
        EXTERN _ZN10CardReader13open_CBD_FileEPc
        EXTERN _ZN10CardReader13write_commandEPc
        EXTERN _ZN10CardReader14close_CBD_FileEv
        EXTERN _ZN10CardReader14startFileprintEv
        EXTERN _ZN10CardReader19printingHasFinishedEv
        EXTERN _ZN10CardReader2lsEv
        EXTERN _ZN10CardReader7releaseEv
        EXTERN _ZN10CardReader8getsdposEv
        EXTERN _ZN10CardReader8openFileEPcbb
        EXTERN _ZN10CardReader9closefileEb
        EXTERN _ZN10CardReader9getStatusEv
        EXTERN _ZN10CardReaderC1Ev
        EXTERN _ZN10USARTClass4readEv
        EXTERN _ZN10USARTClass5flushEv
        EXTERN _ZN10USARTClass5writeEh
        EXTERN _ZN10USARTClass9availableEv
        EXTERN _ZN11GCodeParser10string_argE
        EXTERN _ZN11GCodeParser11command_ptrE
        EXTERN _ZN11GCodeParser14command_letterE
        EXTERN _ZN11GCodeParser18volumetric_enabledE
        EXTERN _ZN11GCodeParser21unknown_command_errorEv
        EXTERN _ZN11GCodeParser5paramE
        EXTERN _ZN11GCodeParser5parseEPc
        EXTERN _ZN11GCodeParser7codenumE
        EXTERN _ZN11GCodeParser8codebitsE
        EXTERN _ZN11GCodeParser9value_ptrE
        EXTERN _ZN11Temperature12PID_autotuneEfaab
        EXTERN _ZN11Temperature13manage_heaterEv
        EXTERN _ZN11Temperature18target_temperatureE
        EXTERN _ZN11Temperature19current_temperatureE
        EXTERN _ZN11Temperature19disable_all_heatersEv
        EXTERN _ZN11Temperature21start_watching_heaterEh
        EXTERN _ZN11Temperature2KdE
        EXTERN _ZN11Temperature2KiE
        EXTERN _ZN11Temperature2KpE
        EXTERN _ZN11Temperature4initEv
        EXTERN _ZN14MarlinSettings4loadEv
        EXTERN _ZN14MarlinSettings4saveEv
        EXTERN _ZN14MarlinSettings5resetEv
        EXTERN _ZN14MarlinSettings6reportEb
        EXTERN _ZN5Print5printEPKc
        EXTERN _ZN5Print5printEdi
        EXTERN _ZN5Print5printEhi
        EXTERN _ZN5Print5printEii
        EXTERN _ZN5Print5printEji
        EXTERN _ZN5Print5printEli
        EXTERN _ZN7Planner12accelerationE
        EXTERN _ZN7Planner13filament_sizeE
        EXTERN _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
        EXTERN _ZN7Planner15flow_percentageE
        EXTERN _ZN7Planner15set_position_mmE8AxisEnumRKf
        EXTERN _ZN7Planner16_set_position_mmERKfS1_S1_S1_
        EXTERN _ZN7Planner17axis_steps_per_mmE
        EXTERN _ZN7Planner17block_buffer_headE
        EXTERN _ZN7Planner17block_buffer_tailE
        EXTERN _ZN7Planner17max_feedrate_mm_sE
        EXTERN _ZN7Planner17min_feedrate_mm_sE
        EXTERN _ZN7Planner18autotemp_M104_M109Ev
        EXTERN _ZN7Planner19check_axes_activityEv
        EXTERN _ZN7Planner19min_segment_time_usE
        EXTERN _ZN7Planner19refresh_positioningEv
        EXTERN _ZN7Planner19travel_accelerationE
        EXTERN _ZN7Planner20retract_accelerationE
        EXTERN _ZN7Planner21volumetric_multiplierE
        EXTERN _ZN7Planner24min_travel_feedrate_mm_sE
        EXTERN _ZN7Planner24reset_acceleration_ratesEv
        EXTERN _ZN7Planner26max_acceleration_mm_per_s2E
        EXTERN _ZN7Planner29max_acceleration_steps_per_s2E
        EXTERN _ZN7Planner32calculate_volumetric_multipliersEv
        EXTERN _ZN7Planner8e_factorE
        EXTERN _ZN7Planner8max_jerkE
        EXTERN _ZN7SSD28284initEv
        EXTERN _ZN7SSD28288sleep_inEv
        EXTERN _ZN7SSD28289sleep_outEv
        EXTERN _ZN7SSD2828C1Ev
        EXTERN _ZN7Stepper10quick_stopEv
        EXTERN _ZN7Stepper11synchronizeEv
        EXTERN _ZN7Stepper16report_positionsEv
        EXTERN _ZN7Stepper18finish_and_disableEv
        EXTERN _ZN7Stepper20get_axis_position_mmE8AxisEnum
        EXTERN _ZN7Stepper23cleaning_buffer_counterE
        EXTERN _ZN7Stepper4initEv
        EXTERN _ZN8Endstops12report_stateEv
        EXTERN _ZN8Endstops16enabled_globallyE
        EXTERN _ZN8Endstops16endstop_hit_bitsE
        EXTERN _ZN8Endstops4M119Ev
        EXTERN _ZN8Endstops7enabledE
        EXTERN _ZN9Stopwatch4stopEv
        EXTERN _ZN9Stopwatch5pauseEv
        EXTERN _ZN9Stopwatch5startEv
        EXTERN _ZN9Stopwatch8durationEv
        EXTERN _ZN9StopwatchC1Ev
        EXTERN __aeabi_d2f
        EXTERN __aeabi_d2uiz
        EXTERN __aeabi_dadd
        EXTERN __aeabi_ddiv
        EXTERN __aeabi_dmul
        EXTERN __aeabi_dsub
        EXTERN __aeabi_f2d
        EXTERN __aeabi_i2d
        EXTERN __aeabi_memcpy
        EXTERN __aeabi_memcpy4
        EXTERN __aeabi_ui2d
        EXTERN __iar_Strchr
        EXTERN __iar_Strrchr
        EXTERN __iar_Strstr
        EXTERN atan2f
        EXTERN atof
        EXTERN bmp_layer_buf
        EXTERN bmp_public_buf
        EXTERN clean_time_flg
        EXTERN clear_cur_ui
        EXTERN cosf
        EXTERN curFileName
        EXTERN default_preview_flg
        EXTERN disp_pre_gcode
        EXTERN disp_state
        EXTERN display_print_statue
        EXTERN draw_dialog
        EXTERN draw_printing
        EXTERN draw_ready_print
        EXTERN draw_status_clear
        EXTERN echomagic
        EXTERN epr_read_data
        EXTERN epr_write_data
        EXTERN errormagic
        EXTERN espGcodeFifo
        EXTERN exposure_msg_display
        EXTERN f_lseek
        EXTERN f_read
        EXTERN filament_det1_cnt
        EXTERN filament_det1_flg
        EXTERN filament_det1_high_cnt
        EXTERN filament_det1_high_flg
        EXTERN filament_det1_low_cnt
        EXTERN filament_det1_low_flg
        EXTERN filament_det2_cnt
        EXTERN filament_det2_flg
        EXTERN filament_det2_high_cnt
        EXTERN filament_det2_high_flg
        EXTERN filament_det2_low_cnt
        EXTERN filament_det2_low_flg
        EXTERN flash_preview_begin
        EXTERN floorf
        EXTERN from_flash_pic
        EXTERN gArrayGpioPin
        EXTERN gArrayGpioPort
        EXTERN gCfgItems
        EXTERN getTick
        EXTERN getTickDiff
        EXTERN hdma_spi1_tx
        EXTERN hspi1
        EXTERN ipPara
        EXTERN layer_pic_clean
        EXTERN layer_pic_display
        EXTERN leveling_first_time
        EXTERN logo_tick1
        EXTERN logo_tick2
        EXTERN memcpy
        EXTERN memset
        EXTERN mipi_te_cnt
        EXTERN mksCfg
        EXTERN parser
        EXTERN pause_resum
        EXTERN poweroff_det_cnt
        EXTERN poweroff_det_flg
        EXTERN poweroff_det_high_cnt
        EXTERN poweroff_det_high_flg
        EXTERN poweroff_det_low_cnt
        EXTERN poweroff_det_low_flg
        EXTERN preview_gcode_prehandle
        EXTERN print_time
        EXTERN reset_file_info
        EXTERN reset_print_time
        EXTERN setProBarRate
        EXTERN sinf
        EXTERN sprintf
        EXTERN sqrt
        EXTERN sqrtf
        EXTERN start_print_time
        EXTERN stop_print_time
        EXTERN strcat
        EXTERN strcmp
        EXTERN strcpy
        EXTERN strncpy
        EXTERN strtod
        EXTERN strtol
        EXTERN strtoul
        EXTERN temperature_change_frequency
        EXTERN thermalManager
        EXTERN time_1s_flg
        EXTERN wifiPara
        EXTERN wifi_check_time
        EXTERN wifi_link_state

        PUBLIC EXTI9_5_IRQHandler
        PUBLIC Line_Pixel
        PUBLIC Line_Pixel_TFT
        PUBLIC Running
        PUBLIC TimeIncrease
        PUBLIC _Z10clr_ticketv
        PUBLIC _Z10freeMemoryv
        PUBLIC _Z10gcode_M104v
        PUBLIC _Z10gcode_M105v
        PUBLIC _Z10gcode_M106v
        PUBLIC _Z10gcode_M107v
        PUBLIC _Z10gcode_M108v
        PUBLIC _Z10gcode_M109v
        PUBLIC _Z10gcode_M110v
        PUBLIC _Z10gcode_M111v
        PUBLIC _Z10gcode_M112v
        PUBLIC _Z10gcode_M114v
        PUBLIC _Z10gcode_M115v
        PUBLIC _Z10gcode_M117v
        PUBLIC _Z10gcode_M118v
        PUBLIC _Z10gcode_M119v
        PUBLIC _Z10gcode_M120v
        PUBLIC _Z10gcode_M121v
        PUBLIC _Z10gcode_M140v
        PUBLIC _Z10gcode_M200v
        PUBLIC _Z10gcode_M201v
        PUBLIC _Z10gcode_M203v
        PUBLIC _Z10gcode_M204v
        PUBLIC _Z10gcode_M205v
        PUBLIC _Z10gcode_M206v
        PUBLIC _Z10gcode_M211v
        PUBLIC _Z10gcode_M220v
        PUBLIC _Z10gcode_M221v
        PUBLIC _Z10gcode_M226v
        PUBLIC _Z10gcode_M301v
        PUBLIC _Z10gcode_M303v
        PUBLIC _Z10gcode_M355v
        PUBLIC _Z10gcode_M400v
        PUBLIC _Z10gcode_M410v
        PUBLIC _Z10gcode_M428v
        PUBLIC _Z10gcode_M500v
        PUBLIC _Z10gcode_M501v
        PUBLIC _Z10gcode_M502v
        PUBLIC _Z10gcode_M503v
        PUBLIC _Z10gcode_M907v
        PUBLIC _Z10gcode_M928v
        PUBLIC _Z10gcode_M998v
        PUBLIC _Z10gcode_M999v
        PUBLIC _Z10ok_to_sendv
        PUBLIC _Z10servo_initv
        PUBLIC _Z11InvertUint8PhS_
        PUBLIC _Z11gcode_G0_G1v
        PUBLIC _Z11gcode_G2_G3b
        PUBLIC _Z11lcd_refreshv
        PUBLIC _Z11tool_changehfb
        PUBLIC _Z12CRC16_XMODEMPhj
        PUBLIC _Z12InvertUint16PtS_
        PUBLIC _Z13find_next_bmpv
        PUBLIC _Z13gcode_M18_M84v
        PUBLIC _Z13home_all_axesv
        PUBLIC _Z13lcd_hasstatusv
        PUBLIC _Z13lcd_setstatusPKcb
        PUBLIC _Z13setup_killpinv
        PUBLIC _Z13strting2floatPhh
        PUBLIC _Z14mks_WriteToEprv
        PUBLIC _Z14serialprintPGMPKc
        PUBLIC _Z15_commit_commandb
        PUBLIC _Z15_enqueuecommandPKcb
        PUBLIC _Z15mks_setFeedratev
        PUBLIC _Z15setup_powerholdv
        PUBLIC _Z16gcode_line_errorPKcb
        PUBLIC _Z16lcd_setstatusPGMPKca
        PUBLIC _Z16mks_get_commandsv
        PUBLIC _Z17get_wifi_commandsv
        PUBLIC _Z17manage_inactivityb
        PUBLIC _Z17mkstft_ui_set_eprv
        PUBLIC _Z17quickstop_stepperv
        PUBLIC _Z17temper_error_killv
        PUBLIC _Z18axis_unhomed_errorb
        PUBLIC _Z18disable_e_steppersv
        PUBLIC _Z18mks_setTemperaturev
        PUBLIC _Z18sync_plan_positionv
        PUBLIC _Z19clear_command_queuev
        PUBLIC _Z19do_blocking_move_toRKfS0_S0_S0_
        PUBLIC _Z19enable_all_steppersv
        PUBLIC _Z19get_serial_commandsv
        PUBLIC _Z19refresh_cmd_timeoutv
        PUBLIC _Z20SysTick_Handler_Userv
        PUBLIC _Z20disable_all_steppersv
        PUBLIC _Z20display_temper_errorv
        PUBLIC _Z20process_next_commandv
        PUBLIC _Z20sync_plan_position_ev
        PUBLIC _Z21do_blocking_move_to_xRKfS0_
        PUBLIC _Z21do_blocking_move_to_zRKfS0_
        PUBLIC _Z21gcode_get_destinationv
        PUBLIC _Z21lcd_reset_alert_levelv
        PUBLIC _Z21lcd_setalertstatusPGMPKc
        PUBLIC _Z21mks_WriteToEpr_pwroffv
        PUBLIC _Z21soft_endstop_min_initv
        PUBLIC _Z22do_blocking_move_to_xyRKfS0_S0_
        PUBLIC _Z22get_available_commandsv
        PUBLIC _Z22invalid_extruder_errorh
        PUBLIC _Z22mks_ReadFromEpr_pwroffv
        PUBLIC _Z22process_parsed_commandv
        PUBLIC _Z22report_mksdlp_positionv
        PUBLIC _Z23report_current_positionv
        PUBLIC _Z24FlushSerialRequestResendv
        PUBLIC _Z24enqueue_and_echo_commandPKcb
        PUBLIC _Z24get_homing_bump_feedrate8AxisEnum
        PUBLIC _Z24update_software_endstops8AxisEnum
        PUBLIC _Z26buffer_line_to_destinationf
        PUBLIC _Z26clamp_to_software_endstopsPf
        PUBLIC _Z26do_blocking_move_to_nowaitRKfS0_S0_S0_
        PUBLIC _Z27enqueue_and_echo_commands_PPKc
        PUBLIC _Z27get_cartesian_from_steppersv
        PUBLIC _Z27prepare_move_to_destinationv
        PUBLIC _Z28do_blocking_move_to_z_nowaitRKfS0_
        PUBLIC _Z28set_current_from_destinationv
        PUBLIC _Z28set_destination_from_currentv
        PUBLIC _Z31buffer_line_to_current_positionv
        PUBLIC _Z32get_target_extruder_from_commandt
        PUBLIC _Z34set_current_from_steppers_for_axis8AxisEnum
        PUBLIC _Z37prepare_move_to_destination_cartesianv
        PUBLIC _Z4idlev
        PUBLIC _Z4killPKc
        PUBLIC _Z4stopv
        PUBLIC _Z5dwellm
        PUBLIC _Z6strchrPci
        PUBLIC _Z6strstrPcPKc
        PUBLIC _Z7gcode_Th
        PUBLIC _Z7mks_G28Pc
        PUBLIC _Z7pft_getv
        PUBLIC _Z7strrchrPci
        PUBLIC _Z7suicidev
        PUBLIC _Z8gcode_G4v
        PUBLIC _Z8lcd_initv
        PUBLIC _Z8plan_arcRA4_KfRA2_S_b
        PUBLIC _Z9IsRunningv
        PUBLIC _Z9IsStoppedv
        PUBLIC _Z9gcode_G28b
        PUBLIC _Z9gcode_G92v
        PUBLIC _Z9gcode_M17v
        PUBLIC _Z9gcode_M20v
        PUBLIC _Z9gcode_M22v
        PUBLIC _Z9gcode_M23v
        PUBLIC _Z9gcode_M24v
        PUBLIC _Z9gcode_M25v
        PUBLIC _Z9gcode_M26v
        PUBLIC _Z9gcode_M27v
        PUBLIC _Z9gcode_M28v
        PUBLIC _Z9gcode_M29v
        PUBLIC _Z9gcode_M30v
        PUBLIC _Z9gcode_M31v
        PUBLIC _Z9gcode_M32v
        PUBLIC _Z9gcode_M42v
        PUBLIC _Z9gcode_M75v
        PUBLIC _Z9gcode_M76v
        PUBLIC _Z9gcode_M77v
        PUBLIC _Z9gcode_M81v
        PUBLIC _Z9gcode_M82v
        PUBLIC _Z9gcode_M83v
        PUBLIC _Z9gcode_M85v
        PUBLIC _Z9gcode_M92v
        PUBLIC _ZN10CardReader10isFileOpenEv
        PUBLIC _ZN10CardReader3eofEv
        PUBLIC _ZN10CardReader4getsEPhj
        PUBLIC _ZN10CardReader8setIndexEl
        PUBLIC _ZN10duration_tC1ERKj
        PUBLIC _ZN11GCodeParser10celsiusvalEcf
        PUBLIC _ZN11GCodeParser10value_boolEv
        PUBLIC _ZN11GCodeParser10value_byteEv
        PUBLIC _ZN11GCodeParser10value_longEv
        PUBLIC _ZN11GCodeParser11value_floatEv
        PUBLIC _ZN11GCodeParser11value_ulongEv
        PUBLIC _ZN11GCodeParser12value_millisEv
        PUBLIC _ZN11GCodeParser12value_ushortEv
        PUBLIC _ZN11GCodeParser13value_celsiusEv
        PUBLIC _ZN11GCodeParser14value_feedrateEv
        PUBLIC _ZN11GCodeParser16value_axis_unitsE8AxisEnum
        PUBLIC _ZN11GCodeParser18value_linear_unitsEv
        PUBLIC _ZN11GCodeParser19value_per_axis_unitE8AxisEnum
        PUBLIC _ZN11GCodeParser25value_millis_from_secondsEv
        PUBLIC _ZN11GCodeParser4seenEc
        PUBLIC _ZN11GCodeParser6intvalEcs
        PUBLIC _ZN11GCodeParser7boolvalEc
        PUBLIC _ZN11GCodeParser7bytevalEch
        PUBLIC _ZN11GCodeParser7seenvalEc
        PUBLIC _ZN11GCodeParser9has_valueEv
        PUBLIC _ZN11GCodeParser9linearvalEcf
        PUBLIC _ZN11GCodeParser9ushortvalEct
        PUBLIC _ZN11GCodeParser9value_intEv
        PUBLIC _ZN11Temperature12setTargetBedEf
        PUBLIC _ZN11Temperature15degTargetHotendEh
        PUBLIC _ZN11Temperature15isCoolingHotendEh
        PUBLIC _ZN11Temperature15setTargetHotendEfh
        PUBLIC _ZN11Temperature9degHotendEh
        PUBLIC _ZN11Temperature9updatePIDEv
        PUBLIC _ZN7MKS_DLP10get_HeightEv
        PUBLIC _ZN7MKS_DLP10pausePrintEv
        PUBLIC _ZN7MKS_DLP10quick_stopEv
        PUBLIC _ZN7MKS_DLP11buzzer_toneEtth
        PUBLIC _ZN7MKS_DLP11resumePrintEv
        PUBLIC _ZN7MKS_DLP11set_ZoffsetEv
        PUBLIC _ZN7MKS_DLP11status_initEv
        PUBLIC _ZN7MKS_DLP12ExposureTestEv
        PUBLIC _ZN7MKS_DLP12get_cpld_verEv
        PUBLIC _ZN7MKS_DLP13buzzer_enableEh
        PUBLIC _ZN7MKS_DLP13draw_printingEv
        PUBLIC _ZN7MKS_DLP13get_LedOnTimeEv
        PUBLIC _ZN7MKS_DLP13line_gen_dataEth
        PUBLIC _ZN7MKS_DLP13set_LedOnTimeEt
        PUBLIC _ZN7MKS_DLP14CleanDataTransEv
        PUBLIC _ZN7MKS_DLP14ExposureAll_onEv
        PUBLIC _ZN7MKS_DLP14bank2disp_readEv
        PUBLIC _ZN7MKS_DLP14buzzer_pollingEv
        PUBLIC _ZN7MKS_DLP14get_LedOffTimeEv
        PUBLIC _ZN7MKS_DLP14line_fill_zeroEth
        PUBLIC _ZN7MKS_DLP14moveRelative_ZEff
        PUBLIC _ZN7MKS_DLP14reTransmissionEv
        PUBLIC _ZN7MKS_DLP14set_LedOffTimeEt
        PUBLIC _ZN7MKS_DLP14startFileprintEv
        PUBLIC _ZN7MKS_DLP15ExposureAll_offEv
        PUBLIC _ZN7MKS_DLP15get_sdcard_bmpsEv
        PUBLIC _ZN7MKS_DLP15get_totalLayersEv
        PUBLIC _ZN7MKS_DLP15moveFistLayer_ZEv
        PUBLIC _ZN7MKS_DLP16Can_Resume_PrintEv
        PUBLIC _ZN7MKS_DLP16TFT_display_testEv
        PUBLIC _ZN7MKS_DLP16bank2disp_enableEhhh
        PUBLIC _ZN7MKS_DLP16bottomLayerPrintEv
        PUBLIC _ZN7MKS_DLP16get_BottomlayersEv
        PUBLIC _ZN7MKS_DLP16get_currentLayerEv
        PUBLIC _ZN7MKS_DLP16get_ttfStatus_ONEv
        PUBLIC _ZN7MKS_DLP16set_BottomlayersEt
        PUBLIC _ZN7MKS_DLP17PrintStatePollingEv
        PUBLIC _ZN7MKS_DLP17get_buzzer_statusEv
        PUBLIC _ZN7MKS_DLP17get_ttfStatus_OFFEv
        PUBLIC _ZN7MKS_DLP17line_fill_all_oneEh
        PUBLIC _ZN7MKS_DLP17line_gen_data_TFTEt
        PUBLIC _ZN7MKS_DLP18GeneralLayersPrintEv
        PUBLIC _ZN7MKS_DLP18Is_Paused_FinishedEv
        PUBLIC _ZN7MKS_DLP18contiuePrint_PwdwnEv
        PUBLIC _ZN7MKS_DLP18get_available_bmpsEv
        PUBLIC _ZN7MKS_DLP18get_totalPrintTimeEv
        PUBLIC _ZN7MKS_DLP18line_fill_all_zeroEcth
        PUBLIC _ZN7MKS_DLP18startFileprint_cbdEv
        PUBLIC _ZN7MKS_DLP19contiuePrint_pausedEv
        PUBLIC _ZN7MKS_DLP19get_BottomLedOnTimeEv
        PUBLIC _ZN7MKS_DLP19printingHasFinishedEv
        PUBLIC _ZN7MKS_DLP19set_BottomLedOnTimeEt
        PUBLIC _ZN7MKS_DLP20get_currentPrintTimeEv
        PUBLIC _ZN7MKS_DLP21bank2disp_enable_grayEhhhh
        PUBLIC _ZN7MKS_DLP21decode_layer_from_rleEjh
        PUBLIC _ZN7MKS_DLP22get_cbddlp_file_headerEv
        PUBLIC _ZN7MKS_DLP22moveRelativeZandGetBmpEff
        PUBLIC _ZN7MKS_DLP22read_Information_layerEv
        PUBLIC _ZN7MKS_DLP22set_test_exposure_timeEt
        PUBLIC _ZN7MKS_DLP23ExposureData2TFT_circleEv
        PUBLIC _ZN7MKS_DLP23clean_Information_layerEv
        PUBLIC _ZN7MKS_DLP23draw_return_printing_uiEv
        PUBLIC _ZN7MKS_DLP23read_Information_pausedEv
        PUBLIC _ZN7MKS_DLP23write_Information_layerE15DLP_MOVE_STATUS
        PUBLIC _ZN7MKS_DLP24ExposureDataTrans_circleEv
        PUBLIC _ZN7MKS_DLP24ExposureDataTrans_squareEv
        PUBLIC _ZN7MKS_DLP24get_cbddlp_cur_layer_defEj
        PUBLIC _ZN7MKS_DLP24get_cbddlp_preview1_infoEv
        PUBLIC _ZN7MKS_DLP24get_cbddlp_preview2_infoEv
        PUBLIC _ZN7MKS_DLP24write_Information_pausedEv
        PUBLIC _ZN7MKS_DLP26get_cbddlp_print_para_infoEv
        PUBLIC _ZN7MKS_DLP6led_onEv
        PUBLIC _ZN7MKS_DLP7getHeadEv
        PUBLIC _ZN7MKS_DLP7led_offEv
        PUBLIC _ZN7MKS_DLP8getHead1Ev
        PUBLIC _ZN7MKS_DLP8getHead2Ev
        PUBLIC _ZN7MKS_DLP8power_onEv
        PUBLIC _ZN7MKS_DLP9dlp_startEv
        PUBLIC _ZN7MKS_DLP9grag_testEv
        PUBLIC _ZN7MKS_DLP9moveMax_ZEv
        PUBLIC _ZN7MKS_DLP9power_offEv
        PUBLIC _ZN7MKS_DLP9stopPrintEv
        PUBLIC _ZN7MKS_DLPC1Ev
        PUBLIC _ZN7MKS_DLPC2Ev
        PUBLIC _ZN7Planner11buffer_lineEfffRKfS1_h
        PUBLIC _ZN7Planner13blocks_queuedEv
        PUBLIC _ZN7Planner15set_position_mmEfffRKf
        PUBLIC _ZN7Planner16refresh_e_factorEh
        PUBLIC _ZN7Planner17set_e_position_mmERKf
        PUBLIC _ZN7Planner17set_filament_sizeEhRKf
        PUBLIC _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
        PUBLIC _ZN8Endstops10not_homingEv
        PUBLIC _ZN8Endstops14hit_on_purposeEv
        PUBLIC _ZN8Endstops15enable_globallyEb
        PUBLIC _ZN8Endstops6enableEb
        PUBLIC _ZNK10duration_t3dayEv
        PUBLIC _ZNK10duration_t4hourEv
        PUBLIC _ZNK10duration_t4yearEv
        PUBLIC _ZNK10duration_t6minuteEv
        PUBLIC _ZNK10duration_t6secondEv
        PUBLIC _ZNK10duration_t8toStringEPc
        PUBLIC _ZTI5Print
        PUBLIC _ZZ10gcode_M104vEs
        PUBLIC _ZZ10gcode_M104vEs_0
        PUBLIC _ZZ10gcode_M104vEs_1
        PUBLIC _ZZ10gcode_M104vEs_2
        PUBLIC _ZZ10gcode_M104vEs_3
        PUBLIC _ZZ10gcode_M104vEs_4
        PUBLIC _ZZ10gcode_M105vEs
        PUBLIC _ZZ10gcode_M109vEs
        PUBLIC _ZZ10gcode_M109vEs_0
        PUBLIC _ZZ10gcode_M109vEs_1
        PUBLIC _ZZ10gcode_M109vEs_2
        PUBLIC _ZZ10gcode_M109vEs_3
        PUBLIC _ZZ10gcode_M109vEs_4
        PUBLIC _ZZ10gcode_M109vEs_5
        PUBLIC _ZZ10gcode_M109vEs_6
        PUBLIC _ZZ10gcode_M111vE11str_debug_1
        PUBLIC _ZZ10gcode_M111vE11str_debug_2
        PUBLIC _ZZ10gcode_M111vE11str_debug_4
        PUBLIC _ZZ10gcode_M111vE11str_debug_8
        PUBLIC _ZZ10gcode_M111vE12str_debug_16
        PUBLIC _ZZ10gcode_M111vE13debug_strings
        PUBLIC _ZZ10gcode_M111vEs_4
        PUBLIC _ZZ10gcode_M111vEs_5
        PUBLIC _ZZ10gcode_M112vEs
        PUBLIC _ZZ10gcode_M115vEs
        PUBLIC _ZZ10gcode_M115vEs_0
        PUBLIC _ZZ10gcode_M115vEs_1
        PUBLIC _ZZ10gcode_M115vEs_2
        PUBLIC _ZZ10gcode_M115vEs_3
        PUBLIC _ZZ10gcode_M115vEs_4
        PUBLIC _ZZ10gcode_M115vEs_5
        PUBLIC _ZZ10gcode_M115vEs_6
        PUBLIC _ZZ10gcode_M115vEs_7
        PUBLIC _ZZ10gcode_M115vEs_8
        PUBLIC _ZZ10gcode_M115vEs_9
        PUBLIC _ZZ10gcode_M115vEs__10_
        PUBLIC _ZZ10gcode_M115vEs__11_
        PUBLIC _ZZ10gcode_M115vEs__12_
        PUBLIC _ZZ10gcode_M115vEs__13_
        PUBLIC _ZZ10gcode_M118vEs
        PUBLIC _ZZ10gcode_M204vEs
        PUBLIC _ZZ10gcode_M204vEs_0
        PUBLIC _ZZ10gcode_M204vEs_1
        PUBLIC _ZZ10gcode_M204vEs_2
        PUBLIC _ZZ10gcode_M211vEs
        PUBLIC _ZZ10gcode_M211vEs_0
        PUBLIC _ZZ10gcode_M211vEs_1
        PUBLIC _ZZ10gcode_M211vEs_2
        PUBLIC _ZZ10gcode_M211vEs_3
        PUBLIC _ZZ10gcode_M211vEs_4
        PUBLIC _ZZ10gcode_M211vEs_5
        PUBLIC _ZZ10gcode_M211vEs_6
        PUBLIC _ZZ10gcode_M301vEs
        PUBLIC _ZZ10gcode_M301vEs_0
        PUBLIC _ZZ10gcode_M301vEs_1
        PUBLIC _ZZ10gcode_M301vEs_2
        PUBLIC _ZZ10gcode_M355vEs
        PUBLIC _ZZ10gcode_M428vEs
        PUBLIC _ZZ10gcode_M428vEs_0
        PUBLIC _ZZ10gcode_M428vEs_1
        PUBLIC _ZZ11gcode_G2_G3bEs
        PUBLIC _ZZ17get_wifi_commandsvE16wifi_line_buffer
        PUBLIC _ZZ17get_wifi_commandsvE17wifi_comment_mode
        PUBLIC _ZZ17get_wifi_commandsvEs
        PUBLIC _ZZ17get_wifi_commandsvEs_0
        PUBLIC _ZZ17get_wifi_commandsvEs_1
        PUBLIC _ZZ17get_wifi_commandsvEs_2
        PUBLIC _ZZ17get_wifi_commandsvEs_3
        PUBLIC _ZZ17get_wifi_commandsvEs_4
        PUBLIC _ZZ19get_serial_commandsvE14last_wait_time
        PUBLIC _ZZ19get_serial_commandsvE18serial_line_buffer
        PUBLIC _ZZ19get_serial_commandsvE19serial_comment_mode
        PUBLIC _ZZ19get_serial_commandsvEs
        PUBLIC _ZZ19get_serial_commandsvEs_0
        PUBLIC _ZZ19get_serial_commandsvEs_1
        PUBLIC _ZZ19get_serial_commandsvEs_2
        PUBLIC _ZZ19get_serial_commandsvEs_3
        PUBLIC _ZZ19get_serial_commandsvEs_4
        PUBLIC _ZZ19get_serial_commandsvEs_5
        PUBLIC _ZZ19get_serial_commandsvEs_6
        PUBLIC _ZZ19get_serial_commandsvEs_7
        PUBLIC _ZZ19get_serial_commandsvEs_8
        PUBLIC _ZZ22invalid_extruder_errorhEs
        PUBLIC _ZZ24get_homing_bump_feedrate8AxisEnumEs
        PUBLIC _ZZ8gcode_G4vEs
        PUBLIC _ZZ9gcode_M17vEs
        PUBLIC _ZZ9gcode_M20vEs
        PUBLIC _ZZ9gcode_M20vEs_0
        PUBLIC _ZZ9gcode_M31vEs
        PUBLIC _ZZ9gcode_M42vEs
        PUBLIC _ZZNK10duration_t8toStringEPcEs
        PUBLIC _ZZNK10duration_t8toStringEPcEs_0
        PUBLIC _ZZNK10duration_t8toStringEPcEs_1
        PUBLIC _ZZNK10duration_t8toStringEPcEs_2
        PUBLIC _ZZNK10duration_t8toStringEPcEs_3
        PUBLIC aalay_cnt
        PUBLIC active_extruder
        PUBLIC axis_homed
        PUBLIC axis_known_position
        PUBLIC axis_relative_modes
        PUBLIC base_home_pos_P
        PUBLIC base_max_pos_P
        PUBLIC base_min_pos_P
        PUBLIC btn_beep_cnt
        PUBLIC btn_beeper
        PUBLIC btn_flg
        PUBLIC card
        PUBLIC cartes
        PUBLIC cbddlp_file_header
        PUBLIC cloud_refresh_flg
        PUBLIC commands_in_queue
        PUBLIC continue_print_error_flg
        PUBLIC ctemp
        PUBLIC current_position
        PUBLIC destination
        PUBLIC fanSpeeds
        PUBLIC feedrate_mm_s
        PUBLIC feedrate_percentage
        PUBLIC from_wifi_flag
        PUBLIC get_pic_display
        PUBLIC get_pic_info
        PUBLIC home_bump_mm_P
        PUBLIC home_dir_P
        PUBLIC home_offset
        PUBLIC homing_feedrate_mm_s
        PUBLIC kill_c
        PUBLIC layer_def
        PUBLIC loop
        PUBLIC marlin_debug_flags
        PUBLIC max_length_P
        PUBLIC mksReprint
        PUBLIC mks_PrintStatePolling
        PUBLIC mks_ReadFromEpr
        PUBLIC mks_ReadFromFile
        PUBLIC mks_WriteToFile
        PUBLIC mks_clearDir
        PUBLIC mks_clearFile
        PUBLIC mks_contiuePrintDelta
        PUBLIC mks_contiuePrintPause
        PUBLIC mks_contiuePrintPwdwn
        PUBLIC mks_contiuePrint_UI
        PUBLIC mks_getPositionXYZE
        PUBLIC mks_heating_busy
        PUBLIC mks_initPrint
        PUBLIC mks_manual_leveling
        PUBLIC mks_moveXY
        PUBLIC mks_moveZ
        PUBLIC mks_pausePrint
        PUBLIC mks_pft_name
        PUBLIC mks_preExtrude
        PUBLIC mks_rePrintCheck
        PUBLIC mks_resumePrint
        PUBLIC mks_saveFileName
        PUBLIC mks_setPositionZ
        PUBLIC mksdlp
        PUBLIC mkstft_ui_init
        PUBLIC mkstft_ui_load
        PUBLIC position_shift
        PUBLIC preview_no_display
        PUBLIC preview_pic1
        PUBLIC preview_pic2
        PUBLIC previous_cmd_ms
        PUBLIC print_job_timer
        PUBLIC print_para
        PUBLIC printing_rate_update_flag
        PUBLIC reTransmission_all_cnt
        PUBLIC reTransmission_data_cnt
        PUBLIC reTransmission_zero_cnt
        PUBLIC saved_feedrate_percentage
        PUBLIC serial_wait_tick
        PUBLIC setup
        PUBLIC soft_endstop_max
        PUBLIC soft_endstop_min
        PUBLIC soft_endstops_enabled
        PUBLIC spi1_hdmatx_CR
        PUBLIC t1
        PUBLIC t12
        PUBLIC t2
        PUBLIC target_extruder
        PUBLIC temper_error_flg
        PUBLIC wait_for_heatup
        PUBLIC waiting_wifi_time
        PUBLIC wifi_init_flg
        PUBLIC wifi_init_state
        PUBLIC wifi_loop_cycle
        PUBLIC wifi_refresh_flg
        PUBLIC workspace_offset
        PUBLIC z_high_count
        
          CFI Names cfiNames0
          CFI StackFrame CFA R13 DATA
          CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
          CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, R13:32, R14:32
          CFI Resource D0:64, D1:64, D2:64, D3:64, D4:64, D5:64, D6:64, D7:64
          CFI Resource D8:64, D9:64, D10:64, D11:64, D12:64, D13:64, D14:64
          CFI Resource D15:64
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 4
          CFI ReturnAddress R14 CODE
          CFI CFA R13+0
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R12 Undefined
          CFI R14 SameValue
          CFI D0 Undefined
          CFI D1 Undefined
          CFI D2 Undefined
          CFI D3 Undefined
          CFI D4 Undefined
          CFI D5 Undefined
          CFI D6 Undefined
          CFI D7 Undefined
          CFI D8 SameValue
          CFI D9 SameValue
          CFI D10 SameValue
          CFI D11 SameValue
          CFI D12 SameValue
          CFI D13 SameValue
          CFI D14 SameValue
          CFI D15 SameValue
          CFI EndCommon cfiCommon0
        

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function _ZN7MKS_DLPC2Ev
          CFI FunCall _ZN7MKS_DLPC1Ev
        THUMB
// __code __interwork __softfp MKS_DLP::subobject MKS_DLP()
_ZN7MKS_DLPC2Ev:
        B.W      _ZN7MKS_DLPC1Ev
          CFI EndBlock cfiBlock0
// D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\Marlin_main.cpp
//    1 /**
//    2  * Marlin 3D Printer Firmware
//    3  * Copyright (C) 2016, 2017 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
//    4  *
//    5  * Based on Sprinter and grbl.
//    6  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
//    7  *
//    8  * This program is free software: you can redistribute it and/or modify
//    9  * it under the terms of the GNU General Public License as published by
//   10  * the Free Software Foundation, either version 3 of the License, or
//   11  * (at your option) any later version.
//   12  *
//   13  * This program is distributed in the hope that it will be useful,
//   14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
//   15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   16  * GNU General Public License for more details.
//   17  *
//   18  * You should have received a copy of the GNU General Public License
//   19  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
//   20  *
//   21  */
//   22 
//   23 /**
//   24  * About Marlin
//   25  *
//   26  * This firmware is a mashup between Sprinter and grbl.
//   27  *  - https://github.com/kliment/Sprinter
//   28  *  - https://github.com/simen/grbl/tree
//   29  */
//   30 
//   31 /**
//   32  * -----------------
//   33  * G-Codes in Marlin
//   34  * -----------------
//   35  *
//   36  * Helpful G-code references:
//   37  *  - http://linuxcnc.org/handbook/gcode/g-code.html
//   38  *  - http://objects.reprap.org/wiki/Mendel_User_Manual:_RepRapGCodes
//   39  *
//   40  * Help to document Marlin's G-codes online:
//   41  *  - http://reprap.org/wiki/G-code
//   42  *  - https://github.com/MarlinFirmware/MarlinDocumentation
//   43  *
//   44  * -----------------
//   45  *
//   46  * "G" Codes
//   47  *
//   48  * G0   -> G1
//   49  * G1   - Coordinated Movement X Y Z E
//   50  * G2   - CW ARC
//   51  * G3   - CCW ARC
//   52  * G4   - Dwell S<seconds> or P<milliseconds>
//   53  * G5   - Cubic B-spline with XYZE destination and IJPQ offsets
//   54  * G10  - Retract filament according to settings of M207 (Requires FWRETRACT)
//   55  * G11  - Retract recover filament according to settings of M208 (Requires FWRETRACT)
//   56  * G12  - Clean tool (Requires NOZZLE_CLEAN_FEATURE)
//   57  * G17  - Select Plane XY (Requires CNC_WORKSPACE_PLANES)
//   58  * G18  - Select Plane ZX (Requires CNC_WORKSPACE_PLANES)
//   59  * G19  - Select Plane YZ (Requires CNC_WORKSPACE_PLANES)
//   60  * G20  - Set input units to inches (Requires INCH_MODE_SUPPORT)
//   61  * G21  - Set input units to millimeters (Requires INCH_MODE_SUPPORT)
//   62  * G26  - Mesh Validation Pattern (Requires G26_MESH_VALIDATION)
//   63  * G27  - Park Nozzle (Requires NOZZLE_PARK_FEATURE)
//   64  * G28  - Home one or more axes
//   65  * G29  - Start or continue the bed leveling probe procedure (Requires bed leveling)
//   66  * G30  - Single Z probe, probes bed at X Y location (defaults to current XY location)
//   67  * G31  - Dock sled (Z_PROBE_SLED only)
//   68  * G32  - Undock sled (Z_PROBE_SLED only)
//   69  * G33  - Delta Auto-Calibration (Requires DELTA_AUTO_CALIBRATION)
//   70  * G38  - Probe in any direction using the Z_MIN_PROBE (Requires G38_PROBE_TARGET)
//   71  * G42  - Coordinated move to a mesh point (Requires MESH_BED_LEVELING, AUTO_BED_LEVELING_BLINEAR, or AUTO_BED_LEVELING_UBL)
//   72  * G90  - Use Absolute Coordinates
//   73  * G91  - Use Relative Coordinates
//   74  * G92  - Set current position to coordinates given
//   75  *
//   76  * "M" Codes
//   77  *
//   78  * M0   - Unconditional stop - Wait for user to press a button on the LCD (Only if ULTRA_LCD is enabled)
//   79  * M1   -> M0
//   80  * M3   - Turn laser/spindle on, set spindle/laser speed/power, set rotation to clockwise
//   81  * M4   - Turn laser/spindle on, set spindle/laser speed/power, set rotation to counter-clockwise
//   82  * M5   - Turn laser/spindle off
//   83  * M17  - Enable/Power all stepper motors
//   84  * M18  - Disable all stepper motors; same as M84
//   85  * M20  - List SD card. (Requires SDSUPPORT)
//   86  * M21  - Init SD card. (Requires SDSUPPORT)
//   87  * M22  - Release SD card. (Requires SDSUPPORT)
//   88  * M23  - Select SD file: "M23 /path/file.gco". (Requires SDSUPPORT)
//   89  * M24  - Start/resume SD print. (Requires SDSUPPORT)
//   90  * M25  - Pause SD print. (Requires SDSUPPORT)
//   91  * M26  - Set SD position in bytes: "M26 S12345". (Requires SDSUPPORT)
//   92  * M27  - Report SD print status. (Requires SDSUPPORT)
//   93  * M28  - Start SD write: "M28 /path/file.gco". (Requires SDSUPPORT)
//   94  * M29  - Stop SD write. (Requires SDSUPPORT)
//   95  * M30  - Delete file from SD: "M30 /path/file.gco"
//   96  * M31  - Report time since last M109 or SD card start to serial.
//   97  * M32  - Select file and start SD print: "M32 [S<bytepos>] !/path/file.gco#". (Requires SDSUPPORT)
//   98  *        Use P to run other files as sub-programs: "M32 P !filename#"
//   99  *        The '#' is necessary when calling from within sd files, as it stops buffer prereading
//  100  * M33  - Get the longname version of a path. (Requires LONG_FILENAME_HOST_SUPPORT)
//  101  * M34  - Set SD Card sorting options. (Requires SDCARD_SORT_ALPHA)
//  102  * M42  - Change pin status via gcode: M42 P<pin> S<value>. LED pin assumed if P is omitted.
//  103  * M43  - Display pin status, watch pins for changes, watch endstops & toggle LED, Z servo probe test, toggle pins
//  104  * M48  - Measure Z Probe repeatability: M48 P<points> X<pos> Y<pos> V<level> E<engage> L<legs>. (Requires Z_MIN_PROBE_REPEATABILITY_TEST)
//  105  * M75  - Start the print job timer.
//  106  * M76  - Pause the print job timer.
//  107  * M77  - Stop the print job timer.
//  108  * M78  - Show statistical information about the print jobs. (Requires PRINTCOUNTER)
//  109  * M80  - Turn on Power Supply. (Requires POWER_SUPPLY > 0)
//  110  * M81  - Turn off Power Supply. (Requires POWER_SUPPLY > 0)
//  111  * M82  - Set E codes absolute (default).
//  112  * M83  - Set E codes relative while in Absolute (G90) mode.
//  113  * M84  - Disable steppers until next move, or use S<seconds> to specify an idle
//  114  *        duration after which steppers should turn off. S0 disables the timeout.
//  115  * M85  - Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
//  116  * M92  - Set planner.axis_steps_per_mm for one or more axes.
//  117  * M100 - Watch Free Memory (for debugging) (Requires M100_FREE_MEMORY_WATCHER)
//  118  * M104 - Set extruder target temp.
//  119  * M105 - Report current temperatures.
//  120  * M106 - Set print fan speed.
//  121  * M107 - Print fan off.
//  122  * M108 - Break out of heating loops (M109, M190, M303). With no controller, breaks out of M0/M1. (Requires EMERGENCY_PARSER)
//  123  * M109 - Sxxx Wait for extruder current temp to reach target temp. Waits only when heating
//  124  *        Rxxx Wait for extruder current temp to reach target temp. Waits when heating and cooling
//  125  *        If AUTOTEMP is enabled, S<mintemp> B<maxtemp> F<factor>. Exit autotemp by any M109 without F
//  126  * M110 - Set the current line number. (Used by host printing)
//  127  * M111 - Set debug flags: "M111 S<flagbits>". See flag bits defined in enum.h.
//  128  * M112 - Emergency stop.
//  129  * M113 - Get or set the timeout interval for Host Keepalive "busy" messages. (Requires HOST_KEEPALIVE_FEATURE)
//  130  * M114 - Report current position.
//  131  * M115 - Report capabilities. (Extended capabilities requires EXTENDED_CAPABILITIES_REPORT)
//  132  * M117 - Display a message on the controller screen. (Requires an LCD)
//  133  * M118 - Display a message in the host console.
//  134  * M119 - Report endstops status.
//  135  * M120 - Enable endstops detection.
//  136  * M121 - Disable endstops detection.
//  137  * M122 - Debug stepper (Requires HAVE_TMC2130)
//  138  * M125 - Save current position and move to filament change position. (Requires PARK_HEAD_ON_PAUSE)
//  139  * M126 - Solenoid Air Valve Open. (Requires BARICUDA)
//  140  * M127 - Solenoid Air Valve Closed. (Requires BARICUDA)
//  141  * M128 - EtoP Open. (Requires BARICUDA)
//  142  * M129 - EtoP Closed. (Requires BARICUDA)
//  143  * M140 - Set bed target temp. S<temp>
//  144  * M145 - Set heatup values for materials on the LCD. H<hotend> B<bed> F<fan speed> for S<material> (0=PLA, 1=ABS)
//  145  * M149 - Set temperature units. (Requires TEMPERATURE_UNITS_SUPPORT)
//  146  * M150 - Set Status LED Color as R<red> U<green> B<blue> P<bright>. Values 0-255. (Requires BLINKM, RGB_LED, RGBW_LED, NEOPIXEL_LED, or PCA9632).
//  147  * M155 - Auto-report temperatures with interval of S<seconds>. (Requires AUTO_REPORT_TEMPERATURES)
//  148  * M163 - Set a single proportion for a mixing extruder. (Requires MIXING_EXTRUDER)
//  149  * M164 - Save the mix as a virtual extruder. (Requires MIXING_EXTRUDER and MIXING_VIRTUAL_TOOLS)
//  150  * M165 - Set the proportions for a mixing extruder. Use parameters ABCDHI to set the mixing factors. (Requires MIXING_EXTRUDER)
//  151  * M190 - Sxxx Wait for bed current temp to reach target temp. ** Waits only when heating! **
//  152  *        Rxxx Wait for bed current temp to reach target temp. ** Waits for heating or cooling. **
//  153  * M200 - Set filament diameter, D<diameter>, setting E axis units to cubic. (Use S0 to revert to linear units.)
//  154  * M201 - Set max acceleration in units/s^2 for print moves: "M201 X<accel> Y<accel> Z<accel> E<accel>"
//  155  * M202 - Set max acceleration in units/s^2 for travel moves: "M202 X<accel> Y<accel> Z<accel> E<accel>" ** UNUSED IN MARLIN! **
//  156  * M203 - Set maximum feedrate: "M203 X<fr> Y<fr> Z<fr> E<fr>" in units/sec.
//  157  * M204 - Set default acceleration in units/sec^2: P<printing> R<extruder_only> T<travel>
//  158  * M205 - Set advanced settings. Current units apply:
//  159             S<print> T<travel> minimum speeds
//  160             B<minimum segment time>
//  161             X<max X jerk>, Y<max Y jerk>, Z<max Z jerk>, E<max E jerk>
//  162  * M206 - Set additional homing offset. (Disabled by NO_WORKSPACE_OFFSETS or DELTA)
//  163  * M207 - Set Retract Length: S<length>, Feedrate: F<units/min>, and Z lift: Z<distance>. (Requires FWRETRACT)
//  164  * M208 - Set Recover (unretract) Additional (!) Length: S<length> and Feedrate: F<units/min>. (Requires FWRETRACT)
//  165  * M209 - Turn Automatic Retract Detection on/off: S<0|1> (For slicers that don't support G10/11). (Requires FWRETRACT)
//  166           Every normal extrude-only move will be classified as retract depending on the direction.
//  167  * M211 - Enable, Disable, and/or Report software endstops: S<0|1> (Requires MIN_SOFTWARE_ENDSTOPS or MAX_SOFTWARE_ENDSTOPS)
//  168  * M218 - Set a tool offset: "M218 T<index> X<offset> Y<offset>". (Requires 2 or more extruders)
//  169  * M220 - Set Feedrate Percentage: "M220 S<percent>" (i.e., "FR" on the LCD)
//  170  * M221 - Set Flow Percentage: "M221 S<percent>"
//  171  * M226 - Wait until a pin is in a given state: "M226 P<pin> S<state>"
//  172  * M240 - Trigger a camera to take a photograph. (Requires CHDK or PHOTOGRAPH_PIN)
//  173  * M250 - Set LCD contrast: "M250 C<contrast>" (0-63). (Requires LCD support)
//  174  * M260 - i2c Send Data (Requires EXPERIMENTAL_I2CBUS)
//  175  * M261 - i2c Request Data (Requires EXPERIMENTAL_I2CBUS)
//  176  * M280 - Set servo position absolute: "M280 P<index> S<angle|µs>". (Requires servos)
//  177  * M290 - Babystepping (Requires BABYSTEPPING)
//  178  * M300 - Play beep sound S<frequency Hz> P<duration ms>
//  179  * M301 - Set PID parameters P I and D. (Requires PIDTEMP)
//  180  * M302 - Allow cold extrudes, or set the minimum extrude S<temperature>. (Requires PREVENT_COLD_EXTRUSION)
//  181  * M303 - PID relay autotune S<temperature> sets the target temperature. Default 150C. (Requires PIDTEMP)
//  182  * M304 - Set bed PID parameters P I and D. (Requires PIDTEMPBED)
//  183  * M350 - Set microstepping mode. (Requires digital microstepping pins.)
//  184  * M351 - Toggle MS1 MS2 pins directly. (Requires digital microstepping pins.)
//  185  * M355 - Set Case Light on/off and set brightness. (Requires CASE_LIGHT_PIN)
//  186  * M380 - Activate solenoid on active extruder. (Requires EXT_SOLENOID)
//  187  * M381 - Disable all solenoids. (Requires EXT_SOLENOID)
//  188  * M400 - Finish all moves.
//  189  * M401 - Lower Z probe. (Requires a probe)
//  190  * M402 - Raise Z probe. (Requires a probe)
//  191  * M404 - Display or set the Nominal Filament Width: "W<diameter>". (Requires FILAMENT_WIDTH_SENSOR)
//  192  * M405 - Enable Filament Sensor flow control. "M405 D<delay_cm>". (Requires FILAMENT_WIDTH_SENSOR)
//  193  * M406 - Disable Filament Sensor flow control. (Requires FILAMENT_WIDTH_SENSOR)
//  194  * M407 - Display measured filament diameter in millimeters. (Requires FILAMENT_WIDTH_SENSOR)
//  195  * M410 - Quickstop. Abort all planned moves.
//  196  * M420 - Enable/Disable Leveling (with current values) S1=enable S0=disable (Requires MESH_BED_LEVELING or ABL)
//  197  * M421 - Set a single Z coordinate in the Mesh Leveling grid. X<units> Y<units> Z<units> (Requires MESH_BED_LEVELING or AUTO_BED_LEVELING_UBL)
//  198  * M428 - Set the home_offset based on the current_position. Nearest edge applies. (Disabled by NO_WORKSPACE_OFFSETS or DELTA)
//  199  * M500 - Store parameters in EEPROM. (Requires EEPROM_SETTINGS)
//  200  * M501 - Restore parameters from EEPROM. (Requires EEPROM_SETTINGS)
//  201  * M502 - Revert to the default "factory settings". ** Does not write them to EEPROM! **
//  202  * M503 - Print the current settings (in memory): "M503 S<verbose>". S0 specifies compact output.
//  203  * M540 - Enable/disable SD card abort on endstop hit: "M540 S<state>". (Requires ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
//  204  * M600 - Pause for filament change: "M600 X<pos> Y<pos> Z<raise> E<first_retract> L<later_retract>". (Requires ADVANCED_PAUSE_FEATURE)
//  205  * M665 - Set delta configurations: "M665 L<diagonal rod> R<delta radius> S<segments/s> A<rod A trim mm> B<rod B trim mm> C<rod C trim mm> I<tower A trim angle> J<tower B trim angle> K<tower C trim angle>" (Requires DELTA)
//  206  * M666 - Set delta endstop adjustment. (Requires DELTA)
//  207  * M605 - Set dual x-carriage movement mode: "M605 S<mode> [X<x_offset>] [R<temp_offset>]". (Requires DUAL_X_CARRIAGE)
//  208  * M851 - Set Z probe's Z offset in current units. (Negative = below the nozzle.)
//  209  * M852 - Set skew factors: "M852 [I<xy>] [J<xz>] [K<yz>]". (Requires SKEW_CORRECTION_GCODE, and SKEW_CORRECTION_FOR_Z for IJ)
//  210  * M860 - Report the position of position encoder modules.
//  211  * M861 - Report the status of position encoder modules.
//  212  * M862 - Perform an axis continuity test for position encoder modules.
//  213  * M863 - Perform steps-per-mm calibration for position encoder modules.
//  214  * M864 - Change position encoder module I2C address.
//  215  * M865 - Check position encoder module firmware version.
//  216  * M866 - Report or reset position encoder module error count.
//  217  * M867 - Enable/disable or toggle error correction for position encoder modules.
//  218  * M868 - Report or set position encoder module error correction threshold.
//  219  * M869 - Report position encoder module error.
//  220  * M900 - Get and/or Set advance K factor and WH/D ratio. (Requires LIN_ADVANCE)
//  221  * M906 - Set or get motor current in milliamps using axis codes X, Y, Z, E. Report values if no axis codes given. (Requires HAVE_TMC2130 or HAVE_TMC2208)
//  222  * M907 - Set digital trimpot motor current using axis codes. (Requires a board with digital trimpots)
//  223  * M908 - Control digital trimpot directly. (Requires DAC_STEPPER_CURRENT or DIGIPOTSS_PIN)
//  224  * M909 - Print digipot/DAC current value. (Requires DAC_STEPPER_CURRENT)
//  225  * M910 - Commit digipot/DAC value to external EEPROM via I2C. (Requires DAC_STEPPER_CURRENT)
//  226  * M911 - Report stepper driver overtemperature pre-warn condition. (Requires HAVE_TMC2130 or HAVE_TMC2208)
//  227  * M912 - Clear stepper driver overtemperature pre-warn condition flag. (Requires HAVE_TMC2130 or HAVE_TMC2208)
//  228  * M913 - Set HYBRID_THRESHOLD speed. (Requires HYBRID_THRESHOLD)
//  229  * M914 - Set SENSORLESS_HOMING sensitivity. (Requires SENSORLESS_HOMING)
//  230  *
//  231  * M360 - SCARA calibration: Move to cal-position ThetaA (0 deg calibration)
//  232  * M361 - SCARA calibration: Move to cal-position ThetaB (90 deg calibration - steps per degree)
//  233  * M362 - SCARA calibration: Move to cal-position PsiA (0 deg calibration)
//  234  * M363 - SCARA calibration: Move to cal-position PsiB (90 deg calibration - steps per degree)
//  235  * M364 - SCARA calibration: Move to cal-position PSIC (90 deg to Theta calibration position)
//  236  *
//  237  * ************ Custom codes - This can change to suit future G-code regulations
//  238  * M928 - Start SD logging: "M928 filename.gco". Stop with M29. (Requires SDSUPPORT)
//  239  * M998	- Stop SD print. (Requires SDSUPPORT)
//  240  * M999 - Restart after being stopped by error
//  241  *
//  242  * "T" Codes
//  243  *
//  244  * T0-T3 - Select an extruder (tool) by index: "T<n> F<units/min>"
//  245  *
//  246  */
//  247 
//  248 #include "Marlin.h"
//  249 
//  250 #include "ultralcd.h"
//  251 #include "planner.h"
//  252 #include "stepper.h"
//  253 #include "endstops.h"
//  254 #include "temperature.h"
//  255 #include "cardreader.h"
//  256 #include "configuration_store.h"
//  257 #include "language.h"
//  258 //#include "pins_arduino.h"
//  259 #include "math.h"
//  260 #include "nozzle.h"
//  261 #include "duration_t.h"
//  262 //#include "types.h"
//  263 #include "tim.h"
//  264 #include "gcode.h"
//  265 
//  266 #include "least_squares_fit.h"
//  267 //#include "ubl.h"
//  268 
//  269 #include "mks_cfg.h"
//  270 #include "mks_reprint.h"
//  271 #include "mks_dlp_main.h"
//  272 #if 1
//  273 
//  274 #include "wifi_module.h"
//  275 
//  276 #include "gui.h"
//  277 
//  278 #include "draw_ready_print.h"
//  279 
//  280 #include "draw_ui.h"
//  281 #include "wifi_module.h"
//  282 #include "draw_printing.h"
//  283 
//  284 
//  285 volatile uint8_t temper_error_flg = 0;
//  286 
//  287 volatile uint8_t mks_heating_busy = 0;
//  288 
//  289 extern void PowerOff_Filament_Check();
//  290 extern void display_temper_error();
//  291 extern void Close_machine_display();
//  292 
//  293 extern uint8_t IsChooseAutoShutdown;
//  294 
//  295 extern uint8_t temperature_change_frequency;
//  296 extern uint8_t from_flash_pic;
//  297 
//  298 static uint32_t temperature_change_frequency_cnt = 0;
//  299 static uint32_t After_finish_print_time = 0;
//  300 
//  301 #if 0
//  302 uint8_t filament_loading_time_flg;
//  303 uint32_t filament_loading_time_cnt;
//  304 uint8_t filament_loading_completed;
//  305 uint8_t filament_unloading_time_flg;
//  306 uint32_t filament_unloading_time_cnt;
//  307 uint8_t filament_unloading_completed;
//  308 
//  309 uint8_t filament_heat_completed_load;
//  310 uint8_t filament_heat_completed_unload;
//  311 
//  312 extern uint32_t filament_rate;
//  313 #endif
//  314 
//  315 volatile uint32_t TimeIncrease;
//  316 uint8_t volatile printing_rate_update_flag;
//  317 uint8_t preview_no_display;
//  318 extern PRINT_TIME  print_time;
//  319 #endif
//  320 
//  321 
//  322 #if HAS_ABL
//  323   #include "vector_3.h"
//  324   #if ENABLED(AUTO_BED_LEVELING_LINEAR)
//  325     #include "least_squares_fit.h"
//  326   #endif
//  327 #elif ENABLED(MESH_BED_LEVELING)
//  328   #include "mesh_bed_leveling.h"
//  329 #endif
//  330 
//  331 #if ENABLED(BEZIER_CURVE_SUPPORT)
//  332   #include "planner_bezier.h"
//  333 #endif
//  334 
//  335 #if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
//  336   #include "buzzer.h"
//  337 #endif
//  338 
//  339 #if ENABLED(USE_WATCHDOG)
//  340   #include "watchdog.h"
//  341 #endif
//  342 
//  343 #if ENABLED(MAX7219_DEBUG)
//  344   #include "Max7219_Debug_LEDs.h"
//  345 #endif
//  346 
//  347 #if HAS_COLOR_LEDS
//  348   #include "leds.h"
//  349 #endif
//  350 
//  351 #if HAS_SERVOS
//  352   #include "servo.h"
//  353 #endif
//  354 
//  355 #if HAS_DIGIPOTSS
//  356   #include <SPI.h>
//  357 #endif
//  358 
//  359 #if ENABLED(DAC_STEPPER_CURRENT)
//  360   #include "stepper_dac.h"
//  361 #endif
//  362 
//  363 #if ENABLED(EXPERIMENTAL_I2CBUS)
//  364   #include "twibus.h"
//  365 #endif
//  366 
//  367 #if ENABLED(I2C_POSITION_ENCODERS)
//  368   #include "I2CPositionEncoder.h"
//  369 #endif
//  370 
//  371 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
//  372   #include "endstop_interrupts.h"
//  373 #endif
//  374 
//  375 #if ENABLED(M100_FREE_MEMORY_WATCHER)
//  376   void gcode_M100();
//  377   void M100_dump_routine(const char * const title, const char *start, const char *end);
//  378 #endif
//  379 
//  380 #if ENABLED(G26_MESH_VALIDATION)
//  381   bool g26_debug_flag; // =false
//  382   void gcode_G26();
//  383 #endif
//  384 
//  385 #if ENABLED(SDSUPPORT)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function __sti__routine
        THUMB
// static __intrinsic __interwork __softfp void __sti__routine()
__sti__routine:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
//  386   CardReader card;
        LDR.W    R4,??DataTable104_6
        MOV      R0,R4
          CFI FunCall _ZN10CardReaderC1Ev
        BL       _ZN10CardReaderC1Ev
        ADD      R0,R4,#+3584
          CFI FunCall _ZN9StopwatchC1Ev
        BL       _ZN9StopwatchC1Ev
        LDR.W    R0,??DataTable104_7
        LDR.W    R1,??DataTable104_8
        LDR      R2,[R1, #+4]
        STR      R2,[R0, #+12]
        LDR      R2,[R1, #+8]
        STR      R2,[R0, #+24]
        LDRSB    R2,[R1, #+1]
        CMP      R2,#+0
        BPL.N    ??__sti__routine_0
        VLDR     S0,[R1, #+4]
        B.N      ??__sti__routine_1
??__sti__routine_0:
        VLDR     S0,[R1, #+8]
??__sti__routine_1:
        VSTR     S0,[R0, #+36]
        VLDR     S0,[R1, #+8]
        VLDR     S1,[R1, #+4]
        VSUB.F32 S0,S0,S1
        VSTR     S0,[R0, #+48]
        LDRB     R1,[R1, #+1]
        STRB     R1,[R0, #+2]
        ADDW     R0,R4,#+2500
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7MKS_DLPC1Ev
        B.W      _ZN7MKS_DLPC1Ev
          CFI EndBlock cfiBlock1
//  387 #endif
//  388 
//  389 #if ENABLED(EXPERIMENTAL_I2CBUS)
//  390   TWIBus i2c;
//  391 #endif
//  392 
//  393 #if ENABLED(G38_PROBE_TARGET)
//  394   bool G38_move = false,
//  395        G38_endstop_hit = false;
//  396 #endif
//  397 
//  398 #if ENABLED(AUTO_BED_LEVELING_UBL)
//  399   #include "ubl.h"
//  400   extern bool defer_return_to_status;
//  401   unified_bed_leveling ubl;
//  402 #endif
//  403 
//  404 #if ENABLED(CNC_COORDINATE_SYSTEMS)
//  405   int8_t active_coordinate_system = -1; // machine space
//  406   float coordinate_system[MAX_COORDINATE_SYSTEMS][XYZ];
//  407 #endif
//  408 
//  409 bool Running = true;
//  410 
//  411 uint8_t marlin_debug_flags = DEBUG_NONE;
//  412 
//  413 /**
//  414  * Cartesian Current Position
//  415  *   Used to track the native machine position as moves are queued.
//  416  *   Used by 'buffer_line_to_current_position' to do a move after changing it.
//  417  *   Used by 'SYNC_PLAN_POSITION_KINEMATIC' to update 'planner.position'.
//  418  */
//  419 float current_position[XYZE] = { 0.0 };
//  420 
//  421 /**
//  422  * Cartesian Destination
//  423  *   The destination for a move, filled in by G-code movement commands,
//  424  *   and expected by functions like 'prepare_move_to_destination'.
//  425  *   Set with 'gcode_get_destination' or 'set_destination_from_current'.
//  426  */
//  427 float destination[XYZE] = { 0.0 };
//  428 
//  429 /**
//  430  * axis_homed
//  431  *   Flags that each linear axis was homed.
//  432  *   XYZ on cartesian, ABC on delta, ABZ on SCARA.
//  433  *
//  434  * axis_known_position
//  435  *   Flags that the position is known in each linear axis. Set when homed.
//  436  *   Cleared whenever a stepper powers off, potentially losing its position.
//  437  */
//  438 bool axis_homed[XYZ] = { false }, axis_known_position[XYZ] = { false };
//  439 
//  440 /**
//  441  * GCode line number handling. Hosts may opt to include line numbers when
//  442  * sending commands to Marlin, and lines will be checked for sequentiality.
//  443  * M110 N<int> sets the current line number.
//  444  */
//  445 static long gcode_N, gcode_LastN, Stopped_gcode_LastN = 0;
//  446 
//  447 /**
//  448  * GCode Command Queue
//  449  * A simple ring buffer of BUFSIZE command strings.
//  450  *
//  451  * Commands are copied into this buffer by the command injectors
//  452  * (immediate, serial, sd card) and they are processed sequentially by
//  453  * the main loop. The process_next_command function parses the next
//  454  * command and hands off execution to individual handler functions.
//  455  */
//  456 uint8_t commands_in_queue = 0; // Count of commands in the queue
//  457 static uint8_t cmd_queue_index_r = 0, // Ring buffer read position
//  458                cmd_queue_index_w = 0; // Ring buffer write position
//  459 #if ENABLED(M100_FREE_MEMORY_WATCHER)
//  460   char command_queue[BUFSIZE][MAX_CMD_SIZE];  // Necessary so M100 Free Memory Dumper can show us the commands and any corruption
//  461 #else                                         // This can be collapsed back to the way it was soon.
//  462 static char command_queue[BUFSIZE][MAX_CMD_SIZE];
//  463 #endif
//  464 
//  465 /**
//  466  * Next Injected Command pointer. NULL if no commands are being injected.
//  467  * Used by Marlin internally to ensure that commands initiated from within
//  468  * are enqueued ahead of any pending serial or sd card commands.
//  469  */
//  470 static const char *injected_commands_P = NULL;
//  471 
//  472 #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
//  473   TempUnit input_temp_units = TEMPUNIT_C;
//  474 #endif
//  475 
//  476 /**
//  477  * Feed rates are often configured with mm/m
//  478  * but the planner and stepper like mm/s units.
//  479  */
//  480  /*
//  481 static const float homing_feedrate_mm_s[] PROGMEM = {
//  482   #if ENABLED(DELTA)
//  483     MMM_TO_MMS(HOMING_FEEDRATE_Z), MMM_TO_MMS(HOMING_FEEDRATE_Z),
//  484   #else
//  485     MMM_TO_MMS(HOMING_FEEDRATE_XY), MMM_TO_MMS(HOMING_FEEDRATE_XY),
//  486   #endif
//  487   MMM_TO_MMS(HOMING_FEEDRATE_Z), 0
//  488 };
//  489 
//  490 FORCE_INLINE float homing_feedrate(const AxisEnum a) { return pgm_read_float(&homing_feedrate_mm_s[a]); }
//  491 */
//  492 
//  493 float  homing_feedrate_mm_s[4];
//  494 
//  495 float feedrate_mm_s = MMM_TO_MMS(1500.0);
//  496 static float saved_feedrate_mm_s;
//  497 int16_t feedrate_percentage = 100, saved_feedrate_percentage;
//  498 
//  499 // Initialized by settings.load()
//  500 bool axis_relative_modes[] = AXIS_RELATIVE_MODES;
//  501 
//  502 #if HAS_WORKSPACE_OFFSET
//  503   #if HAS_POSITION_SHIFT
//  504     // The distance that XYZ has been offset by G92. Reset by G28.
//  505     float position_shift[XYZ] = { 0 };
//  506   #endif
//  507   #if HAS_HOME_OFFSET
//  508     // This offset is added to the configured home position.
//  509     // Set by M206, M428, or menu item. Saved to EEPROM.
//  510     float home_offset[XYZ] = { 0 };
//  511   #endif
//  512   #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
//  513     // The above two are combined to save on computes
//  514     float workspace_offset[XYZ] = { 0 };
//  515   #endif
//  516 #endif
//  517 
//  518 // Software Endstops are based on the configured limits.
//  519 /*
//  520 float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
//  521       soft_endstop_max[XYZ] = { X_MAX_BED, Y_MAX_BED, Z_MAX_POS };
//  522 */
//  523 float soft_endstop_min[XYZ],soft_endstop_max[XYZ];

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function _Z21soft_endstop_min_initv
          CFI NoCalls
        THUMB
//  524 void soft_endstop_min_init()
//  525 {
//  526         soft_endstop_min[0]= X_MIN_BED;
_Z21soft_endstop_min_initv:
        LDR.W    R0,??DataTable104_9
        MOVS     R1,#+0
        STR      R1,[R0, #+16]
//  527         soft_endstop_min[1]= X_MIN_BED;
        STR      R1,[R0, #+20]
//  528         soft_endstop_min[2]= Z_MIN_POS;
        LDR.W    R1,??DataTable104_8
        LDR      R2,[R1, #+4]
        STR      R2,[R0, #+24]
//  529 
//  530         soft_endstop_max[0] = X_MAX_BED;
        VLDR.W   S0,??DataTable88  ;; 0x43480000
        VSTR     S0,[R0, #+28]
//  531         soft_endstop_max[1] = Y_MAX_BED;
        VSTR     S0,[R0, #+32]
//  532         soft_endstop_max[2] = Z_MAX_POS;
        LDR      R1,[R1, #+8]
        STR      R1,[R0, #+36]
//  533 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock2
//  534 
//  535 #if HAS_SOFTWARE_ENDSTOPS
//  536   bool soft_endstops_enabled = true;
//  537   #if IS_KINEMATIC
//  538     float soft_endstop_radius, soft_endstop_radius_2;
//  539   #endif
//  540 #endif
//  541 
//  542 #if FAN_COUNT > 0
//  543   int fanSpeeds[FAN_COUNT] = { 0 };
//  544   #if ENABLED(EXTRA_FAN_SPEED)
//  545     int16_t old_fanSpeeds[FAN_COUNT],
//  546             new_fanSpeeds[FAN_COUNT];
//  547   #endif
//  548   #if ENABLED(PROBING_FANS_OFF)
//  549     bool fans_paused = false;
//  550     int16_t paused_fanSpeeds[FAN_COUNT] = { 0 };
//  551   #endif
//  552 #endif
//  553 
//  554 // The active extruder (tool). Set with T<extruder> command.
//  555 uint8_t active_extruder = 0;
//  556 
//  557 // Relative Mode. Enable with G91, disable with G90.
//  558 static bool relative_mode = false;
//  559 
//  560 // For M109 and M190, this flag may be cleared (by M108) to exit the wait loop
//  561 volatile bool wait_for_heatup = true;
//  562 
//  563 // For M0/M1, this flag may be cleared (by M108) to exit the wait-for-user loop
//  564 #if HAS_RESUME_CONTINUE
//  565   volatile bool wait_for_user = false;
//  566 #endif
//  567 
//  568 const char axis_codes[XYZE] = { 'X', 'Y', 'Z', 'E' };
//  569 
//  570 // Number of characters read in the current line of serial input
//  571 static int serial_count = 0;
//  572 static int wifi_read_count = 0;
//  573 
//  574 // Inactivity shutdown
//  575 millis_t previous_cmd_ms = 0;
//  576 static millis_t max_inactive_time = 0;
//  577 static millis_t stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000UL;
//  578 
//  579 // Print Job Timer
//  580 #if ENABLED(PRINTCOUNTER)
//  581   PrintCounter print_job_timer = PrintCounter();
//  582 #else
//  583   Stopwatch print_job_timer = Stopwatch();
//  584 #endif
//  585 
//  586 // Buzzer - I2C on the LCD or a BEEPER_PIN
//  587 #if ENABLED(LCD_USE_I2C_BUZZER)
//  588   #define BUZZ(d,f) lcd_buzz(d, f)
//  589 #elif PIN_EXISTS(BEEPER)
//  590   Buzzer buzzer;
//  591   #define BUZZ(d,f) buzzer.tone(d, f)
//  592 #else
//  593   #define BUZZ(d,f) NOOP
//  594 #endif
//  595 
//  596 uint8_t target_extruder;
//  597 
//  598 #if HAS_BED_PROBE
//  599   float zprobe_zoffset; // Initialized by settings.load()
//  600 #endif
//  601 
//  602 #if HAS_ABL
//  603   float xy_probe_feedrate_mm_s = MMM_TO_MMS(XY_PROBE_SPEED);
//  604   #define XY_PROBE_FEEDRATE_MM_S xy_probe_feedrate_mm_s
//  605 #elif defined(XY_PROBE_SPEED)
//  606   #define XY_PROBE_FEEDRATE_MM_S MMM_TO_MMS(XY_PROBE_SPEED)
//  607 #else
//  608   #define XY_PROBE_FEEDRATE_MM_S PLANNER_XY_FEEDRATE()
//  609 #endif
//  610 
//  611 #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
//  612   #if ENABLED(DELTA)
//  613     #define ADJUST_DELTA(V) \ 
//  614       if (planner.leveling_active) { \ 
//  615         const float zadj = bilinear_z_offset(V); \ 
//  616         delta[A_AXIS] += zadj; \ 
//  617         delta[B_AXIS] += zadj; \ 
//  618         delta[C_AXIS] += zadj; \ 
//  619       }
//  620   #else
//  621     #define ADJUST_DELTA(V) if (planner.leveling_active) { delta[Z_AXIS] += bilinear_z_offset(V); }
//  622   #endif
//  623 #elif IS_KINEMATIC
//  624   #define ADJUST_DELTA(V) NOOP
//  625 #endif
//  626 
//  627 #if ENABLED(X_DUAL_ENDSTOPS)
//  628   float x_endstop_adj;                // Initialized by settings.load()
//  629 #endif
//  630 #if ENABLED(Y_DUAL_ENDSTOPS)
//  631   float y_endstop_adj;                // Initialized by settings.load()
//  632 #endif
//  633 #if ENABLED(Z_DUAL_ENDSTOPS)
//  634   float z_endstop_adj;                // Initialized by settings.load()
//  635 #endif
//  636 
//  637 // Extruder offsets
//  638 #if HOTENDS > 1
//  639   float hotend_offset[XYZ][HOTENDS];  // Initialized by settings.load()
//  640 #endif
//  641 
//  642 #if HAS_Z_SERVO_ENDSTOP
//  643   const int z_servo_angle[2] = Z_SERVO_ANGLES;
//  644 #endif
//  645 
//  646 #if ENABLED(BARICUDA)
//  647   uint8_t baricuda_valve_pressure = 0,
//  648           baricuda_e_to_p_pressure = 0;
//  649 #endif
//  650 
//  651 #if ENABLED(FWRETRACT)                      // Initialized by settings.load()...
//  652   bool autoretract_enabled,                 // M209 S - Autoretract switch
//  653        retracted[EXTRUDERS] = { false };    // Which extruders are currently retracted
//  654   float retract_length,                     // M207 S - G10 Retract length
//  655         retract_feedrate_mm_s,              // M207 F - G10 Retract feedrate
//  656         retract_zlift,                      // M207 Z - G10 Retract hop size
//  657         retract_recover_length,             // M208 S - G11 Recover length
//  658         retract_recover_feedrate_mm_s,      // M208 F - G11 Recover feedrate
//  659         swap_retract_length,                // M207 W - G10 Swap Retract length
//  660         swap_retract_recover_length,        // M208 W - G11 Swap Recover length
//  661         swap_retract_recover_feedrate_mm_s; // M208 R - G11 Swap Recover feedrate
//  662   #if EXTRUDERS > 1
//  663     bool retracted_swap[EXTRUDERS] = { false }; // Which extruders are swap-retracted
//  664   #else
//  665     constexpr bool retracted_swap[1] = { false };
//  666   #endif
//  667 #endif // FWRETRACT
//  668 
//  669 #if HAS_POWER_SWITCH
//  670   bool powersupply_on =
//  671     #if ENABLED(PS_DEFAULT_OFF)
//  672       false
//  673     #else
//  674       true
//  675     #endif
//  676   ;
//  677 #endif
//  678 
//  679 #if ENABLED(DELTA)
//  680 
//  681   float delta[ABC];
//  682 
//  683   // Initialized by settings.load()
//  684   float delta_height,
//  685         delta_endstop_adj[ABC] = { 0 },
//  686         delta_radius,
//  687         delta_tower_angle_trim[ABC],
//  688         delta_tower[ABC][2],
//  689         delta_diagonal_rod,
//  690         delta_calibration_radius,
//  691         delta_diagonal_rod_2_tower[ABC],
//  692         delta_segments_per_second,
//  693         delta_clip_start_height = Z_MAX_POS;
//  694 
//  695   float delta_safe_distance_from_top();
//  696 
//  697 #endif
//  698 
//  699 #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
//  700   int bilinear_grid_spacing[2], bilinear_start[2];
//  701   float bilinear_grid_factor[2],
//  702         z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
//  703 #endif
//  704 
//  705 #if IS_SCARA
//  706   // Float constants for SCARA calculations
//  707   const float L1 = SCARA_LINKAGE_1, L2 = SCARA_LINKAGE_2,
//  708               L1_2 = sq(float(L1)), L1_2_2 = 2.0 * L1_2,
//  709               L2_2 = sq(float(L2));
//  710 
//  711   float delta_segments_per_second = SCARA_SEGMENTS_PER_SECOND,
//  712         delta[ABC];
//  713 #endif
//  714 
//  715 float cartes[XYZ] = { 0 };
//  716 
//  717 #if ENABLED(FILAMENT_WIDTH_SENSOR)
//  718   bool filament_sensor = false;                                 // M405 turns on filament sensor control. M406 turns it off.
//  719   float filament_width_nominal = DEFAULT_NOMINAL_FILAMENT_DIA,  // Nominal filament width. Change with M404.
//  720         filament_width_meas = DEFAULT_MEASURED_FILAMENT_DIA;    // Measured filament diameter
//  721   uint8_t meas_delay_cm = MEASUREMENT_DELAY_CM;                 // Distance delay setting
//  722   int8_t measurement_delay[MAX_MEASUREMENT_DELAY + 1],          // Ring buffer to delayed measurement. Store extruder factor after subtracting 100
//  723          filwidth_delay_index[2] = { 0, -1 };                   // Indexes into ring buffer
//  724 #endif
//  725 
//  726 #if ENABLED(FILAMENT_RUNOUT_SENSOR)
//  727   static bool filament_ran_out = false;
//  728 #endif
//  729 
//  730 #if ENABLED(ADVANCED_PAUSE_FEATURE)
//  731   AdvancedPauseMenuResponse advanced_pause_menu_response;
//  732 #endif
//  733 
//  734 #if ENABLED(MIXING_EXTRUDER)
//  735   float mixing_factor[MIXING_STEPPERS]; // Reciprocal of mix proportion. 0.0 = off, otherwise >= 1.0.
//  736   #if MIXING_VIRTUAL_TOOLS > 1
//  737     float mixing_virtual_tool_mix[MIXING_VIRTUAL_TOOLS][MIXING_STEPPERS];
//  738   #endif
//  739 #endif
//  740 
//  741 static bool send_ok[BUFSIZE];
//  742 
//  743 #if HAS_SERVOS
//  744   Servo servo[NUM_SERVOS];
//  745   #define MOVE_SERVO(I, P) servo[I].move(P)
//  746   #if HAS_Z_SERVO_ENDSTOP
//  747     #define DEPLOY_Z_SERVO() MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[0])
//  748     #define STOW_Z_SERVO() MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[1])
//  749   #endif
//  750 #endif
//  751 
//  752 #ifdef CHDK
//  753   millis_t chdkHigh = 0;
//  754   bool chdkActive = false;
//  755 #endif
//  756 
//  757 #if ENABLED(PID_EXTRUSION_SCALING)
//  758   int lpq_len = 20;
//  759 #endif
//  760 
//  761 #if ENABLED(HOST_KEEPALIVE_FEATURE)
//  762   MarlinBusyState busy_state = NOT_BUSY;
//  763   static millis_t next_busy_signal_ms = 0;
//  764   uint8_t host_keepalive_interval = DEFAULT_KEEPALIVE_INTERVAL;
//  765 #else
//  766   #define host_keepalive() NOOP
//  767 #endif
//  768 
//  769 #if ENABLED(I2C_POSITION_ENCODERS)
//  770   I2CPositionEncodersMgr I2CPEM;
//  771   uint8_t blockBufferIndexRef = 0;
//  772   millis_t lastUpdateMillis;
//  773 #endif
//  774 
//  775 #if ENABLED(CNC_WORKSPACE_PLANES)
//  776   static WorkspacePlane workspace_plane = PLANE_XY;
//  777 #endif
//  778 
//  779 //FORCE_INLINE float pgm_read_any(const float *p) { return pgm_read_float_near(p); }
//  780 //FORCE_INLINE signed char pgm_read_any(const signed char *p) { return pgm_read_byte_near(p); }
//  781 static inline float pgm_read_any(const float *p) { return (*(const float *)(p)); }
//  782 static inline signed char pgm_read_any(const signed char *p) { return (*(const signed char *)(p)); }
//  783 /*P
//  784 #define XYZ_CONSTS_FROM_CONFIG(type, array, CONFIG) \ 
//  785   static const PROGMEM type array##_P[XYZ] = { X_##CONFIG, Y_##CONFIG, Z_##CONFIG }; \ 
//  786   static inline type array(const AxisEnum axis) { return pgm_read_any(&array##_P[axis]); } \ 
//  787   typedef void __void_##CONFIG##__
//  788 */
//  789 #define XYZ_CONSTS_FROM_CONFIG(type, array, CONFIG) \ 
//  790 	  type array##_P[XYZ] = { X_##CONFIG, Y_##CONFIG, Z_##CONFIG }; \ 
//  791 	  static inline type array(AxisEnum axis) { return (array##_P[axis]); } 
//  792 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function _Z12base_min_pos8AxisEnum
          CFI NoCalls
        THUMB
//  793 XYZ_CONSTS_FROM_CONFIG(float, base_min_pos,   MIN_POS);
_Z12base_min_pos8AxisEnum:
        LDR.W    R1,??DataTable104_7
        ADD      R0,R1,R0, LSL #+2
        VLDR     S0,[R0, #+4]
        BX       LR               ;; return
          CFI EndBlock cfiBlock3

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function _Z12base_max_pos8AxisEnum
          CFI NoCalls
        THUMB
//  794 XYZ_CONSTS_FROM_CONFIG(float, base_max_pos,   MAX_POS);
_Z12base_max_pos8AxisEnum:
        LDR.W    R1,??DataTable104_7
        ADD      R0,R1,R0, LSL #+2
        VLDR     S0,[R0, #+16]
        BX       LR               ;; return
          CFI EndBlock cfiBlock4

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function _Z13base_home_pos8AxisEnum
          CFI NoCalls
        THUMB
//  795 XYZ_CONSTS_FROM_CONFIG(float, base_home_pos,  HOME_POS);
_Z13base_home_pos8AxisEnum:
        LDR.W    R1,??DataTable104_7
        ADD      R0,R1,R0, LSL #+2
        VLDR     S0,[R0, #+28]
        BX       LR               ;; return
          CFI EndBlock cfiBlock5

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock6 Using cfiCommon0
          CFI Function _Z10max_length8AxisEnum
          CFI NoCalls
        THUMB
//  796 XYZ_CONSTS_FROM_CONFIG(float, max_length,     MAX_LENGTH);
_Z10max_length8AxisEnum:
        LDR.W    R1,??DataTable104_7
        ADD      R0,R1,R0, LSL #+2
        VLDR     S0,[R0, #+40]
        BX       LR               ;; return
          CFI EndBlock cfiBlock6

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock7 Using cfiCommon0
          CFI Function _Z12home_bump_mm8AxisEnum
          CFI NoCalls
        THUMB
//  797 XYZ_CONSTS_FROM_CONFIG(float, home_bump_mm,   HOME_BUMP_MM);
_Z12home_bump_mm8AxisEnum:
        LDR.W    R1,??DataTable107
        ADD      R0,R1,R0, LSL #+2
        VLDR     S0,[R0, #+96]
        BX       LR               ;; return
          CFI EndBlock cfiBlock7

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock8 Using cfiCommon0
          CFI Function _Z8home_dir8AxisEnum
          CFI NoCalls
        THUMB
//  798 XYZ_CONSTS_FROM_CONFIG(signed char, home_dir, HOME_DIR);
_Z8home_dir8AxisEnum:
        LDR.W    R1,??DataTable104_7
        LDRSB    R0,[R0, R1]
        BX       LR               ;; return
          CFI EndBlock cfiBlock8
//  799 
//  800 /**
//  801  * ***************************************************************************
//  802  * ******************************** FUNCTIONS ********************************
//  803  * ***************************************************************************
//  804  */
//  805 
//  806 void stop();
//  807 
//  808 void get_available_commands();
//  809 void process_next_command();
//  810 void process_parsed_command();
//  811 
//  812 void get_cartesian_from_steppers();
//  813 void set_current_from_steppers_for_axis(const AxisEnum axis);
//  814 
//  815 #if ENABLED(ARC_SUPPORT)
//  816   void plan_arc(const float (&cart)[XYZE], const float (&offset)[2], const bool clockwise);
//  817 #endif
//  818 
//  819 #if ENABLED(BEZIER_CURVE_SUPPORT)
//  820   void plan_cubic_move(const float (&offset)[4]);
//  821 #endif
//  822 
//  823 void tool_change(const uint8_t tmp_extruder, const float fr_mm_s=0.0, bool no_move=false);
//  824 void report_current_position();
//  825 void report_current_position_detail();
//  826 
//  827 #if ENABLED(DEBUG_LEVELING_FEATURE)
//  828   void print_xyz(const char* prefix, const char* suffix, const float x, const float y, const float z) {
//  829     serialprintPGM(prefix);
//  830     SERIAL_CHAR('(');
//  831     SERIAL_ECHO(x);
//  832     SERIAL_ECHOPAIR(", ", y);
//  833     SERIAL_ECHOPAIR(", ", z);
//  834     SERIAL_CHAR(')');
//  835     if (suffix) serialprintPGM(suffix); else SERIAL_EOL();
//  836   }
//  837 
//  838   void print_xyz(const char* prefix, const char* suffix, const float xyz[]) {
//  839     print_xyz(prefix, suffix, xyz[X_AXIS], xyz[Y_AXIS], xyz[Z_AXIS]);
//  840   }
//  841 
//  842   #if HAS_ABL
//  843     void print_xyz(const char* prefix, const char* suffix, const vector_3 &xyz) {
//  844       print_xyz(prefix, suffix, xyz.x, xyz.y, xyz.z);
//  845     }
//  846   #endif
//  847 
//  848   #define DEBUG_POS(SUFFIX,VAR) do { \ 
//  849     print_xyz(PSTR("  " STRINGIFY(VAR) "="), PSTR(" : " SUFFIX "\n"), VAR); }while(0)
//  850 #endif
//  851 
//  852 /**
//  853  * sync_plan_position
//  854  *
//  855  * Set the planner/stepper positions directly from current_position with
//  856  * no kinematic translation. Used for homing axes and cartesian/core syncing.
//  857  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock9 Using cfiCommon0
          CFI Function _Z18sync_plan_positionv
        THUMB
//  858 void sync_plan_position() {
//  859   #if ENABLED(DEBUG_LEVELING_FEATURE)
//  860     if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position", current_position);
//  861   #endif
//  862   planner.set_position_mm(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
_Z18sync_plan_positionv:
        LDR.W    R1,??DataTable107
        ADD      R0,R1,#+48
        VLDR     S2,[R1, #+44]
        VLDR     S1,[R1, #+40]
        VLDR     S0,[R1, #+36]
          CFI FunCall _ZN7Planner15set_position_mmEfffRKf
        B.W      _ZN7Planner15set_position_mmEfffRKf
          CFI EndBlock cfiBlock9
//  863 }
//  864 inline void sync_plan_position_e() { planner.set_e_position_mm(current_position[E_AXIS]); }
//  865 
//  866 #if IS_KINEMATIC
//  867 
//  868   inline void sync_plan_position_kinematic() {
//  869     #if ENABLED(DEBUG_LEVELING_FEATURE)
//  870       if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position_kinematic", current_position);
//  871     #endif
//  872     planner.set_position_mm_kinematic(current_position);
//  873   }
//  874   #define SYNC_PLAN_POSITION_KINEMATIC() sync_plan_position_kinematic()
//  875 
//  876 #else
//  877 
//  878   #define SYNC_PLAN_POSITION_KINEMATIC() sync_plan_position()
//  879 
//  880 #endif
//  881 
//  882 #if 0//ENABLED(SDSUPPORT)
//  883   #include "SdFatUtil.h"
//  884   int freeMemory() { return SdFatUtil::FreeRam(); }
//  885 #else
//  886 /*
//  887 extern "C" {
//  888   extern char __bss_end;
//  889   extern char __heap_start;
//  890   extern void* __brkval;
//  891 
//  892   int freeMemory() {
//  893     int free_memory;
//  894     if ((int)__brkval == 0)
//  895       free_memory = ((int)&free_memory) - ((int)&__bss_end);
//  896     else
//  897       free_memory = ((int)&free_memory) - ((int)__brkval);
//  898     return free_memory;
//  899   }
//  900 }
//  901 */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock10 Using cfiCommon0
          CFI Function _Z10freeMemoryv
          CFI NoCalls
        THUMB
//  902 	int freeMemory() { return 4396; }	//No free ram management
_Z10freeMemoryv:
        MOVW     R0,#+4396
        BX       LR               ;; return
          CFI EndBlock cfiBlock10
//  903 
//  904 #endif // !SDSUPPORT
//  905 
//  906 #if ENABLED(DIGIPOT_I2C)
//  907   extern void digipot_i2c_set_current(uint8_t channel, float current);
//  908   extern void digipot_i2c_init();
//  909 #endif
//  910 
//  911 /**
//  912  * Inject the next "immediate" command, when possible, onto the front of the queue.
//  913  * Return true if any immediate commands remain to inject.
//  914  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock11 Using cfiCommon0
          CFI Function _Z25drain_injected_commands_Pv
        THUMB
//  915 static bool drain_injected_commands_P() {
_Z25drain_injected_commands_Pv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+32
          CFI CFA R13+48
//  916   if (injected_commands_P != NULL) {
        LDR.W    R4,??DataTable107_1
        LDR      R1,[R4, #+0]
        CMP      R1,#+0
        BEQ.N    ??drain_injected_commands_P_0
//  917     size_t i = 0;
        MOVS     R5,#+0
//  918     char c, cmd[30];
//  919     //strncpy_P(cmd, injected_commands_P, sizeof(cmd) - 1);
//  920     strncpy(cmd, injected_commands_P, sizeof(cmd) - 1);	/*--mks--*/
        MOVS     R2,#+29
        ADD      R0,SP,#+0
          CFI FunCall strncpy
        BL       strncpy
//  921     cmd[sizeof(cmd) - 1] = '\0';
        ADD      R0,SP,#+0
        MOV      R1,R5
        STRB     R1,[R0, #+29]
        B.N      ??drain_injected_commands_P_1
//  922     while ((c = cmd[i]) && c != '\n') i++; // find the end of this gcode command
??drain_injected_commands_P_2:
        ADDS     R5,R5,#+1
??drain_injected_commands_P_1:
        LDRSB    R6,[R5, R0]
        CMP      R6,#+0
        BEQ.N    ??drain_injected_commands_P_3
        CMP      R6,#+10
        BNE.N    ??drain_injected_commands_P_2
//  923     cmd[i] = '\0';
??drain_injected_commands_P_3:
        STRB     R1,[R5, R0]
//  924     if (enqueue_and_echo_command(cmd))     // success?
          CFI FunCall _Z24enqueue_and_echo_commandPKcb
        BL       _Z24enqueue_and_echo_commandPKcb
        CMP      R0,#+0
        BEQ.N    ??drain_injected_commands_P_0
//  925       injected_commands_P = c ? injected_commands_P + i + 1 : NULL; // next command or done
        CMP      R6,#+0
        BEQ.N    ??drain_injected_commands_P_4
        LDR      R0,[R4, #+0]
        ADDS     R0,R5,R0
        ADDS     R0,R0,#+1
        STR      R0,[R4, #+0]
        B.N      ??drain_injected_commands_P_0
??drain_injected_commands_P_4:
        MOVS     R0,#+0
        STR      R0,[R4, #+0]
//  926   }
//  927   return (injected_commands_P != NULL);    // return whether any more remain
??drain_injected_commands_P_0:
        LDR      R0,[R4, #+0]
        CMP      R0,#+0
        BEQ.N    ??drain_injected_commands_P_5
        MOVS     R0,#+1
        B.N      ??drain_injected_commands_P_6
??drain_injected_commands_P_5:
        MOVS     R0,#+0
??drain_injected_commands_P_6:
        ADD      SP,SP,#+32
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock11
//  928 }
//  929 
//  930 /**
//  931  * Record one or many commands to run from program memory.
//  932  * Aborts the current queue, if any.
//  933  * Note: drain_injected_commands_P() must be called repeatedly to drain the commands afterwards
//  934  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock12 Using cfiCommon0
          CFI Function _Z27enqueue_and_echo_commands_PPKc
        THUMB
//  935 void enqueue_and_echo_commands_P(const char * const pgcode) {
//  936   injected_commands_P = pgcode;
_Z27enqueue_and_echo_commands_PPKc:
        LDR.W    R1,??DataTable107_1
        STR      R0,[R1, #+0]
//  937   drain_injected_commands_P(); // first command executed asap (when possible)
          CFI FunCall _Z25drain_injected_commands_Pv
        B.N      _Z25drain_injected_commands_Pv
          CFI EndBlock cfiBlock12
//  938 }
//  939 
//  940 /**
//  941  * Clear the Marlin command queue
//  942  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock13 Using cfiCommon0
          CFI Function _Z19clear_command_queuev
          CFI NoCalls
        THUMB
//  943 void clear_command_queue() {
//  944   cmd_queue_index_r = cmd_queue_index_w;
_Z19clear_command_queuev:
        LDR.W    R0,??DataTable107
        LDRB     R1,[R0, #+18]
        STRB     R1,[R0, #+17]
//  945   commands_in_queue = 0;
        MOVS     R1,#+0
        STRB     R1,[R0, #+16]
//  946 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock13
//  947 
//  948 /**
//  949  * Once a new command is in the ring buffer, call this to commit it
//  950  */
//  951 inline void _commit_command(bool say_ok) {
//  952   send_ok[cmd_queue_index_w] = say_ok;
//  953   if (++cmd_queue_index_w >= BUFSIZE) cmd_queue_index_w = 0;
//  954   commands_in_queue++;
//  955 }
//  956 
//  957 /**
//  958  * Copy a command from RAM into the main command buffer.
//  959  * Return true if the command was successfully added.
//  960  * Return false for a full buffer, or if the 'command' is a comment.
//  961  */
//  962 inline bool _enqueuecommand(const char* cmd, bool say_ok=false) {
//  963   if (*cmd == ';' || commands_in_queue >= BUFSIZE) return false;
//  964   strcpy(command_queue[cmd_queue_index_w], cmd);
//  965   _commit_command(say_ok);
//  966   return true;
//  967 }
//  968 
//  969 /**
//  970  * Enqueue with Serial Echo
//  971  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock14 Using cfiCommon0
          CFI Function _Z24enqueue_and_echo_commandPKcb
        THUMB
//  972 bool enqueue_and_echo_command(const char* cmd, bool say_ok/*=false*/) {
_Z24enqueue_and_echo_commandPKcb:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
//  973   if (_enqueuecommand(cmd, say_ok)) {
          CFI FunCall _Z15_enqueuecommandPKcb
        BL       _Z15_enqueuecommandPKcb
        CMP      R0,#+0
        BEQ.N    ??enqueue_and_echo_command_0
//  974     SERIAL_ECHO_START();
        LDR.W    R0,??DataTable107_2
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
//  975     SERIAL_ECHOPAIR(MSG_ENQUEUEING, cmd);
        MOV      R1,R4
        ADR.W    R0,`?<Constant "enqueueing \\"">`
          CFI FunCall _Z17serial_echopair_PPKcS0_
        BL       _Z17serial_echopair_PPKcS0_
//  976     SERIAL_CHAR('"');
        LDR.W    R4,??DataTable109
        MOVS     R1,#+34
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
//  977     SERIAL_EOL();
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
//  978     return true;
        MOVS     R0,#+1
        POP      {R4,PC}
//  979   }
//  980   return false;
??enqueue_and_echo_command_0:
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock14
//  981 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "enqueueing \\"">`:
        DC8 "enqueueing \""
        DC8 0, 0, 0
//  982 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock15 Using cfiCommon0
          CFI Function _Z13setup_killpinv
          CFI NoCalls
        THUMB
//  983 void setup_killpin() {
//  984   #if HAS_KILL
//  985     SET_INPUT_PULLUP(KILL_PIN);
//  986   #endif
//  987 }
_Z13setup_killpinv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock15
//  988 
//  989 #if ENABLED(FILAMENT_RUNOUT_SENSOR)
//  990 
//  991   void setup_filrunoutpin() {
//  992     #if ENABLED(ENDSTOPPULLUP_FIL_RUNOUT)
//  993       SET_INPUT_PULLUP(FIL_RUNOUT_PIN);
//  994     #else
//  995       SET_INPUT(FIL_RUNOUT_PIN);
//  996     #endif
//  997   }
//  998 
//  999 #endif
// 1000 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock16 Using cfiCommon0
          CFI Function _Z15setup_powerholdv
          CFI NoCalls
        THUMB
// 1001 void setup_powerhold() {
// 1002   #if HAS_SUICIDE
// 1003     OUT_WRITE(SUICIDE_PIN, HIGH);
// 1004   #endif
// 1005   #if HAS_POWER_SWITCH
// 1006     #if ENABLED(PS_DEFAULT_OFF)
// 1007       OUT_WRITE(PS_ON_PIN, PS_ON_ASLEEP);
// 1008     #else
// 1009       OUT_WRITE(PS_ON_PIN, PS_ON_AWAKE);
// 1010     #endif
// 1011   #endif
// 1012 }
_Z15setup_powerholdv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock16
// 1013 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock17 Using cfiCommon0
          CFI Function _Z7suicidev
          CFI NoCalls
        THUMB
// 1014 void suicide() {
// 1015   #if HAS_SUICIDE
// 1016     OUT_WRITE(SUICIDE_PIN, LOW);
// 1017   #endif
// 1018 }
_Z7suicidev:
        BX       LR               ;; return
          CFI EndBlock cfiBlock17
// 1019 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock18 Using cfiCommon0
          CFI Function _Z10servo_initv
          CFI NoCalls
        THUMB
// 1020 void servo_init() {
// 1021   #if NUM_SERVOS >= 1 && HAS_SERVO_0
// 1022     servo[0].attach(SERVO0_PIN);
// 1023     servo[0].detach(); // Just set up the pin. We don't have a position yet. Don't move to a random position.
// 1024   #endif
// 1025   #if NUM_SERVOS >= 2 && HAS_SERVO_1
// 1026     servo[1].attach(SERVO1_PIN);
// 1027     servo[1].detach();
// 1028   #endif
// 1029   #if NUM_SERVOS >= 3 && HAS_SERVO_2
// 1030     servo[2].attach(SERVO2_PIN);
// 1031     servo[2].detach();
// 1032   #endif
// 1033   #if NUM_SERVOS >= 4 && HAS_SERVO_3
// 1034     servo[3].attach(SERVO3_PIN);
// 1035     servo[3].detach();
// 1036   #endif
// 1037 
// 1038   #if HAS_Z_SERVO_ENDSTOP
// 1039     /**
// 1040      * Set position of Z Servo Endstop
// 1041      *
// 1042      * The servo might be deployed and positioned too low to stow
// 1043      * when starting up the machine or rebooting the board.
// 1044      * There's no way to know where the nozzle is positioned until
// 1045      * homing has been done - no homing with z-probe without init!
// 1046      *
// 1047      */
// 1048     STOW_Z_SERVO();
// 1049   #endif
// 1050 }
_Z10servo_initv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock18
// 1051 
// 1052 /**
// 1053  * Stepper Reset (RigidBoard, et.al.)
// 1054  */
// 1055 #if HAS_STEPPER_RESET
// 1056   void disableStepperDrivers() {
// 1057     OUT_WRITE(STEPPER_RESET_PIN, LOW);  // drive it down to hold in reset motor driver chips
// 1058   }
// 1059   void enableStepperDrivers() { SET_INPUT(STEPPER_RESET_PIN); }  // set to input, which allows it to be pulled high by pullups
// 1060 #endif
// 1061 
// 1062 #if ENABLED(EXPERIMENTAL_I2CBUS) && I2C_SLAVE_ADDRESS > 0
// 1063 
// 1064   void i2c_on_receive(int bytes) { // just echo all bytes received to serial
// 1065     i2c.receive(bytes);
// 1066   }
// 1067 
// 1068   void i2c_on_request() {          // just send dummy data for now
// 1069     i2c.reply("Hello World!\n");
// 1070   }
// 1071 
// 1072 #endif
// 1073 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock19 Using cfiCommon0
          CFI Function _Z16gcode_line_errorPKcb
        THUMB
// 1074 void gcode_line_error(const char* err, bool doFlush = true) {
_Z16gcode_line_errorPKcb:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        MOV      R5,R1
// 1075   SERIAL_ERROR_START();
        LDR.W    R0,??DataTable107_3
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 1076   serialprintPGM(err);
        MOV      R0,R4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 1077   SERIAL_ERRORLN(gcode_LastN);
        LDR.W    R4,??DataTable109
        MOVS     R2,#+10
        LDR.W    R0,??DataTable107
        LDR      R1,[R0, #+112]
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEli
        BL       _ZN5Print5printEli
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 1078   //Serial.println(gcode_N);
// 1079   if (doFlush) FlushSerialRequestResend();
        CMP      R5,#+0
        BEQ.N    ??gcode_line_error_0
          CFI FunCall _Z24FlushSerialRequestResendv
        BL       _Z24FlushSerialRequestResendv
// 1080   serial_count = 0;
??gcode_line_error_0:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable111
        STR      R0,[R1, #+0]
// 1081 }
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock19
// 1082 
// 1083 uint8_t serial_wait_tick = 0; //use to calculate the serial wait ticks
// 1084 
// 1085 uint8_t from_wifi_flag = 0; // whether data comes from wifi model
// 1086 
// 1087 /**
// 1088  * Get all commands waiting on the serial port and queue them.
// 1089  * Exit when the buffer is full or when no more characters are
// 1090  * left on the serial port.
// 1091  */
// 1092 inline void get_serial_commands() {
// 1093   static char serial_line_buffer[MAX_CMD_SIZE];
// 1094   static bool serial_comment_mode = false;
// 1095   static millis_t last_wait_time = 0;
// 1096   const millis_t wait_ms = millis();
// 1097 
// 1098   // If the command buffer is empty for too long,
// 1099   // send "wait" to indicate Marlin is still waiting.
// 1100   #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
// 1101     static millis_t last_command_time = 0;
// 1102     const millis_t ms = millis();
// 1103     if (commands_in_queue == 0 && !MYSERIAL.available() && ELAPSED(ms, last_command_time + NO_TIMEOUTS)) {
// 1104       SERIAL_ECHOLNPGM(MSG_WAIT);
// 1105       last_command_time = ms;
// 1106     }
// 1107   #endif
// 1108 #if 1
// 1109   
// 1110 	  /*5s?¡§?2a2?|¨¬?????¡§2¡§oy?Y?¡§¡ã¡§¡§??a??¡§?D¡§¡éa?¡§2?????¨º??¡§|¡§o1¡§??wifi*/
// 1111 	 if (commands_in_queue == 0 && !MYSERIAL.available() && ELAPSED(wait_ms, last_wait_time + 1000)) {
// 1112 		if(serial_wait_tick <= 5)
// 1113 	  {
// 1114 		  serial_wait_tick ++;
// 1115 	  }
// 1116 		last_wait_time = wait_ms;
// 1117 	  }
// 1118 #endif
// 1119 
// 1120   /**
// 1121    * Loop while serial characters are incoming and the queue is not full
// 1122    */
// 1123   int c;
// 1124   while (commands_in_queue < BUFSIZE && (c = MYSERIAL.read()) >= 0) {
// 1125 
// 1126     char serial_char = c;
// 1127 	
// 1128 	serial_wait_tick = 0;
// 1129 	from_wifi_flag = 0;
// 1130 
// 1131     /**
// 1132      * If the character ends the line
// 1133      */
// 1134     if (serial_char == '\n' || serial_char == '\r') {
// 1135 
// 1136       serial_comment_mode = false;                      // end of line == end of comment
// 1137 
// 1138       if (!serial_count) continue;                      // Skip empty lines
// 1139 
// 1140       serial_line_buffer[serial_count] = 0;             // Terminate string
// 1141       serial_count = 0;                                 // Reset buffer
// 1142 
// 1143       char* command = serial_line_buffer;
// 1144 
// 1145       while (*command == ' ') command++;                // Skip leading spaces
// 1146       char *npos = (*command == 'N') ? command : NULL;  // Require the N parameter to start the line
// 1147 
// 1148       if (npos) {
// 1149 
// 1150         bool M110 = strstr_P(command, PSTR("M110")) != NULL;
// 1151 
// 1152         if (M110) {
// 1153           char* n2pos = strchr(command + 4, 'N');
// 1154           if (n2pos) npos = n2pos;
// 1155         }
// 1156 
// 1157         gcode_N = strtol(npos + 1, NULL, 10);
// 1158 
// 1159         if (gcode_N != gcode_LastN + 1 && !M110) {
// 1160           gcode_line_error(PSTR(MSG_ERR_LINE_NO));
// 1161           return;
// 1162         }
// 1163 
// 1164         char *apos = strrchr(command, '*');
// 1165         if (apos) {
// 1166           uint8_t checksum = 0, count = uint8_t(apos - command);
// 1167           while (count) checksum ^= command[--count];
// 1168           if (strtol(apos + 1, NULL, 10) != checksum) {
// 1169             gcode_line_error(PSTR(MSG_ERR_CHECKSUM_MISMATCH));
// 1170             return;
// 1171           }
// 1172         }
// 1173         else {
// 1174           gcode_line_error(PSTR(MSG_ERR_NO_CHECKSUM));
// 1175           return;
// 1176         }
// 1177 
// 1178         gcode_LastN = gcode_N;
// 1179       }
// 1180 
// 1181       // Movement commands alert when stopped
// 1182       if (IsStopped()) {
// 1183         char* gpos = strchr(command, 'G');
// 1184         if (gpos) {
// 1185           const int codenum = strtol(gpos + 1, NULL, 10);
// 1186           switch (codenum) {
// 1187             case 0:
// 1188             case 1:
// 1189             case 2:
// 1190             case 3:
// 1191               SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
// 1192               LCD_MESSAGEPGM(MSG_STOPPED);
// 1193               break;
// 1194           }
// 1195         }
// 1196       }
// 1197 
// 1198       #if DISABLED(EMERGENCY_PARSER)
// 1199         // If command was e-stop process now
// 1200         if (strcmp(command, "M108") == 0) {
// 1201           wait_for_heatup = false;
// 1202           #if ENABLED(ULTIPANEL)
// 1203             wait_for_user = false;
// 1204           #endif
// 1205         }
// 1206         if (strcmp(command, "M112") == 0) kill(PSTR(MSG_KILLED));
// 1207         if (strcmp(command, "M410") == 0) { quickstop_stepper(); }
// 1208       #endif
// 1209 
// 1210       #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
// 1211         last_command_time = ms;
// 1212       #endif
// 1213 
// 1214       // Add the command to the queue
// 1215       _enqueuecommand(serial_line_buffer, true);
// 1216     }
// 1217     else if (serial_count >= MAX_CMD_SIZE - 1) {
// 1218       // Keep fetching, but ignore normal characters beyond the max length
// 1219       // The command will be injected when EOL is reached
// 1220     }
// 1221     else if (serial_char == '\\') {  // Handle escapes
// 1222       if ((c = MYSERIAL.read()) >= 0) {
// 1223         // if we have one more character, copy it over
// 1224         serial_char = c;
// 1225         if (!serial_comment_mode) serial_line_buffer[serial_count++] = serial_char;
// 1226       }
// 1227       // otherwise do nothing
// 1228     }
// 1229     else { // it's not a newline, carriage return or escape char
// 1230       if (serial_char == ';') serial_comment_mode = true;
// 1231       if (!serial_comment_mode) serial_line_buffer[serial_count++] = serial_char;
// 1232     }
// 1233 
// 1234   } // queue has space, serial has data
// 1235 }
// 1236 
// 1237 #if ENABLED(SDSUPPORT)
// 1238 
// 1239   /**
// 1240    * Get commands from the SD Card until the command buffer is full
// 1241    * or until the end of the file is reached. The special character '#'
// 1242    * can also interrupt buffering.
// 1243    */
// 1244   inline void get_sdcard_commands() {
// 1245     static bool stop_buffering = false,
// 1246                 sd_comment_mode = false;
// 1247 
// 1248     if (!card.sdprinting) return;
// 1249 
// 1250     /**
// 1251      * '#' stops reading from SD to the buffer prematurely, so procedural
// 1252      * macro calls are possible. If it occurs, stop_buffering is triggered
// 1253      * and the buffer is run dry; this character _can_ occur in serial com
// 1254      * due to checksums, however, no checksums are used in SD printing.
// 1255      */
// 1256 
// 1257     if (commands_in_queue == 0) stop_buffering = false;
// 1258 
// 1259     uint16_t sd_count = 0;
// 1260     bool card_eof = card.eof();
// 1261     while (commands_in_queue < BUFSIZE && !card_eof && !stop_buffering) {
// 1262       const int16_t n = card.get();
// 1263       char sd_char = (char)n;
// 1264       card_eof = card.eof();
// 1265       if (card_eof || n == -1
// 1266           || sd_char == '\n' || sd_char == '\r'
// 1267           || ((sd_char == '#' || sd_char == ':') && !sd_comment_mode)
// 1268       ) {
// 1269         if (card_eof) {
// 1270           gCfgItems.breakpoint_reprint_flg = 0;
// 1271           gCfgItems.breakpoint_z_pos = 0;
// 1272 
// 1273           card.printingHasFinished();
// 1274 
// 1275           if (card.sdprinting)
// 1276             sd_count = 0; // If a sub-file was printing, continue from call point
// 1277           else {
// 1278             SERIAL_PROTOCOLLNPGM(MSG_FILE_PRINTED);
// 1279             #if ENABLED(PRINTER_EVENT_LEDS)
// 1280               LCD_MESSAGEPGM(MSG_INFO_COMPLETED_PRINTS);
// 1281               leds.set_green();
// 1282               #if HAS_RESUME_CONTINUE
// 1283                 enqueue_and_echo_commands_P(PSTR("M0")); // end of the queue!
// 1284               #else
// 1285                 safe_delay(1000);
// 1286               #endif
// 1287               leds.set_off();
// 1288             #endif
// 1289             card.checkautostart(true);
// 1290 			
// 1291 			#if 1
// 1292 			
// 1293 			
// 1294 			//¡ä¨°¨ª¨º1??¨²?¡ê
// 1295 			if((gCfgItems.print_finish_close_machine_flg == 1)&&(IsChooseAutoShutdown==1))
// 1296 			    Close_machine_display();
// 1297 
// 1298             #endif 				
// 1299           }
// 1300         }
// 1301         else if (n == -1) {
// 1302           SERIAL_ERROR_START();
// 1303           SERIAL_ECHOLNPGM(MSG_SD_ERR_READ);
// 1304         }
// 1305         if (sd_char == '#') stop_buffering = true;
// 1306 
// 1307         sd_comment_mode = false; // for new command
// 1308 
// 1309         if (!sd_count) continue; // skip empty lines (and comment lines)
// 1310 
// 1311         command_queue[cmd_queue_index_w][sd_count] = '\0'; // terminate string
// 1312         sd_count = 0; // clear sd line buffer
// 1313 
// 1314         _commit_command(false);
// 1315       }
// 1316       else if (sd_count >= MAX_CMD_SIZE - 1) {
// 1317         /**
// 1318          * Keep fetching, but ignore normal characters beyond the max length
// 1319          * The command will be injected when EOL is reached
// 1320          */
// 1321       }
// 1322       else {
// 1323         if (sd_char == ';') sd_comment_mode = true;
// 1324         //if (!sd_comment_mode) command_queue[cmd_queue_index_w][sd_count++] = sd_char;
// 1325         if (!sd_comment_mode) 
// 1326         {
// 1327 			command_queue[cmd_queue_index_w][sd_count++] = sd_char;
// 1328 #if 0	//mks dlp			
// 1329 			if(sd_char == 0x5a ) //"Z"
// 1330 			{
// 1331 				mksReprint.sdpos = card.getsdpos()-3;	//"¡¤?2?????"
// 1332 				#if 1
// 1333 				mksReprint.sdpos_bak = mksReprint.sdpos;//sdpos_bak¦Ì?¨¨Y??¦Ì?¡ê????¡ä¨º1¨®?
// 1334 				if(gCfgItems.pwroff_save_mode != 1)//sd?¡§¡À¡ê¡ä???¦Ì?¨ºy?Y
// 1335                 #endif
// 1336 					mksReprint.refresh = true;
// 1337 			}
// 1338 #endif			
// 1339         }        
// 1340       }
// 1341     }
// 1342   }
// 1343 
// 1344 #endif // SDSUPPORT
// 1345 #if 1
// 1346 inline void get_wifi_commands() {
// 1347   static char wifi_line_buffer[MAX_CMD_SIZE];
// 1348   static bool wifi_comment_mode = false;
// 1349 
// 1350   if(serial_wait_tick > 5)
// 1351   {
// 1352   	from_wifi_flag = 1;
// 1353 
// 1354 /**
// 1355 	   * Loop while serial characters are incoming and the queue is not full
// 1356 	   */
// 1357 	  while ((commands_in_queue < BUFSIZE) && (espGcodeFifo.r != espGcodeFifo.w)) {
// 1358 
// 1359 	    char wifi_char = espGcodeFifo.Buffer[espGcodeFifo.r];
// 1360 
// 1361 	    espGcodeFifo.r = (espGcodeFifo.r + 1) % WIFI_GCODE_BUFFER_SIZE;
// 1362 
// 1363 	    /**
// 1364 	     * If the character ends the line
// 1365 	     */
// 1366 	    if (wifi_char == '\n' || wifi_char == '\r') {
// 1367 
// 1368 	      wifi_comment_mode = false; // end of line == end of comment
// 1369 
// 1370 	      if (!wifi_read_count) continue; // skip empty lines
// 1371 
// 1372 	      wifi_line_buffer[wifi_read_count] = 0; // terminate string
// 1373 	      wifi_read_count = 0; //reset buffer
// 1374 
// 1375 	      char* command = wifi_line_buffer;
// 1376 
// 1377 	      while (*command == ' ') command++; // skip any leading spaces	    
// 1378 
// 1379 	      // Movement commands alert when stopped
// 1380 	      if (IsStopped()) {
// 1381 	        char* gpos = strchr(command, 'G');
// 1382 	        if (gpos) {
// 1383 	          const int codenum = strtol(gpos + 1, NULL, 10);
// 1384 	          switch (codenum) {
// 1385 	            case 0:
// 1386 	            case 1:
// 1387 	            case 2:
// 1388 	            case 3:
// 1389 	              SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
// 1390 	              LCD_MESSAGEPGM(MSG_STOPPED);
// 1391 	              break;
// 1392 	          }
// 1393 	        }
// 1394 	      }
// 1395 
// 1396 	      #if DISABLED(EMERGENCY_PARSER)
// 1397 	        // If command was e-stop process now
// 1398 	        if (strcmp(command, "M108") == 0) {
// 1399 	          wait_for_heatup = false;
// 1400 	          #if ENABLED(ULTIPANEL)
// 1401 	            wait_for_user = false;
// 1402 	          #endif
// 1403 	        }
// 1404 	        if (strcmp(command, "M112") == 0) kill(PSTR(MSG_KILLED));
// 1405 	        if (strcmp(command, "M410") == 0) { quickstop_stepper(); }
// 1406 	      #endif
// 1407 
// 1408 	      #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
// 1409 	        last_command_time = ms;
// 1410 	      #endif
// 1411 
// 1412 	      // Add the command to the queue
// 1413 	      _enqueuecommand(wifi_line_buffer, true);
// 1414 	    }
// 1415 	    else if (wifi_read_count >= MAX_CMD_SIZE - 1) {
// 1416 	      // Keep fetching, but ignore normal characters beyond the max length
// 1417 	      // The command will be injected when EOL is reached
// 1418 	    }
// 1419 		/*
// 1420 	    else if (wifi_char == '\\') {  // Handle escapes
// 1421 	      if (MYSERIAL.available() > 0) {
// 1422 	        // if we have one more character, copy it over
// 1423 	        wifi_char = MYSERIAL.read();
// 1424 	        if (!serial_comment_mode) serial_line_buffer[serial_count++] = serial_char;
// 1425 	      }
// 1426 	      // otherwise do nothing
// 1427 	    }*/
// 1428 	    else { // it's not a newline, carriage return or escape char
// 1429 	      if (wifi_char == ';') wifi_comment_mode = true;
// 1430 	      if (!wifi_comment_mode) wifi_line_buffer[wifi_read_count++] = wifi_char;
// 1431 	    }
// 1432 
// 1433 	  }
// 1434     }// queue has space, serial has data
// 1435     else
// 1436     {
// 1437     	from_wifi_flag = 0;
// 1438     }
// 1439 }
// 1440 #endif
// 1441 
// 1442 /**
// 1443  * Add to the circular command queue the next command from:
// 1444  *  - The command-injection queue (injected_commands_P)
// 1445  *  - The active serial input (usually USB)
// 1446  *  - The SD card file being actively printed
// 1447  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock20 Using cfiCommon0
          CFI Function _Z22get_available_commandsv
        THUMB
// 1448 void get_available_commands() {
_Z22get_available_commandsv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 1449 
// 1450   // if any immediate commands remain, don't get other commands yet
// 1451   if (drain_injected_commands_P()) return;
          CFI FunCall _Z25drain_injected_commands_Pv
        BL       _Z25drain_injected_commands_Pv
        CMP      R0,#+0
        BNE.N    ??get_available_commands_0
// 1452 
// 1453   get_serial_commands();
          CFI FunCall _Z19get_serial_commandsv
        BL       _Z19get_serial_commandsv
// 1454   
// 1455 #if 1
// 1456 	get_wifi_commands();
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z17get_wifi_commandsv
        B.W      _Z17get_wifi_commandsv
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??get_available_commands_0:
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock20
// 1457 #endif
// 1458 
// 1459   #if ENABLED(SDSUPPORT) && DISABLED(MKS_DLP_BOARD)
// 1460     get_sdcard_commands();
// 1461   #endif
// 1462 }
// 1463 
// 1464 /**
// 1465  * Set target_extruder from the T parameter or the active_extruder
// 1466  *
// 1467  * Returns TRUE if the target is invalid
// 1468  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock21 Using cfiCommon0
          CFI Function _Z32get_target_extruder_from_commandt
        THUMB
// 1469 bool get_target_extruder_from_command(const uint16_t code) {
_Z32get_target_extruder_from_commandt:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R4,R0
// 1470   if (parser.seenval('T')) {
        MOVS     R0,#+84
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??get_target_extruder_from_command_0
// 1471     const int8_t e = parser.value_byte();
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        MOV      R5,R0
        SXTB     R5,R5
// 1472     if (e >= EXTRUDERS) {
        CMP      R5,#+1
        BLT.N    ??get_target_extruder_from_command_1
// 1473       SERIAL_ECHO_START();
        LDR.W    R0,??DataTable107_2
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 1474       SERIAL_CHAR('M');
        LDR.W    R6,??DataTable109
        MOVS     R1,#+77
        MOV      R0,R6
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 1475       SERIAL_ECHO(code);
        MOVS     R2,#+10
        MOV      R1,R4
        MOV      R0,R6
          CFI FunCall _ZN5Print5printEii
        BL       _ZN5Print5printEii
// 1476       SERIAL_ECHOLNPAIR(" " MSG_INVALID_EXTRUDER " ", e);
        MOV      R1,R5
        ADR.W    R0,`?<Constant " Invalid extruder ">`
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        MOVS     R1,#+10
        MOV      R0,R6
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 1477       return true;
        MOVS     R0,#+1
        POP      {R4-R6,PC}
// 1478     }
// 1479     target_extruder = e;
??get_target_extruder_from_command_1:
        LDR.W    R0,??DataTable111_1
        STRB     R5,[R0, #+22]
        B.N      ??get_target_extruder_from_command_2
// 1480   }
// 1481   else
// 1482     target_extruder = active_extruder;
??get_target_extruder_from_command_0:
        LDR.W    R0,??DataTable111_1
        LDRB     R1,[R0, #+19]
        STRB     R1,[R0, #+22]
// 1483 
// 1484   return false;
??get_target_extruder_from_command_2:
        MOVS     R0,#+0
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock21
// 1485 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant " Invalid extruder ">`:
        DC8 " Invalid extruder "
        DC8 0
// 1486 
// 1487 #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
// 1488   bool extruder_duplication_enabled = false; // Used in Dual X mode 2
// 1489 #endif
// 1490 
// 1491 #if ENABLED(DUAL_X_CARRIAGE)
// 1492 
// 1493   static DualXMode dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
// 1494 
// 1495   static float x_home_pos(const int extruder) {
// 1496     if (extruder == 0)
// 1497       return base_home_pos(X_AXIS);
// 1498     else
// 1499       /**
// 1500        * In dual carriage mode the extruder offset provides an override of the
// 1501        * second X-carriage position when homed - otherwise X2_HOME_POS is used.
// 1502        * This allows soft recalibration of the second extruder home position
// 1503        * without firmware reflash (through the M218 command).
// 1504        */
// 1505       return hotend_offset[X_AXIS][1] > 0 ? hotend_offset[X_AXIS][1] : X2_HOME_POS;
// 1506   }
// 1507 
// 1508   static int x_home_dir(const int extruder) { return extruder ? X2_HOME_DIR : X_HOME_DIR; }
// 1509 
// 1510   static float inactive_extruder_x_pos = X2_MAX_POS; // used in mode 0 & 1
// 1511   static bool active_extruder_parked = false;        // used in mode 1 & 2
// 1512   static float raised_parked_position[XYZE];         // used in mode 1
// 1513   static millis_t delayed_move_time = 0;             // used in mode 1
// 1514   static float duplicate_extruder_x_offset = DEFAULT_DUPLICATION_X_OFFSET; // used in mode 2
// 1515   static int16_t duplicate_extruder_temp_offset = 0; // used in mode 2
// 1516 
// 1517 #endif // DUAL_X_CARRIAGE
// 1518 
// 1519 #if HAS_WORKSPACE_OFFSET || ENABLED(DUAL_X_CARRIAGE)
// 1520 
// 1521   /**
// 1522    * Software endstops can be used to monitor the open end of
// 1523    * an axis that has a hardware endstop on the other end. Or
// 1524    * they can prevent axes from moving past endstops and grinding.
// 1525    *
// 1526    * To keep doing their job as the coordinate system changes,
// 1527    * the software endstop positions must be refreshed to remain
// 1528    * at the same positions relative to the machine.
// 1529    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock22 Using cfiCommon0
          CFI Function _Z24update_software_endstops8AxisEnum
        THUMB
// 1530   void update_software_endstops(const AxisEnum axis) {
_Z24update_software_endstops8AxisEnum:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
// 1531     #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
// 1532       workspace_offset[axis] = home_offset[axis] + position_shift[axis];
        LDR.W    R0,??DataTable104_9
        ADD      R5,R0,R4, LSL #+2
        LDR.W    R0,??DataTable111_1
        ADD      R0,R0,R4, LSL #+2
        VLDR     S0,[R0, #+84]
        VLDR     S1,[R0, #+128]
        VADD.F32 S0,S0,S1
        VSTR     S0,[R5, #+4]
// 1533     #endif
// 1534 
// 1535     #if ENABLED(DUAL_X_CARRIAGE)
// 1536       if (axis == X_AXIS) {
// 1537 
// 1538         // In Dual X mode hotend_offset[X] is T1's home position
// 1539         float dual_max_x = max(hotend_offset[X_AXIS][1], X2_MAX_POS);
// 1540 
// 1541         if (active_extruder != 0) {
// 1542           // T1 can move from X2_MIN_POS to X2_MAX_POS or X2 home position (whichever is larger)
// 1543           soft_endstop_min[X_AXIS] = X2_MIN_POS;
// 1544           soft_endstop_max[X_AXIS] = dual_max_x;
// 1545         }
// 1546         else if (dual_x_carriage_mode == DXC_DUPLICATION_MODE) {
// 1547           // In Duplication Mode, T0 can move as far left as X_MIN_POS
// 1548           // but not so far to the right that T1 would move past the end
// 1549           soft_endstop_min[X_AXIS] = base_min_pos(X_AXIS);
// 1550           soft_endstop_max[X_AXIS] = min(base_max_pos(X_AXIS), dual_max_x - duplicate_extruder_x_offset);
// 1551         }
// 1552         else {
// 1553           // In other modes, T0 can move from X_MIN_POS to X_MAX_POS
// 1554           soft_endstop_min[axis] = base_min_pos(axis);
// 1555           soft_endstop_max[axis] = base_max_pos(axis);
// 1556         }
// 1557       }
// 1558     #elif ENABLED(DELTA)
// 1559       soft_endstop_min[axis] = base_min_pos(axis);
// 1560       soft_endstop_max[axis] = axis == Z_AXIS ? delta_height : base_max_pos(axis);
// 1561     #else
// 1562       soft_endstop_min[axis] = base_min_pos(axis);
        MOV      R0,R4
          CFI FunCall _Z12base_min_pos8AxisEnum
        BL       _Z12base_min_pos8AxisEnum
        VSTR     S0,[R5, #+16]
// 1563       soft_endstop_max[axis] = base_max_pos(axis);
        MOV      R0,R4
          CFI FunCall _Z12base_max_pos8AxisEnum
        BL       _Z12base_max_pos8AxisEnum
        VSTR     S0,[R5, #+28]
// 1564     #endif
// 1565 
// 1566     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1567       if (DEBUGGING(LEVELING)) {
// 1568         SERIAL_ECHOPAIR("For ", axis_codes[axis]);
// 1569         #if HAS_HOME_OFFSET
// 1570           SERIAL_ECHOPAIR(" axis:\n home_offset = ", home_offset[axis]);
// 1571         #endif
// 1572         #if HAS_POSITION_SHIFT
// 1573           SERIAL_ECHOPAIR("\n position_shift = ", position_shift[axis]);
// 1574         #endif
// 1575         SERIAL_ECHOPAIR("\n soft_endstop_min = ", soft_endstop_min[axis]);
// 1576         SERIAL_ECHOLNPAIR("\n soft_endstop_max = ", soft_endstop_max[axis]);
// 1577       }
// 1578     #endif
// 1579 
// 1580     #if ENABLED(DELTA)
// 1581       switch(axis) {
// 1582         case X_AXIS:
// 1583         case Y_AXIS:
// 1584           // Get a minimum radius for clamping
// 1585           soft_endstop_radius = MIN3(FABS(max(soft_endstop_min[X_AXIS], soft_endstop_min[Y_AXIS])), soft_endstop_max[X_AXIS], soft_endstop_max[Y_AXIS]);
// 1586           soft_endstop_radius_2 = sq(soft_endstop_radius);
// 1587           break;
// 1588         case Z_AXIS:
// 1589           delta_clip_start_height = soft_endstop_max[axis] - delta_safe_distance_from_top();
// 1590         default: break;
// 1591       }
// 1592     #endif
// 1593   }
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock22
// 1594 
// 1595 #endif // HAS_WORKSPACE_OFFSET || DUAL_X_CARRIAGE
// 1596 
// 1597 #if HAS_M206_COMMAND
// 1598   /**
// 1599    * Change the home offset for an axis, update the current
// 1600    * position and the software endstops to retain the same
// 1601    * relative distance to the new home.
// 1602    *
// 1603    * Since this changes the current_position, code should
// 1604    * call sync_plan_position soon after this.
// 1605    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock23 Using cfiCommon0
          CFI Function _Z15set_home_offset8AxisEnumf
        THUMB
// 1606   static void set_home_offset(const AxisEnum axis, const float v) {
// 1607     home_offset[axis] = v;
_Z15set_home_offset8AxisEnumf:
        LDR.W    R1,??DataTable111_1
        ADD      R1,R1,R0, LSL #+2
        VSTR     S0,[R1, #+84]
// 1608     update_software_endstops(axis);
          CFI FunCall _Z24update_software_endstops8AxisEnum
        B.N      _Z24update_software_endstops8AxisEnum
          CFI EndBlock cfiBlock23
// 1609   }
// 1610 #endif // HAS_M206_COMMAND
// 1611 
// 1612 /**
// 1613  * Set an axis' current position to its home position (after homing).
// 1614  *
// 1615  * For Core and Cartesian robots this applies one-to-one when an
// 1616  * individual axis has been homed.
// 1617  *
// 1618  * DELTA should wait until all homing is done before setting the XYZ
// 1619  * current_position to home, because homing is a single operation.
// 1620  * In the case where the axis positions are already known and previously
// 1621  * homed, DELTA could home to X or Y individually by moving either one
// 1622  * to the center. However, homing Z always homes XY and Z.
// 1623  *
// 1624  * SCARA should wait until all XY homing is done before setting the XY
// 1625  * current_position to home, because neither X nor Y is at home until
// 1626  * both are at home. Z can however be homed individually.
// 1627  *
// 1628  * Callers must sync the planner position after calling this!
// 1629  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock24 Using cfiCommon0
          CFI Function _Z19set_axis_is_at_home8AxisEnum
        THUMB
// 1630 static void set_axis_is_at_home(const AxisEnum axis) {
_Z19set_axis_is_at_home8AxisEnum:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R4,R0
// 1631   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1632     if (DEBUGGING(LEVELING)) {
// 1633       SERIAL_ECHOPAIR(">>> set_axis_is_at_home(", axis_codes[axis]);
// 1634       SERIAL_CHAR(')');
// 1635       SERIAL_EOL();
// 1636     }
// 1637   #endif
// 1638 
// 1639   axis_known_position[axis] = axis_homed[axis] = true;
        LDR.W    R5,??DataTable107
        ADDS     R0,R4,R5
        MOVS     R1,#+1
        STRB     R1,[R0, #+4]
        STRB     R1,[R0, #+8]
// 1640 
// 1641   #if HAS_POSITION_SHIFT
// 1642     position_shift[axis] = 0;
        ADD      R6,R5,R4, LSL #+2
        MOVS     R0,#+0
        STR      R0,[R6, #+128]
// 1643     update_software_endstops(axis);
        MOV      R0,R4
          CFI FunCall _Z24update_software_endstops8AxisEnum
        BL       _Z24update_software_endstops8AxisEnum
// 1644   #endif
// 1645 
// 1646   #if ENABLED(DUAL_X_CARRIAGE)
// 1647     if (axis == X_AXIS && (active_extruder == 1 || dual_x_carriage_mode == DXC_DUPLICATION_MODE)) {
// 1648       current_position[X_AXIS] = x_home_pos(active_extruder);
// 1649       return;
// 1650     }
// 1651   #endif
// 1652 
// 1653   #if ENABLED(MORGAN_SCARA)
// 1654 
// 1655     /**
// 1656      * Morgan SCARA homes XY at the same time
// 1657      */
// 1658     if (axis == X_AXIS || axis == Y_AXIS) {
// 1659 
// 1660       float homeposition[XYZ] = {
// 1661         base_home_pos(X_AXIS),
// 1662         base_home_pos(Y_AXIS),
// 1663         base_home_pos(Z_AXIS)
// 1664       };
// 1665 
// 1666       // SERIAL_ECHOPAIR("homeposition X:", homeposition[X_AXIS]);
// 1667       // SERIAL_ECHOLNPAIR(" Y:", homeposition[Y_AXIS]);
// 1668 
// 1669       /**
// 1670        * Get Home position SCARA arm angles using inverse kinematics,
// 1671        * and calculate homing offset using forward kinematics
// 1672        */
// 1673       inverse_kinematics(homeposition);
// 1674       forward_kinematics_SCARA(delta[A_AXIS], delta[B_AXIS]);
// 1675 
// 1676       // SERIAL_ECHOPAIR("Cartesian X:", cartes[X_AXIS]);
// 1677       // SERIAL_ECHOLNPAIR(" Y:", cartes[Y_AXIS]);
// 1678 
// 1679       current_position[axis] = cartes[axis];
// 1680 
// 1681       /**
// 1682        * SCARA home positions are based on configuration since the actual
// 1683        * limits are determined by the inverse kinematic transform.
// 1684        */
// 1685       soft_endstop_min[axis] = base_min_pos(axis); // + (cartes[axis] - base_home_pos(axis));
// 1686       soft_endstop_max[axis] = base_max_pos(axis); // + (cartes[axis] - base_home_pos(axis));
// 1687     }
// 1688     else
// 1689   #elif ENABLED(DELTA)
// 1690     if (axis == Z_AXIS)
// 1691       current_position[axis] = delta_height;
// 1692     else
// 1693   #endif
// 1694   {
// 1695     current_position[axis] = base_home_pos(axis);
        MOV      R0,R4
          CFI FunCall _Z13base_home_pos8AxisEnum
        BL       _Z13base_home_pos8AxisEnum
        VSTR     S0,[R6, #+36]
// 1696     current_position[C_AXIS] = home_offset[C_AXIS];   //mks_dlp 
        LDR      R0,[R5, #+92]
        STR      R0,[R5, #+44]
// 1697   }
// 1698 
// 1699   /**
// 1700    * Z Probe Z Homing? Account for the probe's Z offset.
// 1701    */
// 1702   //#if HAS_BED_PROBE && Z_HOME_DIR < 0
// 1703 #if 0
// 1704     if (axis == Z_AXIS) {
// 1705       #if HOMING_Z_WITH_PROBE
// 1706 
// 1707         current_position[Z_AXIS] -= zprobe_zoffset;
// 1708 
// 1709         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1710           if (DEBUGGING(LEVELING)) {
// 1711             SERIAL_ECHOLNPGM("*** Z HOMED WITH PROBE (Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) ***");
// 1712             SERIAL_ECHOLNPAIR("> zprobe_zoffset = ", zprobe_zoffset);
// 1713           }
// 1714         #endif
// 1715 
// 1716       #elif ENABLED(DEBUG_LEVELING_FEATURE)
// 1717 
// 1718         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("*** Z HOMED TO ENDSTOP (Z_MIN_PROBE_ENDSTOP) ***");
// 1719 
// 1720       #endif
// 1721     }
// 1722   #endif
// 1723 
// 1724   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1725     if (DEBUGGING(LEVELING)) {
// 1726       #if HAS_HOME_OFFSET
// 1727         SERIAL_ECHOPAIR("> home_offset[", axis_codes[axis]);
// 1728         SERIAL_ECHOLNPAIR("] = ", home_offset[axis]);
// 1729       #endif
// 1730       DEBUG_POS("", current_position);
// 1731       SERIAL_ECHOPAIR("<<< set_axis_is_at_home(", axis_codes[axis]);
// 1732       SERIAL_CHAR(')');
// 1733       SERIAL_EOL();
// 1734     }
// 1735   #endif
// 1736 
// 1737   #if ENABLED(I2C_POSITION_ENCODERS)
// 1738     I2CPEM.homed(axis);
// 1739   #endif
// 1740 }
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock24
// 1741 
// 1742 /**
// 1743  * Some planner shorthand inline functions
// 1744  */
// 1745 inline float get_homing_bump_feedrate(const AxisEnum axis) {
// 1746   //static const uint8_t homing_bump_divisor[] PROGMEM = HOMING_BUMP_DIVISOR;
// 1747 	int  homing_bump_divisor[4];
// 1748 		homing_bump_divisor[0] = 2;
// 1749 		homing_bump_divisor[1] = 2;
// 1750 		homing_bump_divisor[2] = 4;
// 1751   uint8_t hbd = pgm_read_byte(&homing_bump_divisor[axis]);
// 1752   if (hbd < 1) {
// 1753     hbd = 10;
// 1754     SERIAL_ECHO_START();
// 1755     SERIAL_ECHOLNPGM("Warning: Homing Bump Divisor < 1");
// 1756   }
// 1757   //return homing_feedrate(axis) / hbd;
// 1758   return homing_feedrate_mm_s[axis] / hbd;
// 1759 }
// 1760 
// 1761 /**
// 1762  * Move the planner to the current position from wherever it last moved
// 1763  * (or from wherever it has been told it is located).
// 1764  */
// 1765 inline void buffer_line_to_current_position() {
// 1766   planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], feedrate_mm_s, active_extruder);
// 1767 }
// 1768 
// 1769 /**
// 1770  * Move the planner to the position stored in the destination array, which is
// 1771  * used by G0/G1/G2/G3/G5 and many other functions to set a destination.
// 1772  */
// 1773 inline void buffer_line_to_destination(const float fr_mm_s) {
// 1774   planner.buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], fr_mm_s, active_extruder);
// 1775 }
// 1776 
// 1777 #if IS_KINEMATIC
// 1778   /**
// 1779    * Calculate delta, start a line, and set current_position to destination
// 1780    */
// 1781   void prepare_uninterpolated_move_to_destination(const float fr_mm_s=0.0) {
// 1782     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1783       if (DEBUGGING(LEVELING)) DEBUG_POS("prepare_uninterpolated_move_to_destination", destination);
// 1784     #endif
// 1785 
// 1786     refresh_cmd_timeout();
// 1787 
// 1788     #if UBL_SEGMENTED
// 1789       // ubl segmented line will do z-only moves in single segment
// 1790       ubl.prepare_segmented_line_to(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s));
// 1791     #else
// 1792       if ( current_position[X_AXIS] == destination[X_AXIS]
// 1793         && current_position[Y_AXIS] == destination[Y_AXIS]
// 1794         && current_position[Z_AXIS] == destination[Z_AXIS]
// 1795         && current_position[E_AXIS] == destination[E_AXIS]
// 1796       ) return;
// 1797 
// 1798       planner.buffer_line_kinematic(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s), active_extruder);
// 1799     #endif
// 1800 
// 1801     set_current_from_destination();
// 1802   }
// 1803 #endif // IS_KINEMATIC
// 1804 
// 1805 /**
// 1806  *  Plan a move to (X, Y, Z) and set the current_position
// 1807  *  The final current_position may not be the one that was requested
// 1808  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock25 Using cfiCommon0
          CFI Function _Z19do_blocking_move_toRKfS0_S0_S0_
        THUMB
// 1809 void do_blocking_move_to(const float &rx, const float &ry, const float &rz, const float &fr_mm_s/*=0.0*/) {
_Z19do_blocking_move_toRKfS0_S0_S0_:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        VPUSH    {D8}
          CFI D8 Frame(CFA, -32)
          CFI CFA R13+32
        MOV      R6,R0
        MOV      R7,R1
        MOV      R4,R2
        MOV      R8,R3
// 1810   const float old_feedrate_mm_s = feedrate_mm_s;
        LDR.W    R5,??DataTable107
        VLDR     S16,[R5, #+120]
// 1811 
// 1812   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1813     if (DEBUGGING(LEVELING)) print_xyz(PSTR(">>> do_blocking_move_to"), NULL, LOGICAL_X_POSITION(rx), LOGICAL_Y_POSITION(ry), LOGICAL_Z_POSITION(rz));
// 1814   #endif
// 1815 
// 1816   const float z_feedrate = fr_mm_s ? fr_mm_s : homing_feedrate_mm_s[Z_AXIS];
        VLDR     S17,[R8, #0]
        VCMP.F32 S17,#0.0
        FMSTAT   
        BNE.N    ??do_blocking_move_to_0
        VLDR     S17,[R5, #+76]
// 1817 
// 1818   #if ENABLED(DELTA)
// 1819     if (!position_is_reachable(rx, ry)) return;
// 1820 
// 1821     feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
// 1822 
// 1823     set_destination_from_current();          // sync destination at the start
// 1824 
// 1825     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1826       if (DEBUGGING(LEVELING)) DEBUG_POS("set_destination_from_current", destination);
// 1827     #endif
// 1828 
// 1829     // when in the danger zone
// 1830     if (current_position[Z_AXIS] > delta_clip_start_height) {
// 1831       if (rz > delta_clip_start_height) {   // staying in the danger zone
// 1832         destination[X_AXIS] = rx;           // move directly (uninterpolated)
// 1833         destination[Y_AXIS] = ry;
// 1834         destination[Z_AXIS] = rz;
// 1835         prepare_uninterpolated_move_to_destination(); // set_current_from_destination
// 1836         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1837           if (DEBUGGING(LEVELING)) DEBUG_POS("danger zone move", current_position);
// 1838         #endif
// 1839         return;
// 1840       }
// 1841       destination[Z_AXIS] = delta_clip_start_height;
// 1842       prepare_uninterpolated_move_to_destination(); // set_current_from_destination
// 1843       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1844         if (DEBUGGING(LEVELING)) DEBUG_POS("zone border move", current_position);
// 1845       #endif
// 1846     }
// 1847 
// 1848     if (rz > current_position[Z_AXIS]) {    // raising?
// 1849       destination[Z_AXIS] = rz;
// 1850       prepare_uninterpolated_move_to_destination(z_feedrate);   // set_current_from_destination
// 1851       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1852         if (DEBUGGING(LEVELING)) DEBUG_POS("z raise move", current_position);
// 1853       #endif
// 1854     }
// 1855 
// 1856     destination[X_AXIS] = rx;
// 1857     destination[Y_AXIS] = ry;
// 1858     prepare_move_to_destination();         // set_current_from_destination
// 1859     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1860       if (DEBUGGING(LEVELING)) DEBUG_POS("xy move", current_position);
// 1861     #endif
// 1862 
// 1863     if (rz < current_position[Z_AXIS]) {    // lowering?
// 1864       destination[Z_AXIS] = rz;
// 1865       prepare_uninterpolated_move_to_destination(z_feedrate);   // set_current_from_destination
// 1866       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1867         if (DEBUGGING(LEVELING)) DEBUG_POS("z lower move", current_position);
// 1868       #endif
// 1869     }
// 1870 
// 1871   #elif IS_SCARA
// 1872 
// 1873     if (!position_is_reachable(rx, ry)) return;
// 1874 
// 1875     set_destination_from_current();
// 1876 
// 1877     // If Z needs to raise, do it before moving XY
// 1878     if (destination[Z_AXIS] < rz) {
// 1879       destination[Z_AXIS] = rz;
// 1880       prepare_uninterpolated_move_to_destination(z_feedrate);
// 1881     }
// 1882 
// 1883     destination[X_AXIS] = rx;
// 1884     destination[Y_AXIS] = ry;
// 1885     prepare_uninterpolated_move_to_destination(fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S);
// 1886 
// 1887     // If Z needs to lower, do it after moving XY
// 1888     if (destination[Z_AXIS] > rz) {
// 1889       destination[Z_AXIS] = rz;
// 1890       prepare_uninterpolated_move_to_destination(z_feedrate);
// 1891     }
// 1892 
// 1893   #else
// 1894 
// 1895     // If Z needs to raise, do it before moving XY
// 1896     if (current_position[Z_AXIS] < rz) {
??do_blocking_move_to_0:
        VLDR     S0,[R5, #+44]
        VLDR     S1,[R4, #0]
        VCMP.F32 S0,S1
        FMSTAT   
        BPL.N    ??do_blocking_move_to_1
// 1897       feedrate_mm_s = z_feedrate;
        VSTR     S17,[R5, #+120]
// 1898       current_position[Z_AXIS] = rz;
        LDR      R0,[R4, #+0]
        STR      R0,[R5, #+44]
// 1899       buffer_line_to_current_position();
          CFI FunCall _Z31buffer_line_to_current_positionv
        BL       _Z31buffer_line_to_current_positionv
// 1900     }
// 1901 
// 1902     feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
??do_blocking_move_to_1:
        VLDR     S0,[R8, #0]
        VCMP.F32 S0,#0.0
        FMSTAT   
        BEQ.N    ??do_blocking_move_to_2
        VSTR     S0,[R5, #+120]
        B.N      ??do_blocking_move_to_3
??do_blocking_move_to_2:
        LDR.W    R0,??DataTable111_2  ;; 0x43055555
        STR      R0,[R5, #+120]
// 1903     current_position[X_AXIS] = rx;
??do_blocking_move_to_3:
        LDR      R0,[R6, #+0]
        STR      R0,[R5, #+36]
// 1904     current_position[Y_AXIS] = ry;
        LDR      R0,[R7, #+0]
        STR      R0,[R5, #+40]
// 1905     buffer_line_to_current_position();
          CFI FunCall _Z31buffer_line_to_current_positionv
        BL       _Z31buffer_line_to_current_positionv
// 1906 
// 1907     // If Z needs to lower, do it after moving XY
// 1908     if (current_position[Z_AXIS] > rz) {
        VLDR     S0,[R4, #0]
        VLDR     S1,[R5, #+44]
        VCMP.F32 S0,S1
        FMSTAT   
        BPL.N    ??do_blocking_move_to_4
// 1909       feedrate_mm_s = z_feedrate;
        VSTR     S17,[R5, #+120]
// 1910       current_position[Z_AXIS] = rz;
        LDR      R0,[R4, #+0]
        STR      R0,[R5, #+44]
// 1911       buffer_line_to_current_position();
          CFI FunCall _Z31buffer_line_to_current_positionv
        BL       _Z31buffer_line_to_current_positionv
// 1912     }
// 1913 
// 1914   #endif
// 1915 
// 1916   stepper.synchronize();
??do_blocking_move_to_4:
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
// 1917 
// 1918   feedrate_mm_s = old_feedrate_mm_s;
        VSTR     S16,[R5, #+120]
// 1919 
// 1920   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1921     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< do_blocking_move_to");
// 1922   #endif
// 1923 }
        VPOP     {D8}
          CFI D8 SameValue
          CFI CFA R13+24
        POP      {R4-R8,PC}       ;; return
          CFI EndBlock cfiBlock25

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable88:
        DC32     0x43480000
// 1924 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock26 Using cfiCommon0
          CFI Function _Z26do_blocking_move_to_nowaitRKfS0_S0_S0_
        THUMB
// 1925 void do_blocking_move_to_nowait(const float &rx, const float &ry, const float &rz, const float &fr_mm_s/*=0.0*/) {
_Z26do_blocking_move_to_nowaitRKfS0_S0_S0_:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        VPUSH    {D8}
          CFI D8 Frame(CFA, -32)
          CFI CFA R13+32
        MOV      R6,R0
        MOV      R7,R1
        MOV      R4,R2
        MOV      R8,R3
// 1926   const float old_feedrate_mm_s = feedrate_mm_s;
        LDR.W    R5,??DataTable107
        VLDR     S16,[R5, #+120]
// 1927 
// 1928   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1929     if (DEBUGGING(LEVELING)) print_xyz(PSTR(">>> do_blocking_move_to"), NULL, LOGICAL_X_POSITION(rx), LOGICAL_Y_POSITION(ry), LOGICAL_Z_POSITION(rz));
// 1930   #endif
// 1931 
// 1932   const float z_feedrate = fr_mm_s ? fr_mm_s : homing_feedrate_mm_s[Z_AXIS];
        VLDR     S17,[R8, #0]
        VCMP.F32 S17,#0.0
        FMSTAT   
        BNE.N    ??do_blocking_move_to_nowait_0
        VLDR     S17,[R5, #+76]
// 1933 
// 1934   #if ENABLED(DELTA)
// 1935     if (!position_is_reachable(rx, ry)) return;
// 1936 
// 1937     feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
// 1938 
// 1939     set_destination_from_current();          // sync destination at the start
// 1940 
// 1941     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1942       if (DEBUGGING(LEVELING)) DEBUG_POS("set_destination_from_current", destination);
// 1943     #endif
// 1944 
// 1945     // when in the danger zone
// 1946     if (current_position[Z_AXIS] > delta_clip_start_height) {
// 1947       if (rz > delta_clip_start_height) {   // staying in the danger zone
// 1948         destination[X_AXIS] = rx;           // move directly (uninterpolated)
// 1949         destination[Y_AXIS] = ry;
// 1950         destination[Z_AXIS] = rz;
// 1951         prepare_uninterpolated_move_to_destination(); // set_current_from_destination
// 1952         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1953           if (DEBUGGING(LEVELING)) DEBUG_POS("danger zone move", current_position);
// 1954         #endif
// 1955         return;
// 1956       }
// 1957       destination[Z_AXIS] = delta_clip_start_height;
// 1958       prepare_uninterpolated_move_to_destination(); // set_current_from_destination
// 1959       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1960         if (DEBUGGING(LEVELING)) DEBUG_POS("zone border move", current_position);
// 1961       #endif
// 1962     }
// 1963 
// 1964     if (rz > current_position[Z_AXIS]) {    // raising?
// 1965       destination[Z_AXIS] = rz;
// 1966       prepare_uninterpolated_move_to_destination(z_feedrate);   // set_current_from_destination
// 1967       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1968         if (DEBUGGING(LEVELING)) DEBUG_POS("z raise move", current_position);
// 1969       #endif
// 1970     }
// 1971 
// 1972     destination[X_AXIS] = rx;
// 1973     destination[Y_AXIS] = ry;
// 1974     prepare_move_to_destination();         // set_current_from_destination
// 1975     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1976       if (DEBUGGING(LEVELING)) DEBUG_POS("xy move", current_position);
// 1977     #endif
// 1978 
// 1979     if (rz < current_position[Z_AXIS]) {    // lowering?
// 1980       destination[Z_AXIS] = rz;
// 1981       prepare_uninterpolated_move_to_destination(z_feedrate);   // set_current_from_destination
// 1982       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1983         if (DEBUGGING(LEVELING)) DEBUG_POS("z lower move", current_position);
// 1984       #endif
// 1985     }
// 1986 
// 1987   #elif IS_SCARA
// 1988 
// 1989     if (!position_is_reachable(rx, ry)) return;
// 1990 
// 1991     set_destination_from_current();
// 1992 
// 1993     // If Z needs to raise, do it before moving XY
// 1994     if (destination[Z_AXIS] < rz) {
// 1995       destination[Z_AXIS] = rz;
// 1996       prepare_uninterpolated_move_to_destination(z_feedrate);
// 1997     }
// 1998 
// 1999     destination[X_AXIS] = rx;
// 2000     destination[Y_AXIS] = ry;
// 2001     prepare_uninterpolated_move_to_destination(fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S);
// 2002 
// 2003     // If Z needs to lower, do it after moving XY
// 2004     if (destination[Z_AXIS] > rz) {
// 2005       destination[Z_AXIS] = rz;
// 2006       prepare_uninterpolated_move_to_destination(z_feedrate);
// 2007     }
// 2008 
// 2009   #else
// 2010 
// 2011     // If Z needs to raise, do it before moving XY
// 2012     if (current_position[Z_AXIS] < rz) {
??do_blocking_move_to_nowait_0:
        VLDR     S0,[R5, #+44]
        VLDR     S1,[R4, #0]
        VCMP.F32 S0,S1
        FMSTAT   
        BPL.N    ??do_blocking_move_to_nowait_1
// 2013       feedrate_mm_s = z_feedrate;
        VSTR     S17,[R5, #+120]
// 2014       current_position[Z_AXIS] = rz;
        LDR      R0,[R4, #+0]
        STR      R0,[R5, #+44]
// 2015       buffer_line_to_current_position();
          CFI FunCall _Z31buffer_line_to_current_positionv
        BL       _Z31buffer_line_to_current_positionv
// 2016     }
// 2017 
// 2018     feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
??do_blocking_move_to_nowait_1:
        VLDR     S0,[R8, #0]
        VCMP.F32 S0,#0.0
        FMSTAT   
        BEQ.N    ??do_blocking_move_to_nowait_2
        VSTR     S0,[R5, #+120]
        B.N      ??do_blocking_move_to_nowait_3
??do_blocking_move_to_nowait_2:
        LDR.W    R0,??DataTable111_2  ;; 0x43055555
        STR      R0,[R5, #+120]
// 2019     current_position[X_AXIS] = rx;
??do_blocking_move_to_nowait_3:
        LDR      R0,[R6, #+0]
        STR      R0,[R5, #+36]
// 2020     current_position[Y_AXIS] = ry;
        LDR      R0,[R7, #+0]
        STR      R0,[R5, #+40]
// 2021     buffer_line_to_current_position();
          CFI FunCall _Z31buffer_line_to_current_positionv
        BL       _Z31buffer_line_to_current_positionv
// 2022 
// 2023     // If Z needs to lower, do it after moving XY
// 2024     if (current_position[Z_AXIS] > rz) {
        VLDR     S0,[R4, #0]
        VLDR     S1,[R5, #+44]
        VCMP.F32 S0,S1
        FMSTAT   
        BPL.N    ??do_blocking_move_to_nowait_4
// 2025       feedrate_mm_s = z_feedrate;
        VSTR     S17,[R5, #+120]
// 2026       current_position[Z_AXIS] = rz;
        LDR      R0,[R4, #+0]
        STR      R0,[R5, #+44]
// 2027       buffer_line_to_current_position();
          CFI FunCall _Z31buffer_line_to_current_positionv
        BL       _Z31buffer_line_to_current_positionv
// 2028     }
// 2029 
// 2030   #endif
// 2031 
// 2032 //  stepper.synchronize();
// 2033 
// 2034   feedrate_mm_s = old_feedrate_mm_s;
??do_blocking_move_to_nowait_4:
        VSTR     S16,[R5, #+120]
// 2035 
// 2036   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2037     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< do_blocking_move_to");
// 2038   #endif
// 2039 }
        VPOP     {D8}
          CFI D8 SameValue
          CFI CFA R13+24
        POP      {R4-R8,PC}       ;; return
          CFI EndBlock cfiBlock26
// 2040 
// 2041 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock27 Using cfiCommon0
          CFI Function _Z21do_blocking_move_to_xRKfS0_
        THUMB
// 2042 void do_blocking_move_to_x(const float &rx, const float &fr_mm_s/*=0.0*/) {
_Z21do_blocking_move_to_xRKfS0_:
        PUSH     {R3,R4}
          CFI R4 Frame(CFA, -4)
          CFI CFA R13+8
// 2043   do_blocking_move_to(rx, current_position[Y_AXIS], current_position[Z_AXIS], fr_mm_s);
        LDR.W    R4,??DataTable111_1
        MOV      R3,R1
        ADD      R2,R4,#+44
        ADD      R1,R4,#+40
        ADD      SP,SP,#+4
          CFI CFA R13+4
        POP      {R4}
          CFI R4 SameValue
          CFI CFA R13+0
          CFI FunCall _Z19do_blocking_move_toRKfS0_S0_S0_
        B.N      _Z19do_blocking_move_toRKfS0_S0_S0_
          CFI EndBlock cfiBlock27
// 2044 }

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock28 Using cfiCommon0
          CFI Function _Z21do_blocking_move_to_zRKfS0_
        THUMB
// 2045 void do_blocking_move_to_z(const float &rz, const float &fr_mm_s/*=0.0*/) {
_Z21do_blocking_move_to_zRKfS0_:
        PUSH     {R3,R4}
          CFI R4 Frame(CFA, -4)
          CFI CFA R13+8
// 2046   do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], rz, fr_mm_s);
        LDR.W    R4,??DataTable111_1
        MOV      R3,R1
        MOV      R2,R0
        ADD      R1,R4,#+40
        ADD      R0,R4,#+36
        ADD      SP,SP,#+4
          CFI CFA R13+4
        POP      {R4}
          CFI R4 SameValue
          CFI CFA R13+0
          CFI FunCall _Z19do_blocking_move_toRKfS0_S0_S0_
        B.N      _Z19do_blocking_move_toRKfS0_S0_S0_
          CFI EndBlock cfiBlock28
// 2047 }

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock29 Using cfiCommon0
          CFI Function _Z28do_blocking_move_to_z_nowaitRKfS0_
        THUMB
// 2048 void do_blocking_move_to_z_nowait(const float &rz, const float &fr_mm_s/*=0.0*/) {
_Z28do_blocking_move_to_z_nowaitRKfS0_:
        PUSH     {R3,R4}
          CFI R4 Frame(CFA, -4)
          CFI CFA R13+8
// 2049   do_blocking_move_to_nowait(current_position[X_AXIS], current_position[Y_AXIS], rz, fr_mm_s);
        LDR.W    R4,??DataTable111_1
        MOV      R3,R1
        MOV      R2,R0
        ADD      R1,R4,#+40
        ADD      R0,R4,#+36
        ADD      SP,SP,#+4
          CFI CFA R13+4
        POP      {R4}
          CFI R4 SameValue
          CFI CFA R13+0
          CFI FunCall _Z26do_blocking_move_to_nowaitRKfS0_S0_S0_
        B.N      _Z26do_blocking_move_to_nowaitRKfS0_S0_S0_
          CFI EndBlock cfiBlock29
// 2050 }
// 2051 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock30 Using cfiCommon0
          CFI Function _Z22do_blocking_move_to_xyRKfS0_S0_
        THUMB
// 2052 void do_blocking_move_to_xy(const float &rx, const float &ry, const float &fr_mm_s/*=0.0*/) {
// 2053   do_blocking_move_to(rx, ry, current_position[Z_AXIS], fr_mm_s);
_Z22do_blocking_move_to_xyRKfS0_S0_:
        MOV      R3,R2
        LDR.W    R2,??DataTable111_4
          CFI FunCall _Z19do_blocking_move_toRKfS0_S0_S0_
        B.N      _Z19do_blocking_move_toRKfS0_S0_S0_
          CFI EndBlock cfiBlock30
// 2054 }
// 2055 
// 2056 //
// 2057 // Prepare to do endstop or probe moves
// 2058 // with custom feedrates.
// 2059 //
// 2060 //  - Save current feedrates
// 2061 //  - Reset the rate multiplier
// 2062 //  - Reset the command timeout
// 2063 //  - Enable the endstops (for endstop moves)
// 2064 //

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock31 Using cfiCommon0
          CFI Function _Z31setup_for_endstop_or_probe_movev
        THUMB
// 2065 static void setup_for_endstop_or_probe_move() {
// 2066   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2067     if (DEBUGGING(LEVELING)) DEBUG_POS("setup_for_endstop_or_probe_move", current_position);
// 2068   #endif
// 2069   saved_feedrate_mm_s = feedrate_mm_s;
_Z31setup_for_endstop_or_probe_movev:
        LDR.W    R0,??DataTable107
        LDR      R1,[R0, #+120]
        STR      R1,[R0, #+124]
// 2070   saved_feedrate_percentage = feedrate_percentage;
        LDRH     R1,[R0, #+32]
        STRH     R1,[R0, #+34]
// 2071   feedrate_percentage = 100;
        MOVS     R1,#+100
        STRH     R1,[R0, #+32]
// 2072   refresh_cmd_timeout();
          CFI FunCall _Z19refresh_cmd_timeoutv
        B.W      _Z19refresh_cmd_timeoutv
          CFI EndBlock cfiBlock31
// 2073 }
// 2074 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock32 Using cfiCommon0
          CFI Function _Z36clean_up_after_endstop_or_probe_movev
        THUMB
// 2075 static void clean_up_after_endstop_or_probe_move() {
// 2076   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2077     if (DEBUGGING(LEVELING)) DEBUG_POS("clean_up_after_endstop_or_probe_move", current_position);
// 2078   #endif
// 2079   feedrate_mm_s = saved_feedrate_mm_s;
_Z36clean_up_after_endstop_or_probe_movev:
        LDR.W    R0,??DataTable107
        LDR      R1,[R0, #+124]
        STR      R1,[R0, #+120]
// 2080   feedrate_percentage = saved_feedrate_percentage;
        LDRH     R1,[R0, #+34]
        STRH     R1,[R0, #+32]
// 2081   refresh_cmd_timeout();
          CFI FunCall _Z19refresh_cmd_timeoutv
        B.W      _Z19refresh_cmd_timeoutv
          CFI EndBlock cfiBlock32
// 2082 }
// 2083 
// 2084 #if HAS_BED_PROBE
// 2085   /**
// 2086    * Raise Z to a minimum height to make room for a probe to move
// 2087    */
// 2088   inline void do_probe_raise(const float z_raise) {
// 2089     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2090       if (DEBUGGING(LEVELING)) {
// 2091         SERIAL_ECHOPAIR("do_probe_raise(", z_raise);
// 2092         SERIAL_CHAR(')');
// 2093         SERIAL_EOL();
// 2094       }
// 2095     #endif
// 2096 
// 2097     float z_dest = z_raise;
// 2098     if (zprobe_zoffset < 0) z_dest -= zprobe_zoffset;
// 2099 
// 2100     if (z_dest > current_position[Z_AXIS])
// 2101       do_blocking_move_to_z(z_dest);
// 2102   }
// 2103 
// 2104 #endif // HAS_BED_PROBE
// 2105 
// 2106 #if HAS_AXIS_UNHOMED_ERR
// 2107 #if defined(MKS_DLP_BOARD)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock33 Using cfiCommon0
          CFI Function _Z18axis_unhomed_errorb
        THUMB
// 2108   bool axis_unhomed_error(const bool z/*=true*/) {
_Z18axis_unhomed_errorb:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 2109     #if ENABLED(HOME_AFTER_DEACTIVATE)
// 2110       const bool zz = z && !axis_known_position[Z_AXIS];
// 2111     #else
// 2112       const bool zz = z && !axis_homed[Z_AXIS];
        CMP      R0,#+0
        BEQ.N    ??axis_unhomed_error_0
        LDR.W    R0,??DataTable107
        LDRB     R0,[R0, #+6]
        EOR      R4,R0,#0x1
        B.N      ??axis_unhomed_error_1
??axis_unhomed_error_0:
        MOVS     R4,#+0
// 2113     #endif
// 2114     if (zz) {
??axis_unhomed_error_1:
        CMP      R4,#+0
        BEQ.N    ??axis_unhomed_error_2
// 2115       SERIAL_ECHO_START();
        LDR.W    R0,??DataTable107_2
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2116       SERIAL_ECHOPGM(MSG_HOME " ");
        ADR.W    R0,`?<Constant "Home ">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2117       if (zz) SERIAL_ECHOPGM(MSG_Z);
        CMP      R4,#+0
        BEQ.N    ??axis_unhomed_error_3
        ADR.N    R0,??DataTable103  ;; "Z"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2118       SERIAL_ECHOLNPGM(" " MSG_FIRST);
??axis_unhomed_error_3:
        ADR.W    R0,`?<Constant " first\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2119 
// 2120       #if ENABLED(ULTRA_LCD)
// 2121         lcd_status_printf_P(0, PSTR(MSG_HOME " %s%s%s " MSG_FIRST), xx ? MSG_X : "", yy ? MSG_Y : "", zz ? MSG_Z : "");
// 2122       #endif
// 2123       return true;
        MOVS     R0,#+1
        POP      {R4,PC}
// 2124     }
// 2125     return false;
??axis_unhomed_error_2:
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock33
// 2126   }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Home ">`:
        DC8 "Home "
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant " first\\n">`:
        DC8 " first\012"
// 2127 #else
// 2128 bool axis_unhomed_error(const bool x/*=true*/, const bool y/*=true*/, const bool z/*=true*/) {
// 2129   #if ENABLED(HOME_AFTER_DEACTIVATE)
// 2130 	const bool xx = x && !axis_known_position[X_AXIS],
// 2131 			   yy = y && !axis_known_position[Y_AXIS],
// 2132 			   zz = z && !axis_known_position[Z_AXIS];
// 2133   #else
// 2134 	const bool xx = x && !axis_homed[X_AXIS],
// 2135 			   yy = y && !axis_homed[Y_AXIS],
// 2136 			   zz = z && !axis_homed[Z_AXIS];
// 2137   #endif
// 2138   if (xx || yy || zz) {
// 2139 	SERIAL_ECHO_START();
// 2140 	SERIAL_ECHOPGM(MSG_HOME " ");
// 2141 	if (xx) SERIAL_ECHOPGM(MSG_X);
// 2142 	if (yy) SERIAL_ECHOPGM(MSG_Y);
// 2143 	if (zz) SERIAL_ECHOPGM(MSG_Z);
// 2144 	SERIAL_ECHOLNPGM(" " MSG_FIRST);
// 2145 
// 2146 	#if ENABLED(ULTRA_LCD)
// 2147 	  lcd_status_printf_P(0, PSTR(MSG_HOME " %s%s%s " MSG_FIRST), xx ? MSG_X : "", yy ? MSG_Y : "", zz ? MSG_Z : "");
// 2148 	#endif
// 2149 	return true;
// 2150   }
// 2151   return false;
// 2152 }
// 2153 
// 2154 #endif
// 2155 #endif // HAS_AXIS_UNHOMED_ERR
// 2156 
// 2157 #if ENABLED(Z_PROBE_SLED)
// 2158 
// 2159   #ifndef SLED_DOCKING_OFFSET
// 2160     #define SLED_DOCKING_OFFSET 0
// 2161   #endif
// 2162 
// 2163   /**
// 2164    * Method to dock/undock a sled designed by Charles Bell.
// 2165    *
// 2166    * stow[in]     If false, move to MAX_X and engage the solenoid
// 2167    *              If true, move to MAX_X and release the solenoid
// 2168    */
// 2169   static void dock_sled(bool stow) {
// 2170     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2171       if (DEBUGGING(LEVELING)) {
// 2172         SERIAL_ECHOPAIR("dock_sled(", stow);
// 2173         SERIAL_CHAR(')');
// 2174         SERIAL_EOL();
// 2175       }
// 2176     #endif
// 2177 
// 2178     // Dock sled a bit closer to ensure proper capturing
// 2179     do_blocking_move_to_x(X_MAX_POS + SLED_DOCKING_OFFSET - ((stow) ? 1 : 0));
// 2180 
// 2181     #if HAS_SOLENOID_1 && DISABLED(EXT_SOLENOID)
// 2182       WRITE(SOL1_PIN, !stow); // switch solenoid
// 2183     #endif
// 2184   }
// 2185 
// 2186 #elif ENABLED(Z_PROBE_ALLEN_KEY)
// 2187 
// 2188   FORCE_INLINE void do_blocking_move_to(const float (&raw)[XYZ], const float &fr_mm_s) {
// 2189     do_blocking_move_to(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], fr_mm_s);
// 2190   }
// 2191 
// 2192   void run_deploy_moves_script() {
// 2193     #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_Z)
// 2194       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_X
// 2195         #define Z_PROBE_ALLEN_KEY_DEPLOY_1_X current_position[X_AXIS]
// 2196       #endif
// 2197       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_Y
// 2198         #define Z_PROBE_ALLEN_KEY_DEPLOY_1_Y current_position[Y_AXIS]
// 2199       #endif
// 2200       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_Z
// 2201         #define Z_PROBE_ALLEN_KEY_DEPLOY_1_Z current_position[Z_AXIS]
// 2202       #endif
// 2203       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE
// 2204         #define Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE 0.0
// 2205       #endif
// 2206       const float deploy_1[] = { Z_PROBE_ALLEN_KEY_DEPLOY_1_X, Z_PROBE_ALLEN_KEY_DEPLOY_1_Y, Z_PROBE_ALLEN_KEY_DEPLOY_1_Z };
// 2207       do_blocking_move_to(deploy_1, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE));
// 2208     #endif
// 2209     #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_Z)
// 2210       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_X
// 2211         #define Z_PROBE_ALLEN_KEY_DEPLOY_2_X current_position[X_AXIS]
// 2212       #endif
// 2213       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_Y
// 2214         #define Z_PROBE_ALLEN_KEY_DEPLOY_2_Y current_position[Y_AXIS]
// 2215       #endif
// 2216       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_Z
// 2217         #define Z_PROBE_ALLEN_KEY_DEPLOY_2_Z current_position[Z_AXIS]
// 2218       #endif
// 2219       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE
// 2220         #define Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE 0.0
// 2221       #endif
// 2222       const float deploy_2[] = { Z_PROBE_ALLEN_KEY_DEPLOY_2_X, Z_PROBE_ALLEN_KEY_DEPLOY_2_Y, Z_PROBE_ALLEN_KEY_DEPLOY_2_Z };
// 2223       do_blocking_move_to(deploy_2, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE));
// 2224     #endif
// 2225     #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_Z)
// 2226       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_X
// 2227         #define Z_PROBE_ALLEN_KEY_DEPLOY_3_X current_position[X_AXIS]
// 2228       #endif
// 2229       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_Y
// 2230         #define Z_PROBE_ALLEN_KEY_DEPLOY_3_Y current_position[Y_AXIS]
// 2231       #endif
// 2232       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_Z
// 2233         #define Z_PROBE_ALLEN_KEY_DEPLOY_3_Z current_position[Z_AXIS]
// 2234       #endif
// 2235       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE
// 2236         #define Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE 0.0
// 2237       #endif
// 2238       const float deploy_3[] = { Z_PROBE_ALLEN_KEY_DEPLOY_3_X, Z_PROBE_ALLEN_KEY_DEPLOY_3_Y, Z_PROBE_ALLEN_KEY_DEPLOY_3_Z };
// 2239       do_blocking_move_to(deploy_3, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE));
// 2240     #endif
// 2241     #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_Z)
// 2242       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_X
// 2243         #define Z_PROBE_ALLEN_KEY_DEPLOY_4_X current_position[X_AXIS]
// 2244       #endif
// 2245       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_Y
// 2246         #define Z_PROBE_ALLEN_KEY_DEPLOY_4_Y current_position[Y_AXIS]
// 2247       #endif
// 2248       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_Z
// 2249         #define Z_PROBE_ALLEN_KEY_DEPLOY_4_Z current_position[Z_AXIS]
// 2250       #endif
// 2251       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE
// 2252         #define Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE 0.0
// 2253       #endif
// 2254       const float deploy_4[] = { Z_PROBE_ALLEN_KEY_DEPLOY_4_X, Z_PROBE_ALLEN_KEY_DEPLOY_4_Y, Z_PROBE_ALLEN_KEY_DEPLOY_4_Z };
// 2255       do_blocking_move_to(deploy_4, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE));
// 2256     #endif
// 2257     #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_Z)
// 2258       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_X
// 2259         #define Z_PROBE_ALLEN_KEY_DEPLOY_5_X current_position[X_AXIS]
// 2260       #endif
// 2261       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_Y
// 2262         #define Z_PROBE_ALLEN_KEY_DEPLOY_5_Y current_position[Y_AXIS]
// 2263       #endif
// 2264       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_Z
// 2265         #define Z_PROBE_ALLEN_KEY_DEPLOY_5_Z current_position[Z_AXIS]
// 2266       #endif
// 2267       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE
// 2268         #define Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE 0.0
// 2269       #endif
// 2270       const float deploy_5[] = { Z_PROBE_ALLEN_KEY_DEPLOY_5_X, Z_PROBE_ALLEN_KEY_DEPLOY_5_Y, Z_PROBE_ALLEN_KEY_DEPLOY_5_Z };
// 2271       do_blocking_move_to(deploy_5, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE));
// 2272     #endif
// 2273   }
// 2274 
// 2275   void run_stow_moves_script() {
// 2276     #if defined(Z_PROBE_ALLEN_KEY_STOW_1_X) || defined(Z_PROBE_ALLEN_KEY_STOW_1_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_1_Z)
// 2277       #ifndef Z_PROBE_ALLEN_KEY_STOW_1_X
// 2278         #define Z_PROBE_ALLEN_KEY_STOW_1_X current_position[X_AXIS]
// 2279       #endif
// 2280       #ifndef Z_PROBE_ALLEN_KEY_STOW_1_Y
// 2281         #define Z_PROBE_ALLEN_KEY_STOW_1_Y current_position[Y_AXIS]
// 2282       #endif
// 2283       #ifndef Z_PROBE_ALLEN_KEY_STOW_1_Z
// 2284         #define Z_PROBE_ALLEN_KEY_STOW_1_Z current_position[Z_AXIS]
// 2285       #endif
// 2286       #ifndef Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE
// 2287         #define Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE 0.0
// 2288       #endif
// 2289       const float stow_1[] = { Z_PROBE_ALLEN_KEY_STOW_1_X, Z_PROBE_ALLEN_KEY_STOW_1_Y, Z_PROBE_ALLEN_KEY_STOW_1_Z };
// 2290       do_blocking_move_to(stow_1, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE));
// 2291     #endif
// 2292     #if defined(Z_PROBE_ALLEN_KEY_STOW_2_X) || defined(Z_PROBE_ALLEN_KEY_STOW_2_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_2_Z)
// 2293       #ifndef Z_PROBE_ALLEN_KEY_STOW_2_X
// 2294         #define Z_PROBE_ALLEN_KEY_STOW_2_X current_position[X_AXIS]
// 2295       #endif
// 2296       #ifndef Z_PROBE_ALLEN_KEY_STOW_2_Y
// 2297         #define Z_PROBE_ALLEN_KEY_STOW_2_Y current_position[Y_AXIS]
// 2298       #endif
// 2299       #ifndef Z_PROBE_ALLEN_KEY_STOW_2_Z
// 2300         #define Z_PROBE_ALLEN_KEY_STOW_2_Z current_position[Z_AXIS]
// 2301       #endif
// 2302       #ifndef Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE
// 2303         #define Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE 0.0
// 2304       #endif
// 2305       const float stow_2[] = { Z_PROBE_ALLEN_KEY_STOW_2_X, Z_PROBE_ALLEN_KEY_STOW_2_Y, Z_PROBE_ALLEN_KEY_STOW_2_Z };
// 2306       do_blocking_move_to(stow_2, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE));
// 2307     #endif
// 2308     #if defined(Z_PROBE_ALLEN_KEY_STOW_3_X) || defined(Z_PROBE_ALLEN_KEY_STOW_3_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_3_Z)
// 2309       #ifndef Z_PROBE_ALLEN_KEY_STOW_3_X
// 2310         #define Z_PROBE_ALLEN_KEY_STOW_3_X current_position[X_AXIS]
// 2311       #endif
// 2312       #ifndef Z_PROBE_ALLEN_KEY_STOW_3_Y
// 2313         #define Z_PROBE_ALLEN_KEY_STOW_3_Y current_position[Y_AXIS]
// 2314       #endif
// 2315       #ifndef Z_PROBE_ALLEN_KEY_STOW_3_Z
// 2316         #define Z_PROBE_ALLEN_KEY_STOW_3_Z current_position[Z_AXIS]
// 2317       #endif
// 2318       #ifndef Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE
// 2319         #define Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE 0.0
// 2320       #endif
// 2321       const float stow_3[] = { Z_PROBE_ALLEN_KEY_STOW_3_X, Z_PROBE_ALLEN_KEY_STOW_3_Y, Z_PROBE_ALLEN_KEY_STOW_3_Z };
// 2322       do_blocking_move_to(stow_3, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE));
// 2323     #endif
// 2324     #if defined(Z_PROBE_ALLEN_KEY_STOW_4_X) || defined(Z_PROBE_ALLEN_KEY_STOW_4_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_4_Z)
// 2325       #ifndef Z_PROBE_ALLEN_KEY_STOW_4_X
// 2326         #define Z_PROBE_ALLEN_KEY_STOW_4_X current_position[X_AXIS]
// 2327       #endif
// 2328       #ifndef Z_PROBE_ALLEN_KEY_STOW_4_Y
// 2329         #define Z_PROBE_ALLEN_KEY_STOW_4_Y current_position[Y_AXIS]
// 2330       #endif
// 2331       #ifndef Z_PROBE_ALLEN_KEY_STOW_4_Z
// 2332         #define Z_PROBE_ALLEN_KEY_STOW_4_Z current_position[Z_AXIS]
// 2333       #endif
// 2334       #ifndef Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE
// 2335         #define Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE 0.0
// 2336       #endif
// 2337       const float stow_4[] = { Z_PROBE_ALLEN_KEY_STOW_4_X, Z_PROBE_ALLEN_KEY_STOW_4_Y, Z_PROBE_ALLEN_KEY_STOW_4_Z };
// 2338       do_blocking_move_to(stow_4, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE));
// 2339     #endif
// 2340     #if defined(Z_PROBE_ALLEN_KEY_STOW_5_X) || defined(Z_PROBE_ALLEN_KEY_STOW_5_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_5_Z)
// 2341       #ifndef Z_PROBE_ALLEN_KEY_STOW_5_X
// 2342         #define Z_PROBE_ALLEN_KEY_STOW_5_X current_position[X_AXIS]
// 2343       #endif
// 2344       #ifndef Z_PROBE_ALLEN_KEY_STOW_5_Y
// 2345         #define Z_PROBE_ALLEN_KEY_STOW_5_Y current_position[Y_AXIS]
// 2346       #endif
// 2347       #ifndef Z_PROBE_ALLEN_KEY_STOW_5_Z
// 2348         #define Z_PROBE_ALLEN_KEY_STOW_5_Z current_position[Z_AXIS]
// 2349       #endif
// 2350       #ifndef Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE
// 2351         #define Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE 0.0
// 2352       #endif
// 2353       const float stow_5[] = { Z_PROBE_ALLEN_KEY_STOW_5_X, Z_PROBE_ALLEN_KEY_STOW_5_Y, Z_PROBE_ALLEN_KEY_STOW_5_Z };
// 2354       do_blocking_move_to(stow_5, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE));
// 2355     #endif
// 2356   }
// 2357 
// 2358 #endif // Z_PROBE_ALLEN_KEY
// 2359 
// 2360 #if ENABLED(PROBING_FANS_OFF)
// 2361 
// 2362   void fans_pause(const bool p) {
// 2363     if (p != fans_paused) {
// 2364       fans_paused = p;
// 2365       if (p)
// 2366         for (uint8_t x = 0; x < FAN_COUNT; x++) {
// 2367           paused_fanSpeeds[x] = fanSpeeds[x];
// 2368           fanSpeeds[x] = 0;
// 2369         }
// 2370       else
// 2371         for (uint8_t x = 0; x < FAN_COUNT; x++)
// 2372           fanSpeeds[x] = paused_fanSpeeds[x];
// 2373     }
// 2374   }
// 2375 
// 2376 #endif // PROBING_FANS_OFF
// 2377 
// 2378 #if HAS_BED_PROBE
// 2379 
// 2380   // TRIGGERED_WHEN_STOWED_TEST can easily be extended to servo probes, ... if needed.
// 2381   #if ENABLED(PROBE_IS_TRIGGERED_WHEN_STOWED_TEST)
// 2382     #if ENABLED(Z_MIN_PROBE_ENDSTOP)
// 2383       #define _TRIGGERED_WHEN_STOWED_TEST (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)
// 2384     #else
// 2385       #define _TRIGGERED_WHEN_STOWED_TEST (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)
// 2386     #endif
// 2387   #endif
// 2388 
// 2389   #if QUIET_PROBING
// 2390     void probing_pause(const bool p) {
// 2391       #if ENABLED(PROBING_HEATERS_OFF)
// 2392         thermalManager.pause(p);
// 2393       #endif
// 2394       #if ENABLED(PROBING_FANS_OFF)
// 2395         fans_pause(p);
// 2396       #endif
// 2397       if (p) safe_delay(
// 2398         #if DELAY_BEFORE_PROBING > 25
// 2399           DELAY_BEFORE_PROBING
// 2400         #else
// 2401           25
// 2402         #endif
// 2403       );
// 2404     }
// 2405   #endif // QUIET_PROBING
// 2406 
// 2407   #if ENABLED(BLTOUCH)
// 2408 
// 2409     void bltouch_command(int angle) {
// 2410       MOVE_SERVO(Z_ENDSTOP_SERVO_NR, angle);  // Give the BL-Touch the command and wait
// 2411       safe_delay(BLTOUCH_DELAY);
// 2412     }
// 2413 
// 2414     bool set_bltouch_deployed(const bool deploy) {
// 2415       if (deploy && TEST_BLTOUCH()) {      // If BL-Touch says it's triggered
// 2416         bltouch_command(BLTOUCH_RESET);    //  try to reset it.
// 2417         bltouch_command(BLTOUCH_DEPLOY);   // Also needs to deploy and stow to
// 2418         bltouch_command(BLTOUCH_STOW);     //  clear the triggered condition.
// 2419         safe_delay(1500);                  // Wait for internal self-test to complete.
// 2420                                            //  (Measured completion time was 0.65 seconds
// 2421                                            //   after reset, deploy, and stow sequence)
// 2422         if (TEST_BLTOUCH()) {              // If it still claims to be triggered...
// 2423           SERIAL_ERROR_START();
// 2424           SERIAL_ERRORLNPGM(MSG_STOP_BLTOUCH);
// 2425           stop();                          // punt!
// 2426           return true;
// 2427         }
// 2428       }
// 2429 
// 2430       bltouch_command(deploy ? BLTOUCH_DEPLOY : BLTOUCH_STOW);
// 2431 
// 2432       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2433         if (DEBUGGING(LEVELING)) {
// 2434           SERIAL_ECHOPAIR("set_bltouch_deployed(", deploy);
// 2435           SERIAL_CHAR(')');
// 2436           SERIAL_EOL();
// 2437         }
// 2438       #endif
// 2439 
// 2440       return false;
// 2441     }
// 2442 
// 2443   #endif // BLTOUCH
// 2444 
// 2445   // returns false for ok and true for failure
// 2446   bool set_probe_deployed(bool deploy) {
// 2447 
// 2448     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2449       if (DEBUGGING(LEVELING)) {
// 2450         DEBUG_POS("set_probe_deployed", current_position);
// 2451         SERIAL_ECHOLNPAIR("deploy: ", deploy);
// 2452       }
// 2453     #endif
// 2454 
// 2455     if (endstops.z_probe_enabled == deploy) return false;
// 2456 
// 2457     // Make room for probe
// 2458     //do_probe_raise(_Z_CLEARANCE_DEPLOY_PROBE);
// 2459     do_probe_raise(Z_CLEARANCE_DEPLOY_PROBE>Z_CLEARANCE_BETWEEN_PROBES ? Z_CLEARANCE_DEPLOY_PROBE : Z_CLEARANCE_BETWEEN_PROBES);
// 2460 
// 2461     #if ENABLED(Z_PROBE_SLED) || ENABLED(Z_PROBE_ALLEN_KEY)
// 2462       #if ENABLED(Z_PROBE_SLED)
// 2463         #define _AUE_ARGS true, false, false
// 2464       #else
// 2465         #define _AUE_ARGS
// 2466       #endif
// 2467       if (axis_unhomed_error(_AUE_ARGS)) {
// 2468         SERIAL_ERROR_START();
// 2469         SERIAL_ERRORLNPGM(MSG_STOP_UNHOMED);
// 2470         stop();
// 2471         return true;
// 2472       }
// 2473     #endif
// 2474 
// 2475     const float oldXpos = current_position[X_AXIS],
// 2476                 oldYpos = current_position[Y_AXIS];
// 2477 
// 2478     #ifdef _TRIGGERED_WHEN_STOWED_TEST
// 2479 
// 2480       // If endstop is already false, the Z probe is deployed
// 2481       if (_TRIGGERED_WHEN_STOWED_TEST == deploy) {     // closed after the probe specific actions.
// 2482                                                        // Would a goto be less ugly?
// 2483         //while (!_TRIGGERED_WHEN_STOWED_TEST) idle(); // would offer the opportunity
// 2484                                                        // for a triggered when stowed manual probe.
// 2485 
// 2486         if (!deploy) endstops.enable_z_probe(false); // Switch off triggered when stowed probes early
// 2487                                                      // otherwise an Allen-Key probe can't be stowed.
// 2488     #endif
// 2489 
// 2490         #if ENABLED(SOLENOID_PROBE)
// 2491 
// 2492           #if HAS_SOLENOID_1
// 2493             WRITE(SOL1_PIN, deploy);
// 2494           #endif
// 2495 
// 2496         #elif ENABLED(Z_PROBE_SLED)
// 2497 
// 2498           dock_sled(!deploy);
// 2499 
// 2500         #elif HAS_Z_SERVO_ENDSTOP && DISABLED(BLTOUCH)
// 2501 
// 2502           MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[deploy ? 0 : 1]);
// 2503 
// 2504         #elif ENABLED(Z_PROBE_ALLEN_KEY)
// 2505 
// 2506           deploy ? run_deploy_moves_script() : run_stow_moves_script();
// 2507 
// 2508         #endif
// 2509 
// 2510     #ifdef _TRIGGERED_WHEN_STOWED_TEST
// 2511       } // _TRIGGERED_WHEN_STOWED_TEST == deploy
// 2512 
// 2513       if (_TRIGGERED_WHEN_STOWED_TEST == deploy) { // State hasn't changed?
// 2514 
// 2515         if (IsRunning()) {
// 2516           SERIAL_ERROR_START();
// 2517           SERIAL_ERRORLNPGM("Z-Probe failed");
// 2518           LCD_ALERTMESSAGEPGM("Err: ZPROBE");
// 2519         }
// 2520         stop();
// 2521         return true;
// 2522 
// 2523       } // _TRIGGERED_WHEN_STOWED_TEST == deploy
// 2524 
// 2525     #endif
// 2526 
// 2527     do_blocking_move_to(oldXpos, oldYpos, current_position[Z_AXIS]); // return to position before deploy
// 2528     endstops.enable_z_probe(deploy);
// 2529     return false;
// 2530   }
// 2531 
// 2532   /**
// 2533    * @brief Used by run_z_probe to do a single Z probe move.
// 2534    *
// 2535    * @param  z        Z destination
// 2536    * @param  fr_mm_s  Feedrate in mm/s
// 2537    * @return true to indicate an error
// 2538    */
// 2539   static bool do_probe_move(const float z, const float fr_mm_m) {
// 2540     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2541       if (DEBUGGING(LEVELING)) DEBUG_POS(">>> do_probe_move", current_position);
// 2542     #endif
// 2543 
// 2544     // Deploy BLTouch at the start of any probe
// 2545     #if ENABLED(BLTOUCH)
// 2546       if (set_bltouch_deployed(true)) return true;
// 2547     #endif
// 2548 
// 2549     #if QUIET_PROBING
// 2550       probing_pause(true);
// 2551     #endif
// 2552 
// 2553     // Move down until probe triggered
// 2554     do_blocking_move_to_z(z, MMM_TO_MMS(fr_mm_m));
// 2555 
// 2556     // Check to see if the probe was triggered
// 2557     const bool probe_triggered = TEST(Endstops::endstop_hit_bits,
// 2558       #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
// 2559         Z_MIN
// 2560       #else
// 2561         Z_MIN_PROBE
// 2562       #endif
// 2563     );
// 2564 
// 2565     #if QUIET_PROBING
// 2566       probing_pause(false);
// 2567     #endif
// 2568 
// 2569     // Retract BLTouch immediately after a probe if it was triggered
// 2570     #if ENABLED(BLTOUCH)
// 2571       if (probe_triggered && set_bltouch_deployed(false)) return true;
// 2572     #endif
// 2573 
// 2574     // Clear endstop flags
// 2575     endstops.hit_on_purpose();
// 2576 
// 2577     // Get Z where the steppers were interrupted
// 2578     set_current_from_steppers_for_axis(Z_AXIS);
// 2579 
// 2580     // Tell the planner where we actually are
// 2581     SYNC_PLAN_POSITION_KINEMATIC();
// 2582 
// 2583     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2584       if (DEBUGGING(LEVELING)) DEBUG_POS("<<< do_probe_move", current_position);
// 2585     #endif
// 2586 
// 2587     return !probe_triggered;
// 2588   }
// 2589 
// 2590   /**
// 2591    * @details Used by probe_pt to do a single Z probe at the current position.
// 2592    *          Leaves current_position[Z_AXIS] at the height where the probe triggered.
// 2593    *
// 2594    * @return The raw Z position where the probe was triggered
// 2595    */
// 2596   static float run_z_probe() {
// 2597 
// 2598     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2599       if (DEBUGGING(LEVELING)) DEBUG_POS(">>> run_z_probe", current_position);
// 2600     #endif
// 2601 
// 2602     // Prevent stepper_inactive_time from running out and EXTRUDER_RUNOUT_PREVENT from extruding
// 2603     refresh_cmd_timeout();
// 2604 
// 2605     // Double-probing does a fast probe followed by a slow probe
// 2606     #if MULTIPLE_PROBING == 2
// 2607 
// 2608       // Do a first probe at the fast speed
// 2609       if (do_probe_move(-10, Z_PROBE_SPEED_FAST)) return NAN;
// 2610 
// 2611       float first_probe_z = current_position[Z_AXIS];
// 2612 
// 2613       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2614         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("1st Probe Z:", first_probe_z);
// 2615       #endif
// 2616 
// 2617       // move up to make clearance for the probe
// 2618       do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
// 2619 
// 2620     #else
// 2621 
// 2622       // If the nozzle is above the travel height then
// 2623       // move down quickly before doing the slow probe
// 2624       float z = Z_CLEARANCE_DEPLOY_PROBE;
// 2625       if (zprobe_zoffset < 0) z -= zprobe_zoffset;
// 2626 
// 2627       if (z < current_position[Z_AXIS]) {
// 2628 
// 2629         // If we don't make it to the z position (i.e. the probe triggered), move up to make clearance for the probe
// 2630         if (!do_probe_move(z, Z_PROBE_SPEED_FAST))
// 2631           do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
// 2632       }
// 2633     #endif
// 2634 
// 2635     #if MULTIPLE_PROBING > 2
// 2636       float probes_total = 0;
// 2637       for (uint8_t p = MULTIPLE_PROBING + 1; --p;) {
// 2638     #endif
// 2639 
// 2640         // move down slowly to find bed
// 2641         if (do_probe_move(-10, Z_PROBE_SPEED_SLOW)) return NAN;
// 2642 
// 2643     #if MULTIPLE_PROBING > 2
// 2644         probes_total += current_position[Z_AXIS];
// 2645         if (p > 1) do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
// 2646       }
// 2647     #endif
// 2648 
// 2649     #if MULTIPLE_PROBING > 2
// 2650 
// 2651       // Return the average value of all probes
// 2652       return probes_total * (1.0 / (MULTIPLE_PROBING));
// 2653 
// 2654     #elif MULTIPLE_PROBING == 2
// 2655 
// 2656       const float z2 = current_position[Z_AXIS];
// 2657 
// 2658       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2659         if (DEBUGGING(LEVELING)) {
// 2660           SERIAL_ECHOPAIR("2nd Probe Z:", z2);
// 2661           SERIAL_ECHOLNPAIR(" Discrepancy:", first_probe_z - z2);
// 2662         }
// 2663       #endif
// 2664 
// 2665       // Return a weighted average of the fast and slow probes
// 2666       return (z2 * 3.0 + first_probe_z * 2.0) * 0.2;
// 2667 
// 2668     #else
// 2669 
// 2670       // Return the single probe result
// 2671       return current_position[Z_AXIS];
// 2672 
// 2673     #endif
// 2674 
// 2675     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2676       if (DEBUGGING(LEVELING)) DEBUG_POS("<<< run_z_probe", current_position);
// 2677     #endif
// 2678   }
// 2679 
// 2680   /**
// 2681    * - Move to the given XY
// 2682    * - Deploy the probe, if not already deployed
// 2683    * - Probe the bed, get the Z position
// 2684    * - Depending on the 'stow' flag
// 2685    *   - Stow the probe, or
// 2686    *   - Raise to the BETWEEN height
// 2687    * - Return the probed Z position
// 2688    */
// 2689   float probe_pt(const float &rx, const float &ry, const bool stow, const uint8_t verbose_level, const bool probe_relative=true) {
// 2690     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2691       if (DEBUGGING(LEVELING)) {
// 2692         SERIAL_ECHOPAIR(">>> probe_pt(", LOGICAL_X_POSITION(rx));
// 2693         SERIAL_ECHOPAIR(", ", LOGICAL_Y_POSITION(ry));
// 2694         SERIAL_ECHOPAIR(", ", stow ? "" : "no ");
// 2695         SERIAL_ECHOLNPGM("stow)");
// 2696         DEBUG_POS("", current_position);
// 2697       }
// 2698     #endif
// 2699 
// 2700     // TODO: Adapt for SCARA, where the offset rotates
// 2701     float nx = rx, ny = ry;
// 2702     if (probe_relative) {
// 2703       if (!position_is_reachable_by_probe(rx, ry)) return NAN;  // The given position is in terms of the probe
// 2704       nx -= (X_PROBE_OFFSET_FROM_EXTRUDER);                     // Get the nozzle position
// 2705       ny -= (Y_PROBE_OFFSET_FROM_EXTRUDER);
// 2706     }
// 2707     else if (!position_is_reachable(nx, ny)) return NAN;        // The given position is in terms of the nozzle
// 2708 
// 2709     const float nz =
// 2710       #if ENABLED(DELTA)
// 2711         // Move below clip height or xy move will be aborted by do_blocking_move_to
// 2712         min(current_position[Z_AXIS], delta_clip_start_height)
// 2713       #else
// 2714         current_position[Z_AXIS]
// 2715       #endif
// 2716     ;
// 2717 
// 2718     const float old_feedrate_mm_s = feedrate_mm_s;
// 2719     feedrate_mm_s = XY_PROBE_FEEDRATE_MM_S;
// 2720 
// 2721     // Move the probe to the starting XYZ
// 2722     do_blocking_move_to(nx, ny, nz);
// 2723 
// 2724     float measured_z = NAN;
// 2725     if (!DEPLOY_PROBE()) {
// 2726       measured_z = run_z_probe() + zprobe_zoffset;
// 2727 
// 2728       if (!stow)
// 2729         do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
// 2730       else
// 2731         if (STOW_PROBE()) measured_z = NAN;
// 2732     }
// 2733 
// 2734     if (verbose_level > 2) {
// 2735       SERIAL_PROTOCOLPGM("Bed X: ");
// 2736       SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(rx), 3);
// 2737       SERIAL_PROTOCOLPGM(" Y: ");
// 2738       SERIAL_PROTOCOL_F(LOGICAL_Y_POSITION(ry), 3);
// 2739       SERIAL_PROTOCOLPGM(" Z: ");
// 2740       SERIAL_PROTOCOL_F(measured_z, 3);
// 2741       SERIAL_EOL();
// 2742     }
// 2743 
// 2744     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2745       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< probe_pt");
// 2746     #endif
// 2747 
// 2748     feedrate_mm_s = old_feedrate_mm_s;
// 2749 
// 2750     if (isnan(measured_z)) {
// 2751       LCD_MESSAGEPGM(MSG_ERR_PROBING_FAILED);
// 2752       SERIAL_ERROR_START();
// 2753       SERIAL_ERRORLNPGM(MSG_ERR_PROBING_FAILED);
// 2754     }
// 2755 
// 2756     return measured_z;
// 2757   }
// 2758 
// 2759 #endif // HAS_BED_PROBE
// 2760 
// 2761 #if HAS_LEVELING
// 2762 
// 2763   bool leveling_is_valid() {
// 2764     return
// 2765       #if ENABLED(MESH_BED_LEVELING)
// 2766         mbl.has_mesh
// 2767       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 2768         !!bilinear_grid_spacing[X_AXIS]
// 2769       #elif ENABLED(AUTO_BED_LEVELING_UBL)
// 2770         true
// 2771       #else // 3POINT, LINEAR
// 2772         true
// 2773       #endif
// 2774     ;
// 2775   }
// 2776 
// 2777   /**
// 2778    * Turn bed leveling on or off, fixing the current
// 2779    * position as-needed.
// 2780    *
// 2781    * Disable: Current position = physical position
// 2782    *  Enable: Current position = "unleveled" physical position
// 2783    */
// 2784   void set_bed_leveling_enabled(const bool enable/*=true*/) {
// 2785 
// 2786     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 2787       const bool can_change = (!enable || leveling_is_valid());
// 2788     #else
// 2789       constexpr bool can_change = true;
// 2790     #endif
// 2791 
// 2792     if (can_change && enable != planner.leveling_active) {
// 2793 
// 2794       #if ENABLED(MESH_BED_LEVELING)
// 2795 
// 2796         if (!enable)
// 2797           planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS]);
// 2798 
// 2799         const bool enabling = enable && leveling_is_valid();
// 2800         planner.leveling_active = enabling;
// 2801         if (enabling) planner.unapply_leveling(current_position);
// 2802 
// 2803       #elif ENABLED(AUTO_BED_LEVELING_UBL)
// 2804         #if PLANNER_LEVELING
// 2805           if (planner.leveling_active) {                       // leveling from on to off
// 2806             // change unleveled current_position to physical current_position without moving steppers.
// 2807             planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS]);
// 2808             planner.leveling_active = false;                   // disable only AFTER calling apply_leveling
// 2809           }
// 2810           else {                                        // leveling from off to on
// 2811             planner.leveling_active = true;                    // enable BEFORE calling unapply_leveling, otherwise ignored
// 2812             // change physical current_position to unleveled current_position without moving steppers.
// 2813             planner.unapply_leveling(current_position);
// 2814           }
// 2815         #else
// 2816           planner.leveling_active = enable;                    // just flip the bit, current_position will be wrong until next move.
// 2817         #endif
// 2818 
// 2819       #else // ABL
// 2820 
// 2821         #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 2822           // Force bilinear_z_offset to re-calculate next time
// 2823           const float reset[XYZ] = { -9999.999, -9999.999, 0 };
// 2824           (void)bilinear_z_offset(reset);
// 2825         #endif
// 2826 
// 2827         // Enable or disable leveling compensation in the planner
// 2828         planner.leveling_active = enable;
// 2829 
// 2830         if (!enable)
// 2831           // When disabling just get the current position from the steppers.
// 2832           // This will yield the smallest error when first converted back to steps.
// 2833           set_current_from_steppers_for_axis(
// 2834             #if ABL_PLANAR
// 2835               ALL_AXES
// 2836             #else
// 2837               Z_AXIS
// 2838             #endif
// 2839           );
// 2840         else
// 2841           // When enabling, remove compensation from the current position,
// 2842           // so compensation will give the right stepper counts.
// 2843           planner.unapply_leveling(current_position);
// 2844 
// 2845         SYNC_PLAN_POSITION_KINEMATIC();
// 2846 
// 2847       #endif // ABL
// 2848     }
// 2849   }
// 2850 
// 2851   #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
// 2852 
// 2853     void set_z_fade_height(const float zfh, const bool do_report/*=true*/) {
// 2854 
// 2855       if (planner.z_fade_height == zfh) return; // do nothing if no change
// 2856 
// 2857       const bool level_active = planner.leveling_active;
// 2858 
// 2859       #if ENABLED(AUTO_BED_LEVELING_UBL)
// 2860         if (level_active) set_bed_leveling_enabled(false);  // turn off before changing fade height for proper apply/unapply leveling to maintain current_position
// 2861       #endif
// 2862 
// 2863       planner.set_z_fade_height(zfh);
// 2864 
// 2865       if (level_active) {
// 2866         const float oldpos[] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] };
// 2867         #if ENABLED(AUTO_BED_LEVELING_UBL)
// 2868           set_bed_leveling_enabled(true);  // turn back on after changing fade height
// 2869         #else
// 2870           set_current_from_steppers_for_axis(
// 2871             #if ABL_PLANAR
// 2872               ALL_AXES
// 2873             #else
// 2874               Z_AXIS
// 2875             #endif
// 2876           );
// 2877           SYNC_PLAN_POSITION_KINEMATIC();
// 2878         #endif
// 2879         if (do_report && memcmp(oldpos, current_position, sizeof(oldpos)))
// 2880           report_current_position();
// 2881       }
// 2882     }
// 2883 
// 2884   #endif // LEVELING_FADE_HEIGHT
// 2885 
// 2886   /**
// 2887    * Reset calibration results to zero.
// 2888    */
// 2889   void reset_bed_level() {
// 2890     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2891       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("reset_bed_level");
// 2892     #endif
// 2893     set_bed_leveling_enabled(false);
// 2894     #if ENABLED(MESH_BED_LEVELING)
// 2895       if (leveling_is_valid()) {
// 2896         mbl.reset();
// 2897         mbl.has_mesh = false;
// 2898       }
// 2899     #elif ENABLED(AUTO_BED_LEVELING_UBL)
// 2900       ubl.reset();
// 2901     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 2902       bilinear_start[X_AXIS] = bilinear_start[Y_AXIS] =
// 2903       bilinear_grid_spacing[X_AXIS] = bilinear_grid_spacing[Y_AXIS] = 0;
// 2904       for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
// 2905         for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
// 2906           z_values[x][y] = NAN;
// 2907     #elif ABL_PLANAR
// 2908       planner.bed_level_matrix.set_to_identity();
// 2909     #endif
// 2910   }
// 2911 
// 2912 #endif // HAS_LEVELING
// 2913 
// 2914 #if ENABLED(AUTO_BED_LEVELING_BILINEAR) || ENABLED(MESH_BED_LEVELING)
// 2915 
// 2916   /**
// 2917    * Enable to produce output in JSON format suitable
// 2918    * for SCAD or JavaScript mesh visualizers.
// 2919    *
// 2920    * Visualize meshes in OpenSCAD using the included script.
// 2921    *
// 2922    *   buildroot/shared/scripts/MarlinMesh.scad
// 2923    */
// 2924   //#define SCAD_MESH_OUTPUT
// 2925 
// 2926   /**
// 2927    * Print calibration results for plotting or manual frame adjustment.
// 2928    */
// 2929   static void print_2d_array(const uint8_t sx, const uint8_t sy, const uint8_t precision, float (*fn)(const uint8_t, const uint8_t)) {
// 2930     #ifndef SCAD_MESH_OUTPUT
// 2931       for (uint8_t x = 0; x < sx; x++) {
// 2932         for (uint8_t i = 0; i < precision + 2 + (x < 10 ? 1 : 0); i++)
// 2933           SERIAL_PROTOCOLCHAR(' ');
// 2934         SERIAL_PROTOCOL((int)x);
// 2935       }
// 2936       SERIAL_EOL();
// 2937     #endif
// 2938     #ifdef SCAD_MESH_OUTPUT
// 2939       SERIAL_PROTOCOLLNPGM("measured_z = ["); // open 2D array
// 2940     #endif
// 2941     for (uint8_t y = 0; y < sy; y++) {
// 2942       #ifdef SCAD_MESH_OUTPUT
// 2943         SERIAL_PROTOCOLPGM(" [");           // open sub-array
// 2944       #else
// 2945         if (y < 10) SERIAL_PROTOCOLCHAR(' ');
// 2946         SERIAL_PROTOCOL((int)y);
// 2947       #endif
// 2948       for (uint8_t x = 0; x < sx; x++) {
// 2949         SERIAL_PROTOCOLCHAR(' ');
// 2950         const float offset = fn(x, y);
// 2951         if (!isnan(offset)) {
// 2952           if (offset >= 0) SERIAL_PROTOCOLCHAR('+');
// 2953           SERIAL_PROTOCOL_F(offset, precision);
// 2954         }
// 2955         else {
// 2956           #ifdef SCAD_MESH_OUTPUT
// 2957             for (uint8_t i = 3; i < precision + 3; i++)
// 2958               SERIAL_PROTOCOLCHAR(' ');
// 2959             SERIAL_PROTOCOLPGM("NAN");
// 2960           #else
// 2961             for (uint8_t i = 0; i < precision + 3; i++)
// 2962               SERIAL_PROTOCOLCHAR(i ? '=' : ' ');
// 2963           #endif
// 2964         }
// 2965         #ifdef SCAD_MESH_OUTPUT
// 2966           if (x < sx - 1) SERIAL_PROTOCOLCHAR(',');
// 2967         #endif
// 2968       }
// 2969       #ifdef SCAD_MESH_OUTPUT
// 2970         SERIAL_PROTOCOLCHAR(' ');
// 2971         SERIAL_PROTOCOLCHAR(']');                     // close sub-array
// 2972         if (y < sy - 1) SERIAL_PROTOCOLCHAR(',');
// 2973       #endif
// 2974       SERIAL_EOL();
// 2975     }
// 2976     #ifdef SCAD_MESH_OUTPUT
// 2977       SERIAL_PROTOCOLPGM("];");                       // close 2D array
// 2978     #endif
// 2979     SERIAL_EOL();
// 2980   }
// 2981 
// 2982 #endif
// 2983 
// 2984 #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 2985 
// 2986   /**
// 2987    * Extrapolate a single point from its neighbors
// 2988    */
// 2989   static void extrapolate_one_point(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir) {
// 2990     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2991       if (DEBUGGING(LEVELING)) {
// 2992         SERIAL_ECHOPGM("Extrapolate [");
// 2993         if (x < 10) SERIAL_CHAR(' ');
// 2994         SERIAL_ECHO((int)x);
// 2995         SERIAL_CHAR(xdir ? (xdir > 0 ? '+' : '-') : ' ');
// 2996         SERIAL_CHAR(' ');
// 2997         if (y < 10) SERIAL_CHAR(' ');
// 2998         SERIAL_ECHO((int)y);
// 2999         SERIAL_CHAR(ydir ? (ydir > 0 ? '+' : '-') : ' ');
// 3000         SERIAL_CHAR(']');
// 3001       }
// 3002     #endif
// 3003     if (!isnan(z_values[x][y])) {
// 3004       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3005         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM(" (done)");
// 3006       #endif
// 3007       return;  // Don't overwrite good values.
// 3008     }
// 3009     SERIAL_EOL();
// 3010 
// 3011     // Get X neighbors, Y neighbors, and XY neighbors
// 3012     const uint8_t x1 = x + xdir, y1 = y + ydir, x2 = x1 + xdir, y2 = y1 + ydir;
// 3013     float a1 = z_values[x1][y ], a2 = z_values[x2][y ],
// 3014           b1 = z_values[x ][y1], b2 = z_values[x ][y2],
// 3015           c1 = z_values[x1][y1], c2 = z_values[x2][y2];
// 3016 
// 3017     // Treat far unprobed points as zero, near as equal to far
// 3018     if (isnan(a2)) a2 = 0.0; if (isnan(a1)) a1 = a2;
// 3019     if (isnan(b2)) b2 = 0.0; if (isnan(b1)) b1 = b2;
// 3020     if (isnan(c2)) c2 = 0.0; if (isnan(c1)) c1 = c2;
// 3021 
// 3022     const float a = 2 * a1 - a2, b = 2 * b1 - b2, c = 2 * c1 - c2;
// 3023 
// 3024     // Take the average instead of the median
// 3025     z_values[x][y] = (a + b + c) / 3.0;
// 3026 
// 3027     // Median is robust (ignores outliers).
// 3028     // z_values[x][y] = (a < b) ? ((b < c) ? b : (c < a) ? a : c)
// 3029     //                                : ((c < b) ? b : (a < c) ? a : c);
// 3030   }
// 3031 
// 3032   //Enable this if your SCARA uses 180° of total area
// 3033   //#define EXTRAPOLATE_FROM_EDGE
// 3034 
// 3035   #if ENABLED(EXTRAPOLATE_FROM_EDGE)
// 3036     #if GRID_MAX_POINTS_X < GRID_MAX_POINTS_Y
// 3037       #define HALF_IN_X
// 3038     #elif GRID_MAX_POINTS_Y < GRID_MAX_POINTS_X
// 3039       #define HALF_IN_Y
// 3040     #endif
// 3041   #endif
// 3042 
// 3043   /**
// 3044    * Fill in the unprobed points (corners of circular print surface)
// 3045    * using linear extrapolation, away from the center.
// 3046    */
// 3047   static void extrapolate_unprobed_bed_level() {
// 3048     #ifdef HALF_IN_X
// 3049       constexpr uint8_t ctrx2 = 0, xlen = GRID_MAX_POINTS_X - 1;
// 3050     #else
// 3051       constexpr uint8_t ctrx1 = (GRID_MAX_POINTS_X - 1) / 2, // left-of-center
// 3052                         ctrx2 = (GRID_MAX_POINTS_X) / 2,     // right-of-center
// 3053                         xlen = ctrx1;
// 3054     #endif
// 3055 
// 3056     #ifdef HALF_IN_Y
// 3057       constexpr uint8_t ctry2 = 0, ylen = GRID_MAX_POINTS_Y - 1;
// 3058     #else
// 3059       constexpr uint8_t ctry1 = (GRID_MAX_POINTS_Y - 1) / 2, // top-of-center
// 3060                         ctry2 = (GRID_MAX_POINTS_Y) / 2,     // bottom-of-center
// 3061                         ylen = ctry1;
// 3062     #endif
// 3063 
// 3064     for (uint8_t xo = 0; xo <= xlen; xo++)
// 3065       for (uint8_t yo = 0; yo <= ylen; yo++) {
// 3066         uint8_t x2 = ctrx2 + xo, y2 = ctry2 + yo;
// 3067         #ifndef HALF_IN_X
// 3068           const uint8_t x1 = ctrx1 - xo;
// 3069         #endif
// 3070         #ifndef HALF_IN_Y
// 3071           const uint8_t y1 = ctry1 - yo;
// 3072           #ifndef HALF_IN_X
// 3073             extrapolate_one_point(x1, y1, +1, +1);   //  left-below + +
// 3074           #endif
// 3075           extrapolate_one_point(x2, y1, -1, +1);     // right-below - +
// 3076         #endif
// 3077         #ifndef HALF_IN_X
// 3078           extrapolate_one_point(x1, y2, +1, -1);     //  left-above + -
// 3079         #endif
// 3080         extrapolate_one_point(x2, y2, -1, -1);       // right-above - -
// 3081       }
// 3082 
// 3083   }
// 3084 
// 3085   static void print_bilinear_leveling_grid() {
// 3086     SERIAL_ECHOLNPGM("Bilinear Leveling Grid:");
// 3087     print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 3,
// 3088       [](const uint8_t ix, const uint8_t iy) { return z_values[ix][iy]; }
// 3089     );
// 3090   }
// 3091 
// 3092   #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 3093 
// 3094     #define ABL_GRID_POINTS_VIRT_X (GRID_MAX_POINTS_X - 1) * (BILINEAR_SUBDIVISIONS) + 1
// 3095     #define ABL_GRID_POINTS_VIRT_Y (GRID_MAX_POINTS_Y - 1) * (BILINEAR_SUBDIVISIONS) + 1
// 3096     #define ABL_TEMP_POINTS_X (GRID_MAX_POINTS_X + 2)
// 3097     #define ABL_TEMP_POINTS_Y (GRID_MAX_POINTS_Y + 2)
// 3098     float z_values_virt[ABL_GRID_POINTS_VIRT_X][ABL_GRID_POINTS_VIRT_Y];
// 3099     int bilinear_grid_spacing_virt[2] = { 0 };
// 3100     float bilinear_grid_factor_virt[2] = { 0 };
// 3101 
// 3102     static void print_bilinear_leveling_grid_virt() {
// 3103       SERIAL_ECHOLNPGM("Subdivided with CATMULL ROM Leveling Grid:");
// 3104       print_2d_array(ABL_GRID_POINTS_VIRT_X, ABL_GRID_POINTS_VIRT_Y, 5,
// 3105         [](const uint8_t ix, const uint8_t iy) { return z_values_virt[ix][iy]; }
// 3106       );
// 3107     }
// 3108 
// 3109     #define LINEAR_EXTRAPOLATION(E, I) ((E) * 2 - (I))
// 3110     float bed_level_virt_coord(const uint8_t x, const uint8_t y) {
// 3111       uint8_t ep = 0, ip = 1;
// 3112       if (!x || x == ABL_TEMP_POINTS_X - 1) {
// 3113         if (x) {
// 3114           ep = GRID_MAX_POINTS_X - 1;
// 3115           ip = GRID_MAX_POINTS_X - 2;
// 3116         }
// 3117         if (WITHIN(y, 1, ABL_TEMP_POINTS_Y - 2))
// 3118           return LINEAR_EXTRAPOLATION(
// 3119             z_values[ep][y - 1],
// 3120             z_values[ip][y - 1]
// 3121           );
// 3122         else
// 3123           return LINEAR_EXTRAPOLATION(
// 3124             bed_level_virt_coord(ep + 1, y),
// 3125             bed_level_virt_coord(ip + 1, y)
// 3126           );
// 3127       }
// 3128       if (!y || y == ABL_TEMP_POINTS_Y - 1) {
// 3129         if (y) {
// 3130           ep = GRID_MAX_POINTS_Y - 1;
// 3131           ip = GRID_MAX_POINTS_Y - 2;
// 3132         }
// 3133         if (WITHIN(x, 1, ABL_TEMP_POINTS_X - 2))
// 3134           return LINEAR_EXTRAPOLATION(
// 3135             z_values[x - 1][ep],
// 3136             z_values[x - 1][ip]
// 3137           );
// 3138         else
// 3139           return LINEAR_EXTRAPOLATION(
// 3140             bed_level_virt_coord(x, ep + 1),
// 3141             bed_level_virt_coord(x, ip + 1)
// 3142           );
// 3143       }
// 3144       return z_values[x - 1][y - 1];
// 3145     }
// 3146 
// 3147     static float bed_level_virt_cmr(const float p[4], const uint8_t i, const float t) {
// 3148       return (
// 3149           p[i-1] * -t * sq(1 - t)
// 3150         + p[i]   * (2 - 5 * sq(t) + 3 * t * sq(t))
// 3151         + p[i+1] * t * (1 + 4 * t - 3 * sq(t))
// 3152         - p[i+2] * sq(t) * (1 - t)
// 3153       ) * 0.5;
// 3154     }
// 3155 
// 3156     static float bed_level_virt_2cmr(const uint8_t x, const uint8_t y, const float &tx, const float &ty) {
// 3157       float row[4], column[4];
// 3158       for (uint8_t i = 0; i < 4; i++) {
// 3159         for (uint8_t j = 0; j < 4; j++) {
// 3160           column[j] = bed_level_virt_coord(i + x - 1, j + y - 1);
// 3161         }
// 3162         row[i] = bed_level_virt_cmr(column, 1, ty);
// 3163       }
// 3164       return bed_level_virt_cmr(row, 1, tx);
// 3165     }
// 3166 
// 3167     void bed_level_virt_interpolate() {
// 3168       bilinear_grid_spacing_virt[X_AXIS] = bilinear_grid_spacing[X_AXIS] / (BILINEAR_SUBDIVISIONS);
// 3169       bilinear_grid_spacing_virt[Y_AXIS] = bilinear_grid_spacing[Y_AXIS] / (BILINEAR_SUBDIVISIONS);
// 3170       bilinear_grid_factor_virt[X_AXIS] = RECIPROCAL(bilinear_grid_spacing_virt[X_AXIS]);
// 3171       bilinear_grid_factor_virt[Y_AXIS] = RECIPROCAL(bilinear_grid_spacing_virt[Y_AXIS]);
// 3172       for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
// 3173         for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
// 3174           for (uint8_t ty = 0; ty < BILINEAR_SUBDIVISIONS; ty++)
// 3175             for (uint8_t tx = 0; tx < BILINEAR_SUBDIVISIONS; tx++) {
// 3176               if ((ty && y == GRID_MAX_POINTS_Y - 1) || (tx && x == GRID_MAX_POINTS_X - 1))
// 3177                 continue;
// 3178               z_values_virt[x * (BILINEAR_SUBDIVISIONS) + tx][y * (BILINEAR_SUBDIVISIONS) + ty] =
// 3179                 bed_level_virt_2cmr(
// 3180                   x + 1,
// 3181                   y + 1,
// 3182                   (float)tx / (BILINEAR_SUBDIVISIONS),
// 3183                   (float)ty / (BILINEAR_SUBDIVISIONS)
// 3184                 );
// 3185             }
// 3186     }
// 3187   #endif // ABL_BILINEAR_SUBDIVISION
// 3188 
// 3189   // Refresh after other values have been updated
// 3190   void refresh_bed_level() {
// 3191     bilinear_grid_factor[X_AXIS] = RECIPROCAL(bilinear_grid_spacing[X_AXIS]);
// 3192     bilinear_grid_factor[Y_AXIS] = RECIPROCAL(bilinear_grid_spacing[Y_AXIS]);
// 3193     #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 3194       bed_level_virt_interpolate();
// 3195     #endif
// 3196   }
// 3197 
// 3198 #endif // AUTO_BED_LEVELING_BILINEAR
// 3199 
// 3200 /**
// 3201  * Home an individual linear axis
// 3202  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock34 Using cfiCommon0
          CFI Function _Z14do_homing_move8AxisEnumff
        THUMB
// 3203 static void do_homing_move(const AxisEnum axis, const float distance, const float fr_mm_s=0.0) {
_Z14do_homing_move8AxisEnumff:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        VPUSH    {D8}
          CFI D8 Frame(CFA, -24)
          CFI CFA R13+24
        SUB      SP,SP,#+8
          CFI CFA R13+32
        VMOV.F32 S16,S0
        VMOV.F32 S17,S1
        LDR.W    R4,??DataTable107
        ADD      R5,R4,R0, LSL #+2
        MOVS     R0,#+0
        STR      R0,[R5, #+36]
// 3204 
// 3205   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3206     if (DEBUGGING(LEVELING)) {
// 3207       SERIAL_ECHOPAIR(">>> do_homing_move(", axis_codes[axis]);
// 3208       SERIAL_ECHOPAIR(", ", distance);
// 3209       SERIAL_ECHOPAIR(", ", fr_mm_s);
// 3210       SERIAL_CHAR(')');
// 3211       SERIAL_EOL();
// 3212     }
// 3213   #endif
// 3214 
// 3215 //  #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
// 3216 #if 0    
// 3217     const bool deploy_bltouch = (axis == Z_AXIS && distance < 0);
// 3218     if (deploy_bltouch) set_bltouch_deployed(true);
// 3219   #endif
// 3220 
// 3221   #if QUIET_PROBING
// 3222     if (axis == Z_AXIS) probing_pause(true);
// 3223   #endif
// 3224 
// 3225   // Tell the planner the axis is at 0
// 3226   current_position[axis] = 0;
// 3227 
// 3228   #if IS_SCARA
// 3229     SYNC_PLAN_POSITION_KINEMATIC();
// 3230     current_position[axis] = distance;
// 3231     inverse_kinematics(current_position);
// 3232     planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate(axis), active_extruder);
// 3233   #else
// 3234     sync_plan_position();
          CFI FunCall _Z18sync_plan_positionv
        BL       _Z18sync_plan_positionv
// 3235     current_position[axis] = distance;
        VSTR     S16,[R5, #+36]
// 3236     //planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate(axis), active_extruder);
// 3237     planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate_mm_s[axis], active_extruder);
        VCMP.F32 S17,#0.0
        FMSTAT   
        BEQ.N    ??do_homing_move_0
        VSTR     S17,[SP, #+0]
        B.N      ??do_homing_move_1
??do_homing_move_0:
        LDR      R0,[R5, #+68]
        STR      R0,[SP, #+0]
??do_homing_move_1:
        LDRB     R2,[R4, #+19]
        ADD      R1,SP,#+0
        ADD      R0,R4,#+48
        VLDR     S2,[R4, #+44]
        VLDR     S1,[R4, #+40]
        VLDR     S0,[R4, #+36]
          CFI FunCall _ZN7Planner11buffer_lineEfffRKfS1_h
        BL       _ZN7Planner11buffer_lineEfffRKfS1_h
// 3238 
// 3239   #endif
// 3240 
// 3241   stepper.synchronize();
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
// 3242 
// 3243   #if QUIET_PROBING
// 3244     if (axis == Z_AXIS) probing_pause(false);
// 3245   #endif
// 3246 
// 3247 //  #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
// 3248 #if 0    
// 3249     if (deploy_bltouch) set_bltouch_deployed(false);
// 3250   #endif
// 3251 
// 3252   endstops.hit_on_purpose();
          CFI FunCall _ZN8Endstops14hit_on_purposeEv
        BL       _ZN8Endstops14hit_on_purposeEv
// 3253 
// 3254   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3255     if (DEBUGGING(LEVELING)) {
// 3256       SERIAL_ECHOPAIR("<<< do_homing_move(", axis_codes[axis]);
// 3257       SERIAL_CHAR(')');
// 3258       SERIAL_EOL();
// 3259     }
// 3260   #endif
// 3261 }
        ADD      SP,SP,#+8
          CFI CFA R13+24
        VPOP     {D8}
          CFI D8 SameValue
          CFI CFA R13+16
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock34
// 3262 
// 3263 /**
// 3264  * TMC2130 specific sensorless homing using stallGuard2.
// 3265  * stallGuard2 only works when in spreadCycle mode.
// 3266  * spreadCycle and stealthChop are mutually exclusive.
// 3267  */
// 3268 #if ENABLED(SENSORLESS_HOMING)
// 3269   template<typename TMC>
// 3270   void tmc_sensorless_homing(TMC &st, bool enable=true) {
// 3271     #if ENABLED(STEALTHCHOP)
// 3272       if (enable) {
// 3273         st.coolstep_min_speed(1024UL * 1024UL - 1UL);
// 3274         st.stealthChop(0);
// 3275       }
// 3276       else {
// 3277         st.coolstep_min_speed(0);
// 3278         st.stealthChop(1);
// 3279       }
// 3280     #endif
// 3281 
// 3282     st.diag1_stall(enable ? 1 : 0);
// 3283   }
// 3284 #endif
// 3285 
// 3286 /**
// 3287  * Home an individual "raw axis" to its endstop.
// 3288  * This applies to XYZ on Cartesian and Core robots, and
// 3289  * to the individual ABC steppers on DELTA and SCARA.
// 3290  *
// 3291  * At the end of the procedure the axis is marked as
// 3292  * homed and the current position of that axis is updated.
// 3293  * Kinematic robots should wait till all axes are homed
// 3294  * before updating the current position.
// 3295  */
// 3296 
// 3297 #define HOMEAXIS(LETTER) homeaxis(LETTER##_AXIS)
// 3298 

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock35 Using cfiCommon0
          CFI Function _Z8homeaxis8AxisEnum
        THUMB
// 3299 static void homeaxis(const AxisEnum axis) {
_Z8homeaxis8AxisEnum:
        PUSH     {R3-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+32
        VPUSH    {D8}
          CFI D8 Frame(CFA, -40)
          CFI CFA R13+40
        MOV      R4,R0
// 3300 
// 3301   #if IS_SCARA
// 3302     // Only Z homing (with probe) is permitted
// 3303     if (axis != Z_AXIS) { BUZZ(100, 880); return; }
// 3304   #else
// 3305     #define CAN_HOME(A) \ 
// 3306       (axis == A##_AXIS && ((A##_MIN_PIN > -1 && A##_HOME_DIR < 0) || (A##_MAX_PIN > -1 && A##_HOME_DIR > 0)))
// 3307     if (!CAN_HOME(X) && !CAN_HOME(Y) && !CAN_HOME(Z)) return;
        MOV      R5,R4
        CMP      R5,#+2
        BNE.N    ??homeaxis_0
        LDR.N    R0,??DataTable104_8
        LDRSB    R0,[R0, #+1]
        CMP      R0,#+0
        BEQ.N    ??homeaxis_0
// 3308   #endif
// 3309 
// 3310   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3311     if (DEBUGGING(LEVELING)) {
// 3312       SERIAL_ECHOPAIR(">>> homeaxis(", axis_codes[axis]);
// 3313       SERIAL_CHAR(')');
// 3314       SERIAL_EOL();
// 3315     }
// 3316   #endif
// 3317 
// 3318   const int axis_home_dir =
// 3319     #if ENABLED(DUAL_X_CARRIAGE)
// 3320       (axis == X_AXIS) ? x_home_dir(active_extruder) :
// 3321     #endif
// 3322     home_dir(axis);
        MOV      R0,R4
          CFI FunCall _Z8home_dir8AxisEnum
        BL       _Z8home_dir8AxisEnum
        VMOV     S17,R0
// 3323 
// 3324   // Homing Z towards the bed? Deploy the Z probe or endstop.
// 3325   #if HOMING_Z_WITH_PROBE
// 3326     if (axis == Z_AXIS && DEPLOY_PROBE()) return;
// 3327   #endif
// 3328 
// 3329   // Set flags for X, Y, Z motor locking
// 3330   #if ENABLED(X_DUAL_ENDSTOPS)
// 3331     if (axis == X_AXIS) stepper.set_homing_flag_x(true);
// 3332   #endif
// 3333   #if ENABLED(Y_DUAL_ENDSTOPS)
// 3334     if (axis == Y_AXIS) stepper.set_homing_flag_y(true);
// 3335   #endif
// 3336   #if ENABLED(Z_DUAL_ENDSTOPS)
// 3337     if (axis == Z_AXIS) stepper.set_homing_flag_z(true);
// 3338   #endif
// 3339 
// 3340   // Disable stealthChop if used. Enable diag1 pin on driver.
// 3341   #if ENABLED(SENSORLESS_HOMING)
// 3342     #if ENABLED(X_IS_TMC2130)
// 3343       if (axis == X_AXIS) tmc_sensorless_homing(stepperX);
// 3344     #endif
// 3345     #if ENABLED(Y_IS_TMC2130)
// 3346       if (axis == Y_AXIS) tmc_sensorless_homing(stepperY);
// 3347     #endif
// 3348   #endif
// 3349 
// 3350   // Fast move towards endstop until triggered
// 3351   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3352     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 1 Fast:");
// 3353   #endif
// 3354   mksdlp.quick_stop_ena = false;
        LDR.N    R6,??DataTable104_6
        MOVS     R0,#+0
        STRB     R0,[R6, #+3253]
// 3355   do_homing_move(axis, 1.5 * max_length(axis) * axis_home_dir);
        MOV      R0,R4
          CFI FunCall _Z10max_length8AxisEnum
        BL       _Z10max_length8AxisEnum
        VLDR.W   S1,??DataTable103_1  ;; 0x0
        VMOV.F32 S16,S1
        VMOV     R0,S0
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        LDR.W    R3,??DataTable111_6  ;; 0x3ff80000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R8,R0
        MOV      R9,R1
        VMOV     R0,S17
          CFI FunCall __aeabi_i2d
        BL       __aeabi_i2d
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        VMOV     S0,R0
        VMOV.F32 S1,S16
        MOV      R0,R4
          CFI FunCall _Z14do_homing_move8AxisEnumff
        BL       _Z14do_homing_move8AxisEnumff
// 3356   
// 3357   mksdlp.buzzer_tone(500,100,2);
        ADDW     R7,R6,#+2500
        MOVS     R3,#+2
        MOVS     R2,#+100
        MOV      R1,#+500
        MOV      R0,R7
          CFI FunCall _ZN7MKS_DLP11buzzer_toneEtth
        BL       _ZN7MKS_DLP11buzzer_toneEtth
// 3358   // When homing Z with probe respect probe clearance
// 3359   const float bump = axis_home_dir * (
// 3360     //#if HOMING_Z_WITH_PROBE
// 3361 #if 0                                 
// 3362       (axis == Z_AXIS) ? max(Z_CLEARANCE_BETWEEN_PROBES, home_bump_mm(Z_AXIS)) :
// 3363     #endif
// 3364     home_bump_mm(axis)
// 3365   );
        VCVT.F32.S32 S16,S17
        MOV      R0,R4
          CFI FunCall _Z12home_bump_mm8AxisEnum
        BL       _Z12home_bump_mm8AxisEnum
        VMUL.F32 S16,S16,S0
// 3366 
// 3367   // If a second homing move is configured...
// 3368   if (bump) {
        VCMP.F32 S16,#0.0
        FMSTAT   
        BEQ.N    ??homeaxis_1
// 3369     // Move away from the endstop by the axis HOME_BUMP_MM
// 3370     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3371       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Move Away:");
// 3372     #endif
// 3373 	if(!mksdlp.quick_stop_ena)
        LDRB     R0,[R6, #+3253]
        CMP      R0,#+0
        BNE.N    ??homeaxis_2
// 3374 		{
// 3375 	    do_homing_move(axis, -bump);
        VLDR.W   S1,??DataTable103_1  ;; 0x0
        VNEG.F32 S0,S16
        MOV      R0,R4
          CFI FunCall _Z14do_homing_move8AxisEnumff
        BL       _Z14do_homing_move8AxisEnumff
// 3376 		}
// 3377     // Slow move towards endstop until triggered
// 3378     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3379       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 2 Slow:");
// 3380     #endif
// 3381 	if(!mksdlp.quick_stop_ena)
??homeaxis_2:
        LDRB     R0,[R6, #+3253]
        CMP      R0,#+0
        BNE.N    ??homeaxis_1
// 3382 		{
// 3383   	  	do_homing_move(axis, 2 * bump, get_homing_bump_feedrate(axis));
        MOV      R0,R4
          CFI FunCall _Z24get_homing_bump_feedrate8AxisEnum
        BL       _Z24get_homing_bump_feedrate8AxisEnum
        VMOV.F32 S1,S0
        VMOV.F32 S0,#2.0
        VMUL.F32 S0,S16,S0
        MOV      R0,R4
          CFI FunCall _Z14do_homing_move8AxisEnumff
        BL       _Z14do_homing_move8AxisEnumff
// 3384 		mksdlp.buzzer_tone(500,100,2);
        MOVS     R3,#+2
        MOVS     R2,#+100
        MOV      R1,#+500
        MOV      R0,R7
          CFI FunCall _ZN7MKS_DLP11buzzer_toneEtth
        BL       _ZN7MKS_DLP11buzzer_toneEtth
// 3385 		}
// 3386   }
// 3387 
// 3388   /**
// 3389    * Home axes that have dual endstops... differently
// 3390    */
// 3391   #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
// 3392     const bool pos_dir = axis_home_dir > 0;
// 3393     #if ENABLED(X_DUAL_ENDSTOPS)
// 3394       if (axis == X_AXIS) {
// 3395         const bool lock_x1 = pos_dir ? (x_endstop_adj > 0) : (x_endstop_adj < 0);
// 3396         const float adj = FABS(x_endstop_adj);
// 3397         if (lock_x1) stepper.set_x_lock(true); else stepper.set_x2_lock(true);
// 3398         do_homing_move(axis, pos_dir ? -adj : adj);
// 3399         if (lock_x1) stepper.set_x_lock(false); else stepper.set_x2_lock(false);
// 3400         stepper.set_homing_flag_x(false);
// 3401       }
// 3402     #endif
// 3403     #if ENABLED(Y_DUAL_ENDSTOPS)
// 3404       if (axis == Y_AXIS) {
// 3405         const bool lock_y1 = pos_dir ? (y_endstop_adj > 0) : (y_endstop_adj < 0);
// 3406         const float adj = FABS(y_endstop_adj);
// 3407         if (lock_y1) stepper.set_y_lock(true); else stepper.set_y2_lock(true);
// 3408         do_homing_move(axis, pos_dir ? -adj : adj);
// 3409         if (lock_y1) stepper.set_y_lock(false); else stepper.set_y2_lock(false);
// 3410         stepper.set_homing_flag_y(false);
// 3411       }
// 3412     #endif
// 3413     #if ENABLED(Z_DUAL_ENDSTOPS)
// 3414       if (axis == Z_AXIS) {
// 3415         const bool lock_z1 = pos_dir ? (z_endstop_adj > 0) : (z_endstop_adj < 0);
// 3416         const float adj = FABS(z_endstop_adj);
// 3417         if (lock_z1) stepper.set_z_lock(true); else stepper.set_z2_lock(true);
// 3418         do_homing_move(axis, pos_dir ? -adj : adj);
// 3419         if (lock_z1) stepper.set_z_lock(false); else stepper.set_z2_lock(false);
// 3420         stepper.set_homing_flag_z(false);
// 3421       }
// 3422     #endif
// 3423   #endif
// 3424 
// 3425   #if IS_SCARA
// 3426 
// 3427     set_axis_is_at_home(axis);
// 3428     SYNC_PLAN_POSITION_KINEMATIC();
// 3429 
// 3430   #elif ENABLED(DELTA)
// 3431 
// 3432     // Delta has already moved all three towers up in G28
// 3433     // so here it re-homes each tower in turn.
// 3434     // Delta homing treats the axes as normal linear axes.
// 3435 
// 3436     // retrace by the amount specified in delta_endstop_adj + additional 0.1mm in order to have minimum steps
// 3437     if (delta_endstop_adj[axis] * Z_HOME_DIR <= 0) {
// 3438       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3439         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("delta_endstop_adj:");
// 3440       #endif
// 3441       do_homing_move(axis, delta_endstop_adj[axis] - 0.1 * Z_HOME_DIR);
// 3442     }
// 3443 
// 3444   #else
// 3445 
// 3446     // For cartesian/core machines,
// 3447     // set the axis to its home position
// 3448     axis_homed[Z_AXIS]=false;
??homeaxis_1:
        LDR.W    R7,??DataTable107
        MOVS     R0,#+0
        STRB     R0,[R7, #+6]
// 3449   if(!mksdlp.quick_stop_ena)
        LDRB     R0,[R6, #+3253]
        CMP      R0,#+0
        BNE.N    ??homeaxis_0
// 3450   	{
// 3451     set_axis_is_at_home(axis);
        MOV      R0,R4
          CFI FunCall _Z19set_axis_is_at_home8AxisEnum
        BL       _Z19set_axis_is_at_home8AxisEnum
// 3452     sync_plan_position();
          CFI FunCall _Z18sync_plan_positionv
        BL       _Z18sync_plan_positionv
// 3453     destination[axis] = current_position[axis];
        ADD      R0,R7,R5, LSL #+2
        LDR      R1,[R0, #+36]
        STR      R1,[R0, #+52]
// 3454   	}
// 3455     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3456       if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
// 3457     #endif
// 3458 
// 3459   #endif
// 3460 
// 3461   // Re-enable stealthChop if used. Disable diag1 pin on driver.
// 3462   #if ENABLED(SENSORLESS_HOMING)
// 3463     #if ENABLED(X_IS_TMC2130)
// 3464       if (axis == X_AXIS) tmc_sensorless_homing(stepperX, false);
// 3465     #endif
// 3466     #if ENABLED(Y_IS_TMC2130)
// 3467       if (axis == Y_AXIS) tmc_sensorless_homing(stepperY, false);
// 3468     #endif
// 3469   #endif
// 3470 
// 3471   // Put away the Z probe
// 3472   //#if HOMING_Z_WITH_PROBE
// 3473 #if 0      
// 3474     if (axis == Z_AXIS && STOW_PROBE()) return;
// 3475   #endif
// 3476 
// 3477   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3478     if (DEBUGGING(LEVELING)) {
// 3479       SERIAL_ECHOPAIR("<<< homeaxis(", axis_codes[axis]);
// 3480       SERIAL_CHAR(')');
// 3481       SERIAL_EOL();
// 3482     }
// 3483   #endif
// 3484 } // homeaxis()
??homeaxis_0:
        VPOP     {D8}
          CFI D8 SameValue
          CFI CFA R13+32
        POP      {R0,R4-R9,PC}    ;; return
          CFI EndBlock cfiBlock35
// 3485 
// 3486 #if ENABLED(FWRETRACT)
// 3487 
// 3488   /**
// 3489    * Retract or recover according to firmware settings
// 3490    *
// 3491    * This function handles retract/recover moves for G10 and G11,
// 3492    * plus auto-retract moves sent from G0/G1 when E-only moves are done.
// 3493    *
// 3494    * To simplify the logic, doubled retract/recover moves are ignored.
// 3495    *
// 3496    * Note: Z lift is done transparently to the planner. Aborting
// 3497    *       a print between G10 and G11 may corrupt the Z position.
// 3498    *
// 3499    * Note: Auto-retract will apply the set Z hop in addition to any Z hop
// 3500    *       included in the G-code. Use M207 Z0 to to prevent double hop.
// 3501    */
// 3502   void retract(const bool retracting
// 3503     #if EXTRUDERS > 1
// 3504       , bool swapping = false
// 3505     #endif
// 3506   ) {
// 3507 
// 3508     static float hop_amount = 0.0;  // Total amount lifted, for use in recover
// 3509 
// 3510     // Prevent two retracts or recovers in a row
// 3511     if (retracted[active_extruder] == retracting) return;
// 3512 
// 3513     // Prevent two swap-retract or recovers in a row
// 3514     #if EXTRUDERS > 1
// 3515       // Allow G10 S1 only after G10
// 3516       if (swapping && retracted_swap[active_extruder] == retracting) return;
// 3517       // G11 priority to recover the long retract if activated
// 3518       if (!retracting) swapping = retracted_swap[active_extruder];
// 3519     #else
// 3520       const bool swapping = false;
// 3521     #endif
// 3522 
// 3523     /* // debugging
// 3524       SERIAL_ECHOLNPAIR("retracting ", retracting);
// 3525       SERIAL_ECHOLNPAIR("swapping ", swapping);
// 3526       SERIAL_ECHOLNPAIR("active extruder ", active_extruder);
// 3527       for (uint8_t i = 0; i < EXTRUDERS; ++i) {
// 3528         SERIAL_ECHOPAIR("retracted[", i);
// 3529         SERIAL_ECHOLNPAIR("] ", retracted[i]);
// 3530         SERIAL_ECHOPAIR("retracted_swap[", i);
// 3531         SERIAL_ECHOLNPAIR("] ", retracted_swap[i]);
// 3532       }
// 3533       SERIAL_ECHOLNPAIR("current_position[z] ", current_position[Z_AXIS]);
// 3534       SERIAL_ECHOLNPAIR("hop_amount ", hop_amount);
// 3535     //*/
// 3536 
// 3537     const bool has_zhop = retract_zlift > 0.01;     // Is there a hop set?
// 3538     const float old_feedrate_mm_s = feedrate_mm_s;
// 3539 
// 3540     // The current position will be the destination for E and Z moves
// 3541     set_destination_from_current();
// 3542     stepper.synchronize();  // Wait for buffered moves to complete
// 3543 
// 3544     const float renormalize = 1.0 / planner.e_factor[active_extruder];
// 3545 
// 3546     if (retracting) {
// 3547       // Retract by moving from a faux E position back to the current E position
// 3548       feedrate_mm_s = retract_feedrate_mm_s;
// 3549       current_position[E_AXIS] += (swapping ? swap_retract_length : retract_length) * renormalize;
// 3550       sync_plan_position_e();
// 3551       prepare_move_to_destination();
// 3552 
// 3553       // Is a Z hop set, and has the hop not yet been done?
// 3554       if (has_zhop && !hop_amount) {
// 3555         hop_amount += retract_zlift;                        // Carriage is raised for retraction hop
// 3556         feedrate_mm_s = planner.max_feedrate_mm_s[Z_AXIS];  // Z feedrate to max
// 3557         current_position[Z_AXIS] -= retract_zlift;          // Pretend current pos is lower. Next move raises Z.
// 3558         SYNC_PLAN_POSITION_KINEMATIC();                     // Set the planner to the new position
// 3559         prepare_move_to_destination();                      // Raise up to the old current pos
// 3560         feedrate_mm_s = retract_feedrate_mm_s;              // Restore feedrate
// 3561       }
// 3562     }
// 3563     else {
// 3564       // If a hop was done and Z hasn't changed, undo the Z hop
// 3565       if (hop_amount) {
// 3566         current_position[Z_AXIS] += retract_zlift;          // Pretend current pos is lower. Next move raises Z.
// 3567         SYNC_PLAN_POSITION_KINEMATIC();                     // Set the planner to the new position
// 3568         feedrate_mm_s = planner.max_feedrate_mm_s[Z_AXIS];  // Z feedrate to max
// 3569         prepare_move_to_destination();                      // Raise up to the old current pos
// 3570         hop_amount = 0.0;                                   // Clear hop
// 3571       }
// 3572 
// 3573       // A retract multiplier has been added here to get faster swap recovery
// 3574       feedrate_mm_s = swapping ? swap_retract_recover_feedrate_mm_s : retract_recover_feedrate_mm_s;
// 3575 
// 3576       const float move_e = swapping ? swap_retract_length + swap_retract_recover_length : retract_length + retract_recover_length;
// 3577       current_position[E_AXIS] -= move_e * renormalize;
// 3578       sync_plan_position_e();
// 3579       prepare_move_to_destination();                        // Recover E
// 3580     }
// 3581 
// 3582     feedrate_mm_s = old_feedrate_mm_s;                      // Restore original feedrate
// 3583 
// 3584     retracted[active_extruder] = retracting;                // Active extruder now retracted / recovered
// 3585 
// 3586     // If swap retract/recover update the retracted_swap flag too
// 3587     #if EXTRUDERS > 1
// 3588       if (swapping) retracted_swap[active_extruder] = retracting;
// 3589     #endif
// 3590 
// 3591     /* // debugging
// 3592       SERIAL_ECHOLNPAIR("retracting ", retracting);
// 3593       SERIAL_ECHOLNPAIR("swapping ", swapping);
// 3594       SERIAL_ECHOLNPAIR("active_extruder ", active_extruder);
// 3595       for (uint8_t i = 0; i < EXTRUDERS; ++i) {
// 3596         SERIAL_ECHOPAIR("retracted[", i);
// 3597         SERIAL_ECHOLNPAIR("] ", retracted[i]);
// 3598         SERIAL_ECHOPAIR("retracted_swap[", i);
// 3599         SERIAL_ECHOLNPAIR("] ", retracted_swap[i]);
// 3600       }
// 3601       SERIAL_ECHOLNPAIR("current_position[z] ", current_position[Z_AXIS]);
// 3602       SERIAL_ECHOLNPAIR("hop_amount ", hop_amount);
// 3603     //*/
// 3604 
// 3605   }
// 3606 
// 3607 #endif // FWRETRACT
// 3608 
// 3609 #if ENABLED(MIXING_EXTRUDER)
// 3610 
// 3611   void normalize_mix() {
// 3612     float mix_total = 0.0;
// 3613     for (uint8_t i = 0; i < MIXING_STEPPERS; i++) mix_total += RECIPROCAL(mixing_factor[i]);
// 3614     // Scale all values if they don't add up to ~1.0
// 3615     if (!NEAR(mix_total, 1.0)) {
// 3616       SERIAL_PROTOCOLLNPGM("Warning: Mix factors must add up to 1.0. Scaling.");
// 3617       for (uint8_t i = 0; i < MIXING_STEPPERS; i++) mixing_factor[i] *= mix_total;
// 3618     }
// 3619   }
// 3620 
// 3621   #if ENABLED(DIRECT_MIXING_IN_G1)
// 3622     // Get mixing parameters from the GCode
// 3623     // The total "must" be 1.0 (but it will be normalized)
// 3624     // If no mix factors are given, the old mix is preserved
// 3625     void gcode_get_mix() {
// 3626       const char* mixing_codes = "ABCDHI";
// 3627       byte mix_bits = 0;
// 3628       for (uint8_t i = 0; i < MIXING_STEPPERS; i++) {
// 3629         if (parser.seenval(mixing_codes[i])) {
// 3630           SBI(mix_bits, i);
// 3631           float v = parser.value_float();
// 3632           NOLESS(v, 0.0);
// 3633           mixing_factor[i] = RECIPROCAL(v);
// 3634         }
// 3635       }
// 3636       // If any mixing factors were included, clear the rest
// 3637       // If none were included, preserve the last mix
// 3638       if (mix_bits) {
// 3639         for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
// 3640           if (!TEST(mix_bits, i)) mixing_factor[i] = 0.0;
// 3641         normalize_mix();
// 3642       }
// 3643     }
// 3644   #endif
// 3645 
// 3646 #endif
// 3647 
// 3648 /**
// 3649  * ***************************************************************************
// 3650  * ***************************** G-CODE HANDLING *****************************
// 3651  * ***************************************************************************
// 3652  */
// 3653 
// 3654 /**
// 3655  * Set XYZE destination and feedrate from the current GCode command
// 3656  *
// 3657  *  - Set destination from included axis codes
// 3658  *  - Set to current for missing axis codes
// 3659  *  - Set the feedrate, if included
// 3660  */

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock36 Using cfiCommon0
          CFI Function _Z21gcode_get_destinationv
        THUMB
// 3661 void gcode_get_destination() {
_Z21gcode_get_destinationv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
// 3662   LOOP_XYZE(i) {
        MOVS     R4,#+0
        LDR.W    R6,??DataTable107
        B.N      ??gcode_get_destination_0
// 3663     if (parser.seen(axis_codes[i])) {
// 3664       const float v = parser.value_axis_units((AxisEnum)i) + (axis_relative_modes[i] || relative_mode ? current_position[i] : 0);
// 3665       //destination[i] = i == E_AXIS ? v : LOGICAL_TO_NATIVE(v, i);
// 3666       destination[i] = v;
// 3667     }
// 3668     else
// 3669       destination[i] = current_position[i];
??gcode_get_destination_1:
        LDR      R0,[R5, #+36]
        STR      R0,[R5, #+52]
??gcode_get_destination_2:
        ADDS     R4,R4,#+1
??gcode_get_destination_0:
        CMP      R4,#+4
        BGE.N    ??gcode_get_destination_3
        ADD      R5,R6,R4, LSL #+2
        ADR.W    R0,axis_codes
        LDRSB    R0,[R4, R0]
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_get_destination_1
        MOV      R0,R4
        SXTB     R0,R0
          CFI FunCall _ZN11GCodeParser16value_axis_unitsE8AxisEnum
        BL       _ZN11GCodeParser16value_axis_unitsE8AxisEnum
        LDRB     R0,[R4, R6]
        LDRB     R1,[R6, #+20]
        ORRS     R0,R1,R0
        BEQ.N    ??gcode_get_destination_4
        VLDR     S1,[R5, #+36]
        B.N      ??gcode_get_destination_5
??gcode_get_destination_4:
        VLDR.W   S1,??DataTable103_1  ;; 0x0
??gcode_get_destination_5:
        VADD.F32 S0,S0,S1
        VSTR     S0,[R5, #+52]
        B.N      ??gcode_get_destination_2
// 3670   }
// 3671 
// 3672   if (parser.linearval('F') > 0.0)
??gcode_get_destination_3:
        VLDR.W   S0,??DataTable103_1  ;; 0x0
        MOVS     R0,#+70
          CFI FunCall _ZN11GCodeParser9linearvalEcf
        BL       _ZN11GCodeParser9linearvalEcf
        VCMP.F32 S0,#0.0
        FMSTAT   
        BLE.N    ??gcode_get_destination_6
// 3673     feedrate_mm_s = MMM_TO_MMS(parser.value_feedrate());
          CFI FunCall _ZN11GCodeParser14value_feedrateEv
        BL       _ZN11GCodeParser14value_feedrateEv
        VLDR.W   S1,??DataTable104  ;; 0x42700000
        VDIV.F32 S0,S0,S1
        MOV      R0,R6
        VSTR     S0,[R0, #+120]
// 3674 
// 3675   #if ENABLED(PRINTCOUNTER)
// 3676     if (!DEBUGGING(DRYRUN))
// 3677       print_job_timer.incFilamentUsed(destination[E_AXIS] - current_position[E_AXIS]);
// 3678   #endif
// 3679 
// 3680   // Get ABCDHI mixing factors
// 3681   #if ENABLED(MIXING_EXTRUDER) && ENABLED(DIRECT_MIXING_IN_G1)
// 3682     gcode_get_mix();
// 3683   #endif
// 3684 }
??gcode_get_destination_6:
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock36

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
axis_codes:
        DC8 88, 89, 90, 69
// 3685 
// 3686 #if ENABLED(HOST_KEEPALIVE_FEATURE)
// 3687 
// 3688   /**
// 3689    * Output a "busy" message at regular intervals
// 3690    * while the machine is not accepting commands.
// 3691    */
// 3692   void host_keepalive() {
// 3693     const millis_t ms = millis();
// 3694     if (host_keepalive_interval && busy_state != NOT_BUSY) {
// 3695       if (PENDING(ms, next_busy_signal_ms)) return;
// 3696       switch (busy_state) {
// 3697         case IN_HANDLER:
// 3698         case IN_PROCESS:
// 3699           SERIAL_ECHO_START();
// 3700           SERIAL_ECHOLNPGM(MSG_BUSY_PROCESSING);
// 3701           break;
// 3702         case PAUSED_FOR_USER:
// 3703           SERIAL_ECHO_START();
// 3704           SERIAL_ECHOLNPGM(MSG_BUSY_PAUSED_FOR_USER);
// 3705           break;
// 3706         case PAUSED_FOR_INPUT:
// 3707           SERIAL_ECHO_START();
// 3708           SERIAL_ECHOLNPGM(MSG_BUSY_PAUSED_FOR_INPUT);
// 3709           break;
// 3710         default:
// 3711           break;
// 3712       }
// 3713     }
// 3714     next_busy_signal_ms = ms + host_keepalive_interval * 1000UL;
// 3715   }
// 3716 
// 3717 #endif // HOST_KEEPALIVE_FEATURE
// 3718 
// 3719 
// 3720 /**************************************************
// 3721  ***************** GCode Handlers *****************
// 3722  **************************************************/
// 3723 
// 3724 #if ENABLED(NO_MOTION_BEFORE_HOMING)
// 3725   #define G0_G1_CONDITION !axis_unhomed_error(parser.seen('X'), parser.seen('Y'), parser.seen('Z'))
// 3726 #else
// 3727   #define G0_G1_CONDITION true
// 3728 #endif
// 3729 
// 3730 /**
// 3731  * G0, G1: Coordinated movement of X Y Z E axes
// 3732  */
// 3733 inline void gcode_G0_G1(
// 3734   #if IS_SCARA
// 3735     bool fast_move=false
// 3736   #endif
// 3737 ) {
// 3738   if (IsRunning() && G0_G1_CONDITION) {
// 3739     gcode_get_destination(); // For X Y Z E F
// 3740 
// 3741     #if ENABLED(FWRETRACT)
// 3742       if (MIN_AUTORETRACT <= MAX_AUTORETRACT) {
// 3743         // When M209 Autoretract is enabled, convert E-only moves to firmware retract/recover moves
// 3744         if (autoretract_enabled && parser.seen('E') && !(parser.seen('X') || parser.seen('Y') || parser.seen('Z'))) {
// 3745           const float echange = destination[E_AXIS] - current_position[E_AXIS];
// 3746           // Is this a retract or recover move?
// 3747           if (WITHIN(FABS(echange), MIN_AUTORETRACT, MAX_AUTORETRACT) && retracted[active_extruder] == (echange > 0.0)) {
// 3748             current_position[E_AXIS] = destination[E_AXIS]; // Hide a G1-based retract/recover from calculations
// 3749             sync_plan_position_e();                         // AND from the planner
// 3750             return retract(echange < 0.0);                  // Firmware-based retract/recover (double-retract ignored)
// 3751           }
// 3752         }
// 3753       }
// 3754     #endif // FWRETRACT
// 3755 
// 3756     #if IS_SCARA
// 3757       fast_move ? prepare_uninterpolated_move_to_destination() : prepare_move_to_destination();
// 3758     #else
// 3759       prepare_move_to_destination();
// 3760     #endif
// 3761 
// 3762     #if ENABLED(NANODLP_Z_SYNC)
// 3763       #if ENABLED(NANODLP_ALL_AXIS)
// 3764         #define _MOVE_SYNC true                 // For any move wait and output sync message
// 3765       #else
// 3766         #define _MOVE_SYNC parser.seenval('Z')  // Only for Z move
// 3767       #endif
// 3768       if (_MOVE_SYNC) {
// 3769         stepper.synchronize();
// 3770         SERIAL_ECHOLNPGM(MSG_Z_MOVE_COMP);
// 3771       }
// 3772     #endif
// 3773   }
// 3774 }
// 3775 
// 3776 /**
// 3777  * G2: Clockwise Arc
// 3778  * G3: Counterclockwise Arc
// 3779  *
// 3780  * This command has two forms: IJ-form and R-form.
// 3781  *
// 3782  *  - I specifies an X offset. J specifies a Y offset.
// 3783  *    At least one of the IJ parameters is required.
// 3784  *    X and Y can be omitted to do a complete circle.
// 3785  *    The given XY is not error-checked. The arc ends
// 3786  *     based on the angle of the destination.
// 3787  *    Mixing I or J with R will throw an error.
// 3788  *
// 3789  *  - R specifies the radius. X or Y is required.
// 3790  *    Omitting both X and Y will throw an error.
// 3791  *    X or Y must differ from the current XY.
// 3792  *    Mixing R with I or J will throw an error.
// 3793  *
// 3794  *  - P specifies the number of full circles to do
// 3795  *    before the specified arc move.
// 3796  *
// 3797  *  Examples:
// 3798  *
// 3799  *    G2 I10           ; CW circle centered at X+10
// 3800  *    G3 X20 Y12 R14   ; CCW circle with r=14 ending at X20 Y12
// 3801  */
// 3802 #if ENABLED(ARC_SUPPORT)
// 3803 
// 3804   inline void gcode_G2_G3(const bool clockwise) {
// 3805     #if ENABLED(NO_MOTION_BEFORE_HOMING)
// 3806       if (axis_unhomed_error()) return;
// 3807     #endif
// 3808 
// 3809     if (IsRunning()) {
// 3810 
// 3811       #if ENABLED(SF_ARC_FIX)
// 3812         const bool relative_mode_backup = relative_mode;
// 3813         relative_mode = true;
// 3814       #endif
// 3815 
// 3816       gcode_get_destination();
// 3817 
// 3818       #if ENABLED(SF_ARC_FIX)
// 3819         relative_mode = relative_mode_backup;
// 3820       #endif
// 3821 
// 3822       float arc_offset[2] = { 0.0, 0.0 };
// 3823       if (parser.seenval('R')) {
// 3824         const float r = parser.value_linear_units(),
// 3825                     p1 = current_position[X_AXIS], q1 = current_position[Y_AXIS],
// 3826                     p2 = destination[X_AXIS], q2 = destination[Y_AXIS];
// 3827         if (r && (p2 != p1 || q2 != q1)) {
// 3828           const float e = clockwise ^ (r < 0) ? -1 : 1,           // clockwise -1/1, counterclockwise 1/-1
// 3829                       dx = p2 - p1, dy = q2 - q1,                 // X and Y differences
// 3830                       d = HYPOT(dx, dy),                          // Linear distance between the points
// 3831                       h = SQRT(sq(r) - sq(d * 0.5)),              // Distance to the arc pivot-point
// 3832                       mx = (p1 + p2) * 0.5, my = (q1 + q2) * 0.5, // Point between the two points
// 3833                       sx = -dy / d, sy = dx / d,                  // Slope of the perpendicular bisector
// 3834                       cx = mx + e * h * sx, cy = my + e * h * sy; // Pivot-point of the arc
// 3835           arc_offset[0] = cx - p1;
// 3836           arc_offset[1] = cy - q1;
// 3837         }
// 3838       }
// 3839       else {
// 3840         if (parser.seenval('I')) arc_offset[0] = parser.value_linear_units();
// 3841         if (parser.seenval('J')) arc_offset[1] = parser.value_linear_units();
// 3842       }
// 3843 
// 3844       if (arc_offset[0] || arc_offset[1]) {
// 3845 
// 3846         #if ENABLED(ARC_P_CIRCLES)
// 3847           // P indicates number of circles to do
// 3848           int8_t circles_to_do = parser.byteval('P');
// 3849           if (!WITHIN(circles_to_do, 0, 100)) {
// 3850             SERIAL_ERROR_START();
// 3851             SERIAL_ERRORLNPGM(MSG_ERR_ARC_ARGS);
// 3852           }
// 3853           while (circles_to_do--)
// 3854             plan_arc(current_position, arc_offset, clockwise);
// 3855         #endif
// 3856 
// 3857         // Send the arc to the planner
// 3858         plan_arc(destination, arc_offset, clockwise);
// 3859         refresh_cmd_timeout();
// 3860       }
// 3861       else {
// 3862         // Bad arguments
// 3863         SERIAL_ERROR_START();
// 3864         SERIAL_ERRORLNPGM(MSG_ERR_ARC_ARGS);
// 3865       }
// 3866     }
// 3867   }
// 3868 
// 3869 #endif // ARC_SUPPORT
// 3870 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock37 Using cfiCommon0
          CFI Function _Z5dwellm
        THUMB
// 3871 void dwell(millis_t time) {
_Z5dwellm:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
// 3872   refresh_cmd_timeout();
          CFI FunCall _Z19refresh_cmd_timeoutv
        BL       _Z19refresh_cmd_timeoutv
// 3873   time += previous_cmd_ms;
        LDR.W    R0,??DataTable118
        LDR      R0,[R0, #+0]
        ADDS     R4,R0,R4
        B.N      ??dwell_0
// 3874   while (PENDING(millis(), time)) idle();
??dwell_1:
          CFI FunCall _Z4idlev
        BL       _Z4idlev
??dwell_0:
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        SUBS     R0,R0,R4
        BMI.N    ??dwell_1
// 3875 }
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock37
// 3876 
// 3877 /**
// 3878  * G4: Dwell S<seconds> or P<milliseconds>
// 3879  */
// 3880 inline void gcode_G4() {
// 3881   millis_t dwell_ms = 0;
// 3882 
// 3883   if (parser.seenval('P')) dwell_ms = parser.value_millis(); // milliseconds to wait
// 3884   if (parser.seenval('S')) dwell_ms = parser.value_millis_from_seconds(); // seconds to wait
// 3885 
// 3886   stepper.synchronize();
// 3887   #if ENABLED(NANODLP_Z_SYNC)
// 3888     SERIAL_ECHOLNPGM(MSG_Z_MOVE_COMP);
// 3889   #endif
// 3890 
// 3891   if (!lcd_hasstatus()) LCD_MESSAGEPGM(MSG_DWELL);
// 3892 
// 3893   dwell(dwell_ms);
// 3894 }
// 3895 
// 3896 #if ENABLED(BEZIER_CURVE_SUPPORT)
// 3897 
// 3898   /**
// 3899    * Parameters interpreted according to:
// 3900    * http://linuxcnc.org/docs/2.6/html/gcode/gcode.html#sec:G5-Cubic-Spline
// 3901    * However I, J omission is not supported at this point; all
// 3902    * parameters can be omitted and default to zero.
// 3903    */
// 3904 
// 3905   /**
// 3906    * G5: Cubic B-spline
// 3907    */
// 3908   inline void gcode_G5() {
// 3909     #if ENABLED(NO_MOTION_BEFORE_HOMING)
// 3910       if (axis_unhomed_error()) return;
// 3911     #endif
// 3912 
// 3913     if (IsRunning()) {
// 3914 
// 3915       #if ENABLED(CNC_WORKSPACE_PLANES)
// 3916         if (workspace_plane != PLANE_XY) {
// 3917           SERIAL_ERROR_START();
// 3918           SERIAL_ERRORLNPGM(MSG_ERR_BAD_PLANE_MODE);
// 3919           return;
// 3920         }
// 3921       #endif
// 3922 
// 3923       gcode_get_destination();
// 3924 
// 3925       const float offset[] = {
// 3926         parser.linearval('I'),
// 3927         parser.linearval('J'),
// 3928         parser.linearval('P'),
// 3929         parser.linearval('Q')
// 3930       };
// 3931 
// 3932       plan_cubic_move(offset);
// 3933     }
// 3934   }
// 3935 
// 3936 #endif // BEZIER_CURVE_SUPPORT
// 3937 
// 3938 #if ENABLED(FWRETRACT)
// 3939 
// 3940   /**
// 3941    * G10 - Retract filament according to settings of M207
// 3942    */
// 3943   inline void gcode_G10() {
// 3944     #if EXTRUDERS > 1
// 3945       const bool rs = parser.boolval('S');
// 3946       retracted_swap[active_extruder] = rs; // Use 'S' for swap, default to false
// 3947     #endif
// 3948     retract(true
// 3949       #if EXTRUDERS > 1
// 3950         , rs
// 3951       #endif
// 3952     );
// 3953   }
// 3954 
// 3955   /**
// 3956    * G11 - Recover filament according to settings of M208
// 3957    */
// 3958   inline void gcode_G11() { retract(false); }
// 3959 
// 3960 #endif // FWRETRACT
// 3961 
// 3962 #if ENABLED(NOZZLE_CLEAN_FEATURE)
// 3963   /**
// 3964    * G12: Clean the nozzle
// 3965    */
// 3966   inline void gcode_G12() {
// 3967     // Don't allow nozzle cleaning without homing first
// 3968     if (axis_unhomed_error()) return;
// 3969 
// 3970     const uint8_t pattern = parser.ushortval('P', 0),
// 3971                   strokes = parser.ushortval('S', NOZZLE_CLEAN_STROKES),
// 3972                   objects = parser.ushortval('T', NOZZLE_CLEAN_TRIANGLES);
// 3973     const float radius = parser.floatval('R', NOZZLE_CLEAN_CIRCLE_RADIUS);
// 3974 
// 3975     Nozzle::clean(pattern, strokes, radius, objects);
// 3976   }
// 3977 #endif
// 3978 
// 3979 #if ENABLED(CNC_WORKSPACE_PLANES)
// 3980 
// 3981   inline void report_workspace_plane() {
// 3982     SERIAL_ECHO_START();
// 3983     SERIAL_ECHOPGM("Workspace Plane ");
// 3984     serialprintPGM(
// 3985       workspace_plane == PLANE_YZ ? PSTR("YZ\n") :
// 3986       workspace_plane == PLANE_ZX ? PSTR("ZX\n") :
// 3987                                     PSTR("XY\n")
// 3988     );
// 3989   }
// 3990 
// 3991   inline void set_workspace_plane(const WorkspacePlane plane) {
// 3992     workspace_plane = plane;
// 3993     if (DEBUGGING(INFO)) report_workspace_plane();
// 3994   }
// 3995 
// 3996   /**
// 3997    * G17: Select Plane XY
// 3998    * G18: Select Plane ZX
// 3999    * G19: Select Plane YZ
// 4000    */
// 4001   inline void gcode_G17() { set_workspace_plane(PLANE_XY); }
// 4002   inline void gcode_G18() { set_workspace_plane(PLANE_ZX); }
// 4003   inline void gcode_G19() { set_workspace_plane(PLANE_YZ); }
// 4004 
// 4005 #endif // CNC_WORKSPACE_PLANES
// 4006 
// 4007 #if ENABLED(CNC_COORDINATE_SYSTEMS)
// 4008 
// 4009   /**
// 4010    * Select a coordinate system and update the workspace offset.
// 4011    * System index -1 is used to specify machine-native.
// 4012    */
// 4013   bool select_coordinate_system(const int8_t _new) {
// 4014     if (active_coordinate_system == _new) return false;
// 4015     float old_offset[XYZ] = { 0 }, new_offset[XYZ] = { 0 };
// 4016     if (WITHIN(active_coordinate_system, 0, MAX_COORDINATE_SYSTEMS - 1))
// 4017       COPY(old_offset, coordinate_system[active_coordinate_system]);
// 4018     if (WITHIN(_new, 0, MAX_COORDINATE_SYSTEMS - 1))
// 4019       COPY(new_offset, coordinate_system[_new]);
// 4020     active_coordinate_system = _new;
// 4021     LOOP_XYZ(i) {
// 4022       const float diff = new_offset[i] - old_offset[i];
// 4023       if (diff) {
// 4024         position_shift[i] += diff;
// 4025         update_software_endstops((AxisEnum)i);
// 4026       }
// 4027     }
// 4028     return true;
// 4029   }
// 4030 
// 4031   /**
// 4032    * In CNC G-code G53 is like a modifier
// 4033    * It precedes a movement command (or other modifiers) on the same line.
// 4034    * This is the first command to use parser.chain() to make this possible.
// 4035    */
// 4036   inline void gcode_G53() {
// 4037     // If this command has more following...
// 4038     if (parser.chain()) {
// 4039       const int8_t _system = active_coordinate_system;
// 4040       active_coordinate_system = -1;
// 4041       process_parsed_command();
// 4042       active_coordinate_system = _system;
// 4043     }
// 4044   }
// 4045 
// 4046   /**
// 4047    * G54-G59.3: Select a new workspace
// 4048    *
// 4049    * A workspace is an XYZ offset to the machine native space.
// 4050    * All workspaces default to 0,0,0 at start, or with EEPROM
// 4051    * support they may be restored from a previous session.
// 4052    *
// 4053    * G92 is used to set the current workspace's offset.
// 4054    */
// 4055   inline void gcode_G54_59(uint8_t subcode=0) {
// 4056     const int8_t _space = parser.codenum - 54 + subcode;
// 4057     if (select_coordinate_system(_space)) {
// 4058       SERIAL_PROTOCOLLNPAIR("Select workspace ", _space);
// 4059       report_current_position();
// 4060     }
// 4061   }
// 4062   FORCE_INLINE void gcode_G54() { gcode_G54_59(); }
// 4063   FORCE_INLINE void gcode_G55() { gcode_G54_59(); }
// 4064   FORCE_INLINE void gcode_G56() { gcode_G54_59(); }
// 4065   FORCE_INLINE void gcode_G57() { gcode_G54_59(); }
// 4066   FORCE_INLINE void gcode_G58() { gcode_G54_59(); }
// 4067   FORCE_INLINE void gcode_G59() { gcode_G54_59(parser.subcode); }
// 4068 
// 4069 #endif
// 4070 
// 4071 #if ENABLED(INCH_MODE_SUPPORT)
// 4072   /**
// 4073    * G20: Set input mode to inches
// 4074    */
// 4075   inline void gcode_G20() { parser.set_input_linear_units(LINEARUNIT_INCH); }
// 4076 
// 4077   /**
// 4078    * G21: Set input mode to millimeters
// 4079    */
// 4080   inline void gcode_G21() { parser.set_input_linear_units(LINEARUNIT_MM); }
// 4081 #endif
// 4082 
// 4083 #if ENABLED(NOZZLE_PARK_FEATURE)
// 4084   /**
// 4085    * G27: Park the nozzle
// 4086    */
// 4087   inline void gcode_G27() {
// 4088     // Don't allow nozzle parking without homing first
// 4089     if (axis_unhomed_error()) return;
// 4090     Nozzle::park(parser.ushortval('P'));
// 4091   }
// 4092 #endif // NOZZLE_PARK_FEATURE
// 4093 
// 4094 #if ENABLED(QUICK_HOME)
// 4095 
// 4096   static void quick_home_xy() {
// 4097 
// 4098     // Pretend the current position is 0,0
// 4099     current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
// 4100     sync_plan_position();
// 4101 
// 4102     const int x_axis_home_dir =
// 4103       #if ENABLED(DUAL_X_CARRIAGE)
// 4104         x_home_dir(active_extruder)
// 4105       #else
// 4106         home_dir(X_AXIS)
// 4107       #endif
// 4108     ;
// 4109 
// 4110     const float mlx = max_length(X_AXIS),
// 4111                 mly = max_length(Y_AXIS),
// 4112                 mlratio = mlx > mly ? mly / mlx : mlx / mly,
// 4113                 fr_mm_s = min(homing_feedrate_mm_s[X_AXIS], homing_feedrate_mm_s[Y_AXIS]) * SQRT(sq(mlratio) + 1.0);
// 4114 
// 4115     do_blocking_move_to_xy(1.5 * mlx * x_axis_home_dir, 1.5 * mly * home_dir(Y_AXIS), fr_mm_s);
// 4116     endstops.hit_on_purpose(); // clear endstop hit flags
// 4117     current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
// 4118   }
// 4119 
// 4120 #endif // QUICK_HOME
// 4121 
// 4122 #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4123 
// 4124   void log_machine_info() {
// 4125     SERIAL_ECHOPGM("Machine Type: ");
// 4126     #if ENABLED(DELTA)
// 4127       SERIAL_ECHOLNPGM("Delta");
// 4128     #elif IS_SCARA
// 4129       SERIAL_ECHOLNPGM("SCARA");
// 4130     #elif IS_CORE
// 4131       SERIAL_ECHOLNPGM("Core");
// 4132     #else
// 4133       SERIAL_ECHOLNPGM("Cartesian");
// 4134     #endif
// 4135 
// 4136     SERIAL_ECHOPGM("Probe: ");
// 4137     #if ENABLED(PROBE_MANUALLY)
// 4138       SERIAL_ECHOLNPGM("PROBE_MANUALLY");
// 4139     #elif ENABLED(FIX_MOUNTED_PROBE)
// 4140       SERIAL_ECHOLNPGM("FIX_MOUNTED_PROBE");
// 4141     #elif ENABLED(BLTOUCH)
// 4142       SERIAL_ECHOLNPGM("BLTOUCH");
// 4143     #elif HAS_Z_SERVO_ENDSTOP
// 4144       SERIAL_ECHOLNPGM("SERVO PROBE");
// 4145     #elif ENABLED(Z_PROBE_SLED)
// 4146       SERIAL_ECHOLNPGM("Z_PROBE_SLED");
// 4147     #elif ENABLED(Z_PROBE_ALLEN_KEY)
// 4148       SERIAL_ECHOLNPGM("Z_PROBE_ALLEN_KEY");
// 4149     #else
// 4150       SERIAL_ECHOLNPGM("NONE");
// 4151     #endif
// 4152 
// 4153     #if HAS_BED_PROBE
// 4154       SERIAL_ECHOPAIR("Probe Offset X:", X_PROBE_OFFSET_FROM_EXTRUDER);
// 4155       SERIAL_ECHOPAIR(" Y:", Y_PROBE_OFFSET_FROM_EXTRUDER);
// 4156       SERIAL_ECHOPAIR(" Z:", zprobe_zoffset);
// 4157       #if X_PROBE_OFFSET_FROM_EXTRUDER > 0
// 4158         SERIAL_ECHOPGM(" (Right");
// 4159       #elif X_PROBE_OFFSET_FROM_EXTRUDER < 0
// 4160         SERIAL_ECHOPGM(" (Left");
// 4161       #elif Y_PROBE_OFFSET_FROM_EXTRUDER != 0
// 4162         SERIAL_ECHOPGM(" (Middle");
// 4163       #else
// 4164         SERIAL_ECHOPGM(" (Aligned With");
// 4165       #endif
// 4166       #if Y_PROBE_OFFSET_FROM_EXTRUDER > 0
// 4167         SERIAL_ECHOPGM("-Back");
// 4168       #elif Y_PROBE_OFFSET_FROM_EXTRUDER < 0
// 4169         SERIAL_ECHOPGM("-Front");
// 4170       #elif X_PROBE_OFFSET_FROM_EXTRUDER != 0
// 4171         SERIAL_ECHOPGM("-Center");
// 4172       #endif
// 4173       if (zprobe_zoffset < 0)
// 4174         SERIAL_ECHOPGM(" & Below");
// 4175       else if (zprobe_zoffset > 0)
// 4176         SERIAL_ECHOPGM(" & Above");
// 4177       else
// 4178         SERIAL_ECHOPGM(" & Same Z as");
// 4179       SERIAL_ECHOLNPGM(" Nozzle)");
// 4180     #endif
// 4181 
// 4182     #if HAS_ABL
// 4183       SERIAL_ECHOPGM("Auto Bed Leveling: ");
// 4184       #if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 4185         SERIAL_ECHOPGM("LINEAR");
// 4186       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 4187         SERIAL_ECHOPGM("BILINEAR");
// 4188       #elif ENABLED(AUTO_BED_LEVELING_3POINT)
// 4189         SERIAL_ECHOPGM("3POINT");
// 4190       #elif ENABLED(AUTO_BED_LEVELING_UBL)
// 4191         SERIAL_ECHOPGM("UBL");
// 4192       #endif
// 4193       if (planner.leveling_active) {
// 4194         SERIAL_ECHOLNPGM(" (enabled)");
// 4195         #if ABL_PLANAR
// 4196           const float diff[XYZ] = {
// 4197             stepper.get_axis_position_mm(X_AXIS) - current_position[X_AXIS],
// 4198             stepper.get_axis_position_mm(Y_AXIS) - current_position[Y_AXIS],
// 4199             stepper.get_axis_position_mm(Z_AXIS) - current_position[Z_AXIS]
// 4200           };
// 4201           SERIAL_ECHOPGM("ABL Adjustment X");
// 4202           if (diff[X_AXIS] > 0) SERIAL_CHAR('+');
// 4203           SERIAL_ECHO(diff[X_AXIS]);
// 4204           SERIAL_ECHOPGM(" Y");
// 4205           if (diff[Y_AXIS] > 0) SERIAL_CHAR('+');
// 4206           SERIAL_ECHO(diff[Y_AXIS]);
// 4207           SERIAL_ECHOPGM(" Z");
// 4208           if (diff[Z_AXIS] > 0) SERIAL_CHAR('+');
// 4209           SERIAL_ECHO(diff[Z_AXIS]);
// 4210         #elif ENABLED(AUTO_BED_LEVELING_UBL)
// 4211           SERIAL_ECHOPAIR("UBL Adjustment Z", stepper.get_axis_position_mm(Z_AXIS) - current_position[Z_AXIS]);
// 4212         #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 4213           SERIAL_ECHOPAIR("ABL Adjustment Z", bilinear_z_offset(current_position));
// 4214         #endif
// 4215       }
// 4216       else
// 4217         SERIAL_ECHOLNPGM(" (disabled)");
// 4218 
// 4219       SERIAL_EOL();
// 4220 
// 4221     #elif ENABLED(MESH_BED_LEVELING)
// 4222 
// 4223       SERIAL_ECHOPGM("Mesh Bed Leveling");
// 4224       if (planner.leveling_active) {
// 4225         float rz = current_position[Z_AXIS];
// 4226         planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], rz);
// 4227         SERIAL_ECHOLNPGM(" (enabled)");
// 4228         SERIAL_ECHOPAIR("MBL Adjustment Z", rz);
// 4229       }
// 4230       else
// 4231         SERIAL_ECHOPGM(" (disabled)");
// 4232 
// 4233       SERIAL_EOL();
// 4234 
// 4235     #endif // MESH_BED_LEVELING
// 4236   }
// 4237 
// 4238 #endif // DEBUG_LEVELING_FEATURE
// 4239 
// 4240 #if ENABLED(DELTA)
// 4241 
// 4242   /**
// 4243    * A delta can only safely home all axes at the same time
// 4244    * This is like quick_home_xy() but for 3 towers.
// 4245    */
// 4246   inline bool home_delta() {
// 4247     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4248       if (DEBUGGING(LEVELING)) DEBUG_POS(">>> home_delta", current_position);
// 4249     #endif
// 4250     // Init the current position of all carriages to 0,0,0
// 4251     ZERO(current_position);
// 4252     sync_plan_position();
// 4253 
// 4254     // Move all carriages together linearly until an endstop is hit.
// 4255     current_position[X_AXIS] = current_position[Y_AXIS] = current_position[Z_AXIS] = (delta_height + 10);
// 4256     feedrate_mm_s = homing_feedrate_mm_s[X_AXIS];
// 4257     buffer_line_to_current_position();
// 4258     stepper.synchronize();
// 4259 
// 4260     // If an endstop was not hit, then damage can occur if homing is continued.
// 4261     // This can occur if the delta height not set correctly.
// 4262     if (!(Endstops::endstop_hit_bits & (_BV(X_MAX) | _BV(Y_MAX) | _BV(Z_MAX)))) {
// 4263       LCD_MESSAGEPGM(MSG_ERR_HOMING_FAILED);
// 4264       SERIAL_ERROR_START();
// 4265       SERIAL_ERRORLNPGM(MSG_ERR_HOMING_FAILED);
// 4266       return false;
// 4267     }
// 4268 
// 4269     endstops.hit_on_purpose(); // clear endstop hit flags
// 4270 
// 4271     // At least one carriage has reached the top.
// 4272     // Now re-home each carriage separately.
// 4273     HOMEAXIS(A);
// 4274     HOMEAXIS(B);
// 4275     HOMEAXIS(C);
// 4276 
// 4277     // Set all carriages to their home positions
// 4278     // Do this here all at once for Delta, because
// 4279     // XYZ isn't ABC. Applying this per-tower would
// 4280     // give the impression that they are the same.
// 4281     LOOP_XYZ(i) set_axis_is_at_home((AxisEnum)i);
// 4282 
// 4283     SYNC_PLAN_POSITION_KINEMATIC();
// 4284 
// 4285     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4286       if (DEBUGGING(LEVELING)) DEBUG_POS("<<< home_delta", current_position);
// 4287     #endif
// 4288 
// 4289     return true;
// 4290   }
// 4291 
// 4292 #endif // DELTA
// 4293 
// 4294 #if ENABLED(Z_SAFE_HOMING)
// 4295 
// 4296   inline void home_z_safely() {
// 4297 
// 4298     // Disallow Z homing if X or Y are unknown
// 4299     if (!axis_known_position[X_AXIS] || !axis_known_position[Y_AXIS]) {
// 4300       LCD_MESSAGEPGM(MSG_ERR_Z_HOMING);
// 4301       SERIAL_ECHO_START();
// 4302       SERIAL_ECHOLNPGM(MSG_ERR_Z_HOMING);
// 4303       return;
// 4304     }
// 4305 
// 4306     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4307       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Z_SAFE_HOMING >>>");
// 4308     #endif
// 4309 
// 4310     SYNC_PLAN_POSITION_KINEMATIC();
// 4311 
// 4312     /**
// 4313      * Move the Z probe (or just the nozzle) to the safe homing point
// 4314      */
// 4315     destination[X_AXIS] = Z_SAFE_HOMING_X_POINT;
// 4316     destination[Y_AXIS] = Z_SAFE_HOMING_Y_POINT;
// 4317     destination[Z_AXIS] = current_position[Z_AXIS]; // Z is already at the right height
// 4318 
// 4319     #if HOMING_Z_WITH_PROBE
// 4320       destination[X_AXIS] -= X_PROBE_OFFSET_FROM_EXTRUDER;
// 4321       destination[Y_AXIS] -= Y_PROBE_OFFSET_FROM_EXTRUDER;
// 4322     #endif
// 4323 
// 4324     if (position_is_reachable(destination[X_AXIS], destination[Y_AXIS])) {
// 4325 
// 4326       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4327         if (DEBUGGING(LEVELING)) DEBUG_POS("Z_SAFE_HOMING", destination);
// 4328       #endif
// 4329 
// 4330       // This causes the carriage on Dual X to unpark
// 4331       #if ENABLED(DUAL_X_CARRIAGE)
// 4332         active_extruder_parked = false;
// 4333       #endif
// 4334 
// 4335       do_blocking_move_to_xy(destination[X_AXIS], destination[Y_AXIS]);
// 4336       HOMEAXIS(Z);
// 4337     }
// 4338     else {
// 4339       LCD_MESSAGEPGM(MSG_ZPROBE_OUT);
// 4340       SERIAL_ECHO_START();
// 4341       SERIAL_ECHOLNPGM(MSG_ZPROBE_OUT);
// 4342     }
// 4343 
// 4344     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4345       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< Z_SAFE_HOMING");
// 4346     #endif
// 4347   }
// 4348 
// 4349 #endif // Z_SAFE_HOMING
// 4350 
// 4351 #if ENABLED(PROBE_MANUALLY)
// 4352   bool g29_in_progress = false;
// 4353 #else
// 4354   constexpr bool g29_in_progress = false;
// 4355 #endif
// 4356 
// 4357 /**
// 4358  * G28: Home all axes according to settings
// 4359  *
// 4360  * Parameters
// 4361  *
// 4362  *  None  Home to all axes with no parameters.
// 4363  *        With QUICK_HOME enabled XY will home together, then Z.
// 4364  *
// 4365  * Cartesian parameters
// 4366  *
// 4367  *  X   Home to the X endstop
// 4368  *  Y   Home to the Y endstop
// 4369  *  Z   Home to the Z endstop
// 4370  *
// 4371  */
// 4372 inline void gcode_G28(const bool always_home_all) {
// 4373 
// 4374   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4375     if (DEBUGGING(LEVELING)) {
// 4376       SERIAL_ECHOLNPGM(">>> gcode_G28");
// 4377       log_machine_info();
// 4378     }
// 4379   #endif
// 4380 
// 4381   // Wait for planner moves to finish!
// 4382   stepper.synchronize();
// 4383 
// 4384   // Cancel the active G29 session
// 4385   #if ENABLED(PROBE_MANUALLY)
// 4386     g29_in_progress = false;
// 4387   #endif
// 4388 
// 4389   // Disable the leveling matrix before homing
// 4390   #if HAS_LEVELING
// 4391     #if ENABLED(AUTO_BED_LEVELING_UBL)
// 4392       const bool ubl_state_at_entry = planner.leveling_active;
// 4393     #endif
// 4394     set_bed_leveling_enabled(false);
// 4395   #endif
// 4396 
// 4397   #if ENABLED(CNC_WORKSPACE_PLANES)
// 4398     workspace_plane = PLANE_XY;
// 4399   #endif
// 4400 
// 4401   // Always home with tool 0 active
// 4402   #if HOTENDS > 1
// 4403     const uint8_t old_tool_index = active_extruder;
// 4404     tool_change(0, 0, true);
// 4405   #endif
// 4406 
// 4407   #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
// 4408     extruder_duplication_enabled = false;
// 4409   #endif
// 4410 
// 4411   setup_for_endstop_or_probe_move();
// 4412   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4413     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> endstops.enable(true)");
// 4414   #endif
// 4415   endstops.enable(true); // Enable endstops for next homing move
// 4416 
// 4417   #if ENABLED(DELTA)
// 4418 
// 4419     home_delta();
// 4420     UNUSED(always_home_all);
// 4421 
// 4422   #else // NOT DELTA
// 4423 
// 4424     const bool homeX = always_home_all || parser.seen('X'),
// 4425                homeY = always_home_all || parser.seen('Y'),
// 4426                homeZ = always_home_all || parser.seen('Z'),
// 4427                home_all = (!homeX && !homeY && !homeZ) || (homeX && homeY && homeZ);
// 4428 
// 4429     set_destination_from_current();
// 4430 
// 4431     //#if Z_HOME_DIR > 0  // If homing away from BED do Z first
// 4432 if(Z_HOME_DIR > 0)
// 4433 {
// 4434       if (home_all || homeZ) {
// 4435         HOMEAXIS(Z);
// 4436         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4437           if (DEBUGGING(LEVELING)) DEBUG_POS("> HOMEAXIS(Z)", current_position);
// 4438         #endif
// 4439       }
// 4440 }
// 4441     //#endif
// 4442 
// 4443     if (home_all || homeX || homeY) {
// 4444       // Raise Z before homing any other axes and z is not already high enough (never lower z)
// 4445       destination[Z_AXIS] = Z_HOMING_HEIGHT;
// 4446       if (destination[Z_AXIS] > current_position[Z_AXIS]) {
// 4447 
// 4448         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4449           if (DEBUGGING(LEVELING))
// 4450             SERIAL_ECHOLNPAIR("Raise Z (before homing) to ", destination[Z_AXIS]);
// 4451         #endif
// 4452 
// 4453         do_blocking_move_to_z(destination[Z_AXIS]);
// 4454       }
// 4455     }
// 4456 
// 4457     #if ENABLED(QUICK_HOME)
// 4458 
// 4459       if (home_all || (homeX && homeY)) quick_home_xy();
// 4460 
// 4461     #endif
// 4462 
// 4463     #if ENABLED(HOME_Y_BEFORE_X)
// 4464 
// 4465       // Home Y
// 4466       if (home_all || homeY) {
// 4467         HOMEAXIS(Y);
// 4468         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4469           if (DEBUGGING(LEVELING)) DEBUG_POS("> homeY", current_position);
// 4470         #endif
// 4471       }
// 4472 
// 4473     #endif
// 4474 
// 4475     // Home X
// 4476     if (home_all || homeX) {
// 4477 
// 4478       #if ENABLED(DUAL_X_CARRIAGE)
// 4479 
// 4480         // Always home the 2nd (right) extruder first
// 4481         active_extruder = 1;
// 4482         HOMEAXIS(X);
// 4483 
// 4484         // Remember this extruder's position for later tool change
// 4485         inactive_extruder_x_pos = current_position[X_AXIS];
// 4486 
// 4487         // Home the 1st (left) extruder
// 4488         active_extruder = 0;
// 4489         HOMEAXIS(X);
// 4490 
// 4491         // Consider the active extruder to be parked
// 4492         COPY(raised_parked_position, current_position);
// 4493         delayed_move_time = 0;
// 4494         active_extruder_parked = true;
// 4495 
// 4496       #else
// 4497 
// 4498         HOMEAXIS(X);
// 4499 
// 4500       #endif
// 4501 
// 4502       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4503         if (DEBUGGING(LEVELING)) DEBUG_POS("> homeX", current_position);
// 4504       #endif
// 4505     }
// 4506 
// 4507     #if DISABLED(HOME_Y_BEFORE_X)
// 4508       // Home Y
// 4509       if (home_all || homeY) {
// 4510         HOMEAXIS(Y);
// 4511         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4512           if (DEBUGGING(LEVELING)) DEBUG_POS("> homeY", current_position);
// 4513         #endif
// 4514       }
// 4515     #endif
// 4516 
// 4517     // Home Z last if homing towards the bed
// 4518     //#if Z_HOME_DIR < 0
// 4519     if(Z_HOME_DIR < 0)
// 4520     {
// 4521       if (home_all || homeZ) {
// 4522         #if ENABLED(Z_SAFE_HOMING)
// 4523           home_z_safely();
// 4524         #else
// 4525           HOMEAXIS(Z);
// 4526         #endif
// 4527         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4528           if (DEBUGGING(LEVELING)) DEBUG_POS("> (home_all || homeZ) > final", current_position);
// 4529         #endif
// 4530       } // home_all || homeZ
// 4531     }
// 4532     //#endif // Z_HOME_DIR < 0
// 4533 
// 4534     SYNC_PLAN_POSITION_KINEMATIC();
// 4535 
// 4536   #endif // !DELTA (gcode_G28)
// 4537 
// 4538   endstops.not_homing();
// 4539 
// 4540   #if ENABLED(DELTA) && ENABLED(DELTA_HOME_TO_SAFE_ZONE)
// 4541     // move to a height where we can use the full xy-area
// 4542     do_blocking_move_to_z(delta_clip_start_height);
// 4543   #endif
// 4544 
// 4545   #if ENABLED(AUTO_BED_LEVELING_UBL)
// 4546     set_bed_leveling_enabled(ubl_state_at_entry);
// 4547   #endif
// 4548 
// 4549   clean_up_after_endstop_or_probe_move();
// 4550 
// 4551   // Restore the active tool after homing
// 4552   #if HOTENDS > 1
// 4553     #if ENABLED(PARKING_EXTRUDER)
// 4554       #define NO_FETCH false // fetch the previous toolhead
// 4555     #else
// 4556       #define NO_FETCH true
// 4557     #endif
// 4558     tool_change(old_tool_index, 0, NO_FETCH);
// 4559   #endif
// 4560 
// 4561   lcd_refresh();
// 4562 
// 4563   report_current_position();
// 4564 
// 4565   #if ENABLED(NANODLP_Z_SYNC)
// 4566     #if ENABLED(NANODLP_ALL_AXIS)
// 4567       #define _HOME_SYNC true                 // For any axis, output sync text.
// 4568     #else
// 4569       #define _HOME_SYNC (home_all || homeZ)  // Only for Z-axis
// 4570     #endif
// 4571     if (_HOME_SYNC)
// 4572       SERIAL_ECHOLNPGM(MSG_Z_MOVE_COMP);
// 4573   #endif
// 4574 
// 4575   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4576     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< gcode_G28");
// 4577   #endif
// 4578 } // G28
// 4579 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock38 Using cfiCommon0
          CFI Function _Z13home_all_axesv
        THUMB
// 4580 void home_all_axes() { gcode_G28(true); }
_Z13home_all_axesv:
        MOVS     R0,#+1
          CFI FunCall _Z9gcode_G28b
        B.W      _Z9gcode_G28b
          CFI EndBlock cfiBlock38
// 4581 
// 4582 #if HAS_PROBING_PROCEDURE
// 4583 
// 4584   void out_of_range_error(const char* p_edge) {
// 4585     SERIAL_PROTOCOLPGM("?Probe ");
// 4586     serialprintPGM(p_edge);
// 4587     SERIAL_PROTOCOLLNPGM(" position out of range.");
// 4588   }
// 4589 
// 4590 #endif
// 4591 
// 4592 #if ENABLED(MESH_BED_LEVELING) || ENABLED(PROBE_MANUALLY)
// 4593 
// 4594   #if ENABLED(LCD_BED_LEVELING)
// 4595     //extern 
// 4596     bool lcd_wait_for_move;
// 4597   #else
// 4598     constexpr bool lcd_wait_for_move = false;
// 4599   #endif
// 4600 
// 4601   inline void _manual_goto_xy(const float &rx, const float &ry) {
// 4602 
// 4603     #if MANUAL_PROBE_HEIGHT > 0
// 4604       const float prev_z = current_position[Z_AXIS];
// 4605       do_blocking_move_to(rx, ry, MANUAL_PROBE_HEIGHT);
// 4606       do_blocking_move_to_z(prev_z);
// 4607     #else
// 4608       do_blocking_move_to_xy(rx, ry);
// 4609     #endif
// 4610 
// 4611     current_position[X_AXIS] = rx;
// 4612     current_position[Y_AXIS] = ry;
// 4613 
// 4614     #if ENABLED(LCD_BED_LEVELING)
// 4615       lcd_wait_for_move = false;
// 4616     #endif
// 4617   }
// 4618 
// 4619 #endif
// 4620 
// 4621 #if ENABLED(MESH_BED_LEVELING)
// 4622 
// 4623   // Save 130 bytes with non-duplication of PSTR
// 4624   void echo_not_entered() { SERIAL_PROTOCOLLNPGM(" not entered."); }
// 4625 
// 4626   void mbl_mesh_report() {
// 4627     SERIAL_PROTOCOLLNPGM("Num X,Y: " STRINGIFY(GRID_MAX_POINTS_X) "," STRINGIFY(GRID_MAX_POINTS_Y));
// 4628     SERIAL_PROTOCOLPGM("Z offset: "); SERIAL_PROTOCOL_F(mbl.z_offset, 5);
// 4629     SERIAL_PROTOCOLLNPGM("\nMeasured points:");
// 4630     print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 5,
// 4631       [](const uint8_t ix, const uint8_t iy) { return mbl.z_values[ix][iy]; }
// 4632     );
// 4633   }
// 4634 
// 4635   /**
// 4636    * G29: Mesh-based Z probe, probes a grid and produces a
// 4637    *      mesh to compensate for variable bed height
// 4638    *
// 4639    * Parameters With MESH_BED_LEVELING:
// 4640    *
// 4641    *  S0              Produce a mesh report
// 4642    *  S1              Start probing mesh points
// 4643    *  S2              Probe the next mesh point
// 4644    *  S3 Xn Yn Zn.nn  Manually modify a single point
// 4645    *  S4 Zn.nn        Set z offset. Positive away from bed, negative closer to bed.
// 4646    *  S5              Reset and disable mesh
// 4647    *
// 4648    * The S0 report the points as below
// 4649    *
// 4650    *  +----> X-axis  1-n
// 4651    *  |
// 4652    *  |
// 4653    *  v Y-axis  1-n
// 4654    *
// 4655    */
// 4656   inline void gcode_G29() {
// 4657 
// 4658     static int mbl_probe_index = -1;
// 4659     #if HAS_SOFTWARE_ENDSTOPS
// 4660       static bool enable_soft_endstops;
// 4661     #endif
// 4662 
// 4663     const MeshLevelingState state = (MeshLevelingState)parser.byteval('S', (int8_t)MeshReport);
// 4664     if (!WITHIN(state, 0, 5)) {
// 4665       SERIAL_PROTOCOLLNPGM("S out of range (0-5).");
// 4666       return;
// 4667     }
// 4668 
// 4669     int8_t px, py;
// 4670 
// 4671     switch (state) {
// 4672       case MeshReport:
// 4673         if (leveling_is_valid()) {
// 4674           SERIAL_PROTOCOLLNPAIR("State: ", planner.leveling_active ? MSG_ON : MSG_OFF);
// 4675           mbl_mesh_report();
// 4676         }
// 4677         else
// 4678           SERIAL_PROTOCOLLNPGM("Mesh bed leveling has no data.");
// 4679         break;
// 4680 
// 4681       case MeshStart:
// 4682         mbl.reset();
// 4683         mbl_probe_index = 0;
// 4684         enqueue_and_echo_commands_P(lcd_wait_for_move ? PSTR("G29 S2") : PSTR("G28\nG29 S2"));
// 4685         break;
// 4686 
// 4687       case MeshNext:
// 4688         if (mbl_probe_index < 0) {
// 4689           SERIAL_PROTOCOLLNPGM("Start mesh probing with \"G29 S1\" first.");
// 4690           return;
// 4691         }
// 4692         // For each G29 S2...
// 4693         if (mbl_probe_index == 0) {
// 4694           #if HAS_SOFTWARE_ENDSTOPS
// 4695             // For the initial G29 S2 save software endstop state
// 4696             enable_soft_endstops = soft_endstops_enabled;
// 4697           #endif
// 4698         }
// 4699         else {
// 4700           // For G29 S2 after adjusting Z.
// 4701           mbl.set_zigzag_z(mbl_probe_index - 1, current_position[Z_AXIS]);
// 4702           #if HAS_SOFTWARE_ENDSTOPS
// 4703             soft_endstops_enabled = enable_soft_endstops;
// 4704           #endif
// 4705         }
// 4706         // If there's another point to sample, move there with optional lift.
// 4707         if (mbl_probe_index < GRID_MAX_POINTS) {
// 4708           mbl.zigzag(mbl_probe_index, px, py);
// 4709           _manual_goto_xy(mbl.index_to_xpos[px], mbl.index_to_ypos[py]);
// 4710 
// 4711           #if HAS_SOFTWARE_ENDSTOPS
// 4712             // Disable software endstops to allow manual adjustment
// 4713             // If G29 is not completed, they will not be re-enabled
// 4714             soft_endstops_enabled = false;
// 4715           #endif
// 4716 
// 4717           mbl_probe_index++;
// 4718         }
// 4719         else {
// 4720           // One last "return to the bed" (as originally coded) at completion
// 4721           current_position[Z_AXIS] = Z_MIN_POS + MANUAL_PROBE_HEIGHT;
// 4722           buffer_line_to_current_position();
// 4723           stepper.synchronize();
// 4724 
// 4725           // After recording the last point, activate home and activate
// 4726           mbl_probe_index = -1;
// 4727           SERIAL_PROTOCOLLNPGM("Mesh probing done.");
// 4728           BUZZ(100, 659);
// 4729           BUZZ(100, 698);
// 4730           mbl.has_mesh = true;
// 4731 
// 4732           home_all_axes();
// 4733           set_bed_leveling_enabled(true);
// 4734 
// 4735           #if ENABLED(MESH_G28_REST_ORIGIN)
// 4736             current_position[Z_AXIS] = Z_MIN_POS;
// 4737             set_destination_from_current();
// 4738             buffer_line_to_destination(homing_feedrate_mm_s[Z_AXIS]);
// 4739             stepper.synchronize();
// 4740           #endif
// 4741 
// 4742           #if ENABLED(LCD_BED_LEVELING)
// 4743             lcd_wait_for_move = false;
// 4744           #endif
// 4745         }
// 4746         break;
// 4747 
// 4748       case MeshSet:
// 4749         if (parser.seenval('X')) {
// 4750           px = parser.value_int() - 1;
// 4751           if (!WITHIN(px, 0, GRID_MAX_POINTS_X - 1)) {
// 4752             SERIAL_PROTOCOLLNPGM("X out of range (1-" STRINGIFY(GRID_MAX_POINTS_X) ").");
// 4753             return;
// 4754           }
// 4755         }
// 4756         else {
// 4757           SERIAL_CHAR('X'); echo_not_entered();
// 4758           return;
// 4759         }
// 4760 
// 4761         if (parser.seenval('Y')) {
// 4762           py = parser.value_int() - 1;
// 4763           if (!WITHIN(py, 0, GRID_MAX_POINTS_Y - 1)) {
// 4764             SERIAL_PROTOCOLLNPGM("Y out of range (1-" STRINGIFY(GRID_MAX_POINTS_Y) ").");
// 4765             return;
// 4766           }
// 4767         }
// 4768         else {
// 4769           SERIAL_CHAR('Y'); echo_not_entered();
// 4770           return;
// 4771         }
// 4772 
// 4773         if (parser.seenval('Z'))
// 4774           mbl.z_values[px][py] = parser.value_linear_units();
// 4775         else {
// 4776           SERIAL_CHAR('Z'); echo_not_entered();
// 4777           return;
// 4778         }
// 4779         break;
// 4780 
// 4781       case MeshSetZOffset:
// 4782         if (parser.seenval('Z'))
// 4783           mbl.z_offset = parser.value_linear_units();
// 4784         else {
// 4785           SERIAL_CHAR('Z'); echo_not_entered();
// 4786           return;
// 4787         }
// 4788         break;
// 4789 
// 4790       case MeshReset:
// 4791         reset_bed_level();
// 4792         break;
// 4793 
// 4794     } // switch(state)
// 4795 
// 4796     if (state == MeshStart || state == MeshNext) {
// 4797       SERIAL_PROTOCOLPAIR("MBL G29 point ", min(mbl_probe_index, GRID_MAX_POINTS));
// 4798       SERIAL_PROTOCOLLNPAIR(" of ", int(GRID_MAX_POINTS));
// 4799     }
// 4800 
// 4801     report_current_position();
// 4802   }
// 4803 
// 4804 #elif OLDSCHOOL_ABL
// 4805 
// 4806   #if ABL_GRID
// 4807     #if ENABLED(PROBE_Y_FIRST)
// 4808       #define PR_OUTER_VAR xCount
// 4809       #define PR_OUTER_END abl_grid_points_x
// 4810       #define PR_INNER_VAR yCount
// 4811       #define PR_INNER_END abl_grid_points_y
// 4812     #else
// 4813       #define PR_OUTER_VAR yCount
// 4814       #define PR_OUTER_END abl_grid_points_y
// 4815       #define PR_INNER_VAR xCount
// 4816       #define PR_INNER_END abl_grid_points_x
// 4817     #endif
// 4818   #endif
// 4819 
// 4820   /**
// 4821    * G29: Detailed Z probe, probes the bed at 3 or more points.
// 4822    *      Will fail if the printer has not been homed with G28.
// 4823    *
// 4824    * Enhanced G29 Auto Bed Leveling Probe Routine
// 4825    *
// 4826    *  D  Dry-Run mode. Just evaluate the bed Topology - Don't apply
// 4827    *     or alter the bed level data. Useful to check the topology
// 4828    *     after a first run of G29.
// 4829    *
// 4830    *  J  Jettison current bed leveling data
// 4831    *
// 4832    *  V  Set the verbose level (0-4). Example: "G29 V3"
// 4833    *
// 4834    * Parameters With LINEAR leveling only:
// 4835    *
// 4836    *  P  Set the size of the grid that will be probed (P x P points).
// 4837    *     Example: "G29 P4"
// 4838    *
// 4839    *  X  Set the X size of the grid that will be probed (X x Y points).
// 4840    *     Example: "G29 X7 Y5"
// 4841    *
// 4842    *  Y  Set the Y size of the grid that will be probed (X x Y points).
// 4843    *
// 4844    *  T  Generate a Bed Topology Report. Example: "G29 P5 T" for a detailed report.
// 4845    *     This is useful for manual bed leveling and finding flaws in the bed (to
// 4846    *     assist with part placement).
// 4847    *     Not supported by non-linear delta printer bed leveling.
// 4848    *
// 4849    * Parameters With LINEAR and BILINEAR leveling only:
// 4850    *
// 4851    *  S  Set the XY travel speed between probe points (in units/min)
// 4852    *
// 4853    *  F  Set the Front limit of the probing grid
// 4854    *  B  Set the Back limit of the probing grid
// 4855    *  L  Set the Left limit of the probing grid
// 4856    *  R  Set the Right limit of the probing grid
// 4857    *
// 4858    * Parameters with DEBUG_LEVELING_FEATURE only:
// 4859    *
// 4860    *  C  Make a totally fake grid with no actual probing.
// 4861    *     For use in testing when no probing is possible.
// 4862    *
// 4863    * Parameters with BILINEAR leveling only:
// 4864    *
// 4865    *  Z  Supply an additional Z probe offset
// 4866    *
// 4867    * Extra parameters with PROBE_MANUALLY:
// 4868    *
// 4869    *  To do manual probing simply repeat G29 until the procedure is complete.
// 4870    *  The first G29 accepts parameters. 'G29 Q' for status, 'G29 A' to abort.
// 4871    *
// 4872    *  Q  Query leveling and G29 state
// 4873    *
// 4874    *  A  Abort current leveling procedure
// 4875    *
// 4876    * Extra parameters with BILINEAR only:
// 4877    *
// 4878    *  W  Write a mesh point. (If G29 is idle.)
// 4879    *  I  X index for mesh point
// 4880    *  J  Y index for mesh point
// 4881    *  X  X for mesh point, overrides I
// 4882    *  Y  Y for mesh point, overrides J
// 4883    *  Z  Z for mesh point. Otherwise, raw current Z.
// 4884    *
// 4885    * Without PROBE_MANUALLY:
// 4886    *
// 4887    *  E  By default G29 will engage the Z probe, test the bed, then disengage.
// 4888    *     Include "E" to engage/disengage the Z probe for each sample.
// 4889    *     There's no extra effect if you have a fixed Z probe.
// 4890    *
// 4891    */
// 4892   inline void gcode_G29() {
// 4893 
// 4894     // G29 Q is also available if debugging
// 4895     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4896       const bool query = parser.seen('Q');
// 4897       const uint8_t old_debug_flags = marlin_debug_flags;
// 4898       if (query) marlin_debug_flags |= DEBUG_LEVELING;
// 4899       if (DEBUGGING(LEVELING)) {
// 4900         DEBUG_POS(">>> G29", current_position);
// 4901         log_machine_info();
// 4902       }
// 4903       marlin_debug_flags = old_debug_flags;
// 4904       #if DISABLED(PROBE_MANUALLY)
// 4905         if (query) return;
// 4906       #endif
// 4907     #endif
// 4908 
// 4909     #if ENABLED(PROBE_MANUALLY)
// 4910       const bool seenA = parser.seen('A'), seenQ = parser.seen('Q'), no_action = seenA || seenQ;
// 4911     #endif
// 4912 
// 4913     #if ENABLED(DEBUG_LEVELING_FEATURE) && DISABLED(PROBE_MANUALLY)
// 4914       const bool faux = parser.boolval('C');
// 4915     #elif ENABLED(PROBE_MANUALLY)
// 4916       const bool faux = no_action;
// 4917     #else
// 4918       bool constexpr faux = false;
// 4919     #endif
// 4920 
// 4921     // Don't allow auto-leveling without homing first
// 4922     if (axis_unhomed_error()) return;
// 4923 
// 4924     // Define local vars 'static' for manual probing, 'auto' otherwise
// 4925     #if ENABLED(PROBE_MANUALLY)
// 4926       #define ABL_VAR static
// 4927     #else
// 4928       #define ABL_VAR
// 4929     #endif
// 4930 
// 4931     ABL_VAR int verbose_level;
// 4932     ABL_VAR float xProbe, yProbe, measured_z;
// 4933     ABL_VAR bool dryrun, abl_should_enable;
// 4934 
// 4935     #if ENABLED(PROBE_MANUALLY) || ENABLED(AUTO_BED_LEVELING_LINEAR)
// 4936       ABL_VAR int abl_probe_index;
// 4937     #endif
// 4938 
// 4939     #if HAS_SOFTWARE_ENDSTOPS && ENABLED(PROBE_MANUALLY)
// 4940       ABL_VAR bool enable_soft_endstops = true;
// 4941     #endif
// 4942 
// 4943     #if ABL_GRID
// 4944 
// 4945       #if ENABLED(PROBE_MANUALLY)
// 4946         ABL_VAR uint8_t PR_OUTER_VAR;
// 4947         ABL_VAR  int8_t PR_INNER_VAR;
// 4948       #endif
// 4949 
// 4950       ABL_VAR int left_probe_bed_position, right_probe_bed_position, front_probe_bed_position, back_probe_bed_position;
// 4951       ABL_VAR float xGridSpacing = 0, yGridSpacing = 0;
// 4952 
// 4953       #if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 4954         ABL_VAR uint8_t abl_grid_points_x = GRID_MAX_POINTS_X,
// 4955                         abl_grid_points_y = GRID_MAX_POINTS_Y;
// 4956         ABL_VAR bool do_topography_map;
// 4957       #else // Bilinear
// 4958         uint8_t constexpr abl_grid_points_x = GRID_MAX_POINTS_X,
// 4959                           abl_grid_points_y = GRID_MAX_POINTS_Y;
// 4960       #endif
// 4961 
// 4962       #if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 4963         ABL_VAR int abl2;
// 4964       #elif ENABLED(PROBE_MANUALLY) // Bilinear
// 4965         int constexpr abl2 = GRID_MAX_POINTS;
// 4966       #endif
// 4967 
// 4968       #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 4969 
// 4970         ABL_VAR float zoffset;
// 4971 
// 4972       #elif ENABLED(AUTO_BED_LEVELING_LINEAR)
// 4973 
// 4974         ABL_VAR int indexIntoAB[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
// 4975 
// 4976         ABL_VAR float eqnAMatrix[GRID_MAX_POINTS * 3], // "A" matrix of the linear system of equations
// 4977                       eqnBVector[GRID_MAX_POINTS],     // "B" vector of Z points
// 4978                       mean;
// 4979       #endif
// 4980 
// 4981     #elif ENABLED(AUTO_BED_LEVELING_3POINT)
// 4982 
// 4983       #if ENABLED(PROBE_MANUALLY)
// 4984         int constexpr abl2 = 3; // used to show total points
// 4985       #endif
// 4986 
// 4987       // Probe at 3 arbitrary points
// 4988       ABL_VAR vector_3 points[3] = {
// 4989         vector_3(ABL_PROBE_PT_1_X, ABL_PROBE_PT_1_Y, 0),
// 4990         vector_3(ABL_PROBE_PT_2_X, ABL_PROBE_PT_2_Y, 0),
// 4991         vector_3(ABL_PROBE_PT_3_X, ABL_PROBE_PT_3_Y, 0)
// 4992       };
// 4993 
// 4994     #endif // AUTO_BED_LEVELING_3POINT
// 4995 
// 4996     #if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 4997       struct linear_fit_data lsf_results;
// 4998       incremental_LSF_reset(&lsf_results);
// 4999     #endif
// 5000 
// 5001     /**
// 5002      * On the initial G29 fetch command parameters.
// 5003      */
// 5004     if (!g29_in_progress) {
// 5005 
// 5006       #if ENABLED(PROBE_MANUALLY) || ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5007         abl_probe_index = -1;
// 5008       #endif
// 5009 
// 5010       abl_should_enable = planner.leveling_active;
// 5011 
// 5012       #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5013 
// 5014         if (parser.seen('W')) {
// 5015           if (!leveling_is_valid()) {
// 5016             SERIAL_ERROR_START();
// 5017             SERIAL_ERRORLNPGM("No bilinear grid");
// 5018             return;
// 5019           }
// 5020 
// 5021           const float rz = parser.seenval('Z') ? RAW_Z_POSITION(parser.value_linear_units()) : current_position[Z_AXIS];
// 5022           if (!WITHIN(rz, -10, 10)) {
// 5023             SERIAL_ERROR_START();
// 5024             SERIAL_ERRORLNPGM("Bad Z value");
// 5025             return;
// 5026           }
// 5027 
// 5028           const float rx = RAW_X_POSITION(parser.linearval('X', NAN)),
// 5029                       ry = RAW_Y_POSITION(parser.linearval('Y', NAN));
// 5030           int8_t i = parser.byteval('I', -1),
// 5031                  j = parser.byteval('J', -1);
// 5032 
// 5033           if (!isnan(rx) && !isnan(ry)) {
// 5034             // Get nearest i / j from rx / ry
// 5035             i = (rx - bilinear_start[X_AXIS] + 0.5 * xGridSpacing) / xGridSpacing;
// 5036             j = (ry - bilinear_start[Y_AXIS] + 0.5 * yGridSpacing) / yGridSpacing;
// 5037             i = constrain(i, 0, GRID_MAX_POINTS_X - 1);
// 5038             j = constrain(j, 0, GRID_MAX_POINTS_Y - 1);
// 5039           }
// 5040           if (WITHIN(i, 0, GRID_MAX_POINTS_X - 1) && WITHIN(j, 0, GRID_MAX_POINTS_Y)) {
// 5041             set_bed_leveling_enabled(false);
// 5042             z_values[i][j] = rz;
// 5043             #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 5044               bed_level_virt_interpolate();
// 5045             #endif
// 5046             set_bed_leveling_enabled(abl_should_enable);
// 5047             if (abl_should_enable) report_current_position();
// 5048           }
// 5049           return;
// 5050         } // parser.seen('W')
// 5051 
// 5052       #endif
// 5053 
// 5054       // Jettison bed leveling data
// 5055       if (parser.seen('J')) {
// 5056         reset_bed_level();
// 5057         return;
// 5058       }
// 5059 
// 5060       verbose_level = parser.intval('V');
// 5061       if (!WITHIN(verbose_level, 0, 4)) {
// 5062         SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-4).");
// 5063         return;
// 5064       }
// 5065 
// 5066       dryrun = parser.boolval('D')
// 5067         #if ENABLED(PROBE_MANUALLY)
// 5068           || no_action
// 5069         #endif
// 5070       ;
// 5071 
// 5072       #if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5073 
// 5074         do_topography_map = verbose_level > 2 || parser.boolval('T');
// 5075 
// 5076         // X and Y specify points in each direction, overriding the default
// 5077         // These values may be saved with the completed mesh
// 5078         abl_grid_points_x = parser.intval('X', GRID_MAX_POINTS_X);
// 5079         abl_grid_points_y = parser.intval('Y', GRID_MAX_POINTS_Y);
// 5080         if (parser.seenval('P')) abl_grid_points_x = abl_grid_points_y = parser.value_int();
// 5081 
// 5082         if (abl_grid_points_x < 2 || abl_grid_points_y < 2) {
// 5083           SERIAL_PROTOCOLLNPGM("?Number of probe points is implausible (2 minimum).");
// 5084           return;
// 5085         }
// 5086 
// 5087         abl2 = abl_grid_points_x * abl_grid_points_y;
// 5088         mean = 0;
// 5089 
// 5090       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5091 
// 5092         zoffset = parser.linearval('Z');
// 5093 
// 5094       #endif
// 5095 
// 5096       #if ABL_GRID
// 5097 
// 5098         xy_probe_feedrate_mm_s = MMM_TO_MMS(parser.linearval('S', XY_PROBE_SPEED));
// 5099 
// 5100         left_probe_bed_position  = parser.seenval('L') ? (int)RAW_X_POSITION(parser.value_linear_units()) : LEFT_PROBE_BED_POSITION;
// 5101         right_probe_bed_position = parser.seenval('R') ? (int)RAW_X_POSITION(parser.value_linear_units()) : RIGHT_PROBE_BED_POSITION;
// 5102         front_probe_bed_position = parser.seenval('F') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : FRONT_PROBE_BED_POSITION;
// 5103         back_probe_bed_position  = parser.seenval('B') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : BACK_PROBE_BED_POSITION;
// 5104 
// 5105         const bool left_out_l = left_probe_bed_position < MIN_PROBE_X,
// 5106                    left_out = left_out_l || left_probe_bed_position > right_probe_bed_position - (MIN_PROBE_EDGE),
// 5107                    right_out_r = right_probe_bed_position > MAX_PROBE_X,
// 5108                    right_out = right_out_r || right_probe_bed_position < left_probe_bed_position + MIN_PROBE_EDGE,
// 5109                    front_out_f = front_probe_bed_position < MIN_PROBE_Y,
// 5110                    front_out = front_out_f || front_probe_bed_position > back_probe_bed_position - (MIN_PROBE_EDGE),
// 5111                    back_out_b = back_probe_bed_position > MAX_PROBE_Y,
// 5112                    back_out = back_out_b || back_probe_bed_position < front_probe_bed_position + MIN_PROBE_EDGE;
// 5113 
// 5114         if (left_out || right_out || front_out || back_out) {
// 5115           if (left_out) {
// 5116             out_of_range_error(PSTR("(L)eft"));
// 5117             left_probe_bed_position = left_out_l ? MIN_PROBE_X : right_probe_bed_position - (MIN_PROBE_EDGE);
// 5118           }
// 5119           if (right_out) {
// 5120             out_of_range_error(PSTR("(R)ight"));
// 5121             right_probe_bed_position = right_out_r ? MAX_PROBE_X : left_probe_bed_position + MIN_PROBE_EDGE;
// 5122           }
// 5123           if (front_out) {
// 5124             out_of_range_error(PSTR("(F)ront"));
// 5125             front_probe_bed_position = front_out_f ? MIN_PROBE_Y : back_probe_bed_position - (MIN_PROBE_EDGE);
// 5126           }
// 5127           if (back_out) {
// 5128             out_of_range_error(PSTR("(B)ack"));
// 5129             back_probe_bed_position = back_out_b ? MAX_PROBE_Y : front_probe_bed_position + MIN_PROBE_EDGE;
// 5130           }
// 5131           return;
// 5132         }
// 5133 
// 5134         // probe at the points of a lattice grid
// 5135         xGridSpacing = (right_probe_bed_position - left_probe_bed_position) / (abl_grid_points_x - 1);
// 5136         yGridSpacing = (back_probe_bed_position - front_probe_bed_position) / (abl_grid_points_y - 1);
// 5137 
// 5138       #endif // ABL_GRID
// 5139 
// 5140       if (verbose_level > 0) {
// 5141         SERIAL_PROTOCOLPGM("G29 Auto Bed Leveling");
// 5142         if (dryrun) SERIAL_PROTOCOLPGM(" (DRYRUN)");
// 5143         SERIAL_EOL();
// 5144       }
// 5145 
// 5146       stepper.synchronize();
// 5147 
// 5148       // Disable auto bed leveling during G29.
// 5149       // Be formal so G29 can be done successively without G28.
// 5150       set_bed_leveling_enabled(false);
// 5151 
// 5152       #if HAS_BED_PROBE
// 5153         // Deploy the probe. Probe will raise if needed.
// 5154         if (DEPLOY_PROBE()) {
// 5155           set_bed_leveling_enabled(abl_should_enable);
// 5156           return;
// 5157         }
// 5158       #endif
// 5159 
// 5160       if (!faux) setup_for_endstop_or_probe_move();
// 5161 
// 5162       #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5163 
// 5164         #if ENABLED(PROBE_MANUALLY)
// 5165           if (!no_action)
// 5166         #endif
// 5167         if ( xGridSpacing != bilinear_grid_spacing[X_AXIS]
// 5168           || yGridSpacing != bilinear_grid_spacing[Y_AXIS]
// 5169           || left_probe_bed_position != bilinear_start[X_AXIS]
// 5170           || front_probe_bed_position != bilinear_start[Y_AXIS]
// 5171         ) {
// 5172           // Reset grid to 0.0 or "not probed". (Also disables ABL)
// 5173           reset_bed_level();
// 5174 
// 5175           // Initialize a grid with the given dimensions
// 5176           bilinear_grid_spacing[X_AXIS] = xGridSpacing;
// 5177           bilinear_grid_spacing[Y_AXIS] = yGridSpacing;
// 5178           bilinear_start[X_AXIS] = left_probe_bed_position;
// 5179           bilinear_start[Y_AXIS] = front_probe_bed_position;
// 5180 
// 5181           // Can't re-enable (on error) until the new grid is written
// 5182           abl_should_enable = false;
// 5183         }
// 5184 
// 5185       #endif // AUTO_BED_LEVELING_BILINEAR
// 5186 
// 5187       #if ENABLED(AUTO_BED_LEVELING_3POINT)
// 5188 
// 5189         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5190           if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> 3-point Leveling");
// 5191         #endif
// 5192 
// 5193         // Probe at 3 arbitrary points
// 5194         points[0].z = points[1].z = points[2].z = 0;
// 5195 
// 5196       #endif // AUTO_BED_LEVELING_3POINT
// 5197 
// 5198     } // !g29_in_progress
// 5199 
// 5200     #if ENABLED(PROBE_MANUALLY)
// 5201 
// 5202       // For manual probing, get the next index to probe now.
// 5203       // On the first probe this will be incremented to 0.
// 5204       if (!no_action) {
// 5205         ++abl_probe_index;
// 5206         g29_in_progress = true;
// 5207       }
// 5208 
// 5209       // Abort current G29 procedure, go back to idle state
// 5210       if (seenA && g29_in_progress) {
// 5211         SERIAL_PROTOCOLLNPGM("Manual G29 aborted");
// 5212         #if HAS_SOFTWARE_ENDSTOPS
// 5213           soft_endstops_enabled = enable_soft_endstops;
// 5214         #endif
// 5215         set_bed_leveling_enabled(abl_should_enable);
// 5216         g29_in_progress = false;
// 5217         #if ENABLED(LCD_BED_LEVELING)
// 5218           lcd_wait_for_move = false;
// 5219         #endif
// 5220       }
// 5221 
// 5222       // Query G29 status
// 5223       if (verbose_level || seenQ) {
// 5224         SERIAL_PROTOCOLPGM("Manual G29 ");
// 5225         if (g29_in_progress) {
// 5226           SERIAL_PROTOCOLPAIR("point ", min(abl_probe_index + 1, abl2));
// 5227           SERIAL_PROTOCOLLNPAIR(" of ", abl2);
// 5228         }
// 5229         else
// 5230           SERIAL_PROTOCOLLNPGM("idle");
// 5231       }
// 5232 
// 5233       if (no_action) return;
// 5234 
// 5235       if (abl_probe_index == 0) {
// 5236         // For the initial G29 save software endstop state
// 5237         #if HAS_SOFTWARE_ENDSTOPS
// 5238           enable_soft_endstops = soft_endstops_enabled;
// 5239         #endif
// 5240       }
// 5241       else {
// 5242         // For G29 after adjusting Z.
// 5243         // Save the previous Z before going to the next point
// 5244         measured_z = current_position[Z_AXIS];
// 5245 
// 5246         #if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5247 
// 5248           mean += measured_z;
// 5249           eqnBVector[abl_probe_index] = measured_z;
// 5250           eqnAMatrix[abl_probe_index + 0 * abl2] = xProbe;
// 5251           eqnAMatrix[abl_probe_index + 1 * abl2] = yProbe;
// 5252           eqnAMatrix[abl_probe_index + 2 * abl2] = 1;
// 5253 
// 5254           incremental_LSF(&lsf_results, xProbe, yProbe, measured_z);
// 5255 
// 5256         #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5257 
// 5258           z_values[xCount][yCount] = measured_z + zoffset;
// 5259 
// 5260           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5261             if (DEBUGGING(LEVELING)) {
// 5262               SERIAL_PROTOCOLPAIR("Save X", xCount);
// 5263               SERIAL_PROTOCOLPAIR(" Y", yCount);
// 5264               SERIAL_PROTOCOLLNPAIR(" Z", measured_z + zoffset);
// 5265             }
// 5266           #endif
// 5267 
// 5268         #elif ENABLED(AUTO_BED_LEVELING_3POINT)
// 5269 
// 5270           points[abl_probe_index].z = measured_z;
// 5271 
// 5272         #endif
// 5273       }
// 5274 
// 5275       //
// 5276       // If there's another point to sample, move there with optional lift.
// 5277       //
// 5278 
// 5279       #if ABL_GRID
// 5280 
// 5281         // Skip any unreachable points
// 5282         while (abl_probe_index < abl2) {
// 5283 
// 5284           // Set xCount, yCount based on abl_probe_index, with zig-zag
// 5285           PR_OUTER_VAR = abl_probe_index / PR_INNER_END;
// 5286           PR_INNER_VAR = abl_probe_index - (PR_OUTER_VAR * PR_INNER_END);
// 5287 
// 5288           // Probe in reverse order for every other row/column
// 5289           bool zig = (PR_OUTER_VAR & 1); // != ((PR_OUTER_END) & 1);
// 5290 
// 5291           if (zig) PR_INNER_VAR = (PR_INNER_END - 1) - PR_INNER_VAR;
// 5292 
// 5293           const float xBase = xCount * xGridSpacing + left_probe_bed_position,
// 5294                       yBase = yCount * yGridSpacing + front_probe_bed_position;
// 5295 
// 5296           xProbe = FLOOR(xBase + (xBase < 0 ? 0 : 0.5));
// 5297           yProbe = FLOOR(yBase + (yBase < 0 ? 0 : 0.5));
// 5298 
// 5299           #if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5300             indexIntoAB[xCount][yCount] = abl_probe_index;
// 5301           #endif
// 5302 
// 5303           // Keep looping till a reachable point is found
// 5304           if (position_is_reachable(xProbe, yProbe)) break;
// 5305           ++abl_probe_index;
// 5306         }
// 5307 
// 5308         // Is there a next point to move to?
// 5309         if (abl_probe_index < abl2) {
// 5310           _manual_goto_xy(xProbe, yProbe); // Can be used here too!
// 5311           #if HAS_SOFTWARE_ENDSTOPS
// 5312             // Disable software endstops to allow manual adjustment
// 5313             // If G29 is not completed, they will not be re-enabled
// 5314             soft_endstops_enabled = false;
// 5315           #endif
// 5316           return;
// 5317         }
// 5318         else {
// 5319 
// 5320           // Leveling done! Fall through to G29 finishing code below
// 5321 
// 5322           SERIAL_PROTOCOLLNPGM("Grid probing done.");
// 5323 
// 5324           // Re-enable software endstops, if needed
// 5325           #if HAS_SOFTWARE_ENDSTOPS
// 5326             soft_endstops_enabled = enable_soft_endstops;
// 5327           #endif
// 5328         }
// 5329 
// 5330       #elif ENABLED(AUTO_BED_LEVELING_3POINT)
// 5331 
// 5332         // Probe at 3 arbitrary points
// 5333         if (abl_probe_index < abl2) {
// 5334           xProbe = points[abl_probe_index].x;
// 5335           yProbe = points[abl_probe_index].y;
// 5336           _manual_goto_xy(xProbe, yProbe);
// 5337           #if HAS_SOFTWARE_ENDSTOPS
// 5338             // Disable software endstops to allow manual adjustment
// 5339             // If G29 is not completed, they will not be re-enabled
// 5340             soft_endstops_enabled = false;
// 5341           #endif
// 5342           return;
// 5343         }
// 5344         else {
// 5345 
// 5346           SERIAL_PROTOCOLLNPGM("3-point probing done.");
// 5347 
// 5348           // Re-enable software endstops, if needed
// 5349           #if HAS_SOFTWARE_ENDSTOPS
// 5350             soft_endstops_enabled = enable_soft_endstops;
// 5351           #endif
// 5352 
// 5353           if (!dryrun) {
// 5354             vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
// 5355             if (planeNormal.z < 0) {
// 5356               planeNormal.x *= -1;
// 5357               planeNormal.y *= -1;
// 5358               planeNormal.z *= -1;
// 5359             }
// 5360             planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
// 5361 
// 5362             // Can't re-enable (on error) until the new grid is written
// 5363             abl_should_enable = false;
// 5364           }
// 5365 
// 5366         }
// 5367 
// 5368       #endif // AUTO_BED_LEVELING_3POINT
// 5369 
// 5370     #else // !PROBE_MANUALLY
// 5371     {
// 5372       const bool stow_probe_after_each = parser.boolval('E');
// 5373 
// 5374       measured_z = 0;
// 5375 
// 5376       #if ABL_GRID
// 5377 
// 5378         bool zig = PR_OUTER_END & 1;  // Always end at RIGHT and BACK_PROBE_BED_POSITION
// 5379 
// 5380         measured_z = 0;
// 5381 
// 5382         // Outer loop is Y with PROBE_Y_FIRST disabled
// 5383         for (uint8_t PR_OUTER_VAR = 0; PR_OUTER_VAR < PR_OUTER_END && !isnan(measured_z); PR_OUTER_VAR++) {
// 5384 
// 5385           int8_t inStart, inStop, inInc;
// 5386 
// 5387           if (zig) { // away from origin
// 5388             inStart = 0;
// 5389             inStop = PR_INNER_END;
// 5390             inInc = 1;
// 5391           }
// 5392           else {     // towards origin
// 5393             inStart = PR_INNER_END - 1;
// 5394             inStop = -1;
// 5395             inInc = -1;
// 5396           }
// 5397 
// 5398           zig ^= true; // zag
// 5399 
// 5400           // Inner loop is Y with PROBE_Y_FIRST enabled
// 5401           for (int8_t PR_INNER_VAR = inStart; PR_INNER_VAR != inStop; PR_INNER_VAR += inInc) {
// 5402 
// 5403             float xBase = left_probe_bed_position + xGridSpacing * xCount,
// 5404                   yBase = front_probe_bed_position + yGridSpacing * yCount;
// 5405 
// 5406             xProbe = FLOOR(xBase + (xBase < 0 ? 0 : 0.5));
// 5407             yProbe = FLOOR(yBase + (yBase < 0 ? 0 : 0.5));
// 5408 
// 5409             #if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5410               indexIntoAB[xCount][yCount] = ++abl_probe_index; // 0...
// 5411             #endif
// 5412 
// 5413             #if IS_KINEMATIC
// 5414               // Avoid probing outside the round or hexagonal area
// 5415               if (!position_is_reachable_by_probe(xProbe, yProbe)) continue;
// 5416             #endif
// 5417 
// 5418             measured_z = faux ? 0.001 * random(-100, 101) : probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
// 5419 
// 5420             if (isnan(measured_z)) {
// 5421               set_bed_leveling_enabled(abl_should_enable);
// 5422               break;
// 5423             }
// 5424 
// 5425             #if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5426 
// 5427               mean += measured_z;
// 5428               eqnBVector[abl_probe_index] = measured_z;
// 5429               eqnAMatrix[abl_probe_index + 0 * abl2] = xProbe;
// 5430               eqnAMatrix[abl_probe_index + 1 * abl2] = yProbe;
// 5431               eqnAMatrix[abl_probe_index + 2 * abl2] = 1;
// 5432 
// 5433               incremental_LSF(&lsf_results, xProbe, yProbe, measured_z);
// 5434 
// 5435             #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5436 
// 5437               z_values[xCount][yCount] = measured_z + zoffset;
// 5438 
// 5439             #endif
// 5440 
// 5441             abl_should_enable = false;
// 5442             idle();
// 5443 
// 5444           } // inner
// 5445         } // outer
// 5446 
// 5447       #elif ENABLED(AUTO_BED_LEVELING_3POINT)
// 5448 
// 5449         // Probe at 3 arbitrary points
// 5450 
// 5451         for (uint8_t i = 0; i < 3; ++i) {
// 5452           // Retain the last probe position
// 5453           xProbe = points[i].x;
// 5454           yProbe = points[i].y;
// 5455           measured_z = faux ? 0.001 * random(-100, 101) : probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
// 5456           if (isnan(measured_z)) {
// 5457             set_bed_leveling_enabled(abl_should_enable);
// 5458             break;
// 5459           }
// 5460           points[i].z = measured_z;
// 5461         }
// 5462 
// 5463         if (!dryrun && !isnan(measured_z)) {
// 5464           vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
// 5465           if (planeNormal.z < 0) {
// 5466             planeNormal.x *= -1;
// 5467             planeNormal.y *= -1;
// 5468             planeNormal.z *= -1;
// 5469           }
// 5470           planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
// 5471 
// 5472           // Can't re-enable (on error) until the new grid is written
// 5473           abl_should_enable = false;
// 5474         }
// 5475 
// 5476       #endif // AUTO_BED_LEVELING_3POINT
// 5477 
// 5478       // Raise to _Z_CLEARANCE_DEPLOY_PROBE. Stow the probe.
// 5479       if (STOW_PROBE()) {
// 5480         set_bed_leveling_enabled(abl_should_enable);
// 5481         measured_z = NAN;
// 5482       }
// 5483     }
// 5484     #endif // !PROBE_MANUALLY
// 5485 
// 5486     //
// 5487     // G29 Finishing Code
// 5488     //
// 5489     // Unless this is a dry run, auto bed leveling will
// 5490     // definitely be enabled after this point.
// 5491     //
// 5492     // If code above wants to continue leveling, it should
// 5493     // return or loop before this point.
// 5494     //
// 5495 
// 5496     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5497       if (DEBUGGING(LEVELING)) DEBUG_POS("> probing complete", current_position);
// 5498     #endif
// 5499 
// 5500     #if ENABLED(PROBE_MANUALLY)
// 5501       g29_in_progress = false;
// 5502       #if ENABLED(LCD_BED_LEVELING)
// 5503         lcd_wait_for_move = false;
// 5504       #endif
// 5505     #endif
// 5506 
// 5507     // Calculate leveling, print reports, correct the position
// 5508     if (!isnan(measured_z)) {
// 5509       #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5510 
// 5511         if (!dryrun) extrapolate_unprobed_bed_level();
// 5512         print_bilinear_leveling_grid();
// 5513 
// 5514         refresh_bed_level();
// 5515 
// 5516         #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 5517           print_bilinear_leveling_grid_virt();
// 5518         #endif
// 5519 
// 5520       #elif ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5521 
// 5522         // For LINEAR leveling calculate matrix, print reports, correct the position
// 5523 
// 5524         /**
// 5525          * solve the plane equation ax + by + d = z
// 5526          * A is the matrix with rows [x y 1] for all the probed points
// 5527          * B is the vector of the Z positions
// 5528          * the normal vector to the plane is formed by the coefficients of the
// 5529          * plane equation in the standard form, which is Vx*x+Vy*y+Vz*z+d = 0
// 5530          * so Vx = -a Vy = -b Vz = 1 (we want the vector facing towards positive Z
// 5531          */
// 5532         float plane_equation_coefficients[3];
// 5533 
// 5534         finish_incremental_LSF(&lsf_results);
// 5535         plane_equation_coefficients[0] = -lsf_results.A;  // We should be able to eliminate the '-' on these three lines and down below
// 5536         plane_equation_coefficients[1] = -lsf_results.B;  // but that is not yet tested.
// 5537         plane_equation_coefficients[2] = -lsf_results.D;
// 5538 
// 5539         mean /= abl2;
// 5540 
// 5541         if (verbose_level) {
// 5542           SERIAL_PROTOCOLPGM("Eqn coefficients: a: ");
// 5543           SERIAL_PROTOCOL_F(plane_equation_coefficients[0], 8);
// 5544           SERIAL_PROTOCOLPGM(" b: ");
// 5545           SERIAL_PROTOCOL_F(plane_equation_coefficients[1], 8);
// 5546           SERIAL_PROTOCOLPGM(" d: ");
// 5547           SERIAL_PROTOCOL_F(plane_equation_coefficients[2], 8);
// 5548           SERIAL_EOL();
// 5549           if (verbose_level > 2) {
// 5550             SERIAL_PROTOCOLPGM("Mean of sampled points: ");
// 5551             SERIAL_PROTOCOL_F(mean, 8);
// 5552             SERIAL_EOL();
// 5553           }
// 5554         }
// 5555 
// 5556         // Create the matrix but don't correct the position yet
// 5557         if (!dryrun)
// 5558           planner.bed_level_matrix = matrix_3x3::create_look_at(
// 5559             vector_3(-plane_equation_coefficients[0], -plane_equation_coefficients[1], 1)    // We can eliminate the '-' here and up above
// 5560           );
// 5561 
// 5562         // Show the Topography map if enabled
// 5563         if (do_topography_map) {
// 5564 
// 5565           SERIAL_PROTOCOLLNPGM("\nBed Height Topography:\n"
// 5566                                  "   +--- BACK --+\n"
// 5567                                  "   |           |\n"
// 5568                                  " L |    (+)    | R\n"
// 5569                                  " E |           | I\n"
// 5570                                  " F | (-) N (+) | G\n"
// 5571                                  " T |           | H\n"
// 5572                                  "   |    (-)    | T\n"
// 5573                                  "   |           |\n"
// 5574                                  "   O-- FRONT --+\n"
// 5575                                  " (0,0)");
// 5576 
// 5577           float min_diff = 999;
// 5578 
// 5579           for (int8_t yy = abl_grid_points_y - 1; yy >= 0; yy--) {
// 5580             for (uint8_t xx = 0; xx < abl_grid_points_x; xx++) {
// 5581               int ind = indexIntoAB[xx][yy];
// 5582               float diff = eqnBVector[ind] - mean,
// 5583                     x_tmp = eqnAMatrix[ind + 0 * abl2],
// 5584                     y_tmp = eqnAMatrix[ind + 1 * abl2],
// 5585                     z_tmp = 0;
// 5586 
// 5587               apply_rotation_xyz(planner.bed_level_matrix, x_tmp, y_tmp, z_tmp);
// 5588 
// 5589               NOMORE(min_diff, eqnBVector[ind] - z_tmp);
// 5590 
// 5591               if (diff >= 0.0)
// 5592                 SERIAL_PROTOCOLPGM(" +");   // Include + for column alignment
// 5593               else
// 5594                 SERIAL_PROTOCOLCHAR(' ');
// 5595               SERIAL_PROTOCOL_F(diff, 5);
// 5596             } // xx
// 5597             SERIAL_EOL();
// 5598           } // yy
// 5599           SERIAL_EOL();
// 5600 
// 5601           if (verbose_level > 3) {
// 5602             SERIAL_PROTOCOLLNPGM("\nCorrected Bed Height vs. Bed Topology:");
// 5603 
// 5604             for (int8_t yy = abl_grid_points_y - 1; yy >= 0; yy--) {
// 5605               for (uint8_t xx = 0; xx < abl_grid_points_x; xx++) {
// 5606                 int ind = indexIntoAB[xx][yy];
// 5607                 float x_tmp = eqnAMatrix[ind + 0 * abl2],
// 5608                       y_tmp = eqnAMatrix[ind + 1 * abl2],
// 5609                       z_tmp = 0;
// 5610 
// 5611                 apply_rotation_xyz(planner.bed_level_matrix, x_tmp, y_tmp, z_tmp);
// 5612 
// 5613                 float diff = eqnBVector[ind] - z_tmp - min_diff;
// 5614                 if (diff >= 0.0)
// 5615                   SERIAL_PROTOCOLPGM(" +");
// 5616                 // Include + for column alignment
// 5617                 else
// 5618                   SERIAL_PROTOCOLCHAR(' ');
// 5619                 SERIAL_PROTOCOL_F(diff, 5);
// 5620               } // xx
// 5621               SERIAL_EOL();
// 5622             } // yy
// 5623             SERIAL_EOL();
// 5624           }
// 5625         } //do_topography_map
// 5626 
// 5627       #endif // AUTO_BED_LEVELING_LINEAR
// 5628 
// 5629       #if ABL_PLANAR
// 5630 
// 5631         // For LINEAR and 3POINT leveling correct the current position
// 5632 
// 5633         if (verbose_level > 0)
// 5634           planner.bed_level_matrix.debug(PSTR("\n\nBed Level Correction Matrix:"));
// 5635 
// 5636         if (!dryrun) {
// 5637           //
// 5638           // Correct the current XYZ position based on the tilted plane.
// 5639           //
// 5640 
// 5641           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5642             if (DEBUGGING(LEVELING)) DEBUG_POS("G29 uncorrected XYZ", current_position);
// 5643           #endif
// 5644 
// 5645           float converted[XYZ];
// 5646           COPY(converted, current_position);
// 5647 
// 5648           planner.leveling_active = true;
// 5649           planner.unapply_leveling(converted); // use conversion machinery
// 5650           planner.leveling_active = false;
// 5651 
// 5652           // Use the last measured distance to the bed, if possible
// 5653           if ( NEAR(current_position[X_AXIS], xProbe - (X_PROBE_OFFSET_FROM_EXTRUDER))
// 5654             && NEAR(current_position[Y_AXIS], yProbe - (Y_PROBE_OFFSET_FROM_EXTRUDER))
// 5655           ) {
// 5656             const float simple_z = current_position[Z_AXIS] - measured_z;
// 5657             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5658               if (DEBUGGING(LEVELING)) {
// 5659                 SERIAL_ECHOPAIR("Z from Probe:", simple_z);
// 5660                 SERIAL_ECHOPAIR("  Matrix:", converted[Z_AXIS]);
// 5661                 SERIAL_ECHOLNPAIR("  Discrepancy:", simple_z - converted[Z_AXIS]);
// 5662               }
// 5663             #endif
// 5664             converted[Z_AXIS] = simple_z;
// 5665           }
// 5666 
// 5667           // The rotated XY and corrected Z are now current_position
// 5668           COPY(current_position, converted);
// 5669 
// 5670           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5671             if (DEBUGGING(LEVELING)) DEBUG_POS("G29 corrected XYZ", current_position);
// 5672           #endif
// 5673         }
// 5674 
// 5675       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5676 
// 5677         if (!dryrun) {
// 5678           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5679             if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("G29 uncorrected Z:", current_position[Z_AXIS]);
// 5680           #endif
// 5681 
// 5682           // Unapply the offset because it is going to be immediately applied
// 5683           // and cause compensation movement in Z
// 5684           current_position[Z_AXIS] -= bilinear_z_offset(current_position);
// 5685 
// 5686           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5687             if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR(" corrected Z:", current_position[Z_AXIS]);
// 5688           #endif
// 5689         }
// 5690 
// 5691       #endif // ABL_PLANAR
// 5692 
// 5693       #ifdef Z_PROBE_END_SCRIPT
// 5694         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5695           if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
// 5696         #endif
// 5697         enqueue_and_echo_commands_P(PSTR(Z_PROBE_END_SCRIPT));
// 5698         stepper.synchronize();
// 5699       #endif
// 5700 
// 5701       // Auto Bed Leveling is complete! Enable if possible.
// 5702       planner.leveling_active = dryrun ? abl_should_enable : true;
// 5703     } // !isnan(measured_z)
// 5704 
// 5705     // Restore state after probing
// 5706     if (!faux) clean_up_after_endstop_or_probe_move();
// 5707 
// 5708     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5709       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< G29");
// 5710     #endif
// 5711 
// 5712     report_current_position();
// 5713 
// 5714     KEEPALIVE_STATE(IN_HANDLER);
// 5715 
// 5716     if (planner.leveling_active)
// 5717       SYNC_PLAN_POSITION_KINEMATIC();
// 5718   }
// 5719 
// 5720 #endif // OLDSCHOOL_ABL
// 5721 
// 5722 #if HAS_BED_PROBE
// 5723 
// 5724   /**
// 5725    * G30: Do a single Z probe at the current XY
// 5726    *
// 5727    * Parameters:
// 5728    *
// 5729    *   X   Probe X position (default current X)
// 5730    *   Y   Probe Y position (default current Y)
// 5731    *   E   Engage the probe for each probe
// 5732    */
// 5733   inline void gcode_G30() {
// 5734     const float xpos = parser.linearval('X', current_position[X_AXIS] + X_PROBE_OFFSET_FROM_EXTRUDER),
// 5735                 ypos = parser.linearval('Y', current_position[Y_AXIS] + Y_PROBE_OFFSET_FROM_EXTRUDER);
// 5736 
// 5737     if (!position_is_reachable_by_probe(xpos, ypos)) return;
// 5738 
// 5739     // Disable leveling so the planner won't mess with us
// 5740     #if HAS_LEVELING
// 5741       set_bed_leveling_enabled(false);
// 5742     #endif
// 5743 
// 5744     setup_for_endstop_or_probe_move();
// 5745 
// 5746     const float measured_z = probe_pt(xpos, ypos, parser.boolval('E'), 1);
// 5747 
// 5748     if (!isnan(measured_z)) {
// 5749       SERIAL_PROTOCOLPAIR("Bed X: ", FIXFLOAT(xpos));
// 5750       SERIAL_PROTOCOLPAIR(" Y: ", FIXFLOAT(ypos));
// 5751       SERIAL_PROTOCOLLNPAIR(" Z: ", FIXFLOAT(measured_z));
// 5752     }
// 5753 
// 5754     clean_up_after_endstop_or_probe_move();
// 5755 
// 5756     report_current_position();
// 5757   }
// 5758 
// 5759   #if ENABLED(Z_PROBE_SLED)
// 5760 
// 5761     /**
// 5762      * G31: Deploy the Z probe
// 5763      */
// 5764     inline void gcode_G31() { DEPLOY_PROBE(); }
// 5765 
// 5766     /**
// 5767      * G32: Stow the Z probe
// 5768      */
// 5769     inline void gcode_G32() { STOW_PROBE(); }
// 5770 
// 5771   #endif // Z_PROBE_SLED
// 5772 
// 5773 #endif // HAS_BED_PROBE
// 5774 
// 5775 #if ENABLED(DELTA_AUTO_CALIBRATION)
// 5776 
// 5777   constexpr uint8_t _7P_STEP = 1,              // 7-point step - to change number of calibration points
// 5778                     _4P_STEP = _7P_STEP * 2,   // 4-point step
// 5779                     NPP      = _7P_STEP * 6;   // number of calibration points on the radius
// 5780   enum CalEnum {                               // the 7 main calibration points - add definitions if needed
// 5781     CEN      = 0,
// 5782     __A      = 1,
// 5783     _AB      = __A + _7P_STEP,
// 5784     __B      = _AB + _7P_STEP,
// 5785     _BC      = __B + _7P_STEP,
// 5786     __C      = _BC + _7P_STEP,
// 5787     _CA      = __C + _7P_STEP,
// 5788   };
// 5789 
// 5790   #define LOOP_CAL_PT(VAR, S, N) for (uint8_t VAR=S; VAR<=NPP; VAR+=N)
// 5791   #define F_LOOP_CAL_PT(VAR, S, N) for (float VAR=S; VAR<NPP+0.9999; VAR+=N)
// 5792   #define I_LOOP_CAL_PT(VAR, S, N) for (float VAR=S; VAR>CEN+0.9999; VAR-=N)
// 5793   #define LOOP_CAL_ALL(VAR) LOOP_CAL_PT(VAR, CEN, 1)
// 5794   #define LOOP_CAL_RAD(VAR) LOOP_CAL_PT(VAR, __A, _7P_STEP)
// 5795   #define LOOP_CAL_ACT(VAR, _4P, _OP) LOOP_CAL_PT(VAR, _OP ? _AB : __A, _4P ? _4P_STEP : _7P_STEP)
// 5796 
// 5797   static void print_signed_float(const char * const prefix, const float &f) {
// 5798     SERIAL_PROTOCOLPGM("  ");
// 5799     serialprintPGM(prefix);
// 5800     SERIAL_PROTOCOLCHAR(':');
// 5801     if (f >= 0) SERIAL_CHAR('+');
// 5802     SERIAL_PROTOCOL_F(f, 2);
// 5803   }
// 5804 
// 5805   static void print_G33_settings(const bool end_stops, const bool tower_angles) {
// 5806     SERIAL_PROTOCOLPAIR(".Height:", delta_height);
// 5807     if (end_stops) {
// 5808       print_signed_float(PSTR("Ex"), delta_endstop_adj[A_AXIS]);
// 5809       print_signed_float(PSTR("Ey"), delta_endstop_adj[B_AXIS]);
// 5810       print_signed_float(PSTR("Ez"), delta_endstop_adj[C_AXIS]);
// 5811     }
// 5812     if (end_stops && tower_angles) {
// 5813       SERIAL_PROTOCOLPAIR("  Radius:", delta_radius);
// 5814       SERIAL_EOL();
// 5815       SERIAL_CHAR('.');
// 5816       SERIAL_PROTOCOL_SP(13);
// 5817     }
// 5818     if (tower_angles) {
// 5819       print_signed_float(PSTR("Tx"), delta_tower_angle_trim[A_AXIS]);
// 5820       print_signed_float(PSTR("Ty"), delta_tower_angle_trim[B_AXIS]);
// 5821       print_signed_float(PSTR("Tz"), delta_tower_angle_trim[C_AXIS]);
// 5822     }
// 5823     if ((!end_stops && tower_angles) || (end_stops && !tower_angles)) { // XOR
// 5824       SERIAL_PROTOCOLPAIR("  Radius:", delta_radius);
// 5825     }
// 5826     SERIAL_EOL();
// 5827   }
// 5828 
// 5829   static void print_G33_results(const float z_at_pt[NPP + 1], const bool tower_points, const bool opposite_points) {
// 5830     SERIAL_PROTOCOLPGM(".    ");
// 5831     print_signed_float(PSTR("c"), z_at_pt[CEN]);
// 5832     if (tower_points) {
// 5833       print_signed_float(PSTR(" x"), z_at_pt[__A]);
// 5834       print_signed_float(PSTR(" y"), z_at_pt[__B]);
// 5835       print_signed_float(PSTR(" z"), z_at_pt[__C]);
// 5836     }
// 5837     if (tower_points && opposite_points) {
// 5838       SERIAL_EOL();
// 5839       SERIAL_CHAR('.');
// 5840       SERIAL_PROTOCOL_SP(13);
// 5841     }
// 5842     if (opposite_points) {
// 5843       print_signed_float(PSTR("yz"), z_at_pt[_BC]);
// 5844       print_signed_float(PSTR("zx"), z_at_pt[_CA]);
// 5845       print_signed_float(PSTR("xy"), z_at_pt[_AB]);
// 5846     }
// 5847     SERIAL_EOL();
// 5848   }
// 5849 
// 5850   /**
// 5851    * After G33:
// 5852    *  - Move to the print ceiling (DELTA_HOME_TO_SAFE_ZONE only)
// 5853    *  - Stow the probe
// 5854    *  - Restore endstops state
// 5855    *  - Select the old tool, if needed
// 5856    */
// 5857   static void G33_cleanup(
// 5858     #if HOTENDS > 1
// 5859       const uint8_t old_tool_index
// 5860     #endif
// 5861   ) {
// 5862     #if ENABLED(DELTA_HOME_TO_SAFE_ZONE)
// 5863       do_blocking_move_to_z(delta_clip_start_height);
// 5864     #endif
// 5865     STOW_PROBE();
// 5866     clean_up_after_endstop_or_probe_move();
// 5867     #if HOTENDS > 1
// 5868       tool_change(old_tool_index, 0, true);
// 5869     #endif
// 5870   }
// 5871 
// 5872   inline float calibration_probe(const float nx, const float ny, const bool stow) {
// 5873     #if HAS_BED_PROBE
// 5874       return probe_pt(nx, ny, stow, 0, false);
// 5875     #else
// 5876       UNUSED(stow);
// 5877       return lcd_probe_pt(nx, ny);
// 5878     #endif
// 5879   }
// 5880 
// 5881   static float probe_G33_points(float z_at_pt[NPP + 1], const int8_t probe_points, const bool towers_set, const bool stow_after_each) {
// 5882     const bool _0p_calibration      = probe_points == 0,
// 5883                _1p_calibration      = probe_points == 1,
// 5884                _4p_calibration      = probe_points == 2,
// 5885                _4p_opposite_points  = _4p_calibration && !towers_set,
// 5886                _7p_calibration      = probe_points >= 3 || probe_points == 0,
// 5887                _7p_no_intermediates = probe_points == 3,
// 5888                _7p_1_intermediates  = probe_points == 4,
// 5889                _7p_2_intermediates  = probe_points == 5,
// 5890                _7p_4_intermediates  = probe_points == 6,
// 5891                _7p_6_intermediates  = probe_points == 7,
// 5892                _7p_8_intermediates  = probe_points == 8,
// 5893                _7p_11_intermediates = probe_points == 9,
// 5894                _7p_14_intermediates = probe_points == 10,
// 5895                _7p_intermed_points  = probe_points >= 4,
// 5896                _7p_6_centre         = probe_points >= 5 && probe_points <= 7,
// 5897                _7p_9_centre         = probe_points >= 8;
// 5898 
// 5899     LOOP_CAL_ALL(axis) z_at_pt[axis] = 0.0;
// 5900 
// 5901     if (!_0p_calibration) {
// 5902 
// 5903       if (!_7p_no_intermediates && !_7p_4_intermediates && !_7p_11_intermediates) { // probe the center
// 5904         z_at_pt[CEN] += calibration_probe(0, 0, stow_after_each);
// 5905         if (isnan(z_at_pt[CEN])) return NAN;
// 5906       }
// 5907 
// 5908       if (_7p_calibration) { // probe extra center points
// 5909         const float start  = _7p_9_centre ? _CA + _7P_STEP / 3.0 : _7p_6_centre ? _CA : __C,
// 5910                     steps  = _7p_9_centre ? _4P_STEP / 3.0 : _7p_6_centre ? _7P_STEP : _4P_STEP;
// 5911         I_LOOP_CAL_PT(axis, start, steps) {
// 5912           const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
// 5913                       r = delta_calibration_radius * 0.1;
// 5914           z_at_pt[CEN] += calibration_probe(cos(a) * r, sin(a) * r, stow_after_each);
// 5915           if (isnan(z_at_pt[CEN])) return NAN;
// 5916        }
// 5917         z_at_pt[CEN] /= float(_7p_2_intermediates ? 7 : probe_points);
// 5918       }
// 5919 
// 5920       if (!_1p_calibration) {  // probe the radius
// 5921         const CalEnum start  = _4p_opposite_points ? _AB : __A;
// 5922         const float   steps  = _7p_14_intermediates ? _7P_STEP / 15.0 : // 15r * 6 + 10c = 100
// 5923                                _7p_11_intermediates ? _7P_STEP / 12.0 : // 12r * 6 +  9c = 81
// 5924                                _7p_8_intermediates  ? _7P_STEP /  9.0 : //  9r * 6 + 10c = 64
// 5925                                _7p_6_intermediates  ? _7P_STEP /  7.0 : //  7r * 6 +  7c = 49
// 5926                                _7p_4_intermediates  ? _7P_STEP /  5.0 : //  5r * 6 +  6c = 36
// 5927                                _7p_2_intermediates  ? _7P_STEP /  3.0 : //  3r * 6 +  7c = 25
// 5928                                _7p_1_intermediates  ? _7P_STEP /  2.0 : //  2r * 6 +  4c = 16
// 5929                                _7p_no_intermediates ? _7P_STEP :        //  1r * 6 +  3c = 9
// 5930                                _4P_STEP;                                // .5r * 6 +  1c = 4
// 5931         bool zig_zag = true;
// 5932         F_LOOP_CAL_PT(axis, start, _7p_9_centre ? steps * 3 : steps) {
// 5933           const int8_t offset = _7p_9_centre ? 1 : 0;
// 5934           for (int8_t circle = -offset; circle <= offset; circle++) {
// 5935             const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
// 5936                         r = delta_calibration_radius * (1 + 0.1 * (zig_zag ? circle : - circle)),
// 5937                         interpol = fmod(axis, 1);
// 5938             const float z_temp = calibration_probe(cos(a) * r, sin(a) * r, stow_after_each);
// 5939             if (isnan(z_temp)) return NAN;
// 5940             // split probe point to neighbouring calibration points
// 5941             z_at_pt[uint8_t(round(axis - interpol + NPP - 1)) % NPP + 1] += z_temp * sq(cos(RADIANS(interpol * 90)));
// 5942             z_at_pt[uint8_t(round(axis - interpol))           % NPP + 1] += z_temp * sq(sin(RADIANS(interpol * 90)));
// 5943           }
// 5944           zig_zag = !zig_zag;
// 5945         }
// 5946         if (_7p_intermed_points)
// 5947           LOOP_CAL_RAD(axis)
// 5948             z_at_pt[axis] /= _7P_STEP / steps;
// 5949       }
// 5950 
// 5951       float S1 = z_at_pt[CEN],
// 5952             S2 = sq(z_at_pt[CEN]);
// 5953       int16_t N = 1;
// 5954       if (!_1p_calibration) { // std dev from zero plane
// 5955         LOOP_CAL_ACT(axis, _4p_calibration, _4p_opposite_points) {
// 5956           S1 += z_at_pt[axis];
// 5957           S2 += sq(z_at_pt[axis]);
// 5958           N++;
// 5959         }
// 5960         return round(SQRT(S2 / N) * 1000.0) / 1000.0 + 0.00001;
// 5961       }
// 5962     }
// 5963 
// 5964     return 0.00001;
// 5965   }
// 5966 
// 5967   #if HAS_BED_PROBE
// 5968 
// 5969     static bool G33_auto_tune() {
// 5970       float z_at_pt[NPP + 1]      = { 0.0 },
// 5971             z_at_pt_base[NPP + 1] = { 0.0 },
// 5972             z_temp, h_fac = 0.0, r_fac = 0.0, a_fac = 0.0, norm = 0.8;
// 5973 
// 5974       #define ZP(N,I) ((N) * z_at_pt[I])
// 5975       #define Z06(I)  ZP(6, I)
// 5976       #define Z03(I)  ZP(3, I)
// 5977       #define Z02(I)  ZP(2, I)
// 5978       #define Z01(I)  ZP(1, I)
// 5979       #define Z32(I)  ZP(3/2, I)
// 5980 
// 5981       SERIAL_PROTOCOLPGM("AUTO TUNE baseline");
// 5982       SERIAL_EOL();
// 5983       if (isnan(probe_G33_points(z_at_pt_base, 3, true, false))) return false;
// 5984       print_G33_results(z_at_pt_base, true, true);
// 5985 
// 5986       LOOP_XYZ(axis) {
// 5987         delta_endstop_adj[axis] -= 1.0;
// 5988         recalc_delta_settings();
// 5989 
// 5990         endstops.enable(true);
// 5991         if (!home_delta()) return false;
// 5992         endstops.not_homing();
// 5993 
// 5994         SERIAL_PROTOCOLPGM("Tuning E");
// 5995         SERIAL_CHAR(tolower(axis_codes[axis]));
// 5996         SERIAL_EOL();
// 5997 
// 5998         if (isnan(probe_G33_points(z_at_pt, 3, true, false))) return false;
// 5999         LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
// 6000         print_G33_results(z_at_pt, true, true);
// 6001         delta_endstop_adj[axis] += 1.0;
// 6002         recalc_delta_settings();
// 6003         switch (axis) {
// 6004           case A_AXIS :
// 6005             h_fac += 4.0 / (Z03(CEN) +Z01(__A)                               +Z32(_CA) +Z32(_AB)); // Offset by X-tower end-stop
// 6006             break;
// 6007           case B_AXIS :
// 6008             h_fac += 4.0 / (Z03(CEN)           +Z01(__B)           +Z32(_BC)           +Z32(_AB)); // Offset by Y-tower end-stop
// 6009             break;
// 6010           case C_AXIS :
// 6011             h_fac += 4.0 / (Z03(CEN)                     +Z01(__C) +Z32(_BC) +Z32(_CA)          ); // Offset by Z-tower end-stop
// 6012             break;
// 6013         }
// 6014       }
// 6015       h_fac /= 3.0;
// 6016       h_fac *= norm; // Normalize to 1.02 for Kossel mini
// 6017 
// 6018       for (int8_t zig_zag = -1; zig_zag < 2; zig_zag += 2) {
// 6019         delta_radius += 1.0 * zig_zag;
// 6020         recalc_delta_settings();
// 6021 
// 6022         endstops.enable(true);
// 6023         if (!home_delta()) return false;
// 6024         endstops.not_homing();
// 6025 
// 6026         SERIAL_PROTOCOLPGM("Tuning R");
// 6027         SERIAL_PROTOCOL(zig_zag == -1 ? "-" : "+");
// 6028         SERIAL_EOL();
// 6029         if (isnan(probe_G33_points(z_at_pt, 3, true, false))) return false;
// 6030         LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
// 6031         print_G33_results(z_at_pt, true, true);
// 6032         delta_radius -= 1.0 * zig_zag;
// 6033         recalc_delta_settings();
// 6034         r_fac -= zig_zag * 6.0 / (Z03(__A) +Z03(__B) +Z03(__C) +Z03(_BC) +Z03(_CA) +Z03(_AB)); // Offset by delta radius
// 6035       }
// 6036       r_fac /= 2.0;
// 6037       r_fac *= 3 * norm; // Normalize to 2.25 for Kossel mini
// 6038 
// 6039       LOOP_XYZ(axis) {
// 6040         delta_tower_angle_trim[axis] += 1.0;
// 6041         delta_endstop_adj[(axis + 1) % 3] -= 1.0 / 4.5;
// 6042         delta_endstop_adj[(axis + 2) % 3] += 1.0 / 4.5;
// 6043         z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
// 6044         delta_height -= z_temp;
// 6045         LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
// 6046         recalc_delta_settings();
// 6047 
// 6048         endstops.enable(true);
// 6049         if (!home_delta()) return false;
// 6050         endstops.not_homing();
// 6051 
// 6052         SERIAL_PROTOCOLPGM("Tuning T");
// 6053         SERIAL_CHAR(tolower(axis_codes[axis]));
// 6054         SERIAL_EOL();
// 6055 
// 6056         if (isnan(probe_G33_points(z_at_pt, 3, true, false))) return false;
// 6057         LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
// 6058         print_G33_results(z_at_pt, true, true);
// 6059 
// 6060         delta_tower_angle_trim[axis] -= 1.0;
// 6061         delta_endstop_adj[(axis+1) % 3] += 1.0/4.5;
// 6062         delta_endstop_adj[(axis+2) % 3] -= 1.0/4.5;
// 6063         z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
// 6064         delta_height -= z_temp;
// 6065         LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
// 6066         recalc_delta_settings();
// 6067         switch (axis) {
// 6068           case A_AXIS :
// 6069             a_fac += 4.0 / (          Z06(__B) -Z06(__C)           +Z06(_CA) -Z06(_AB)); // Offset by alpha tower angle
// 6070             break;
// 6071           case B_AXIS :
// 6072             a_fac += 4.0 / (-Z06(__A)          +Z06(__C) -Z06(_BC)           +Z06(_AB)); // Offset by beta tower angle
// 6073             break;
// 6074           case C_AXIS :
// 6075             a_fac += 4.0 / (Z06(__A) -Z06(__B)           +Z06(_BC) -Z06(_CA)          ); // Offset by gamma tower angle
// 6076             break;
// 6077         }
// 6078       }
// 6079       a_fac /= 3.0;
// 6080       a_fac *= norm; // Normalize to 0.83 for Kossel mini
// 6081 
// 6082       endstops.enable(true);
// 6083       if (!home_delta()) return false;
// 6084       endstops.not_homing();
// 6085       print_signed_float(PSTR( "H_FACTOR: "), h_fac);
// 6086       print_signed_float(PSTR(" R_FACTOR: "), r_fac);
// 6087       print_signed_float(PSTR(" A_FACTOR: "), a_fac);
// 6088       SERIAL_EOL();
// 6089       SERIAL_PROTOCOLPGM("Copy these values to Configuration.h");
// 6090       SERIAL_EOL();
// 6091       return true;
// 6092     }
// 6093 
// 6094   #endif // HAS_BED_PROBE
// 6095 
// 6096   /**
// 6097    * G33 - Delta '1-4-7-point' Auto-Calibration
// 6098    *       Calibrate height, endstops, delta radius, and tower angles.
// 6099    *
// 6100    * Parameters:
// 6101    *
// 6102    *   Pn  Number of probe points:
// 6103    *      P0     No probe. Normalize only.
// 6104    *      P1     Probe center and set height only.
// 6105    *      P2     Probe center and towers. Set height, endstops and delta radius.
// 6106    *      P3     Probe all positions: center, towers and opposite towers. Set all.
// 6107    *      P4-P10 Probe all positions + at different itermediate locations and average them.
// 6108    *
// 6109    *   T   Don't calibrate tower angle corrections
// 6110    *
// 6111    *   Cn.nn  Calibration precision; when omitted calibrates to maximum precision
// 6112    *
// 6113    *   Fn  Force to run at least n iterations and takes the best result
// 6114    *
// 6115    *   A   Auto tune calibartion factors (set in Configuration.h)
// 6116    *
// 6117    *   Vn  Verbose level:
// 6118    *      V0  Dry-run mode. Report settings and probe results. No calibration.
// 6119    *      V1  Report start and end settings only
// 6120    *      V2  Report settings at each iteration
// 6121    *      V3  Report settings and probe results
// 6122    *
// 6123    *   E   Engage the probe for each point
// 6124    */
// 6125   inline void gcode_G33() {
// 6126 
// 6127     const int8_t probe_points = parser.intval('P', DELTA_CALIBRATION_DEFAULT_POINTS);
// 6128     if (!WITHIN(probe_points, 0, 10)) {
// 6129       SERIAL_PROTOCOLLNPGM("?(P)oints is implausible (0-10).");
// 6130       return;
// 6131     }
// 6132 
// 6133     const int8_t verbose_level = parser.byteval('V', 1);
// 6134     if (!WITHIN(verbose_level, 0, 3)) {
// 6135       SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-3).");
// 6136       return;
// 6137     }
// 6138 
// 6139     const float calibration_precision = parser.floatval('C', 0.0);
// 6140     if (calibration_precision < 0) {
// 6141       SERIAL_PROTOCOLLNPGM("?(C)alibration precision is implausible (>=0).");
// 6142       return;
// 6143     }
// 6144 
// 6145     const int8_t force_iterations = parser.intval('F', 0);
// 6146     if (!WITHIN(force_iterations, 0, 30)) {
// 6147       SERIAL_PROTOCOLLNPGM("?(F)orce iteration is implausible (0-30).");
// 6148       return;
// 6149     }
// 6150 
// 6151     const bool towers_set           = !parser.boolval('T'),
// 6152                auto_tune            = parser.boolval('A'),
// 6153                stow_after_each      = parser.boolval('E'),
// 6154                _0p_calibration      = probe_points == 0,
// 6155                _1p_calibration      = probe_points == 1,
// 6156                _4p_calibration      = probe_points == 2,
// 6157                _7p_9_centre         = probe_points >= 8,
// 6158                _tower_results       = (_4p_calibration && towers_set)
// 6159                                       || probe_points >= 3 || probe_points == 0,
// 6160                _opposite_results    = (_4p_calibration && !towers_set)
// 6161                                       || probe_points >= 3 || probe_points == 0,
// 6162                _endstop_results     = probe_points != 1,
// 6163                _angle_results       = (probe_points >= 3 || probe_points == 0) && towers_set;
// 6164     const static char save_message[] PROGMEM = "Save with M500 and/or copy to Configuration.h";
// 6165     int8_t iterations = 0;
// 6166     float test_precision,
// 6167           zero_std_dev = (verbose_level ? 999.0 : 0.0), // 0.0 in dry-run mode : forced end
// 6168           zero_std_dev_min = zero_std_dev,
// 6169           e_old[ABC] = {
// 6170             delta_endstop_adj[A_AXIS],
// 6171             delta_endstop_adj[B_AXIS],
// 6172             delta_endstop_adj[C_AXIS]
// 6173           },
// 6174           dr_old = delta_radius,
// 6175           zh_old = delta_height,
// 6176           ta_old[ABC] = {
// 6177             delta_tower_angle_trim[A_AXIS],
// 6178             delta_tower_angle_trim[B_AXIS],
// 6179             delta_tower_angle_trim[C_AXIS]
// 6180           };
// 6181 
// 6182     SERIAL_PROTOCOLLNPGM("G33 Auto Calibrate");
// 6183 
// 6184     if (!_1p_calibration && !_0p_calibration) {  // test if the outer radius is reachable
// 6185       LOOP_CAL_RAD(axis) {
// 6186         const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
// 6187                     r = delta_calibration_radius * (1 + (_7p_9_centre ? 0.1 : 0.0));
// 6188         if (!position_is_reachable(cos(a) * r, sin(a) * r)) {
// 6189           SERIAL_PROTOCOLLNPGM("?(M665 B)ed radius is implausible.");
// 6190           return;
// 6191         }
// 6192       }
// 6193     }
// 6194 
// 6195     stepper.synchronize();
// 6196     #if HAS_LEVELING
// 6197       reset_bed_level(); // After calibration bed-level data is no longer valid
// 6198     #endif
// 6199 
// 6200     #if HOTENDS > 1
// 6201       const uint8_t old_tool_index = active_extruder;
// 6202       tool_change(0, 0, true);
// 6203       #define G33_CLEANUP() G33_cleanup(old_tool_index)
// 6204     #else
// 6205       #define G33_CLEANUP() G33_cleanup()
// 6206     #endif
// 6207 
// 6208     setup_for_endstop_or_probe_move();
// 6209     endstops.enable(true);
// 6210     if (!_0p_calibration) {
// 6211       if (!home_delta())
// 6212         return;
// 6213       endstops.not_homing();
// 6214     }
// 6215 
// 6216     if (auto_tune) {
// 6217       #if HAS_BED_PROBE
// 6218         G33_auto_tune();
// 6219       #else
// 6220         SERIAL_PROTOCOLLNPGM("A probe is needed for auto-tune");
// 6221       #endif
// 6222       G33_CLEANUP();
// 6223       return;
// 6224     }
// 6225 
// 6226     // Report settings
// 6227 
// 6228     const char *checkingac = PSTR("Checking... AC"); // TODO: Make translatable string
// 6229     serialprintPGM(checkingac);
// 6230     if (verbose_level == 0) SERIAL_PROTOCOLPGM(" (DRY-RUN)");
// 6231     SERIAL_EOL();
// 6232     lcd_setstatusPGM(checkingac);
// 6233 
// 6234     print_G33_settings(_endstop_results, _angle_results);
// 6235 
// 6236     do {
// 6237 
// 6238       float z_at_pt[NPP + 1] = { 0.0 };
// 6239 
// 6240       test_precision = zero_std_dev;
// 6241 
// 6242       iterations++;
// 6243 
// 6244       // Probe the points
// 6245 
// 6246       zero_std_dev = probe_G33_points(z_at_pt, probe_points, towers_set, stow_after_each);
// 6247       if (isnan(zero_std_dev)) {
// 6248         SERIAL_PROTOCOLPGM("Correct delta_radius with M665 R or end-stops with M666 X Y Z");
// 6249         SERIAL_EOL();
// 6250         return G33_CLEANUP();
// 6251       }
// 6252 
// 6253       // Solve matrices
// 6254 
// 6255       if ((zero_std_dev < test_precision || iterations <= force_iterations) && zero_std_dev > calibration_precision) {
// 6256         if (zero_std_dev < zero_std_dev_min) {
// 6257           COPY(e_old, delta_endstop_adj);
// 6258           dr_old = delta_radius;
// 6259           zh_old = delta_height;
// 6260           COPY(ta_old, delta_tower_angle_trim);
// 6261         }
// 6262 
// 6263         float e_delta[ABC] = { 0.0 }, r_delta = 0.0, t_delta[ABC] = { 0.0 };
// 6264         const float r_diff = delta_radius - delta_calibration_radius,
// 6265                     h_factor = 1 / 6.0 *
// 6266                       #ifdef H_FACTOR
// 6267                         (H_FACTOR),                                       // Set in Configuration.h
// 6268                       #else
// 6269                         (1.00 + r_diff * 0.001),                          // 1.02 for r_diff = 20mm
// 6270                       #endif
// 6271                     r_factor = 1 / 6.0 *
// 6272                       #ifdef R_FACTOR
// 6273                         -(R_FACTOR),                                      // Set in Configuration.h
// 6274                       #else
// 6275                         -(1.75 + 0.005 * r_diff + 0.001 * sq(r_diff)),    // 2.25 for r_diff = 20mm
// 6276                       #endif
// 6277                     a_factor = 1 / 6.0 *
// 6278                       #ifdef A_FACTOR
// 6279                         (A_FACTOR);                                       // Set in Configuration.h
// 6280                       #else
// 6281                         (66.66 / delta_calibration_radius);               // 0.83 for cal_rd = 80mm
// 6282                       #endif
// 6283 
// 6284         #define ZP(N,I) ((N) * z_at_pt[I])
// 6285         #define Z6(I) ZP(6, I)
// 6286         #define Z4(I) ZP(4, I)
// 6287         #define Z2(I) ZP(2, I)
// 6288         #define Z1(I) ZP(1, I)
// 6289 
// 6290         #if !HAS_BED_PROBE
// 6291           test_precision = 0.00; // forced end
// 6292         #endif
// 6293 
// 6294         switch (probe_points) {
// 6295           case 0:
// 6296             test_precision = 0.00; // forced end
// 6297             break;
// 6298 
// 6299           case 1:
// 6300             test_precision = 0.00; // forced end
// 6301             LOOP_XYZ(axis) e_delta[axis] = Z1(CEN);
// 6302             break;
// 6303 
// 6304           case 2:
// 6305             if (towers_set) {
// 6306               e_delta[A_AXIS] = (Z6(CEN) +Z4(__A) -Z2(__B) -Z2(__C)) * h_factor;
// 6307               e_delta[B_AXIS] = (Z6(CEN) -Z2(__A) +Z4(__B) -Z2(__C)) * h_factor;
// 6308               e_delta[C_AXIS] = (Z6(CEN) -Z2(__A) -Z2(__B) +Z4(__C)) * h_factor;
// 6309               r_delta         = (Z6(CEN) -Z2(__A) -Z2(__B) -Z2(__C)) * r_factor;
// 6310             }
// 6311             else {
// 6312               e_delta[A_AXIS] = (Z6(CEN) -Z4(_BC) +Z2(_CA) +Z2(_AB)) * h_factor;
// 6313               e_delta[B_AXIS] = (Z6(CEN) +Z2(_BC) -Z4(_CA) +Z2(_AB)) * h_factor;
// 6314               e_delta[C_AXIS] = (Z6(CEN) +Z2(_BC) +Z2(_CA) -Z4(_AB)) * h_factor;
// 6315               r_delta         = (Z6(CEN) -Z2(_BC) -Z2(_CA) -Z2(_AB)) * r_factor;
// 6316             }
// 6317             break;
// 6318 
// 6319           default:
// 6320             e_delta[A_AXIS] = (Z6(CEN) +Z2(__A) -Z1(__B) -Z1(__C) -Z2(_BC) +Z1(_CA) +Z1(_AB)) * h_factor;
// 6321             e_delta[B_AXIS] = (Z6(CEN) -Z1(__A) +Z2(__B) -Z1(__C) +Z1(_BC) -Z2(_CA) +Z1(_AB)) * h_factor;
// 6322             e_delta[C_AXIS] = (Z6(CEN) -Z1(__A) -Z1(__B) +Z2(__C) +Z1(_BC) +Z1(_CA) -Z2(_AB)) * h_factor;
// 6323             r_delta         = (Z6(CEN) -Z1(__A) -Z1(__B) -Z1(__C) -Z1(_BC) -Z1(_CA) -Z1(_AB)) * r_factor;
// 6324 
// 6325             if (towers_set) {
// 6326               t_delta[A_AXIS] = (         -Z4(__B) +Z4(__C)          -Z4(_CA) +Z4(_AB)) * a_factor;
// 6327               t_delta[B_AXIS] = ( Z4(__A)          -Z4(__C) +Z4(_BC)          -Z4(_AB)) * a_factor;
// 6328               t_delta[C_AXIS] = (-Z4(__A) +Z4(__B)          -Z4(_BC) +Z4(_CA)         ) * a_factor;
// 6329               e_delta[A_AXIS] += (t_delta[B_AXIS] - t_delta[C_AXIS]) / 4.5;
// 6330               e_delta[B_AXIS] += (t_delta[C_AXIS] - t_delta[A_AXIS]) / 4.5;
// 6331               e_delta[C_AXIS] += (t_delta[A_AXIS] - t_delta[B_AXIS]) / 4.5;
// 6332             }
// 6333             break;
// 6334         }
// 6335 
// 6336         LOOP_XYZ(axis) delta_endstop_adj[axis] += e_delta[axis];
// 6337         delta_radius += r_delta;
// 6338         LOOP_XYZ(axis) delta_tower_angle_trim[axis] += t_delta[axis];
// 6339       }
// 6340       else if (zero_std_dev >= test_precision) {   // step one back
// 6341         COPY(delta_endstop_adj, e_old);
// 6342         delta_radius = dr_old;
// 6343         delta_height = zh_old;
// 6344         COPY(delta_tower_angle_trim, ta_old);
// 6345       }
// 6346 
// 6347       if (verbose_level != 0) {                                    // !dry run
// 6348         // normalise angles to least squares
// 6349         if (_angle_results) {
// 6350           float a_sum = 0.0;
// 6351           LOOP_XYZ(axis) a_sum += delta_tower_angle_trim[axis];
// 6352           LOOP_XYZ(axis) delta_tower_angle_trim[axis] -= a_sum / 3.0;
// 6353         }
// 6354 
// 6355         // adjust delta_height and endstops by the max amount
// 6356         const float z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
// 6357         delta_height -= z_temp;
// 6358         LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
// 6359       }
// 6360       recalc_delta_settings();
// 6361       NOMORE(zero_std_dev_min, zero_std_dev);
// 6362 
// 6363       // print report
// 6364 
// 6365       if (verbose_level > 2)
// 6366         print_G33_results(z_at_pt, _tower_results, _opposite_results);
// 6367 
// 6368       if (verbose_level != 0) {                                    // !dry run
// 6369         if ((zero_std_dev >= test_precision && iterations > force_iterations) || zero_std_dev <= calibration_precision) {  // end iterations
// 6370           SERIAL_PROTOCOLPGM("Calibration OK");
// 6371           SERIAL_PROTOCOL_SP(32);
// 6372           #if HAS_BED_PROBE
// 6373             if (zero_std_dev >= test_precision && !_1p_calibration)
// 6374               SERIAL_PROTOCOLPGM("rolling back.");
// 6375             else
// 6376           #endif
// 6377             {
// 6378               SERIAL_PROTOCOLPGM("std dev:");
// 6379               SERIAL_PROTOCOL_F(zero_std_dev_min, 3);
// 6380             }
// 6381           SERIAL_EOL();
// 6382           char mess[21];
// 6383           strcpy_P(mess, PSTR("Calibration sd:"));
// 6384           if (zero_std_dev_min < 1)
// 6385             sprintf_P(&mess[15], PSTR("0.%03i"), (int)round(zero_std_dev_min * 1000.0));
// 6386           else
// 6387             sprintf_P(&mess[15], PSTR("%03i.x"), (int)round(zero_std_dev_min));
// 6388           lcd_setstatus(mess);
// 6389           print_G33_settings(_endstop_results, _angle_results);
// 6390           serialprintPGM(save_message);
// 6391           SERIAL_EOL();
// 6392         }
// 6393         else {                                                     // !end iterations
// 6394           char mess[15];
// 6395           if (iterations < 31)
// 6396             sprintf_P(mess, PSTR("Iteration : %02i"), (int)iterations);
// 6397           else
// 6398             strcpy_P(mess, PSTR("No convergence"));
// 6399           SERIAL_PROTOCOL(mess);
// 6400           SERIAL_PROTOCOL_SP(32);
// 6401           SERIAL_PROTOCOLPGM("std dev:");
// 6402           SERIAL_PROTOCOL_F(zero_std_dev, 3);
// 6403           SERIAL_EOL();
// 6404           lcd_setstatus(mess);
// 6405           if (verbose_level > 1)
// 6406             print_G33_settings(_endstop_results, _angle_results);
// 6407         }
// 6408       }
// 6409       else {                                                       // dry run
// 6410         const char *enddryrun = PSTR("End DRY-RUN");
// 6411         serialprintPGM(enddryrun);
// 6412         SERIAL_PROTOCOL_SP(35);
// 6413         SERIAL_PROTOCOLPGM("std dev:");
// 6414         SERIAL_PROTOCOL_F(zero_std_dev, 3);
// 6415         SERIAL_EOL();
// 6416 
// 6417         char mess[21];
// 6418         strcpy_P(mess, enddryrun);
// 6419         strcpy_P(&mess[11], PSTR(" sd:"));
// 6420         if (zero_std_dev < 1)
// 6421           sprintf_P(&mess[15], PSTR("0.%03i"), (int)round(zero_std_dev * 1000.0));
// 6422         else
// 6423           sprintf_P(&mess[15], PSTR("%03i.x"), (int)round(zero_std_dev));
// 6424         lcd_setstatus(mess);
// 6425       }
// 6426 
// 6427       endstops.enable(true);
// 6428       if (!home_delta())
// 6429         return;
// 6430       endstops.not_homing();
// 6431 
// 6432     }
// 6433     while (((zero_std_dev < test_precision && iterations < 31) || iterations <= force_iterations) && zero_std_dev > calibration_precision);
// 6434 
// 6435     G33_CLEANUP();
// 6436   }
// 6437 
// 6438 #endif // DELTA_AUTO_CALIBRATION
// 6439 
// 6440 #if ENABLED(G38_PROBE_TARGET)
// 6441 
// 6442   static bool G38_run_probe() {
// 6443 
// 6444     bool G38_pass_fail = false;
// 6445 
// 6446     #if MULTIPLE_PROBING > 1
// 6447       // Get direction of move and retract
// 6448       float retract_mm[XYZ];
// 6449       LOOP_XYZ(i) {
// 6450         float dist = destination[i] - current_position[i];
// 6451         retract_mm[i] = FABS(dist) < G38_MINIMUM_MOVE ? 0 : home_bump_mm((AxisEnum)i) * (dist > 0 ? -1 : 1);
// 6452       }
// 6453     #endif
// 6454 
// 6455     stepper.synchronize();  // wait until the machine is idle
// 6456 
// 6457     // Move until destination reached or target hit
// 6458     endstops.enable(true);
// 6459     G38_move = true;
// 6460     G38_endstop_hit = false;
// 6461     prepare_move_to_destination();
// 6462     stepper.synchronize();
// 6463     G38_move = false;
// 6464 
// 6465     endstops.hit_on_purpose();
// 6466     set_current_from_steppers_for_axis(ALL_AXES);
// 6467     SYNC_PLAN_POSITION_KINEMATIC();
// 6468 
// 6469     if (G38_endstop_hit) {
// 6470 
// 6471       G38_pass_fail = true;
// 6472 
// 6473       #if MULTIPLE_PROBING > 1
// 6474         // Move away by the retract distance
// 6475         set_destination_from_current();
// 6476         LOOP_XYZ(i) destination[i] += retract_mm[i];
// 6477         endstops.enable(false);
// 6478         prepare_move_to_destination();
// 6479         stepper.synchronize();
// 6480 
// 6481         feedrate_mm_s /= 4;
// 6482 
// 6483         // Bump the target more slowly
// 6484         LOOP_XYZ(i) destination[i] -= retract_mm[i] * 2;
// 6485 
// 6486         endstops.enable(true);
// 6487         G38_move = true;
// 6488         prepare_move_to_destination();
// 6489         stepper.synchronize();
// 6490         G38_move = false;
// 6491 
// 6492         set_current_from_steppers_for_axis(ALL_AXES);
// 6493         SYNC_PLAN_POSITION_KINEMATIC();
// 6494       #endif
// 6495     }
// 6496 
// 6497     endstops.hit_on_purpose();
// 6498     endstops.not_homing();
// 6499     return G38_pass_fail;
// 6500   }
// 6501 
// 6502   /**
// 6503    * G38.2 - probe toward workpiece, stop on contact, signal error if failure
// 6504    * G38.3 - probe toward workpiece, stop on contact
// 6505    *
// 6506    * Like G28 except uses Z min probe for all axes
// 6507    */
// 6508   inline void gcode_G38(bool is_38_2) {
// 6509     // Get X Y Z E F
// 6510     gcode_get_destination();
// 6511 
// 6512     setup_for_endstop_or_probe_move();
// 6513 
// 6514     // If any axis has enough movement, do the move
// 6515     LOOP_XYZ(i)
// 6516       if (FABS(destination[i] - current_position[i]) >= G38_MINIMUM_MOVE) {
// 6517         if (!parser.seenval('F')) feedrate_mm_s = homing_feedrate_mm_s[(AxisEnum)i];
// 6518         // If G38.2 fails throw an error
// 6519         if (!G38_run_probe() && is_38_2) {
// 6520           SERIAL_ERROR_START();
// 6521           SERIAL_ERRORLNPGM("Failed to reach target");
// 6522         }
// 6523         break;
// 6524       }
// 6525 
// 6526     clean_up_after_endstop_or_probe_move();
// 6527   }
// 6528 
// 6529 #endif // G38_PROBE_TARGET
// 6530 
// 6531 #if HAS_MESH
// 6532 
// 6533   /**
// 6534    * G42: Move X & Y axes to mesh coordinates (I & J)
// 6535    */
// 6536   inline void gcode_G42() {
// 6537     #if ENABLED(NO_MOTION_BEFORE_HOMING)
// 6538       if (axis_unhomed_error()) return;
// 6539     #endif
// 6540 
// 6541     if (IsRunning()) {
// 6542       const bool hasI = parser.seenval('I');
// 6543       const int8_t ix = hasI ? parser.value_int() : 0;
// 6544       const bool hasJ = parser.seenval('J');
// 6545       const int8_t iy = hasJ ? parser.value_int() : 0;
// 6546 
// 6547       if ((hasI && !WITHIN(ix, 0, GRID_MAX_POINTS_X - 1)) || (hasJ && !WITHIN(iy, 0, GRID_MAX_POINTS_Y - 1))) {
// 6548         SERIAL_ECHOLNPGM(MSG_ERR_MESH_XY);
// 6549         return;
// 6550       }
// 6551 
// 6552       set_destination_from_current();
// 6553       if (hasI) destination[X_AXIS] = _GET_MESH_X(ix);
// 6554       if (hasJ) destination[Y_AXIS] = _GET_MESH_Y(iy);
// 6555       if (parser.boolval('P')) {
// 6556         if (hasI) destination[X_AXIS] -= X_PROBE_OFFSET_FROM_EXTRUDER;
// 6557         if (hasJ) destination[Y_AXIS] -= Y_PROBE_OFFSET_FROM_EXTRUDER;
// 6558       }
// 6559 
// 6560       const float fval = parser.linearval('F');
// 6561       if (fval > 0.0) feedrate_mm_s = MMM_TO_MMS(fval);
// 6562 
// 6563       // SCARA kinematic has "safe" XY raw moves
// 6564       #if IS_SCARA
// 6565         prepare_uninterpolated_move_to_destination();
// 6566       #else
// 6567         prepare_move_to_destination();
// 6568       #endif
// 6569     }
// 6570   }
// 6571 
// 6572 #endif // HAS_MESH
// 6573 
// 6574 /**
// 6575  * G92: Set current position to given X Y Z E
// 6576  */
// 6577 inline void gcode_G92() {
// 6578 
// 6579   stepper.synchronize();
// 6580 
// 6581   #if ENABLED(CNC_COORDINATE_SYSTEMS)
// 6582     switch (parser.subcode) {
// 6583       case 1:
// 6584         // Zero the G92 values and restore current position
// 6585         #if !IS_SCARA
// 6586           LOOP_XYZ(i) {
// 6587             const float v = position_shift[i];
// 6588             if (v) {
// 6589               position_shift[i] = 0;
// 6590               update_software_endstops((AxisEnum)i);
// 6591             }
// 6592           }
// 6593         #endif // Not SCARA
// 6594         return;
// 6595     }
// 6596   #endif
// 6597 
// 6598   #if ENABLED(CNC_COORDINATE_SYSTEMS)
// 6599     #define IS_G92_0 (parser.subcode == 0)
// 6600   #else
// 6601     #define IS_G92_0 true
// 6602   #endif
// 6603 
// 6604   bool didE = false;
// 6605 //  #if IS_SCARA || !HAS_POSITION_SHIFT
// 6606   #if 1	//mks dlp
// 6607     bool didXYZ = false;
// 6608   #else
// 6609     constexpr bool didXYZ = false;
// 6610   #endif
// 6611 
// 6612   if (IS_G92_0) LOOP_XYZE(i) {
// 6613     if (parser.seenval(axis_codes[i])) {
// 6614       const float l = parser.value_axis_units((AxisEnum)i),
// 6615                   v = i == E_AXIS ? l : LOGICAL_TO_NATIVE(l, i),
// 6616                   d = v - current_position[i];
// 6617       if (!NEAR_ZERO(d)) {
// 6618         //#if IS_SCARA || !HAS_POSITION_SHIFT
// 6619 		#if 1	//mks dlp
// 6620           if (i == E_AXIS) didE = true; else didXYZ = true;
// 6621           current_position[i] = v;        // Without workspaces revert to Marlin 1.0 behavior
// 6622         #elif HAS_POSITION_SHIFT
// 6623           if (i == E_AXIS) {
// 6624             didE = true;
// 6625             current_position[E_AXIS] = v; // When using coordinate spaces, only E is set directly
// 6626           }
// 6627           else {
// 6628             position_shift[i] += d;       // Other axes simply offset the coordinate space
// 6629             update_software_endstops((AxisEnum)i);
// 6630           }
// 6631         #endif
// 6632       }
// 6633     }
// 6634   }
// 6635 
// 6636   #if ENABLED(CNC_COORDINATE_SYSTEMS)
// 6637     // Apply workspace offset to the active coordinate system
// 6638     if (WITHIN(active_coordinate_system, 0, MAX_COORDINATE_SYSTEMS - 1))
// 6639       COPY(coordinate_system[active_coordinate_system], position_shift);
// 6640   #endif
// 6641 
// 6642   if (didXYZ)
// 6643     SYNC_PLAN_POSITION_KINEMATIC();
// 6644   else if (didE)
// 6645     sync_plan_position_e();
// 6646 
// 6647   report_current_position();
// 6648 }
// 6649 
// 6650 #if HAS_RESUME_CONTINUE
// 6651 
// 6652   /**
// 6653    * M0: Unconditional stop - Wait for user button press on LCD
// 6654    * M1: Conditional stop   - Wait for user button press on LCD
// 6655    */
// 6656   inline void gcode_M0_M1() {
// 6657     const char * const args = parser.string_arg;
// 6658 
// 6659     millis_t ms = 0;
// 6660     bool hasP = false, hasS = false;
// 6661     if (parser.seenval('P')) {
// 6662       ms = parser.value_millis(); // milliseconds to wait
// 6663       hasP = ms > 0;
// 6664     }
// 6665     if (parser.seenval('S')) {
// 6666       ms = parser.value_millis_from_seconds(); // seconds to wait
// 6667       hasS = ms > 0;
// 6668     }
// 6669 
// 6670     #if ENABLED(ULTIPANEL)
// 6671 
// 6672       if (!hasP && !hasS && args && *args)
// 6673         lcd_setstatus(args, true);
// 6674       else {
// 6675         LCD_MESSAGEPGM(MSG_USERWAIT);
// 6676         #if ENABLED(LCD_PROGRESS_BAR) && PROGRESS_MSG_EXPIRE > 0
// 6677           dontExpireStatus();
// 6678         #endif
// 6679       }
// 6680 
// 6681     #else
// 6682 
// 6683       if (!hasP && !hasS && args && *args) {
// 6684         SERIAL_ECHO_START();
// 6685         SERIAL_ECHOLN(args);
// 6686       }
// 6687 
// 6688     #endif
// 6689 
// 6690     KEEPALIVE_STATE(PAUSED_FOR_USER);
// 6691     wait_for_user = true;
// 6692 
// 6693     stepper.synchronize();
// 6694     refresh_cmd_timeout();
// 6695 
// 6696     if (ms > 0) {
// 6697       ms += previous_cmd_ms;  // wait until this time for a click
// 6698       while (PENDING(millis(), ms) && wait_for_user) idle();
// 6699     }
// 6700     else {
// 6701       #if ENABLED(ULTIPANEL)
// 6702         if (lcd_detected()) {
// 6703           while (wait_for_user) idle();
// 6704           print_job_timer.isPaused() ? LCD_MESSAGEPGM(WELCOME_MSG) : LCD_MESSAGEPGM(MSG_RESUMING);
// 6705         }
// 6706       #else
// 6707         while (wait_for_user) idle();
// 6708       #endif
// 6709     }
// 6710 
// 6711     wait_for_user = false;
// 6712     KEEPALIVE_STATE(IN_HANDLER);
// 6713   }
// 6714 
// 6715 #endif // HAS_RESUME_CONTINUE
// 6716 
// 6717 #if ENABLED(SPINDLE_LASER_ENABLE)
// 6718   /**
// 6719    * M3: Spindle Clockwise
// 6720    * M4: Spindle Counter-clockwise
// 6721    *
// 6722    *  S0 turns off spindle.
// 6723    *
// 6724    *  If no speed PWM output is defined then M3/M4 just turns it on.
// 6725    *
// 6726    *  At least 12.8KHz (50Hz * 256) is needed for spindle PWM.
// 6727    *  Hardware PWM is required. ISRs are too slow.
// 6728    *
// 6729    * NOTE: WGM for timers 3, 4, and 5 must be either Mode 1 or Mode 5.
// 6730    *       No other settings give a PWM signal that goes from 0 to 5 volts.
// 6731    *
// 6732    *       The system automatically sets WGM to Mode 1, so no special
// 6733    *       initialization is needed.
// 6734    *
// 6735    *       WGM bits for timer 2 are automatically set by the system to
// 6736    *       Mode 1. This produces an acceptable 0 to 5 volt signal.
// 6737    *       No special initialization is needed.
// 6738    *
// 6739    * NOTE: A minimum PWM frequency of 50 Hz is needed. All prescaler
// 6740    *       factors for timers 2, 3, 4, and 5 are acceptable.
// 6741    *
// 6742    *  SPINDLE_LASER_ENABLE_PIN needs an external pullup or it may power on
// 6743    *  the spindle/laser during power-up or when connecting to the host
// 6744    *  (usually goes through a reset which sets all I/O pins to tri-state)
// 6745    *
// 6746    *  PWM duty cycle goes from 0 (off) to 255 (always on).
// 6747    */
// 6748 
// 6749   // Wait for spindle to come up to speed
// 6750   inline void delay_for_power_up() { dwell(SPINDLE_LASER_POWERUP_DELAY); }
// 6751 
// 6752   // Wait for spindle to stop turning
// 6753   inline void delay_for_power_down() { dwell(SPINDLE_LASER_POWERDOWN_DELAY); }
// 6754 
// 6755   /**
// 6756    * ocr_val_mode() is used for debugging and to get the points needed to compute the RPM vs ocr_val line
// 6757    *
// 6758    * it accepts inputs of 0-255
// 6759    */
// 6760 
// 6761   inline void ocr_val_mode() {
// 6762     uint8_t spindle_laser_power = parser.value_byte();
// 6763     WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT); // turn spindle on (active low)
// 6764     if (SPINDLE_LASER_PWM_INVERT) spindle_laser_power = 255 - spindle_laser_power;
// 6765     analogWrite(SPINDLE_LASER_PWM_PIN, spindle_laser_power);
// 6766   }
// 6767 
// 6768   inline void gcode_M3_M4(bool is_M3) {
// 6769 
// 6770     stepper.synchronize();   // wait until previous movement commands (G0/G0/G2/G3) have completed before playing with the spindle
// 6771     #if SPINDLE_DIR_CHANGE
// 6772       const bool rotation_dir = (is_M3 && !SPINDLE_INVERT_DIR || !is_M3 && SPINDLE_INVERT_DIR) ? HIGH : LOW;
// 6773       if (SPINDLE_STOP_ON_DIR_CHANGE \ 
// 6774          && READ(SPINDLE_LASER_ENABLE_PIN) == SPINDLE_LASER_ENABLE_INVERT \ 
// 6775          && READ(SPINDLE_DIR_PIN) != rotation_dir
// 6776       ) {
// 6777         WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);  // turn spindle off
// 6778         delay_for_power_down();
// 6779       }
// 6780       WRITE(SPINDLE_DIR_PIN, rotation_dir);
// 6781     #endif
// 6782 
// 6783     /**
// 6784      * Our final value for ocr_val is an unsigned 8 bit value between 0 and 255 which usually means uint8_t.
// 6785      * Went to uint16_t because some of the uint8_t calculations would sometimes give 1000 0000 rather than 1111 1111.
// 6786      * Then needed to AND the uint16_t result with 0x00FF to make sure we only wrote the byte of interest.
// 6787      */
// 6788     #if ENABLED(SPINDLE_LASER_PWM)
// 6789       if (parser.seen('O')) ocr_val_mode();
// 6790       else {
// 6791         const float spindle_laser_power = parser.floatval('S');
// 6792         if (spindle_laser_power == 0) {
// 6793           WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);                                    // turn spindle off (active low)
// 6794           analogWrite(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);                           // only write low byte
// 6795           delay_for_power_down();
// 6796         }
// 6797         else {
// 6798           int16_t ocr_val = (spindle_laser_power - (SPEED_POWER_INTERCEPT)) * (1.0 / (SPEED_POWER_SLOPE));  // convert RPM to PWM duty cycle
// 6799           NOMORE(ocr_val, 255);                                                                             // limit to max the Atmel PWM will support
// 6800           if (spindle_laser_power <= SPEED_POWER_MIN)
// 6801             ocr_val = (SPEED_POWER_MIN - (SPEED_POWER_INTERCEPT)) * (1.0 / (SPEED_POWER_SLOPE));            // minimum setting
// 6802           if (spindle_laser_power >= SPEED_POWER_MAX)
// 6803             ocr_val = (SPEED_POWER_MAX - (SPEED_POWER_INTERCEPT)) * (1.0 / (SPEED_POWER_SLOPE));            // limit to max RPM
// 6804           if (SPINDLE_LASER_PWM_INVERT) ocr_val = 255 - ocr_val;
// 6805           WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT);                                     // turn spindle on (active low)
// 6806           analogWrite(SPINDLE_LASER_PWM_PIN, ocr_val & 0xFF);                                               // only write low byte
// 6807           delay_for_power_up();
// 6808         }
// 6809       }
// 6810     #else
// 6811       WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT); // turn spindle on (active low) if spindle speed option not enabled
// 6812       delay_for_power_up();
// 6813     #endif
// 6814   }
// 6815 
// 6816  /**
// 6817   * M5 turn off spindle
// 6818   */
// 6819   inline void gcode_M5() {
// 6820     stepper.synchronize();
// 6821     WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);
// 6822     delay_for_power_down();
// 6823   }
// 6824 
// 6825 #endif // SPINDLE_LASER_ENABLE
// 6826 
// 6827 /**
// 6828  * M17: Enable power on all stepper motors
// 6829  */
// 6830 inline void gcode_M17() {
// 6831   LCD_MESSAGEPGM(MSG_NO_MOVE);
// 6832   enable_all_steppers();
// 6833 }
// 6834 
// 6835 #if ENABLED(ADVANCED_PAUSE_FEATURE)
// 6836 
// 6837   static float resume_position[XYZE];
// 6838   static bool move_away_flag = false;
// 6839   #if ENABLED(SDSUPPORT)
// 6840     static bool sd_print_paused = false;
// 6841   #endif
// 6842 
// 6843   static void filament_change_beep(const int8_t max_beep_count, const bool init=false) {
// 6844     static millis_t next_buzz = 0;
// 6845     static int8_t runout_beep = 0;
// 6846 
// 6847     if (init) next_buzz = runout_beep = 0;
// 6848 
// 6849     const millis_t ms = millis();
// 6850     if (ELAPSED(ms, next_buzz)) {
// 6851       if (max_beep_count < 0 || runout_beep < max_beep_count + 5) { // Only beep as long as we're supposed to
// 6852         next_buzz = ms + ((max_beep_count < 0 || runout_beep < max_beep_count) ? 2500 : 400);
// 6853         BUZZ(300, 2000);
// 6854         runout_beep++;
// 6855       }
// 6856     }
// 6857   }
// 6858 
// 6859   static void ensure_safe_temperature() {
// 6860     bool heaters_heating = true;
// 6861 
// 6862     wait_for_heatup = true;    // M108 will clear this
// 6863     while (wait_for_heatup && heaters_heating) {
// 6864       idle();
// 6865       heaters_heating = false;
// 6866       HOTEND_LOOP() {
// 6867         if (thermalManager.degTargetHotend(e) && abs(thermalManager.degHotend(e) - thermalManager.degTargetHotend(e)) > TEMP_HYSTERESIS) {
// 6868           heaters_heating = true;
// 6869           #if ENABLED(ULTIPANEL)
// 6870             lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_WAIT_FOR_NOZZLES_TO_HEAT);
// 6871           #endif
// 6872           break;
// 6873         }
// 6874       }
// 6875     }
// 6876   }
// 6877 
// 6878   #if IS_KINEMATIC
// 6879     #define RUNPLAN(RATE_MM_S) planner.buffer_line_kinematic(destination, RATE_MM_S, active_extruder)
// 6880   #else
// 6881     #define RUNPLAN(RATE_MM_S) buffer_line_to_destination(RATE_MM_S)
// 6882   #endif
// 6883 
// 6884   void do_pause_e_move(const float &length, const float fr) {
// 6885     current_position[E_AXIS] += length / planner.e_factor[active_extruder];
// 6886     set_destination_from_current();
// 6887     RUNPLAN(fr);
// 6888     stepper.synchronize();
// 6889   }
// 6890 
// 6891   static bool pause_print(const float &retract, const point_t &park_point, const float &unload_length = 0,
// 6892                           const int8_t max_beep_count = 0, const bool show_lcd = false
// 6893   ) {
// 6894     if (move_away_flag) return false; // already paused
// 6895 
// 6896     #ifdef ACTION_ON_PAUSE
// 6897       SERIAL_ECHOLNPGM("//action:" ACTION_ON_PAUSE);
// 6898     #endif
// 6899 
// 6900     if (!DEBUGGING(DRYRUN) && unload_length != 0) {
// 6901       #if ENABLED(PREVENT_COLD_EXTRUSION)
// 6902         if (!thermalManager.allow_cold_extrude &&
// 6903             thermalManager.degTargetHotend(active_extruder) < thermalManager.extrude_min_temp) {
// 6904           SERIAL_ERROR_START();
// 6905           SERIAL_ERRORLNPGM(MSG_TOO_COLD_FOR_M600);
// 6906           return false;
// 6907         }
// 6908       #endif
// 6909 
// 6910       ensure_safe_temperature(); // wait for extruder to heat up before unloading
// 6911     }
// 6912 
// 6913     // Indicate that the printer is paused
// 6914     move_away_flag = true;
// 6915 
// 6916     // Pause the print job and timer
// 6917     #if ENABLED(SDSUPPORT)
// 6918       if (card.sdprinting) {
// 6919         card.pauseSDPrint();
// 6920         sd_print_paused = true;
// 6921       }
// 6922     #endif
// 6923     print_job_timer.pause();
// 6924 
// 6925     // Show initial message and wait for synchronize steppers
// 6926     if (show_lcd) {
// 6927       #if ENABLED(ULTIPANEL)
// 6928         lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INIT);
// 6929       #endif
// 6930     }
// 6931 
// 6932     // Save current position
// 6933     stepper.synchronize();
// 6934     COPY(resume_position, current_position);
// 6935 
// 6936     // Initial retract before move to filament change position
// 6937     if (retract && !thermalManager.tooColdToExtrude(active_extruder))
// 6938       do_pause_e_move(retract, PAUSE_PARK_RETRACT_FEEDRATE);
// 6939 
// 6940     // Park the nozzle by moving up by z_lift and then moving to (x_pos, y_pos)
// 6941     Nozzle::park(2, park_point);
// 6942 
// 6943     if (unload_length != 0) {
// 6944       if (show_lcd) {
// 6945         #if ENABLED(ULTIPANEL)
// 6946           lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_UNLOAD);
// 6947           idle();
// 6948         #endif
// 6949       }
// 6950 
// 6951       // Unload filament
// 6952       do_pause_e_move(unload_length, FILAMENT_CHANGE_UNLOAD_FEEDRATE);
// 6953     }
// 6954 
// 6955     if (show_lcd) {
// 6956       #if ENABLED(ULTIPANEL)
// 6957         lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INSERT);
// 6958       #endif
// 6959     }
// 6960 
// 6961     #if HAS_BUZZER
// 6962       filament_change_beep(max_beep_count, true);
// 6963     #endif
// 6964 
// 6965     idle();
// 6966 
// 6967     // Disable extruders steppers for manual filament changing (only on boards that have separate ENABLE_PINS)
// 6968     #if E0_ENABLE_PIN != X_ENABLE_PIN && E1_ENABLE_PIN != Y_ENABLE_PIN
// 6969       disable_e_steppers();
// 6970       safe_delay(100);
// 6971     #endif
// 6972 
// 6973     // Start the heater idle timers
// 6974     const millis_t nozzle_timeout = (millis_t)(PAUSE_PARK_NOZZLE_TIMEOUT) * 1000UL;
// 6975 
// 6976     HOTEND_LOOP()
// 6977       thermalManager.start_heater_idle_timer(e, nozzle_timeout);
// 6978 
// 6979     return true;
// 6980   }
// 6981 
// 6982   static void wait_for_filament_reload(const int8_t max_beep_count = 0) {
// 6983     bool nozzle_timed_out = false;
// 6984 
// 6985     // Wait for filament insert by user and press button
// 6986     KEEPALIVE_STATE(PAUSED_FOR_USER);
// 6987     wait_for_user = true;    // LCD click or M108 will clear this
// 6988     while (wait_for_user) {
// 6989       #if HAS_BUZZER
// 6990         filament_change_beep(max_beep_count);
// 6991       #endif
// 6992 
// 6993       // If the nozzle has timed out, wait for the user to press the button to re-heat the nozzle, then
// 6994       // re-heat the nozzle, re-show the insert screen, restart the idle timers, and start over
// 6995       if (!nozzle_timed_out)
// 6996         HOTEND_LOOP()
// 6997           nozzle_timed_out |= thermalManager.is_heater_idle(e);
// 6998 
// 6999       if (nozzle_timed_out) {
// 7000         #if ENABLED(ULTIPANEL)
// 7001           lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_CLICK_TO_HEAT_NOZZLE);
// 7002         #endif
// 7003 
// 7004         // Wait for LCD click or M108
// 7005         while (wait_for_user) idle(true);
// 7006 
// 7007         // Re-enable the heaters if they timed out
// 7008         HOTEND_LOOP() thermalManager.reset_heater_idle_timer(e);
// 7009 
// 7010         // Wait for the heaters to reach the target temperatures
// 7011         ensure_safe_temperature();
// 7012 
// 7013         #if ENABLED(ULTIPANEL)
// 7014           lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INSERT);
// 7015         #endif
// 7016 
// 7017         // Start the heater idle timers
// 7018         const millis_t nozzle_timeout = (millis_t)(PAUSE_PARK_NOZZLE_TIMEOUT) * 1000UL;
// 7019 
// 7020         HOTEND_LOOP()
// 7021           thermalManager.start_heater_idle_timer(e, nozzle_timeout);
// 7022 
// 7023         wait_for_user = true; /* Wait for user to load filament */
// 7024         nozzle_timed_out = false;
// 7025 
// 7026         #if HAS_BUZZER
// 7027           filament_change_beep(max_beep_count, true);
// 7028         #endif
// 7029       }
// 7030 
// 7031       idle(true);
// 7032     }
// 7033     KEEPALIVE_STATE(IN_HANDLER);
// 7034   }
// 7035 
// 7036   static void resume_print(const float &load_length = 0, const float &initial_extrude_length = 0, const int8_t max_beep_count = 0) {
// 7037     bool nozzle_timed_out = false;
// 7038 
// 7039     if (!move_away_flag) return;
// 7040 
// 7041     // Re-enable the heaters if they timed out
// 7042     HOTEND_LOOP() {
// 7043       nozzle_timed_out |= thermalManager.is_heater_idle(e);
// 7044       thermalManager.reset_heater_idle_timer(e);
// 7045     }
// 7046 
// 7047     if (nozzle_timed_out) ensure_safe_temperature();
// 7048 
// 7049     #if HAS_BUZZER
// 7050       filament_change_beep(max_beep_count, true);
// 7051     #endif
// 7052 
// 7053     set_destination_from_current();
// 7054 
// 7055     if (load_length != 0) {
// 7056       #if ENABLED(ULTIPANEL)
// 7057         // Show "insert filament"
// 7058         if (nozzle_timed_out)
// 7059           lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INSERT);
// 7060       #endif
// 7061 
// 7062       KEEPALIVE_STATE(PAUSED_FOR_USER);
// 7063       wait_for_user = true;    // LCD click or M108 will clear this
// 7064       while (wait_for_user && nozzle_timed_out) {
// 7065         #if HAS_BUZZER
// 7066           filament_change_beep(max_beep_count);
// 7067         #endif
// 7068         idle(true);
// 7069       }
// 7070       KEEPALIVE_STATE(IN_HANDLER);
// 7071 
// 7072       #if ENABLED(ULTIPANEL)
// 7073         // Show "load" message
// 7074         lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_LOAD);
// 7075       #endif
// 7076 
// 7077       // Load filament
// 7078       do_pause_e_move(load_length, FILAMENT_CHANGE_LOAD_FEEDRATE);
// 7079     }
// 7080 
// 7081     #if ENABLED(ULTIPANEL) && ADVANCED_PAUSE_EXTRUDE_LENGTH > 0
// 7082 
// 7083       if (!thermalManager.tooColdToExtrude(active_extruder)) {
// 7084         float extrude_length = initial_extrude_length;
// 7085 
// 7086         do {
// 7087           if (extrude_length > 0) {
// 7088             // "Wait for filament extrude"
// 7089             lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_EXTRUDE);
// 7090 
// 7091             // Extrude filament to get into hotend
// 7092             do_pause_e_move(extrude_length, ADVANCED_PAUSE_EXTRUDE_FEEDRATE);
// 7093           }
// 7094 
// 7095           // Show "Extrude More" / "Resume" menu and wait for reply
// 7096           KEEPALIVE_STATE(PAUSED_FOR_USER);
// 7097           wait_for_user = false;
// 7098           lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_OPTION);
// 7099           while (advanced_pause_menu_response == ADVANCED_PAUSE_RESPONSE_WAIT_FOR) idle(true);
// 7100           KEEPALIVE_STATE(IN_HANDLER);
// 7101 
// 7102           extrude_length = ADVANCED_PAUSE_EXTRUDE_LENGTH;
// 7103 
// 7104           // Keep looping if "Extrude More" was selected
// 7105         } while (advanced_pause_menu_response == ADVANCED_PAUSE_RESPONSE_EXTRUDE_MORE);
// 7106       }
// 7107 
// 7108     #endif
// 7109 
// 7110     #if ENABLED(ULTIPANEL)
// 7111       // "Wait for print to resume"
// 7112       lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_RESUME);
// 7113     #endif
// 7114 
// 7115     // Set extruder to saved position
// 7116     destination[E_AXIS] = current_position[E_AXIS] = resume_position[E_AXIS];
// 7117     planner.set_e_position_mm(current_position[E_AXIS]);
// 7118 
// 7119     // Move XY to starting position, then Z
// 7120     do_blocking_move_to_xy(resume_position[X_AXIS], resume_position[Y_AXIS], NOZZLE_PARK_XY_FEEDRATE);
// 7121     do_blocking_move_to_z(resume_position[Z_AXIS], NOZZLE_PARK_Z_FEEDRATE);
// 7122 
// 7123     #if ENABLED(FILAMENT_RUNOUT_SENSOR)
// 7124       filament_ran_out = false;
// 7125     #endif
// 7126 
// 7127     #if ENABLED(ULTIPANEL)
// 7128       // Show status screen
// 7129       lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_STATUS);
// 7130     #endif
// 7131 
// 7132     #ifdef ACTION_ON_RESUME
// 7133       SERIAL_ECHOLNPGM("//action:" ACTION_ON_RESUME);
// 7134     #endif
// 7135 
// 7136     #if ENABLED(SDSUPPORT)
// 7137       if (sd_print_paused) {
// 7138         card.startFileprint();
// 7139         sd_print_paused = false;
// 7140       }
// 7141     #endif
// 7142 
// 7143     move_away_flag = false;
// 7144   }
// 7145 #endif // ADVANCED_PAUSE_FEATURE
// 7146 
// 7147 #if ENABLED(SDSUPPORT)
// 7148 
// 7149   /**
// 7150    * M20: List SD card to serial output
// 7151    */
// 7152   inline void gcode_M20() {
// 7153     SERIAL_PROTOCOLLNPGM(MSG_BEGIN_FILE_LIST);
// 7154     card.ls();
// 7155     SERIAL_PROTOCOLLNPGM(MSG_END_FILE_LIST);
// 7156   }
// 7157 
// 7158   /**
// 7159    * M21: Init SD Card
// 7160    */
// 7161   inline void gcode_M21() { card.initsd(); }
// 7162 
// 7163   /**
// 7164    * M22: Release SD Card
// 7165    */
// 7166   inline void gcode_M22() { card.release(); }
// 7167 
// 7168   /**
// 7169    * M23: Open a file
// 7170    */
// 7171    #ifdef USE_MKS_WIFI    
// 7172   inline void gcode_M23() { 
// 7173   	if(card.openFile(parser.command_ptr, true) < 0)
// 7174   	{
// 7175   		/*for 8.3 principle*/
// 7176 		char *gSuffix = strstr((char *)parser.command_ptr, ".g");
// 7177 		if(!gSuffix)
// 7178 		{
// 7179 			gSuffix = strstr((char *)parser.command_ptr, ".G");		
// 7180 		}
// 7181 		if(gSuffix)
// 7182 		{
// 7183 			*(gSuffix + 2) = '\0';
// 7184 			if((uint32_t)gSuffix - (uint32_t)parser.command_ptr > 8)
// 7185 			{
// 7186 				parser.command_ptr[7] = '~';
// 7187 				parser.command_ptr[8] = '.';
// 7188 				parser.command_ptr[9] = 'g';
// 7189 				parser.command_ptr[10] = '\0';
// 7190 			}
// 7191 			card.openFile(parser.command_ptr, true) ;
// 7192 		}
// 7193   	}
// 7194   }
// 7195 #else
// 7196   inline void gcode_M23() {
// 7197     // Simplify3D includes the size, so zero out all spaces (#7227)
// 7198     for (char *fn = parser.string_arg; *fn; ++fn) if (*fn == ' ') *fn = '\0';
// 7199     card.openFile(parser.string_arg, true);
// 7200     strcpy(curFileName, mksReprint.filename);//(uint8_t *)&mksReprint.filename[0]
// 7201   }
// 7202 #endif
// 7203   /**
// 7204    * M24: Start or Resume SD Print
// 7205    */
// 7206   inline void gcode_M24() {
// 7207   	mks_resumePrint();
// 7208   
// 7209     #if ENABLED(PARK_HEAD_ON_PAUSE)
// 7210       resume_print();
// 7211     #endif
// 7212 	
// 7213 	#ifdef USE_MKS_WIFI
// 7214 	if(card.lastOpenOk())
// 7215 	#endif	
// 7216 		if(mksReprint.mks_printer_state != MKS_REPRINTING && mksReprint.mks_printer_state != MKS_REPRINTED)
// 7217 		{
// 7218 	    	card.startFileprint();
// 7219 	    	print_job_timer.start();
// 7220 		}
// 7221   }
// 7222 
// 7223   /**
// 7224    * M25: Pause SD Print
// 7225    */
// 7226   inline void gcode_M25() {
// 7227     card.pauseSDPrint();
// 7228     print_job_timer.pause();
// 7229 
// 7230     #if ENABLED(PARK_HEAD_ON_PAUSE)
// 7231       enqueue_and_echo_commands_P(PSTR("M125")); // Must be enqueued with pauseSDPrint set to be last in the buffer
// 7232     #endif
// 7233 	
// 7234 	mksReprint.mks_printer_state = MKS_PAUSING;
// 7235   }
// 7236 /**
// 7237 	 * M998: Stop SD Print
// 7238 */
// 7239 	inline void gcode_M998() {
// 7240 		if(mksReprint.mks_printer_state == MKS_REPRINTED)	
// 7241 		return;
// 7242 			
// 7243 		mksReprint.mks_printer_state = MKS_IDLE;
// 7244         if(gCfgItems.pwroff_save_mode != 1)
// 7245 		    epr_write_data(EPR_SAV_FLAG, (uint8_t *)&mksReprint.mks_printer_state,sizeof(mksReprint.mks_printer_state));
// 7246 
// 7247 		card.stopSDPrint();
// 7248 		clear_command_queue();
// 7249 		quickstop_stepper();
// 7250 		print_job_timer.stop();
// 7251 		thermalManager.disable_all_heaters();
// 7252 		#if FAN_COUNT > 0
// 7253 			for (uint8_t i = 0; i < FAN_COUNT; i++) 
// 7254             {         
// 7255                 fanSpeeds[i] = 0;
// 7256                 #if 1
// 7257                 MKS_FAN_TIM = 0 ;
// 7258                 #endif
// 7259              }
// 7260 		#endif
// 7261 		wait_for_heatup = false;
// 7262 	}
// 7263 
// 7264   /**
// 7265    * M26: Set SD Card file index
// 7266    */
// 7267   inline void gcode_M26() {
// 7268     if (card.cardOK && parser.seenval('S'))
// 7269       card.setIndex(parser.value_long());
// 7270   }
// 7271 
// 7272   /**
// 7273    * M27: Get SD Card status
// 7274    */
// 7275   inline void gcode_M27() { card.getStatus(); }
// 7276 
// 7277   /**
// 7278    * M28: Start SD Write
// 7279    */
// 7280   inline void gcode_M28() { card.openFile(parser.string_arg, false); }
// 7281 
// 7282   /**
// 7283    * M29: Stop SD Write
// 7284    * Processed in write to file routine above
// 7285    */
// 7286   inline void gcode_M29() {
// 7287     // card.saving = false;
// 7288   }
// 7289 
// 7290   /**
// 7291    * M30 <filename>: Delete SD Card file
// 7292    */
// 7293   inline void gcode_M30() {
// 7294     if (card.cardOK) {
// 7295       card.closefile();
// 7296       card.removeFile(parser.string_arg);
// 7297     }
// 7298   }
// 7299 
// 7300 #endif // SDSUPPORT
// 7301 
// 7302 /**
// 7303  * M31: Get the time since the start of SD Print (or last M109)
// 7304  */
// 7305 inline void gcode_M31() {
// 7306   char buffer[21];
// 7307   duration_t elapsed = print_job_timer.duration();
// 7308   elapsed.toString(buffer);
// 7309   lcd_setstatus(buffer);
// 7310 
// 7311   SERIAL_ECHO_START();
// 7312   SERIAL_ECHOLNPAIR("Print time: ", buffer);
// 7313 }
// 7314 
// 7315 #if ENABLED(SDSUPPORT)
// 7316 
// 7317   /**
// 7318    * M32: Select file and start SD Print
// 7319    *
// 7320    * Examples:
// 7321    *
// 7322    *    M32 !PATH/TO/FILE.GCO#      ; Start FILE.GCO
// 7323    *    M32 P !PATH/TO/FILE.GCO#    ; Start FILE.GCO as a procedure
// 7324    *    M32 S60 !PATH/TO/FILE.GCO#  ; Start FILE.GCO at byte 60
// 7325    *
// 7326    */
// 7327   inline void gcode_M32() {
// 7328     if (card.sdprinting) stepper.synchronize();
// 7329 
// 7330     if (card.cardOK|| card.usbOK) {
// 7331       const bool call_procedure = parser.boolval('P');
// 7332 
// 7333       card.openFile(parser.string_arg, true, call_procedure);
// 7334 
// 7335       if (parser.seenval('S')) card.setIndex(parser.value_long());
// 7336 
// 7337       card.startFileprint();
// 7338 
// 7339       // Procedure calls count as normal print time.
// 7340       if (!call_procedure) print_job_timer.start();
// 7341     }
// 7342   }
// 7343 
// 7344   #if ENABLED(LONG_FILENAME_HOST_SUPPORT)
// 7345 
// 7346     /**
// 7347      * M33: Get the long full path of a file or folder
// 7348      *
// 7349      * Parameters:
// 7350      *   <dospath> Case-insensitive DOS-style path to a file or folder
// 7351      *
// 7352      * Example:
// 7353      *   M33 miscel~1/armchair/armcha~1.gco
// 7354      *
// 7355      * Output:
// 7356      *   /Miscellaneous/Armchair/Armchair.gcode
// 7357      */
// 7358     inline void gcode_M33() {
// 7359       card.printLongPath(parser.string_arg);
// 7360     }
// 7361 
// 7362   #endif
// 7363 
// 7364   #if ENABLED(SDCARD_SORT_ALPHA) && ENABLED(SDSORT_GCODE)
// 7365     /**
// 7366      * M34: Set SD Card Sorting Options
// 7367      */
// 7368     inline void gcode_M34() {
// 7369       if (parser.seen('S')) card.setSortOn(parser.value_bool());
// 7370       if (parser.seenval('F')) {
// 7371         const int v = parser.value_long();
// 7372         card.setSortFolders(v < 0 ? -1 : v > 0 ? 1 : 0);
// 7373       }
// 7374       //if (parser.seen('R')) card.setSortReverse(parser.value_bool());
// 7375     }
// 7376   #endif // SDCARD_SORT_ALPHA && SDSORT_GCODE
// 7377 
// 7378   /**
// 7379    * M928: Start SD Write
// 7380    */
// 7381   inline void gcode_M928() {
// 7382     card.openLogFile(parser.string_arg);
// 7383   }
// 7384 
// 7385 #endif // SDSUPPORT
// 7386 
// 7387 /**
// 7388  * Sensitive pin test for M42, M226
// 7389  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock39 Using cfiCommon0
          CFI Function _Z16pin_is_protecteda
          CFI NoCalls
        THUMB
// 7390 static bool pin_is_protected(const int8_t pin) {
// 7391   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
// 7392   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
_Z16pin_is_protecteda:
        MOVS     R1,#+0
        B.N      ??pin_is_protected_0
??pin_is_protected_1:
        ADDS     R1,R1,#+1
??pin_is_protected_0:
        UXTB     R1,R1
        CMP      R1,#+40
        BCS.N    ??pin_is_protected_2
// 7393     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
        ADR.W    R2,??sensitive_pins
        LDRSB    R2,[R1, R2]
        CMP      R0,R2
        BNE.N    ??pin_is_protected_1
        MOVS     R0,#+1
        BX       LR
// 7394   return false;
??pin_is_protected_2:
        MOVS     R0,#+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock39
// 7395 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??sensitive_pins:
        DC8 0, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 0, 2, 3, 4, -1, -1
        DC8 -1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
        DC8 -1, -1, -1, -1

        SECTION `.rodata`:CONST:REORDER:NOROOT(0)
        SECTION_GROUP _ZTI5Print
// __absolute char const <Typeinfo for Print>
_ZTI5Print:
        DATA
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZNK10duration_t8toStringEPcEs
// __absolute char const <_ZZNK10duration_t8toStringEPcEs>[20]
_ZZNK10duration_t8toStringEPcEs:
        DATA
        DC8 "%iy %id %ih %im %is"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZNK10duration_t8toStringEPcEs_0
// __absolute char const <_ZZNK10duration_t8toStringEPcEs_0>[16]
_ZZNK10duration_t8toStringEPcEs_0:
        DATA
        DC8 "%id %ih %im %is"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZNK10duration_t8toStringEPcEs_1
// __absolute char const <_ZZNK10duration_t8toStringEPcEs_1>[12]
_ZZNK10duration_t8toStringEPcEs_1:
        DATA
        DC8 "%ih %im %is"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZNK10duration_t8toStringEPcEs_2
// __absolute char const <_ZZNK10duration_t8toStringEPcEs_2>[8]
_ZZNK10duration_t8toStringEPcEs_2:
        DATA
        DC8 "%im %is"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZNK10duration_t8toStringEPcEs_3
// __absolute char const <_ZZNK10duration_t8toStringEPcEs_3>[4]
_ZZNK10duration_t8toStringEPcEs_3:
        DATA
        DC8 "%is"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs
// __absolute char const <_ZZ19get_serial_commandsvEs>[5]
_ZZ19get_serial_commandsvEs:
        DATA
        DC8 "M110"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_0
// __absolute char const <_ZZ19get_serial_commandsvEs_0>[51]
_ZZ19get_serial_commandsvEs_0:
        DATA
        DC8 4CH, 69H, 6EH, 65H, 20H, 4EH, 75H, 6DH
        DC8 62H, 65H, 72H, 20H, 69H, 73H, 20H, 6EH
        DC8 6FH, 74H, 20H, 4CH, 61H, 73H, 74H, 20H
        DC8 4CH, 69H, 6EH, 65H, 20H, 4EH, 75H, 6DH
        DC8 62H, 65H, 72H, 2BH, 31H, 2CH, 20H, 4CH
        DC8 61H, 73H, 74H, 20H, 4CH, 69H, 6EH, 65H
        DC8 3AH, 20H, 0
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_1
// __absolute char const <_ZZ19get_serial_commandsvEs_1>[31]
_ZZ19get_serial_commandsvEs_1:
        DATA
        DC8 "checksum mismatch, Last Line: "
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_2
// __absolute char const <_ZZ19get_serial_commandsvEs_2>[42]
_ZZ19get_serial_commandsvEs_2:
        DATA
        DC8 "No Checksum with line number, Last Line: "
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_3
// __absolute char const <_ZZ19get_serial_commandsvEs_3>[119]
_ZZ19get_serial_commandsvEs_3:
        DATA
        DC8 50H, 72H, 69H, 6EH, 74H, 65H, 72H, 20H
        DC8 73H, 74H, 6FH, 70H, 70H, 65H, 64H, 20H
        DC8 64H, 75H, 65H, 20H, 74H, 6FH, 20H, 65H
        DC8 72H, 72H, 6FH, 72H, 73H, 2EH, 20H, 46H
        DC8 69H, 78H, 20H, 74H, 68H, 65H, 20H, 65H
        DC8 72H, 72H, 6FH, 72H, 20H, 61H, 6EH, 64H
        DC8 20H, 75H, 73H, 65H, 20H, 4DH, 39H, 39H
        DC8 39H, 20H, 74H, 6FH, 20H, 72H, 65H, 73H
        DC8 74H, 61H, 72H, 74H, 2EH, 20H, 28H, 54H
        DC8 65H, 6DH, 70H, 65H, 72H, 61H, 74H, 75H
        DC8 72H, 65H, 20H, 69H, 73H, 20H, 72H, 65H
        DC8 73H, 65H, 74H, 2EH, 20H, 53H, 65H, 74H
        DC8 20H, 69H, 74H, 20H, 61H, 66H, 74H, 65H
        DC8 72H, 20H, 72H, 65H, 73H, 74H, 61H, 72H
        DC8 74H, 69H, 6EH, 67H, 29H, 0AH, 0
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_4
// __absolute char const <_ZZ19get_serial_commandsvEs_4>[10]
_ZZ19get_serial_commandsvEs_4:
        DATA
        DC8 "STOPPED. "
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_5
// __absolute char const <_ZZ19get_serial_commandsvEs_5>[5]
_ZZ19get_serial_commandsvEs_5:
        DATA
        DC8 "M108"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_6
// __absolute char const <_ZZ19get_serial_commandsvEs_6>[5]
_ZZ19get_serial_commandsvEs_6:
        DATA
        DC8 "M112"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_7
// __absolute char const <_ZZ19get_serial_commandsvEs_7>[9]
_ZZ19get_serial_commandsvEs_7:
        DATA
        DC8 "KILLED. "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_8
// __absolute char const <_ZZ19get_serial_commandsvEs_8>[5]
_ZZ19get_serial_commandsvEs_8:
        DATA
        DC8 "M410"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ17get_wifi_commandsvEs
// __absolute char const <_ZZ17get_wifi_commandsvEs>[119]
_ZZ17get_wifi_commandsvEs:
        DATA
        DC8 50H, 72H, 69H, 6EH, 74H, 65H, 72H, 20H
        DC8 73H, 74H, 6FH, 70H, 70H, 65H, 64H, 20H
        DC8 64H, 75H, 65H, 20H, 74H, 6FH, 20H, 65H
        DC8 72H, 72H, 6FH, 72H, 73H, 2EH, 20H, 46H
        DC8 69H, 78H, 20H, 74H, 68H, 65H, 20H, 65H
        DC8 72H, 72H, 6FH, 72H, 20H, 61H, 6EH, 64H
        DC8 20H, 75H, 73H, 65H, 20H, 4DH, 39H, 39H
        DC8 39H, 20H, 74H, 6FH, 20H, 72H, 65H, 73H
        DC8 74H, 61H, 72H, 74H, 2EH, 20H, 28H, 54H
        DC8 65H, 6DH, 70H, 65H, 72H, 61H, 74H, 75H
        DC8 72H, 65H, 20H, 69H, 73H, 20H, 72H, 65H
        DC8 73H, 65H, 74H, 2EH, 20H, 53H, 65H, 74H
        DC8 20H, 69H, 74H, 20H, 61H, 66H, 74H, 65H
        DC8 72H, 20H, 72H, 65H, 73H, 74H, 61H, 72H
        DC8 74H, 69H, 6EH, 67H, 29H, 0AH, 0
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ17get_wifi_commandsvEs_0
// __absolute char const <_ZZ17get_wifi_commandsvEs_0>[10]
_ZZ17get_wifi_commandsvEs_0:
        DATA
        DC8 "STOPPED. "
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ17get_wifi_commandsvEs_1
// __absolute char const <_ZZ17get_wifi_commandsvEs_1>[5]
_ZZ17get_wifi_commandsvEs_1:
        DATA
        DC8 "M108"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ17get_wifi_commandsvEs_2
// __absolute char const <_ZZ17get_wifi_commandsvEs_2>[5]
_ZZ17get_wifi_commandsvEs_2:
        DATA
        DC8 "M112"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ17get_wifi_commandsvEs_3
// __absolute char const <_ZZ17get_wifi_commandsvEs_3>[9]
_ZZ17get_wifi_commandsvEs_3:
        DATA
        DC8 "KILLED. "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ17get_wifi_commandsvEs_4
// __absolute char const <_ZZ17get_wifi_commandsvEs_4>[5]
_ZZ17get_wifi_commandsvEs_4:
        DATA
        DC8 "M410"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ24get_homing_bump_feedrate8AxisEnumEs
// __absolute char const <_ZZ24get_homing_bump_feedrate8AxisEnumEs>[34]
_ZZ24get_homing_bump_feedrate8AxisEnumEs:
        DATA
        DC8 "Warning: Homing Bump Divisor < 1\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ11gcode_G2_G3bEs
// __absolute char const <_ZZ11gcode_G2_G3bEs>[22]
_ZZ11gcode_G2_G3bEs:
        DATA
        DC8 "G2/G3 bad parameters\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ8gcode_G4vEs
// __absolute char const <_ZZ8gcode_G4vEs>[9]
_ZZ8gcode_G4vEs:
        DATA
        DC8 "Sleep..."
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M17vEs
// __absolute char const <_ZZ9gcode_M17vEs>[9]
_ZZ9gcode_M17vEs:
        DATA
        DC8 "No move."
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M20vEs
// __absolute char const <_ZZ9gcode_M20vEs>[17]
_ZZ9gcode_M20vEs:
        DATA
        DC8 "Begin file list\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M20vEs_0
// __absolute char const <_ZZ9gcode_M20vEs_0>[15]
_ZZ9gcode_M20vEs_0:
        DATA
        DC8 "End file list\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M31vEs
// __absolute char const <_ZZ9gcode_M31vEs>[13]
_ZZ9gcode_M31vEs:
        DATA
        DC8 "Print time: "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M42vEs
// __absolute char const <_ZZ9gcode_M42vEs>[15]
_ZZ9gcode_M42vEs:
        DATA
        DC8 "Protected Pin\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M104vEs
// __absolute char const <_ZZ10gcode_M104vEs>[18]
_ZZ10gcode_M104vEs:
        DATA
        DC8 "3D Printer ready."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M104vEs_0
// __absolute char const <_ZZ10gcode_M104vEs_0>[14]
_ZZ10gcode_M104vEs_0:
        DATA
        DC8 "E1 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M104vEs_1
// __absolute char const <_ZZ10gcode_M104vEs_1>[14]
_ZZ10gcode_M104vEs_1:
        DATA
        DC8 "E2 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M104vEs_2
// __absolute char const <_ZZ10gcode_M104vEs_2>[14]
_ZZ10gcode_M104vEs_2:
        DATA
        DC8 "E3 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M104vEs_3
// __absolute char const <_ZZ10gcode_M104vEs_3>[14]
_ZZ10gcode_M104vEs_3:
        DATA
        DC8 "E4 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M104vEs_4
// __absolute char const <_ZZ10gcode_M104vEs_4>[14]
_ZZ10gcode_M104vEs_4:
        DATA
        DC8 "E5 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M105vEs
// __absolute char const <_ZZ10gcode_M105vEs>[33]
_ZZ10gcode_M105vEs:
        DATA
        DC8 "No thermistors - no temperature\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M112vEs
// __absolute char const <_ZZ10gcode_M112vEs>[9]
_ZZ10gcode_M112vEs:
        DATA
        DC8 "KILLED. "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs
// __absolute char const <_ZZ10gcode_M109vEs>[18]
_ZZ10gcode_M109vEs:
        DATA
        DC8 "3D Printer ready."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs_0
// __absolute char const <_ZZ10gcode_M109vEs_0>[14]
_ZZ10gcode_M109vEs_0:
        DATA
        DC8 "E1 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs_1
// __absolute char const <_ZZ10gcode_M109vEs_1>[14]
_ZZ10gcode_M109vEs_1:
        DATA
        DC8 "E2 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs_2
// __absolute char const <_ZZ10gcode_M109vEs_2>[14]
_ZZ10gcode_M109vEs_2:
        DATA
        DC8 "E3 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs_3
// __absolute char const <_ZZ10gcode_M109vEs_3>[14]
_ZZ10gcode_M109vEs_3:
        DATA
        DC8 "E4 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs_4
// __absolute char const <_ZZ10gcode_M109vEs_4>[14]
_ZZ10gcode_M109vEs_4:
        DATA
        DC8 "E5 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs_5
// __absolute char const <_ZZ10gcode_M109vEs_5>[4]
_ZZ10gcode_M109vEs_5:
        DATA
        DC8 " W:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs_6
// __absolute char const <_ZZ10gcode_M109vEs_6>[14]
_ZZ10gcode_M109vEs_6:
        DATA
        DC8 "Heating done."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vEs_4
// __absolute char const <_ZZ10gcode_M111vEs_4>[7]
_ZZ10gcode_M111vEs_4:
        DATA
        DC8 "DEBUG:"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vEs_5
// __absolute char const <_ZZ10gcode_M111vEs_5>[4]
_ZZ10gcode_M111vEs_5:
        DATA
        DC8 "off"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs
// __absolute char const <_ZZ10gcode_M115vEs>[198]
_ZZ10gcode_M115vEs:
        DATA
        DC8 46H, 49H, 52H, 4DH, 57H, 41H, 52H, 45H
        DC8 5FH, 4EH, 41H, 4DH, 45H, 3AH, 4DH, 61H
        DC8 72H, 6CH, 69H, 6EH, 20H, 31H, 2EH, 30H
        DC8 2EH, 30H, 20H, 28H, 47H, 69H, 74H, 68H
        DC8 75H, 62H, 29H, 20H, 53H, 4FH, 55H, 52H
        DC8 43H, 45H, 5FH, 43H, 4FH, 44H, 45H, 5FH
        DC8 55H, 52H, 4CH, 3AH, 68H, 74H, 74H, 70H
        DC8 73H, 3AH, 2FH, 2FH, 67H, 69H, 74H, 68H
        DC8 75H, 62H, 2EH, 63H, 6FH, 6DH, 2FH, 4DH
        DC8 61H, 72H, 6CH, 69H, 6EH, 46H, 69H, 72H
        DC8 6DH, 77H, 61H, 72H, 65H, 2FH, 4DH, 61H
        DC8 72H, 6CH, 69H, 6EH, 20H, 50H, 52H, 4FH
        DC8 54H, 4FH, 43H, 4FH, 4CH, 5FH, 56H, 45H
        DC8 52H, 53H, 49H, 4FH, 4EH, 3AH, 31H, 2EH
        DC8 30H, 20H, 4DH, 41H, 43H, 48H, 49H, 4EH
        DC8 45H, 5FH, 54H, 59H, 50H, 45H, 3AH, 33H
        DC8 44H, 20H, 50H, 72H, 69H, 6EH, 74H, 65H
        DC8 72H, 20H, 45H, 58H, 54H, 52H, 55H, 44H
        DC8 45H, 52H, 5FH, 43H, 4FH, 55H, 4EH, 54H
        DC8 3AH, 31H, 20H, 55H, 55H, 49H, 44H, 3AH
        DC8 63H, 65H, 64H, 65H, 32H, 61H, 32H, 66H
        DC8 2DH, 34H, 31H, 61H, 32H, 2DH, 34H, 37H
        DC8 34H, 38H, 2DH, 39H, 62H, 31H, 32H, 2DH
        DC8 63H, 35H, 35H, 63H, 36H, 32H, 66H, 33H
        DC8 36H, 37H, 66H, 66H, 0AH, 0
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_0
// __absolute char const <_ZZ10gcode_M115vEs_0>[16]
_ZZ10gcode_M115vEs_0:
        DATA
        DC8 "SERIAL_XON_XOFF"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_1
// __absolute char const <_ZZ10gcode_M115vEs_1>[7]
_ZZ10gcode_M115vEs_1:
        DATA
        DC8 "EEPROM"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_2
// __absolute char const <_ZZ10gcode_M115vEs_2>[11]
_ZZ10gcode_M115vEs_2:
        DATA
        DC8 "VOLUMETRIC"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_3
// __absolute char const <_ZZ10gcode_M115vEs_3>[16]
_ZZ10gcode_M115vEs_3:
        DATA
        DC8 "AUTOREPORT_TEMP"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_4
// __absolute char const <_ZZ10gcode_M115vEs_4>[9]
_ZZ10gcode_M115vEs_4:
        DATA
        DC8 "PROGRESS"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_5
// __absolute char const <_ZZ10gcode_M115vEs_5>[10]
_ZZ10gcode_M115vEs_5:
        DATA
        DC8 "PRINT_JOB"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_6
// __absolute char const <_ZZ10gcode_M115vEs_6>[10]
_ZZ10gcode_M115vEs_6:
        DATA
        DC8 "AUTOLEVEL"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_7
// __absolute char const <_ZZ10gcode_M115vEs_7>[8]
_ZZ10gcode_M115vEs_7:
        DATA
        DC8 "Z_PROBE"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_8
// __absolute char const <_ZZ10gcode_M115vEs_8>[14]
_ZZ10gcode_M115vEs_8:
        DATA
        DC8 "LEVELING_DATA"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_9
// __absolute char const <_ZZ10gcode_M115vEs_9>[14]
_ZZ10gcode_M115vEs_9:
        DATA
        DC8 "BUILD_PERCENT"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs__10_
// __absolute char const <_ZZ10gcode_M115vEs__10_>[15]
_ZZ10gcode_M115vEs__10_:
        DATA
        DC8 "SOFTWARE_POWER"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs__11_
// __absolute char const <_ZZ10gcode_M115vEs__11_>[14]
_ZZ10gcode_M115vEs__11_:
        DATA
        DC8 "TOGGLE_LIGHTS"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs__12_
// __absolute char const <_ZZ10gcode_M115vEs__12_>[22]
_ZZ10gcode_M115vEs__12_:
        DATA
        DC8 "CASE_LIGHT_BRIGHTNESS"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs__13_
// __absolute char const <_ZZ10gcode_M115vEs__13_>[17]
_ZZ10gcode_M115vEs__13_:
        DATA
        DC8 "EMERGENCY_PARSER"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M118vEs
// __absolute char const <_ZZ10gcode_M118vEs>[4]
_ZZ10gcode_M118vEs:
        DATA
        DC8 "// "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M204vEs
// __absolute char const <_ZZ10gcode_M204vEs>[40]
_ZZ10gcode_M204vEs:
        DATA
        DC8 "Setting Print and Travel Acceleration: "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M204vEs_0
// __absolute char const <_ZZ10gcode_M204vEs_0>[29]
_ZZ10gcode_M204vEs_0:
        DATA
        DC8 "Setting Print Acceleration: "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M204vEs_1
// __absolute char const <_ZZ10gcode_M204vEs_1>[31]
_ZZ10gcode_M204vEs_1:
        DATA
        DC8 "Setting Retract Acceleration: "
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M204vEs_2
// __absolute char const <_ZZ10gcode_M204vEs_2>[30]
_ZZ10gcode_M204vEs_2:
        DATA
        DC8 "Setting Travel Acceleration: "
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs
// __absolute char const <_ZZ10gcode_M211vEs>[16]
_ZZ10gcode_M211vEs:
        DATA
        DC8 "Soft endstops: "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs_0
// __absolute char const <_ZZ10gcode_M211vEs_0>[4]
_ZZ10gcode_M211vEs_0:
        DATA
        DC8 "On "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs_1
// __absolute char const <_ZZ10gcode_M211vEs_1>[4]
_ZZ10gcode_M211vEs_1:
        DATA
        DC8 "Off"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs_2
// __absolute char const <_ZZ10gcode_M211vEs_2>[8]
_ZZ10gcode_M211vEs_2:
        DATA
        DC8 "  Min: "

        SECTION `.rodata`:CONST:REORDER:NOROOT(1)
        SECTION_GROUP _ZZ10gcode_M211vEs_3
// __absolute char const <_ZZ10gcode_M211vEs_3>[2]
_ZZ10gcode_M211vEs_3:
        DATA
        DC8 "X"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs_4
// __absolute char const <_ZZ10gcode_M211vEs_4>[3]
_ZZ10gcode_M211vEs_4:
        DATA
        DC8 " Y"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs_5
// __absolute char const <_ZZ10gcode_M211vEs_5>[3]
_ZZ10gcode_M211vEs_5:
        DATA
        DC8 " Z"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs_6
// __absolute char const <_ZZ10gcode_M211vEs_6>[8]
_ZZ10gcode_M211vEs_6:
        DATA
        DC8 "  Max: "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M301vEs
// __absolute char const <_ZZ10gcode_M301vEs>[4]
_ZZ10gcode_M301vEs:
        DATA
        DC8 " p:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M301vEs_0
// __absolute char const <_ZZ10gcode_M301vEs_0>[4]
_ZZ10gcode_M301vEs_0:
        DATA
        DC8 " i:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M301vEs_1
// __absolute char const <_ZZ10gcode_M301vEs_1>[4]
_ZZ10gcode_M301vEs_1:
        DATA
        DC8 " d:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M301vEs_2
// __absolute char const <_ZZ10gcode_M301vEs_2>[17]
_ZZ10gcode_M301vEs_2:
        DATA
        DC8 "Invalid extruder"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M428vEs
// __absolute char const <_ZZ10gcode_M428vEs>[30]
_ZZ10gcode_M428vEs:
        DATA
        DC8 "Too far from reference point\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M428vEs_0
// __absolute char const <_ZZ10gcode_M428vEs_0>[14]
_ZZ10gcode_M428vEs_0:
        DATA
        DC8 "Err: Too far!"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M428vEs_1
// __absolute char const <_ZZ10gcode_M428vEs_1>[16]
_ZZ10gcode_M428vEs_1:
        DATA
        DC8 "Offsets applied"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M355vEs
// __absolute char const <_ZZ10gcode_M355vEs>[15]
_ZZ10gcode_M355vEs:
        DATA
        DC8 "No case light\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ22invalid_extruder_errorhEs
// __absolute char const <_ZZ22invalid_extruder_errorhEs>[17]
_ZZ22invalid_extruder_errorhEs:
        DATA
        DC8 "Invalid extruder"
        DC8 0, 0, 0
// 7396 
// 7397 /**
// 7398  * M42: Change pin status via GCode
// 7399  *
// 7400  *  P<pin>  Pin number (LED if omitted)
// 7401  *  S<byte> Pin status from 0 - 255
// 7402  */
// 7403 inline void gcode_M42() {
// 7404   if (!parser.seenval('S')) return;
// 7405   const byte pin_status = parser.value_byte();
// 7406 
// 7407   const int pin_number = parser.intval('P', LED_PIN);
// 7408   if (pin_number < 0) return;
// 7409 
// 7410   if (pin_is_protected(pin_number)) {
// 7411     SERIAL_ERROR_START();
// 7412     SERIAL_ERRORLNPGM(MSG_ERR_PROTECTED_PIN);
// 7413     return;
// 7414   }
// 7415 
// 7416   pinMode(pin_number, OUTPUT);
// 7417   digitalWrite(pin_number, pin_status);
// 7418   //analogWrite(pin_number, pin_status);
// 7419 
// 7420   #if FAN_COUNT > 0
// 7421     switch (pin_number) {
// 7422       #if HAS_FAN0
// 7423         case FAN_PIN: fanSpeeds[0] = pin_status; break;
// 7424       #endif
// 7425       #if HAS_FAN1
// 7426         case FAN1_PIN: fanSpeeds[1] = pin_status; break;
// 7427       #endif
// 7428       #if HAS_FAN2
// 7429         case FAN2_PIN: fanSpeeds[2] = pin_status; break;
// 7430       #endif
// 7431     }
// 7432   #endif
// 7433 }
// 7434 
// 7435 #if ENABLED(PINS_DEBUGGING)
// 7436 
// 7437   #include "pinsDebug.h"
// 7438 
// 7439   inline void toggle_pins() {
// 7440     const bool I_flag = parser.boolval('I');
// 7441     const int repeat = parser.intval('R', 1),
// 7442               start = parser.intval('S'),
// 7443               end = parser.intval('L', NUM_DIGITAL_PINS - 1),
// 7444               wait = parser.intval('W', 500);
// 7445 
// 7446     for (uint8_t pin = start; pin <= end; pin++) {
// 7447       //report_pin_state_extended(pin, I_flag, false);
// 7448 
// 7449       if (!I_flag && pin_is_protected(pin)) {
// 7450         report_pin_state_extended(pin, I_flag, true, "Untouched ");
// 7451         SERIAL_EOL();
// 7452       }
// 7453       else {
// 7454         report_pin_state_extended(pin, I_flag, true, "Pulsing   ");
// 7455         #if AVR_AT90USB1286_FAMILY // Teensy IDEs don't know about these pins so must use FASTIO
// 7456           if (pin == TEENSY_E2) {
// 7457             SET_OUTPUT(TEENSY_E2);
// 7458             for (int16_t j = 0; j < repeat; j++) {
// 7459               WRITE(TEENSY_E2, LOW);  safe_delay(wait);
// 7460               WRITE(TEENSY_E2, HIGH); safe_delay(wait);
// 7461               WRITE(TEENSY_E2, LOW);  safe_delay(wait);
// 7462             }
// 7463           }
// 7464           else if (pin == TEENSY_E3) {
// 7465             SET_OUTPUT(TEENSY_E3);
// 7466             for (int16_t j = 0; j < repeat; j++) {
// 7467               WRITE(TEENSY_E3, LOW);  safe_delay(wait);
// 7468               WRITE(TEENSY_E3, HIGH); safe_delay(wait);
// 7469               WRITE(TEENSY_E3, LOW);  safe_delay(wait);
// 7470             }
// 7471           }
// 7472           else
// 7473         #endif
// 7474         {
// 7475           pinMode(pin, OUTPUT);
// 7476           for (int16_t j = 0; j < repeat; j++) {
// 7477             digitalWrite(pin, 0); safe_delay(wait);
// 7478             digitalWrite(pin, 1); safe_delay(wait);
// 7479             digitalWrite(pin, 0); safe_delay(wait);
// 7480           }
// 7481         }
// 7482 
// 7483       }
// 7484       SERIAL_EOL();
// 7485     }
// 7486     SERIAL_ECHOLNPGM("Done.");
// 7487 
// 7488   } // toggle_pins
// 7489 
// 7490   inline void servo_probe_test() {
// 7491     #if !(NUM_SERVOS > 0 && HAS_SERVO_0)
// 7492 
// 7493       SERIAL_ERROR_START();
// 7494       SERIAL_ERRORLNPGM("SERVO not setup");
// 7495 
// 7496     #elif !HAS_Z_SERVO_ENDSTOP
// 7497 
// 7498       SERIAL_ERROR_START();
// 7499       SERIAL_ERRORLNPGM("Z_ENDSTOP_SERVO_NR not setup");
// 7500 
// 7501     #else // HAS_Z_SERVO_ENDSTOP
// 7502 
// 7503       const uint8_t probe_index = parser.byteval('P', Z_ENDSTOP_SERVO_NR);
// 7504 
// 7505       SERIAL_PROTOCOLLNPGM("Servo probe test");
// 7506       SERIAL_PROTOCOLLNPAIR(".  using index:  ", probe_index);
// 7507       SERIAL_PROTOCOLLNPAIR(".  deploy angle: ", z_servo_angle[0]);
// 7508       SERIAL_PROTOCOLLNPAIR(".  stow angle:   ", z_servo_angle[1]);
// 7509 
// 7510       bool probe_inverting;
// 7511 
// 7512       #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
// 7513 
// 7514         #define PROBE_TEST_PIN Z_MIN_PIN
// 7515 
// 7516         SERIAL_PROTOCOLLNPAIR(". probe uses Z_MIN pin: ", PROBE_TEST_PIN);
// 7517         SERIAL_PROTOCOLLNPGM(". uses Z_MIN_ENDSTOP_INVERTING (ignores Z_MIN_PROBE_ENDSTOP_INVERTING)");
// 7518         SERIAL_PROTOCOLPGM(". Z_MIN_ENDSTOP_INVERTING: ");
// 7519 
// 7520         #if Z_MIN_ENDSTOP_INVERTING
// 7521           SERIAL_PROTOCOLLNPGM("true");
// 7522         #else
// 7523           SERIAL_PROTOCOLLNPGM("false");
// 7524         #endif
// 7525 
// 7526         probe_inverting = Z_MIN_ENDSTOP_INVERTING;
// 7527 
// 7528       #elif ENABLED(Z_MIN_PROBE_ENDSTOP)
// 7529 
// 7530         #define PROBE_TEST_PIN Z_MIN_PROBE_PIN
// 7531         SERIAL_PROTOCOLLNPAIR(". probe uses Z_MIN_PROBE_PIN: ", PROBE_TEST_PIN);
// 7532         SERIAL_PROTOCOLLNPGM(". uses Z_MIN_PROBE_ENDSTOP_INVERTING (ignores Z_MIN_ENDSTOP_INVERTING)");
// 7533         SERIAL_PROTOCOLPGM(". Z_MIN_PROBE_ENDSTOP_INVERTING: ");
// 7534 
// 7535         #if Z_MIN_PROBE_ENDSTOP_INVERTING
// 7536           SERIAL_PROTOCOLLNPGM("true");
// 7537         #else
// 7538           SERIAL_PROTOCOLLNPGM("false");
// 7539         #endif
// 7540 
// 7541         probe_inverting = Z_MIN_PROBE_ENDSTOP_INVERTING;
// 7542 
// 7543       #endif
// 7544 
// 7545       SERIAL_PROTOCOLLNPGM(". deploy & stow 4 times");
// 7546       SET_INPUT_PULLUP(PROBE_TEST_PIN);
// 7547       bool deploy_state, stow_state;
// 7548       for (uint8_t i = 0; i < 4; i++) {
// 7549         MOVE_SERVO(probe_index, z_servo_angle[0]); //deploy
// 7550         safe_delay(500);
// 7551         deploy_state = READ(PROBE_TEST_PIN);
// 7552         MOVE_SERVO(probe_index, z_servo_angle[1]); //stow
// 7553         safe_delay(500);
// 7554         stow_state = READ(PROBE_TEST_PIN);
// 7555       }
// 7556       if (probe_inverting != deploy_state) SERIAL_PROTOCOLLNPGM("WARNING - INVERTING setting probably backwards");
// 7557 
// 7558       refresh_cmd_timeout();
// 7559 
// 7560       if (deploy_state != stow_state) {
// 7561         SERIAL_PROTOCOLLNPGM("BLTouch clone detected");
// 7562         if (deploy_state) {
// 7563           SERIAL_PROTOCOLLNPGM(".  DEPLOYED state: HIGH (logic 1)");
// 7564           SERIAL_PROTOCOLLNPGM(".  STOWED (triggered) state: LOW (logic 0)");
// 7565         }
// 7566         else {
// 7567           SERIAL_PROTOCOLLNPGM(".  DEPLOYED state: LOW (logic 0)");
// 7568           SERIAL_PROTOCOLLNPGM(".  STOWED (triggered) state: HIGH (logic 1)");
// 7569         }
// 7570         #if ENABLED(BLTOUCH)
// 7571           SERIAL_PROTOCOLLNPGM("ERROR: BLTOUCH enabled - set this device up as a Z Servo Probe with inverting as true.");
// 7572         #endif
// 7573 
// 7574       }
// 7575       else {                                           // measure active signal length
// 7576         MOVE_SERVO(probe_index, z_servo_angle[0]);     // deploy
// 7577         safe_delay(500);
// 7578         SERIAL_PROTOCOLLNPGM("please trigger probe");
// 7579         uint16_t probe_counter = 0;
// 7580 
// 7581         // Allow 30 seconds max for operator to trigger probe
// 7582         for (uint16_t j = 0; j < 500 * 30 && probe_counter == 0 ; j++) {
// 7583 
// 7584           safe_delay(2);
// 7585 
// 7586           if (0 == j % (500 * 1)) // keep cmd_timeout happy
// 7587             refresh_cmd_timeout();
// 7588 
// 7589           if (deploy_state != READ(PROBE_TEST_PIN)) { // probe triggered
// 7590 
// 7591             for (probe_counter = 1; probe_counter < 50 && deploy_state != READ(PROBE_TEST_PIN); ++probe_counter)
// 7592               safe_delay(2);
// 7593 
// 7594             if (probe_counter == 50)
// 7595               SERIAL_PROTOCOLLNPGM("Z Servo Probe detected"); // >= 100mS active time
// 7596             else if (probe_counter >= 2)
// 7597               SERIAL_PROTOCOLLNPAIR("BLTouch compatible probe detected - pulse width (+/- 4mS): ", probe_counter * 2); // allow 4 - 100mS pulse
// 7598             else
// 7599               SERIAL_PROTOCOLLNPGM("noise detected - please re-run test"); // less than 2mS pulse
// 7600 
// 7601             MOVE_SERVO(probe_index, z_servo_angle[1]); //stow
// 7602 
// 7603           }  // pulse detected
// 7604 
// 7605         } // for loop waiting for trigger
// 7606 
// 7607         if (probe_counter == 0) SERIAL_PROTOCOLLNPGM("trigger not detected");
// 7608 
// 7609       } // measure active signal length
// 7610 
// 7611     #endif
// 7612 
// 7613   } // servo_probe_test
// 7614 
// 7615   /**
// 7616    * M43: Pin debug - report pin state, watch pins, toggle pins and servo probe test/report
// 7617    *
// 7618    *  M43         - report name and state of pin(s)
// 7619    *                  P<pin>  Pin to read or watch. If omitted, reads all pins.
// 7620    *                  I       Flag to ignore Marlin's pin protection.
// 7621    *
// 7622    *  M43 W       - Watch pins -reporting changes- until reset, click, or M108.
// 7623    *                  P<pin>  Pin to read or watch. If omitted, read/watch all pins.
// 7624    *                  I       Flag to ignore Marlin's pin protection.
// 7625    *
// 7626    *  M43 E<bool> - Enable / disable background endstop monitoring
// 7627    *                  - Machine continues to operate
// 7628    *                  - Reports changes to endstops
// 7629    *                  - Toggles LED_PIN when an endstop changes
// 7630    *                  - Can not reliably catch the 5mS pulse from BLTouch type probes
// 7631    *
// 7632    *  M43 T       - Toggle pin(s) and report which pin is being toggled
// 7633    *                  S<pin>  - Start Pin number.   If not given, will default to 0
// 7634    *                  L<pin>  - End Pin number.   If not given, will default to last pin defined for this board
// 7635    *                  I<bool> - Flag to ignore Marlin's pin protection.   Use with caution!!!!
// 7636    *                  R       - Repeat pulses on each pin this number of times before continueing to next pin
// 7637    *                  W       - Wait time (in miliseconds) between pulses.  If not given will default to 500
// 7638    *
// 7639    *  M43 S       - Servo probe test
// 7640    *                  P<index> - Probe index (optional - defaults to 0
// 7641    */
// 7642   inline void gcode_M43() {
// 7643 
// 7644     if (parser.seen('T')) {   // must be first or else its "S" and "E" parameters will execute endstop or servo test
// 7645       toggle_pins();
// 7646       return;
// 7647     }
// 7648 
// 7649     // Enable or disable endstop monitoring
// 7650     if (parser.seen('E')) {
// 7651       endstop_monitor_flag = parser.value_bool();
// 7652       SERIAL_PROTOCOLPGM("endstop monitor ");
// 7653       serialprintPGM(endstop_monitor_flag ? PSTR("en") : PSTR("dis"));
// 7654       SERIAL_PROTOCOLLNPGM("abled");
// 7655       return;
// 7656     }
// 7657 
// 7658     if (parser.seen('S')) {
// 7659       servo_probe_test();
// 7660       return;
// 7661     }
// 7662 
// 7663     // Get the range of pins to test or watch
// 7664     const uint8_t first_pin = parser.byteval('P'),
// 7665                   last_pin = parser.seenval('P') ? first_pin : NUM_DIGITAL_PINS - 1;
// 7666 
// 7667     if (first_pin > last_pin) return;
// 7668 
// 7669     const bool ignore_protection = parser.boolval('I');
// 7670 
// 7671     // Watch until click, M108, or reset
// 7672     if (parser.boolval('W')) {
// 7673       SERIAL_PROTOCOLLNPGM("Watching pins");
// 7674       byte pin_state[last_pin - first_pin + 1];
// 7675       for (int8_t pin = first_pin; pin <= last_pin; pin++) {
// 7676         if (pin_is_protected(pin) && !ignore_protection) continue;
// 7677         pinMode(pin, INPUT_PULLUP);
// 7678         delay(1);
// 7679         /*
// 7680           if (IS_ANALOG(pin))
// 7681             pin_state[pin - first_pin] = analogRead(pin - analogInputToDigitalPin(0)); // int16_t pin_state[...]
// 7682           else
// 7683         //*/
// 7684             pin_state[pin - first_pin] = digitalRead(pin);
// 7685       }
// 7686 
// 7687       #if HAS_RESUME_CONTINUE
// 7688         wait_for_user = true;
// 7689         KEEPALIVE_STATE(PAUSED_FOR_USER);
// 7690       #endif
// 7691 
// 7692       for (;;) {
// 7693         for (int8_t pin = first_pin; pin <= last_pin; pin++) {
// 7694           if (pin_is_protected(pin) && !ignore_protection) continue;
// 7695           const byte val =
// 7696             /*
// 7697               IS_ANALOG(pin)
// 7698                 ? analogRead(pin - analogInputToDigitalPin(0)) : // int16_t val
// 7699                 :
// 7700             //*/
// 7701               digitalRead(pin);
// 7702           if (val != pin_state[pin - first_pin]) {
// 7703             report_pin_state_extended(pin, ignore_protection, false);
// 7704             pin_state[pin - first_pin] = val;
// 7705           }
// 7706         }
// 7707 
// 7708         #if HAS_RESUME_CONTINUE
// 7709           if (!wait_for_user) {
// 7710             KEEPALIVE_STATE(IN_HANDLER);
// 7711             break;
// 7712           }
// 7713         #endif
// 7714 
// 7715         safe_delay(200);
// 7716       }
// 7717       return;
// 7718     }
// 7719 
// 7720     // Report current state of selected pin(s)
// 7721     for (uint8_t pin = first_pin; pin <= last_pin; pin++)
// 7722       report_pin_state_extended(pin, ignore_protection, true);
// 7723   }
// 7724 
// 7725 #endif // PINS_DEBUGGING
// 7726 
// 7727 #if ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
// 7728 
// 7729   /**
// 7730    * M48: Z probe repeatability measurement function.
// 7731    *
// 7732    * Usage:
// 7733    *   M48 <P#> <X#> <Y#> <V#> <E> <L#>
// 7734    *     P = Number of sampled points (4-50, default 10)
// 7735    *     X = Sample X position
// 7736    *     Y = Sample Y position
// 7737    *     V = Verbose level (0-4, default=1)
// 7738    *     E = Engage Z probe for each reading
// 7739    *     L = Number of legs of movement before probe
// 7740    *     S = Schizoid (Or Star if you prefer)
// 7741    *
// 7742    * This function requires the machine to be homed before invocation.
// 7743    */
// 7744   inline void gcode_M48() {
// 7745 
// 7746     if (axis_unhomed_error()) return;
// 7747 
// 7748     const int8_t verbose_level = parser.byteval('V', 1);
// 7749     if (!WITHIN(verbose_level, 0, 4)) {
// 7750       SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-4).");
// 7751       return;
// 7752     }
// 7753 
// 7754     if (verbose_level > 0)
// 7755       SERIAL_PROTOCOLLNPGM("M48 Z-Probe Repeatability Test");
// 7756 
// 7757     const int8_t n_samples = parser.byteval('P', 10);
// 7758     if (!WITHIN(n_samples, 4, 50)) {
// 7759       SERIAL_PROTOCOLLNPGM("?Sample size not plausible (4-50).");
// 7760       return;
// 7761     }
// 7762 
// 7763     const bool stow_probe_after_each = parser.boolval('E');
// 7764 
// 7765     float X_current = current_position[X_AXIS],
// 7766           Y_current = current_position[Y_AXIS];
// 7767 
// 7768     const float X_probe_location = parser.linearval('X', X_current + X_PROBE_OFFSET_FROM_EXTRUDER),
// 7769                 Y_probe_location = parser.linearval('Y', Y_current + Y_PROBE_OFFSET_FROM_EXTRUDER);
// 7770 
// 7771     #if DISABLED(DELTA)
// 7772       if (!WITHIN(X_probe_location, MIN_PROBE_X, MAX_PROBE_X)) {
// 7773         out_of_range_error(PSTR("X"));
// 7774         return;
// 7775       }
// 7776       if (!WITHIN(Y_probe_location, MIN_PROBE_Y, MAX_PROBE_Y)) {
// 7777         out_of_range_error(PSTR("Y"));
// 7778         return;
// 7779       }
// 7780     #else
// 7781       if (!position_is_reachable_by_probe(X_probe_location, Y_probe_location)) {
// 7782         SERIAL_PROTOCOLLNPGM("? (X,Y) location outside of probeable radius.");
// 7783         return;
// 7784       }
// 7785     #endif
// 7786 
// 7787     bool seen_L = parser.seen('L');
// 7788     uint8_t n_legs = seen_L ? parser.value_byte() : 0;
// 7789     if (n_legs > 15) {
// 7790       SERIAL_PROTOCOLLNPGM("?Number of legs in movement not plausible (0-15).");
// 7791       return;
// 7792     }
// 7793     if (n_legs == 1) n_legs = 2;
// 7794 
// 7795     const bool schizoid_flag = parser.boolval('S');
// 7796     if (schizoid_flag && !seen_L) n_legs = 7;
// 7797 
// 7798     /**
// 7799      * Now get everything to the specified probe point So we can safely do a
// 7800      * probe to get us close to the bed.  If the Z-Axis is far from the bed,
// 7801      * we don't want to use that as a starting point for each probe.
// 7802      */
// 7803     if (verbose_level > 2)
// 7804       SERIAL_PROTOCOLLNPGM("Positioning the probe...");
// 7805 
// 7806     // Disable bed level correction in M48 because we want the raw data when we probe
// 7807 
// 7808     #if HAS_LEVELING
// 7809       const bool was_enabled = planner.leveling_active;
// 7810       set_bed_leveling_enabled(false);
// 7811     #endif
// 7812 
// 7813     setup_for_endstop_or_probe_move();
// 7814 
// 7815     double mean = 0.0, sigma = 0.0, min = 99999.9, max = -99999.9, sample_set[n_samples];
// 7816 
// 7817     // Move to the first point, deploy, and probe
// 7818     const float t = probe_pt(X_probe_location, Y_probe_location, stow_probe_after_each, verbose_level);
// 7819     bool probing_good = !isnan(t);
// 7820 
// 7821     if (probing_good) {
// 7822       //randomSeed(millis());
// 7823 	  srand(millis());
// 7824 
// 7825       for (uint8_t n = 0; n < n_samples; n++) {
// 7826         if (n_legs) {
// 7827           const int dir = (random(0, 10) > 5.0) ? -1 : 1;  // clockwise or counter clockwise
// 7828           float angle = random(0.0, 360.0);
// 7829           const float radius = random(
// 7830             #if ENABLED(DELTA)
// 7831               0.1250000000 * (DELTA_PROBEABLE_RADIUS),
// 7832               0.3333333333 * (DELTA_PROBEABLE_RADIUS)
// 7833             #else
// 7834               5.0, 0.125 * min(X_BED_SIZE, Y_BED_SIZE)
// 7835             #endif
// 7836           );
// 7837 
// 7838           if (verbose_level > 3) {
// 7839             SERIAL_ECHOPAIR("Starting radius: ", radius);
// 7840             SERIAL_ECHOPAIR("   angle: ", angle);
// 7841             SERIAL_ECHOPGM(" Direction: ");
// 7842             if (dir > 0) SERIAL_ECHOPGM("Counter-");
// 7843             SERIAL_ECHOLNPGM("Clockwise");
// 7844           }
// 7845 
// 7846           for (uint8_t l = 0; l < n_legs - 1; l++) {
// 7847             double delta_angle;
// 7848 
// 7849             if (schizoid_flag)
// 7850               // The points of a 5 point star are 72 degrees apart.  We need to
// 7851               // skip a point and go to the next one on the star.
// 7852               delta_angle = dir * 2.0 * 72.0;
// 7853 
// 7854             else
// 7855               // If we do this line, we are just trying to move further
// 7856               // around the circle.
// 7857               delta_angle = dir * (float) random(25, 45);
// 7858 
// 7859             angle += delta_angle;
// 7860 
// 7861             while (angle > 360.0)   // We probably do not need to keep the angle between 0 and 2*PI, but the
// 7862               angle -= 360.0;       // Arduino documentation says the trig functions should not be given values
// 7863             while (angle < 0.0)     // outside of this range.   It looks like they behave correctly with
// 7864               angle += 360.0;       // numbers outside of the range, but just to be safe we clamp them.
// 7865 
// 7866             X_current = X_probe_location - (X_PROBE_OFFSET_FROM_EXTRUDER) + cos(RADIANS(angle)) * radius;
// 7867             Y_current = Y_probe_location - (Y_PROBE_OFFSET_FROM_EXTRUDER) + sin(RADIANS(angle)) * radius;
// 7868 
// 7869             #if DISABLED(DELTA)
// 7870               X_current = constrain(X_current, X_MIN_POS, X_MAX_POS);
// 7871               Y_current = constrain(Y_current, Y_MIN_POS, Y_MAX_POS);
// 7872             #else
// 7873               // If we have gone out too far, we can do a simple fix and scale the numbers
// 7874               // back in closer to the origin.
// 7875               while (!position_is_reachable_by_probe(X_current, Y_current)) {
// 7876                 X_current *= 0.8;
// 7877                 Y_current *= 0.8;
// 7878                 if (verbose_level > 3) {
// 7879                   SERIAL_ECHOPAIR("Pulling point towards center:", X_current);
// 7880                   SERIAL_ECHOLNPAIR(", ", Y_current);
// 7881                 }
// 7882               }
// 7883             #endif
// 7884             if (verbose_level > 3) {
// 7885               SERIAL_PROTOCOLPGM("Going to:");
// 7886               SERIAL_ECHOPAIR(" X", X_current);
// 7887               SERIAL_ECHOPAIR(" Y", Y_current);
// 7888               SERIAL_ECHOLNPAIR(" Z", current_position[Z_AXIS]);
// 7889             }
// 7890             do_blocking_move_to_xy(X_current, Y_current);
// 7891           } // n_legs loop
// 7892         } // n_legs
// 7893 
// 7894         // Probe a single point
// 7895         sample_set[n] = probe_pt(X_probe_location, Y_probe_location, stow_probe_after_each, 0);
// 7896 
// 7897         // Break the loop if the probe fails
// 7898         probing_good = !isnan(sample_set[n]);
// 7899         if (!probing_good) break;
// 7900 
// 7901         /**
// 7902          * Get the current mean for the data points we have so far
// 7903          */
// 7904         double sum = 0.0;
// 7905         for (uint8_t j = 0; j <= n; j++) sum += sample_set[j];
// 7906         mean = sum / (n + 1);
// 7907 
// 7908         NOMORE(min, sample_set[n]);
// 7909         NOLESS(max, sample_set[n]);
// 7910 
// 7911         /**
// 7912          * Now, use that mean to calculate the standard deviation for the
// 7913          * data points we have so far
// 7914          */
// 7915         sum = 0.0;
// 7916         for (uint8_t j = 0; j <= n; j++)
// 7917           sum += sq(sample_set[j] - mean);
// 7918 
// 7919         sigma = SQRT(sum / (n + 1));
// 7920         if (verbose_level > 0) {
// 7921           if (verbose_level > 1) {
// 7922             SERIAL_PROTOCOL(n + 1);
// 7923             SERIAL_PROTOCOLPGM(" of ");
// 7924             SERIAL_PROTOCOL((int)n_samples);
// 7925             SERIAL_PROTOCOLPGM(": z: ");
// 7926             SERIAL_PROTOCOL_F(sample_set[n], 3);
// 7927             if (verbose_level > 2) {
// 7928               SERIAL_PROTOCOLPGM(" mean: ");
// 7929               SERIAL_PROTOCOL_F(mean, 4);
// 7930               SERIAL_PROTOCOLPGM(" sigma: ");
// 7931               SERIAL_PROTOCOL_F(sigma, 6);
// 7932               SERIAL_PROTOCOLPGM(" min: ");
// 7933               SERIAL_PROTOCOL_F(min, 3);
// 7934               SERIAL_PROTOCOLPGM(" max: ");
// 7935               SERIAL_PROTOCOL_F(max, 3);
// 7936               SERIAL_PROTOCOLPGM(" range: ");
// 7937               SERIAL_PROTOCOL_F(max-min, 3);
// 7938             }
// 7939             SERIAL_EOL();
// 7940           }
// 7941         }
// 7942 
// 7943       } // n_samples loop
// 7944     }
// 7945 
// 7946     STOW_PROBE();
// 7947 
// 7948     if (probing_good) {
// 7949       SERIAL_PROTOCOLLNPGM("Finished!");
// 7950 
// 7951       if (verbose_level > 0) {
// 7952         SERIAL_PROTOCOLPGM("Mean: ");
// 7953         SERIAL_PROTOCOL_F(mean, 6);
// 7954         SERIAL_PROTOCOLPGM(" Min: ");
// 7955         SERIAL_PROTOCOL_F(min, 3);
// 7956         SERIAL_PROTOCOLPGM(" Max: ");
// 7957         SERIAL_PROTOCOL_F(max, 3);
// 7958         SERIAL_PROTOCOLPGM(" Range: ");
// 7959         SERIAL_PROTOCOL_F(max-min, 3);
// 7960         SERIAL_EOL();
// 7961       }
// 7962 
// 7963       SERIAL_PROTOCOLPGM("Standard Deviation: ");
// 7964       SERIAL_PROTOCOL_F(sigma, 6);
// 7965       SERIAL_EOL();
// 7966       SERIAL_EOL();
// 7967     }
// 7968 
// 7969     clean_up_after_endstop_or_probe_move();
// 7970 
// 7971     // Re-enable bed level correction if it had been on
// 7972     #if HAS_LEVELING
// 7973       set_bed_leveling_enabled(was_enabled);
// 7974     #endif
// 7975 
// 7976     report_current_position();
// 7977   }
// 7978 
// 7979 #endif // Z_MIN_PROBE_REPEATABILITY_TEST
// 7980 
// 7981 #if ENABLED(G26_MESH_VALIDATION)
// 7982 
// 7983   inline void gcode_M49() {
// 7984     g26_debug_flag ^= true;
// 7985     SERIAL_PROTOCOLPGM("G26 Debug ");
// 7986     serialprintPGM(g26_debug_flag ? PSTR("on.\n") : PSTR("off.\n"));
// 7987   }
// 7988 
// 7989 #endif // G26_MESH_VALIDATION
// 7990 
// 7991 #if ENABLED(ULTRA_LCD) && ENABLED(LCD_SET_PROGRESS_MANUALLY)
// 7992   /**
// 7993    * M73: Set percentage complete (for display on LCD)
// 7994    *
// 7995    * Example:
// 7996    *   M73 P25 ; Set progress to 25%
// 7997    *
// 7998    * Notes:
// 7999    *   This has no effect during an SD print job
// 8000    */
// 8001   inline void gcode_M73() {
// 8002     if (!IS_SD_PRINTING && parser.seen('P')) {
// 8003       progress_bar_percent = parser.value_byte();
// 8004       NOMORE(progress_bar_percent, 100);
// 8005     }
// 8006   }
// 8007 #endif // ULTRA_LCD && LCD_SET_PROGRESS_MANUALLY
// 8008 
// 8009 /**
// 8010  * M75: Start print timer
// 8011  */
// 8012 inline void gcode_M75() { print_job_timer.start(); }
// 8013 
// 8014 /**
// 8015  * M76: Pause print timer
// 8016  */
// 8017 inline void gcode_M76() { print_job_timer.pause(); }
// 8018 
// 8019 /**
// 8020  * M77: Stop print timer
// 8021  */
// 8022 inline void gcode_M77() { print_job_timer.stop(); }
// 8023 
// 8024 #if ENABLED(PRINTCOUNTER)
// 8025   /**
// 8026    * M78: Show print statistics
// 8027    */
// 8028   inline void gcode_M78() {
// 8029     // "M78 S78" will reset the statistics
// 8030     if (parser.intval('S') == 78)
// 8031       print_job_timer.initStats();
// 8032     else
// 8033       print_job_timer.showStats();
// 8034   }
// 8035 #endif
// 8036 
// 8037 /**
// 8038  * M104: Set hot end temperature
// 8039  */
// 8040 inline void gcode_M104() {
// 8041   if (get_target_extruder_from_command(104)) return;
// 8042   if (DEBUGGING(DRYRUN)) return;
// 8043 
// 8044   #if ENABLED(SINGLENOZZLE)
// 8045     if (target_extruder != active_extruder) return;
// 8046   #endif
// 8047 
// 8048   if (parser.seenval('S')) {
// 8049     const int16_t temp = parser.value_celsius();
// 8050     thermalManager.setTargetHotend(temp, target_extruder);
// 8051 
// 8052     #if ENABLED(DUAL_X_CARRIAGE)
// 8053       if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && target_extruder == 0)
// 8054         thermalManager.setTargetHotend(temp ? temp + duplicate_extruder_temp_offset : 0, 1);
// 8055     #endif
// 8056 
// 8057     #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
// 8058       /**
// 8059        * Stop the timer at the end of print. Start is managed by 'heat and wait' M109.
// 8060        * We use half EXTRUDE_MINTEMP here to allow nozzles to be put into hot
// 8061        * standby mode, for instance in a dual extruder setup, without affecting
// 8062        * the running print timer.
// 8063        */
// 8064       if (parser.value_celsius() <= (EXTRUDE_MINTEMP) / 2) {
// 8065         print_job_timer.stop();
// 8066         LCD_MESSAGEPGM(WELCOME_MSG);
// 8067       }
// 8068     #endif
// 8069 
// 8070     //if (parser.value_celsius() > thermalManager.degHotend(target_extruder))
// 8071     //  lcd_status_printf_P(0, PSTR("E%i %s"), target_extruder + 1, MSG_HEATING);
// 8072 		if(parser.value_celsius() > thermalManager.degHotend(target_extruder))
// 8073 		{
// 8074 		switch(target_extruder)
// 8075 			{
// 8076 			case 0:
// 8077 				LCD_MESSAGEPGM("E1 Heating...");
// 8078 				break;
// 8079 			case 1:
// 8080 				LCD_MESSAGEPGM("E2 Heating...");
// 8081 				break;
// 8082 			case 2:
// 8083 				LCD_MESSAGEPGM("E3 Heating...");
// 8084 				break;
// 8085 			case 3:
// 8086 				LCD_MESSAGEPGM("E4 Heating...");
// 8087 				break;
// 8088 			case 4:
// 8089 				LCD_MESSAGEPGM("E5 Heating...");
// 8090 				break;
// 8091 			default: break;
// 8092 				
// 8093 			}
// 8094 		}    
// 8095   }
// 8096 
// 8097   #if ENABLED(AUTOTEMP)
// 8098     planner.autotemp_M104_M109();
// 8099   #endif
// 8100 }
// 8101 
// 8102 /**
// 8103  * M105: Read hot end and bed temperature
// 8104  */
// 8105 inline void gcode_M105() {
// 8106   if (get_target_extruder_from_command(105)) return;
// 8107 
// 8108   #if HAS_TEMP_HOTEND || HAS_TEMP_BED
// 8109     SERIAL_PROTOCOLPGM(MSG_OK);
// 8110     thermalManager.print_heaterstates();
// 8111   #else // !HAS_TEMP_HOTEND && !HAS_TEMP_BED
// 8112     SERIAL_ERROR_START();
// 8113     SERIAL_ERRORLNPGM(MSG_ERR_NO_THERMISTORS);
// 8114   #endif
// 8115 
// 8116   SERIAL_EOL();
// 8117 }
// 8118 
// 8119 #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
// 8120 
// 8121   /**
// 8122    * M155: Set temperature auto-report interval. M155 S<seconds>
// 8123    */
// 8124   inline void gcode_M155() {
// 8125     if (parser.seenval('S'))
// 8126       thermalManager.set_auto_report_interval(parser.value_byte());
// 8127   }
// 8128 
// 8129 #endif // AUTO_REPORT_TEMPERATURES
// 8130 
// 8131 #if FAN_COUNT > 0
// 8132 
// 8133   /**
// 8134    * M106: Set Fan Speed
// 8135    *
// 8136    *  S<int>   Speed between 0-255
// 8137    *  P<index> Fan index, if more than one fan
// 8138    *
// 8139    * With EXTRA_FAN_SPEED enabled:
// 8140    *
// 8141    *  T<int>   Restore/Use/Set Temporary Speed:
// 8142    *           1     = Restore previous speed after T2
// 8143    *           2     = Use temporary speed set with T3-255
// 8144    *           3-255 = Set the speed for use with T2
// 8145    */
// 8146   inline void gcode_M106() {
// 8147     const uint8_t p = parser.byteval('P');
// 8148     if (p < FAN_COUNT) {
// 8149       #if ENABLED(EXTRA_FAN_SPEED)
// 8150         const int16_t t = parser.intval('T');
// 8151         if (t > 0) {
// 8152           switch (t) {
// 8153             case 1:
// 8154               fanSpeeds[p] = old_fanSpeeds[p];
// 8155               break;
// 8156             case 2:
// 8157               old_fanSpeeds[p] = fanSpeeds[p];
// 8158               fanSpeeds[p] = new_fanSpeeds[p];
// 8159               break;
// 8160             default:
// 8161               new_fanSpeeds[p] = min(t, 255);
// 8162               break;
// 8163           }
// 8164           return;
// 8165         }
// 8166       #endif // EXTRA_FAN_SPEED
// 8167       const uint16_t s = parser.ushortval('S', 255);
// 8168       fanSpeeds[p] = min(s, 255);
// 8169 	  MKS_FAN_TIM = s*10000/255;
// 8170     }
// 8171   }
// 8172 
// 8173   /**
// 8174    * M107: Fan Off
// 8175    */
// 8176   inline void gcode_M107() {
// 8177     const uint16_t p = parser.ushortval('P');
// 8178     if (p < FAN_COUNT) 
// 8179     {
// 8180 		fanSpeeds[p] = 0;
// 8181 		MKS_FAN_TIM = 0 ;
// 8182     }
// 8183   }
// 8184 
// 8185 #endif // FAN_COUNT > 0
// 8186 
// 8187 #if DISABLED(EMERGENCY_PARSER)
// 8188 
// 8189   /**
// 8190    * M108: Stop the waiting for heaters in M109, M190, M303. Does not affect the target temperature.
// 8191    */
// 8192   inline void gcode_M108() { wait_for_heatup = false; }
// 8193 
// 8194 
// 8195   /**
// 8196    * M112: Emergency Stop
// 8197    */
// 8198   inline void gcode_M112() { kill(PSTR(MSG_KILLED)); }
// 8199 
// 8200 
// 8201   /**
// 8202    * M410: Quickstop - Abort all planned moves
// 8203    *
// 8204    * This will stop the carriages mid-move, so most likely they
// 8205    * will be out of sync with the stepper position after this.
// 8206    */
// 8207   inline void gcode_M410() { quickstop_stepper(); }
// 8208 
// 8209 #endif
// 8210 
// 8211 /**
// 8212  * M109: Sxxx Wait for extruder(s) to reach temperature. Waits only when heating.
// 8213  *       Rxxx Wait for extruder(s) to reach temperature. Waits when heating and cooling.
// 8214  */
// 8215 
// 8216 #ifndef MIN_COOLING_SLOPE_DEG
// 8217   #define MIN_COOLING_SLOPE_DEG 1.50
// 8218 #endif
// 8219 #ifndef MIN_COOLING_SLOPE_TIME
// 8220   #define MIN_COOLING_SLOPE_TIME 60
// 8221 #endif
// 8222 
// 8223 inline void gcode_M109() {
// 8224 
// 8225   if (get_target_extruder_from_command(109)) return;
// 8226   if (DEBUGGING(DRYRUN)) return;
// 8227 
// 8228   #if ENABLED(SINGLENOZZLE)
// 8229     if (target_extruder != active_extruder) return;
// 8230   #endif
// 8231 
// 8232   const bool no_wait_for_cooling = parser.seenval('S');
// 8233   if (no_wait_for_cooling || parser.seenval('R')) {
// 8234     const int16_t temp = parser.value_celsius();
// 8235     thermalManager.setTargetHotend(temp, target_extruder);
// 8236 
// 8237     #if ENABLED(DUAL_X_CARRIAGE)
// 8238       if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && target_extruder == 0)
// 8239         thermalManager.setTargetHotend(temp ? temp + duplicate_extruder_temp_offset : 0, 1);
// 8240     #endif
// 8241 
// 8242     #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
// 8243       /**
// 8244        * Use half EXTRUDE_MINTEMP to allow nozzles to be put into hot
// 8245        * standby mode, (e.g., in a dual extruder setup) without affecting
// 8246        * the running print timer.
// 8247        */
// 8248       if (parser.value_celsius() <= (EXTRUDE_MINTEMP) / 2) {
// 8249         print_job_timer.stop();
// 8250         LCD_MESSAGEPGM(WELCOME_MSG);
// 8251       }
// 8252       else
// 8253         print_job_timer.start();
// 8254     #endif
// 8255 
// 8256     //if (thermalManager.isHeatingHotend(target_extruder)) lcd_status_printf_P(0, PSTR("E%i %s"), target_extruder + 1, MSG_HEATING);
// 8257 	if (parser.value_celsius() > thermalManager.degHotend(target_extruder))
// 8258 	{
// 8259 			switch(target_extruder)
// 8260 			{
// 8261 			case 0:
// 8262 				LCD_MESSAGEPGM("E1 Heating...");
// 8263 				break;
// 8264 			case 1:
// 8265 				LCD_MESSAGEPGM("E2 Heating...");
// 8266 				break;
// 8267 			case 2:
// 8268 				LCD_MESSAGEPGM("E3 Heating...");
// 8269 				break;
// 8270 			case 3:
// 8271 				LCD_MESSAGEPGM("E4 Heating...");
// 8272 				break;
// 8273 			case 4:
// 8274 				LCD_MESSAGEPGM("E5 Heating...");
// 8275 				break;
// 8276 			default: break;
// 8277 			}
// 8278 	}
// 8279 
// 8280   }
// 8281   else return;
// 8282 
// 8283   #if ENABLED(AUTOTEMP)
// 8284     planner.autotemp_M104_M109();
// 8285   #endif
// 8286 
// 8287   #if TEMP_RESIDENCY_TIME > 0
// 8288     millis_t residency_start_ms = 0;
// 8289     // Loop until the temperature has stabilized
// 8290     #define TEMP_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_RESIDENCY_TIME) * 1000UL))
// 8291   #else
// 8292     // Loop until the temperature is very close target
// 8293     #define TEMP_CONDITIONS (wants_to_cool ? thermalManager.isCoolingHotend(target_extruder) : thermalManager.isHeatingHotend(target_extruder))
// 8294   #endif
// 8295 
// 8296   float target_temp = -1.0, old_temp = 9999.0;
// 8297   bool wants_to_cool = false;
// 8298   wait_for_heatup = true;
// 8299   millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
// 8300 
// 8301   #if DISABLED(BUSY_WHILE_HEATING)
// 8302     KEEPALIVE_STATE(NOT_BUSY);
// 8303   #endif
// 8304 
// 8305   #if ENABLED(PRINTER_EVENT_LEDS)
// 8306     const float start_temp = thermalManager.degHotend(target_extruder);
// 8307     uint8_t old_blue = 0;
// 8308   #endif
// 8309   
// 8310   mks_heating_busy = 1;
// 8311 
// 8312   do {
// 8313     // Target temperature might be changed during the loop
// 8314     if (target_temp != thermalManager.degTargetHotend(target_extruder)) {
// 8315       wants_to_cool = thermalManager.isCoolingHotend(target_extruder);
// 8316       target_temp = thermalManager.degTargetHotend(target_extruder);
// 8317 
// 8318       // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
// 8319       if (no_wait_for_cooling && wants_to_cool) break;
// 8320     }
// 8321 
// 8322     now = millis();
// 8323     if (ELAPSED(now, next_temp_ms)) { //Print temp & remaining time every 1s while waiting
// 8324       next_temp_ms = now + 1000UL;
// 8325       //thermalManager.print_heaterstates();    //mks 2018-08
// 8326       #if TEMP_RESIDENCY_TIME > 0
// 8327         SERIAL_PROTOCOLPGM(" W:");
// 8328         if (residency_start_ms)
// 8329           SERIAL_PROTOCOL(long((((TEMP_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL));
// 8330         else
// 8331           SERIAL_PROTOCOLCHAR('?');
// 8332       #endif
// 8333       SERIAL_EOL();
// 8334     }
// 8335 
// 8336     idle();
// 8337     refresh_cmd_timeout(); // to prevent stepper_inactive_time from running out
// 8338 
// 8339     const float temp = thermalManager.degHotend(target_extruder);
// 8340 
// 8341     #if ENABLED(PRINTER_EVENT_LEDS)
// 8342       // Gradually change LED strip from violet to red as nozzle heats up
// 8343       if (!wants_to_cool) {
// 8344         const uint8_t blue = map(constrain(temp, start_temp, target_temp), start_temp, target_temp, 255, 0);
// 8345         if (blue != old_blue) {
// 8346           old_blue = blue;
// 8347           leds.set_color(
// 8348             MakeLEDColor(255, 0, blue, 0, pixels.getBrightness())
// 8349             #if ENABLED(NEOPIXEL_IS_SEQUENTIAL)
// 8350               , true
// 8351             #endif
// 8352           );
// 8353         }
// 8354       }
// 8355     #endif
// 8356 
// 8357     #if TEMP_RESIDENCY_TIME > 0
// 8358 
// 8359       const float temp_diff = FABS(target_temp - temp);
// 8360 
// 8361       if (!residency_start_ms) {
// 8362         // Start the TEMP_RESIDENCY_TIME timer when we reach target temp for the first time.
// 8363         if (temp_diff < TEMP_WINDOW) residency_start_ms = now;
// 8364       }
// 8365       else if (temp_diff > TEMP_HYSTERESIS) {
// 8366         // Restart the timer whenever the temperature falls outside the hysteresis.
// 8367         residency_start_ms = now;
// 8368       }
// 8369 
// 8370     #endif
// 8371 
// 8372     // Prevent a wait-forever situation if R is misused i.e. M109 R0
// 8373     if (wants_to_cool) {
// 8374       // break after MIN_COOLING_SLOPE_TIME seconds
// 8375       // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG
// 8376       if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
// 8377         if (old_temp - temp < MIN_COOLING_SLOPE_DEG) break;
// 8378         next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME;
// 8379         old_temp = temp;
// 8380       }
// 8381     }
// 8382 
// 8383   } while (wait_for_heatup && TEMP_CONDITIONS);
// 8384   
// 8385   mks_heating_busy = 0;
// 8386 
// 8387   if (wait_for_heatup) {
// 8388     LCD_MESSAGEPGM(MSG_HEATING_COMPLETE);
// 8389     #if ENABLED(PRINTER_EVENT_LEDS)
// 8390       leds.set_white();
// 8391     #endif
// 8392   }
// 8393 
// 8394   #if DISABLED(BUSY_WHILE_HEATING)
// 8395     KEEPALIVE_STATE(IN_HANDLER);
// 8396   #endif
// 8397 }
// 8398 
// 8399 #if HAS_TEMP_BED
// 8400 
// 8401   #ifndef MIN_COOLING_SLOPE_DEG_BED
// 8402     #define MIN_COOLING_SLOPE_DEG_BED 1.50
// 8403   #endif
// 8404   #ifndef MIN_COOLING_SLOPE_TIME_BED
// 8405     #define MIN_COOLING_SLOPE_TIME_BED 60
// 8406   #endif
// 8407 
// 8408   /**
// 8409    * M190: Sxxx Wait for bed current temp to reach target temp. Waits only when heating
// 8410    *       Rxxx Wait for bed current temp to reach target temp. Waits when heating and cooling
// 8411    */
// 8412   inline void gcode_M190() {
// 8413     if (DEBUGGING(DRYRUN)) return;
// 8414 
// 8415     LCD_MESSAGEPGM(MSG_BED_HEATING);
// 8416     const bool no_wait_for_cooling = parser.seenval('S');
// 8417     if (no_wait_for_cooling || parser.seenval('R')) {
// 8418       thermalManager.setTargetBed(parser.value_celsius());
// 8419       #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
// 8420         if (parser.value_celsius() > BED_MINTEMP)
// 8421           print_job_timer.start();
// 8422       #endif
// 8423     }
// 8424     else return;
// 8425 
// 8426     #if TEMP_BED_RESIDENCY_TIME > 0
// 8427       millis_t residency_start_ms = 0;
// 8428       // Loop until the temperature has stabilized
// 8429       #define TEMP_BED_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_BED_RESIDENCY_TIME) * 1000UL))
// 8430     #else
// 8431       // Loop until the temperature is very close target
// 8432       #define TEMP_BED_CONDITIONS (wants_to_cool ? thermalManager.isCoolingBed() : thermalManager.isHeatingBed())
// 8433     #endif
// 8434 
// 8435     float target_temp = -1.0, old_temp = 9999.0;
// 8436     bool wants_to_cool = false;
// 8437     wait_for_heatup = true;
// 8438     millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
// 8439 
// 8440     #if DISABLED(BUSY_WHILE_HEATING)
// 8441       KEEPALIVE_STATE(NOT_BUSY);
// 8442     #endif
// 8443 
// 8444     target_extruder = active_extruder; // for print_heaterstates
// 8445 
// 8446     #if ENABLED(PRINTER_EVENT_LEDS)
// 8447       const float start_temp = thermalManager.degBed();
// 8448       uint8_t old_red = 255;
// 8449     #endif
// 8450 	mks_heating_busy = 1;
// 8451 
// 8452     do {
// 8453       // Target temperature might be changed during the loop
// 8454       if (target_temp != thermalManager.degTargetBed()) {
// 8455         wants_to_cool = thermalManager.isCoolingBed();
// 8456         target_temp = thermalManager.degTargetBed();
// 8457 
// 8458         // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
// 8459         if (no_wait_for_cooling && wants_to_cool) break;
// 8460       }
// 8461 
// 8462       now = millis();
// 8463       if (ELAPSED(now, next_temp_ms)) { //Print Temp Reading every 1 second while heating up.
// 8464         next_temp_ms = now + 1000UL;
// 8465         thermalManager.print_heaterstates();
// 8466         #if TEMP_BED_RESIDENCY_TIME > 0
// 8467           SERIAL_PROTOCOLPGM(" W:");
// 8468           if (residency_start_ms)
// 8469             SERIAL_PROTOCOL(long((((TEMP_BED_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL));
// 8470           else
// 8471             SERIAL_PROTOCOLCHAR('?');
// 8472         #endif
// 8473         SERIAL_EOL();
// 8474       }
// 8475 
// 8476       idle();
// 8477       refresh_cmd_timeout(); // to prevent stepper_inactive_time from running out
// 8478 
// 8479       const float temp = thermalManager.degBed();
// 8480 
// 8481       #if ENABLED(PRINTER_EVENT_LEDS)
// 8482         // Gradually change LED strip from blue to violet as bed heats up
// 8483         if (!wants_to_cool) {
// 8484           const uint8_t red = map(constrain(temp, start_temp, target_temp), start_temp, target_temp, 0, 255);
// 8485           if (red != old_red) {
// 8486             old_red = red;
// 8487             leds.set_color(
// 8488               MakeLEDColor(red, 0, 255, 0, pixels.getBrightness())
// 8489               #if ENABLED(NEOPIXEL_IS_SEQUENTIAL)
// 8490                 , true
// 8491               #endif
// 8492             );
// 8493           }
// 8494         }
// 8495       #endif
// 8496 
// 8497       #if TEMP_BED_RESIDENCY_TIME > 0
// 8498 
// 8499         const float temp_diff = FABS(target_temp - temp);
// 8500 
// 8501         if (!residency_start_ms) {
// 8502           // Start the TEMP_BED_RESIDENCY_TIME timer when we reach target temp for the first time.
// 8503           if (temp_diff < TEMP_BED_WINDOW) residency_start_ms = now;
// 8504         }
// 8505         else if (temp_diff > TEMP_BED_HYSTERESIS) {
// 8506           // Restart the timer whenever the temperature falls outside the hysteresis.
// 8507           residency_start_ms = now;
// 8508         }
// 8509 
// 8510       #endif // TEMP_BED_RESIDENCY_TIME > 0
// 8511 
// 8512       // Prevent a wait-forever situation if R is misused i.e. M190 R0
// 8513       if (wants_to_cool) {
// 8514         // Break after MIN_COOLING_SLOPE_TIME_BED seconds
// 8515         // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG_BED
// 8516         if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
// 8517           if (old_temp - temp < MIN_COOLING_SLOPE_DEG_BED) break;
// 8518           next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME_BED;
// 8519           old_temp = temp;
// 8520         }
// 8521       }
// 8522 
// 8523     } while (wait_for_heatup && TEMP_BED_CONDITIONS);
// 8524 
// 8525 	mks_heating_busy = 0;
// 8526 
// 8527     if (wait_for_heatup) LCD_MESSAGEPGM(MSG_BED_DONE);
// 8528     #if DISABLED(BUSY_WHILE_HEATING)
// 8529       KEEPALIVE_STATE(IN_HANDLER);
// 8530     #endif
// 8531   }
// 8532 
// 8533 #endif // HAS_TEMP_BED
// 8534 
// 8535 /**
// 8536  * M110: Set Current Line Number
// 8537  */
// 8538 inline void gcode_M110() {
// 8539   if (parser.seenval('N')) gcode_LastN = parser.value_long();
// 8540 }
// 8541 
// 8542 /**
// 8543  * M111: Set the debug level
// 8544  */
// 8545 inline void gcode_M111() {
// 8546   if (parser.seen('S')) marlin_debug_flags = parser.byteval('S');
// 8547 

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vE11str_debug_1
// 8548   const static char str_debug_1[] PROGMEM = MSG_DEBUG_ECHO,
_ZZ10gcode_M111vE11str_debug_1:
        DATA
        DC8 "ECHO"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vE11str_debug_2
// 8549                     str_debug_2[] PROGMEM = MSG_DEBUG_INFO,
_ZZ10gcode_M111vE11str_debug_2:
        DATA
        DC8 "INFO"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vE11str_debug_4
// 8550                     str_debug_4[] PROGMEM = MSG_DEBUG_ERRORS,
_ZZ10gcode_M111vE11str_debug_4:
        DATA
        DC8 "ERRORS"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vE11str_debug_8
// 8551                     str_debug_8[] PROGMEM = MSG_DEBUG_DRYRUN,
_ZZ10gcode_M111vE11str_debug_8:
        DATA
        DC8 "DRYRUN"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vE12str_debug_16
// 8552                     str_debug_16[] PROGMEM = MSG_DEBUG_COMMUNICATION
_ZZ10gcode_M111vE12str_debug_16:
        DATA
        DC8 "COMMUNICATION"
        DC8 0, 0
// 8553                     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 8554                       , str_debug_32[] PROGMEM = MSG_DEBUG_LEVELING
// 8555                     #endif
// 8556                     ;
// 8557 

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vE13debug_strings
// 8558   const static char* const debug_strings[] PROGMEM = {
_ZZ10gcode_M111vE13debug_strings:
        DATA
        DC32 _ZZ10gcode_M111vE11str_debug_1, _ZZ10gcode_M111vE11str_debug_2
        DC32 _ZZ10gcode_M111vE11str_debug_4, _ZZ10gcode_M111vE11str_debug_8
        DC32 _ZZ10gcode_M111vE12str_debug_16

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "mks_pft.sys">`:
        DC8 "mks_pft.sys"

        SECTION `.rodata`:CONST:NOROOT(1)
        DATA
`?<Constant "Z">`:
        DC8 "Z"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant {(0.0F), (0.0F)}>`:
        DC32 0H, 0H

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant " Z:">`:
        DC8 " Z:"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "X:">`:
        DC8 "X:"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant " Y:">`:
        DC8 " Y:"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant " E:">`:
        DC8 " E:"

        SECTION `.rodata`:CONST:NOROOT(1)
        DATA
`?<Constant ":">`:
        DC8 ":"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "ok">`:
        DC8 "ok"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "M29">`:
        DC8 "M29"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "%f">`:
        DC8 "%f"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant " Y">`:
        DC8 " Y"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "G28">`:
        DC8 "G28"

        SECTION `.rodata`:CONST:NOROOT(1)
        DATA
`?<Constant "/">`:
        DC8 "/"
// 8559     str_debug_1, str_debug_2, str_debug_4, str_debug_8, str_debug_16
// 8560     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 8561       , str_debug_32
// 8562     #endif
// 8563   };
// 8564 
// 8565   SERIAL_ECHO_START();
// 8566   SERIAL_ECHOPGM(MSG_DEBUG_PREFIX);
// 8567   if (marlin_debug_flags) {
// 8568     uint8_t comma = 0;
// 8569     for (uint8_t i = 0; i < COUNT(debug_strings); i++) {
// 8570       if (TEST(marlin_debug_flags, i)) {
// 8571         if (comma++) SERIAL_CHAR(',');
// 8572         //serialprintPGM((char*)pgm_read_word(&debug_strings[i]));
// 8573         serialprintPGM((char*)&(debug_strings[i]));
// 8574       }
// 8575     }
// 8576   }
// 8577   else {
// 8578     SERIAL_ECHOPGM(MSG_DEBUG_OFF);
// 8579   }
// 8580   SERIAL_EOL();
// 8581 }
// 8582 
// 8583 #if ENABLED(HOST_KEEPALIVE_FEATURE)
// 8584 
// 8585   /**
// 8586    * M113: Get or set Host Keepalive interval (0 to disable)
// 8587    *
// 8588    *   S<seconds> Optional. Set the keepalive interval.
// 8589    */
// 8590   inline void gcode_M113() {
// 8591     if (parser.seenval('S')) {
// 8592       host_keepalive_interval = parser.value_byte();
// 8593       NOMORE(host_keepalive_interval, 60);
// 8594     }
// 8595     else {
// 8596       SERIAL_ECHO_START();
// 8597       SERIAL_ECHOLNPAIR("M113 S", (unsigned long)host_keepalive_interval);
// 8598     }
// 8599   }
// 8600 
// 8601 #endif
// 8602 
// 8603 #if ENABLED(BARICUDA)
// 8604 
// 8605   #if HAS_HEATER_1
// 8606     /**
// 8607      * M126: Heater 1 valve open
// 8608      */
// 8609     inline void gcode_M126() { baricuda_valve_pressure = parser.byteval('S', 255); }
// 8610     /**
// 8611      * M127: Heater 1 valve close
// 8612      */
// 8613     inline void gcode_M127() { baricuda_valve_pressure = 0; }
// 8614   #endif
// 8615 
// 8616   #if HAS_HEATER_2
// 8617     /**
// 8618      * M128: Heater 2 valve open
// 8619      */
// 8620     inline void gcode_M128() { baricuda_e_to_p_pressure = parser.byteval('S', 255); }
// 8621     /**
// 8622      * M129: Heater 2 valve close
// 8623      */
// 8624     inline void gcode_M129() { baricuda_e_to_p_pressure = 0; }
// 8625   #endif
// 8626 
// 8627 #endif // BARICUDA
// 8628 
// 8629 /**
// 8630  * M140: Set bed temperature
// 8631  */
// 8632 inline void gcode_M140() {
// 8633   if (DEBUGGING(DRYRUN)) return;
// 8634   if (parser.seenval('S')) thermalManager.setTargetBed(parser.value_celsius());
// 8635 }
// 8636 
// 8637 #if ENABLED(ULTIPANEL)
// 8638 
// 8639   /**
// 8640    * M145: Set the heatup state for a material in the LCD menu
// 8641    *
// 8642    *   S<material> (0=PLA, 1=ABS)
// 8643    *   H<hotend temp>
// 8644    *   B<bed temp>
// 8645    *   F<fan speed>
// 8646    */
// 8647   inline void gcode_M145() {
// 8648     const uint8_t material = (uint8_t)parser.intval('S');
// 8649     if (material >= COUNT(lcd_preheat_hotend_temp)) {
// 8650       SERIAL_ERROR_START();
// 8651       SERIAL_ERRORLNPGM(MSG_ERR_MATERIAL_INDEX);
// 8652     }
// 8653     else {
// 8654       int v;
// 8655       if (parser.seenval('H')) {
// 8656         v = parser.value_int();
// 8657         lcd_preheat_hotend_temp[material] = constrain(v, EXTRUDE_MINTEMP, HEATER_0_MAXTEMP - 15);
// 8658       }
// 8659       if (parser.seenval('F')) {
// 8660         v = parser.value_int();
// 8661         lcd_preheat_fan_speed[material] = constrain(v, 0, 255);
// 8662       }
// 8663       #if TEMP_SENSOR_BED != 0
// 8664         if (parser.seenval('B')) {
// 8665           v = parser.value_int();
// 8666           lcd_preheat_bed_temp[material] = constrain(v, BED_MINTEMP, BED_MAXTEMP - 15);
// 8667         }
// 8668       #endif
// 8669     }
// 8670   }
// 8671 
// 8672 #endif // ULTIPANEL
// 8673 
// 8674 #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
// 8675   /**
// 8676    * M149: Set temperature units
// 8677    */
// 8678   inline void gcode_M149() {
// 8679          if (parser.seenval('C')) parser.set_input_temp_units(TEMPUNIT_C);
// 8680     else if (parser.seenval('K')) parser.set_input_temp_units(TEMPUNIT_K);
// 8681     else if (parser.seenval('F')) parser.set_input_temp_units(TEMPUNIT_F);
// 8682   }
// 8683 #endif
// 8684 
// 8685 #if HAS_POWER_SWITCH
// 8686 
// 8687   /**
// 8688    * M80   : Turn on the Power Supply
// 8689    * M80 S : Report the current state and exit
// 8690    */
// 8691   inline void gcode_M80() {
// 8692 
// 8693     // S: Report the current power supply state and exit
// 8694     if (parser.seen('S')) {
// 8695       serialprintPGM(powersupply_on ? PSTR("PS:1\n") : PSTR("PS:0\n"));
// 8696       return;
// 8697     }
// 8698 
// 8699     OUT_WRITE(PS_ON_PIN, PS_ON_AWAKE); // GND
// 8700 
// 8701     /**
// 8702      * If you have a switch on suicide pin, this is useful
// 8703      * if you want to start another print with suicide feature after
// 8704      * a print without suicide...
// 8705      */
// 8706     #if HAS_SUICIDE
// 8707       OUT_WRITE(SUICIDE_PIN, HIGH);
// 8708     #endif
// 8709 
// 8710     #if ENABLED(HAVE_TMC2130)
// 8711       delay(100);
// 8712       tmc2130_init(); // Settings only stick when the driver has power
// 8713     #endif
// 8714 
// 8715     powersupply_on = true;
// 8716 
// 8717     #if ENABLED(ULTIPANEL)
// 8718       LCD_MESSAGEPGM(WELCOME_MSG);
// 8719     #endif
// 8720 
// 8721     #if ENABLED(HAVE_TMC2208)
// 8722       delay(100);
// 8723       tmc2208_init();
// 8724     #endif
// 8725   }
// 8726 
// 8727 #endif // HAS_POWER_SWITCH
// 8728 
// 8729 /**
// 8730  * M81: Turn off Power, including Power Supply, if there is one.
// 8731  *
// 8732  *      This code should ALWAYS be available for EMERGENCY SHUTDOWN!
// 8733  */
// 8734 inline void gcode_M81() {
// 8735   thermalManager.disable_all_heaters();
// 8736   stepper.finish_and_disable();
// 8737 
// 8738   #if FAN_COUNT > 0
// 8739     for (uint8_t i = 0; i < FAN_COUNT; i++) fanSpeeds[i] = 0;
// 8740     #if ENABLED(PROBING_FANS_OFF)
// 8741       fans_paused = false;
// 8742       ZERO(paused_fanSpeeds);
// 8743     #endif
// 8744   #endif
// 8745 
// 8746   safe_delay(1000); // Wait 1 second before switching off
// 8747 
// 8748   #if HAS_SUICIDE
// 8749     stepper.synchronize();
// 8750     suicide();
// 8751   #elif HAS_POWER_SWITCH
// 8752     OUT_WRITE(PS_ON_PIN, PS_ON_ASLEEP);
// 8753     powersupply_on = false;
// 8754   #endif
// 8755 
// 8756   #if ENABLED(ULTIPANEL)
// 8757     LCD_MESSAGEPGM(MACHINE_NAME " " MSG_OFF ".");
// 8758   #endif
// 8759 }
// 8760 
// 8761 /**
// 8762  * M82: Set E codes absolute (default)
// 8763  */
// 8764 inline void gcode_M82() { axis_relative_modes[E_AXIS] = false; }
// 8765 
// 8766 /**
// 8767  * M83: Set E codes relative while in Absolute Coordinates (G90) mode
// 8768  */
// 8769 inline void gcode_M83() { axis_relative_modes[E_AXIS] = true; }
// 8770 
// 8771 /**
// 8772  * M18, M84: Disable stepper motors
// 8773  */
// 8774 inline void gcode_M18_M84() {
// 8775   if (parser.seenval('S')) {
// 8776     stepper_inactive_time = parser.value_millis_from_seconds();
// 8777   }
// 8778   else {
// 8779     bool all_axis = !((parser.seen('X')) || (parser.seen('Y')) || (parser.seen('Z')) || (parser.seen('E')));
// 8780     if (all_axis) {
// 8781       stepper.finish_and_disable();
// 8782     }
// 8783     else {
// 8784       stepper.synchronize();
// 8785       if (parser.seen('X')) disable_X();
// 8786       if (parser.seen('Y')) disable_Y();
// 8787       if (parser.seen('Z')) disable_Z();
// 8788       #if E0_ENABLE_PIN != X_ENABLE_PIN && E1_ENABLE_PIN != Y_ENABLE_PIN // Only enable on boards that have separate ENABLE_PINS
// 8789         if (parser.seen('E')) disable_e_steppers();
// 8790       #endif
// 8791     }
// 8792 
// 8793     #if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(ULTIPANEL)  // Only needed with an LCD
// 8794       ubl.lcd_map_control = defer_return_to_status = false;
// 8795     #endif
// 8796   }
// 8797 }
// 8798 
// 8799 /**
// 8800  * M85: Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
// 8801  */
// 8802 inline void gcode_M85() {
// 8803   if (parser.seen('S')) max_inactive_time = parser.value_millis_from_seconds();
// 8804 }
// 8805 
// 8806 /**
// 8807  * Multi-stepper support for M92, M201, M203
// 8808  */
// 8809 #if ENABLED(DISTINCT_E_FACTORS)
// 8810   #define GET_TARGET_EXTRUDER(CMD) if (get_target_extruder_from_command(CMD)) return
// 8811   #define TARGET_EXTRUDER target_extruder
// 8812 #else
// 8813   #define GET_TARGET_EXTRUDER(CMD) NOOP
// 8814   #define TARGET_EXTRUDER 0
// 8815 #endif
// 8816 
// 8817 /**
// 8818  * M92: Set axis steps-per-unit for one or more axes, X, Y, Z, and E.
// 8819  *      (Follows the same syntax as G92)
// 8820  *
// 8821  *      With multiple extruders use T to specify which one.
// 8822  */
// 8823 inline void gcode_M92() {
// 8824 
// 8825   GET_TARGET_EXTRUDER(92);
// 8826 
// 8827   LOOP_XYZE(i) {
// 8828     if (parser.seen(axis_codes[i])) {
// 8829       if (i == E_AXIS) {
// 8830         const float value = parser.value_per_axis_unit((AxisEnum)(E_AXIS + TARGET_EXTRUDER));
// 8831         if (value < 20.0) {
// 8832           float factor = planner.axis_steps_per_mm[E_AXIS + TARGET_EXTRUDER] / value; // increase e constants if M92 E14 is given for netfab.
// 8833           planner.max_jerk[E_AXIS] *= factor;
// 8834           planner.max_feedrate_mm_s[E_AXIS + TARGET_EXTRUDER] *= factor;
// 8835           planner.max_acceleration_steps_per_s2[E_AXIS + TARGET_EXTRUDER] *= factor;
// 8836         }
// 8837         planner.axis_steps_per_mm[E_AXIS + TARGET_EXTRUDER] = value;
// 8838       }
// 8839       else {
// 8840         planner.axis_steps_per_mm[i] = parser.value_per_axis_unit((AxisEnum)i);
// 8841       }
// 8842     }
// 8843   }
// 8844   planner.refresh_positioning();
// 8845 }
// 8846 
// 8847 /**
// 8848  * Output the current position to serial
// 8849  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock40 Using cfiCommon0
          CFI Function _Z22report_mksdlp_positionv
        THUMB
// 8850 void report_mksdlp_position() {
_Z22report_mksdlp_positionv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
// 8851 //	SERIAL_PROTOCOLPGM("X:");
// 8852 //	SERIAL_PROTOCOL(/*LOGICAL_X_POSITION*/(current_position[X_AXIS]));
// 8853 //	SERIAL_PROTOCOLPGM(" Y:");
// 8854 //	SERIAL_PROTOCOL(/*LOGICAL_Y_POSITION*/(current_position[Y_AXIS]));
// 8855 
// 8856   SERIAL_PROTOCOLPGM("Layer:");
        ADR.W    R0,`?<Constant "Layer:">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 8857   SERIAL_PROTOCOL(mksdlp.get_currentLayer());
        LDR.W    R0,??DataTable115_1
          CFI FunCall _ZN7MKS_DLP16get_currentLayerEv
        BL       _ZN7MKS_DLP16get_currentLayerEv
        LDR.W    R5,??DataTable109
        MOVS     R2,#+10
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEii
        BL       _ZN5Print5printEii
// 8858 	
// 8859   SERIAL_PROTOCOLPGM(" Z:");
        ADR.N    R0,??DataTable104_1  ;; " Z:"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 8860   SERIAL_PROTOCOL(/*LOGICAL_Z_POSITION*/(current_position[Z_AXIS]));
        MOVS     R1,#+2
        MOV      R4,R1
        LDR.W    R0,??DataTable111_1
        LDR      R0,[R0, #+44]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        VMOV     D0,R0,R1
        MOV      R1,R4
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
// 8861 //	SERIAL_PROTOCOLPGM(" E:");
// 8862 //	SERIAL_PROTOCOL(current_position[E_AXIS]);
// 8863 	
// 8864   stepper.report_positions();
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Stepper16report_positionsEv
        B.W      _ZN7Stepper16report_positionsEv
          CFI EndBlock cfiBlock40
// 8865 	
// 8866 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Layer:">`:
        DC8 "Layer:"
        DC8 0
// 8867 
// 8868  

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock41 Using cfiCommon0
          CFI Function _Z23report_current_positionv
        THUMB
// 8869 void report_current_position() {
_Z23report_current_positionv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
// 8870   SERIAL_PROTOCOLPGM("X:");
        ADR.N    R0,??DataTable104_2  ;; 0x58, 0x3A, 0x00, 0x00
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 8871   SERIAL_PROTOCOL(/*LOGICAL_X_POSITION*/(current_position[X_AXIS]));
        LDR.W    R5,??DataTable109
        LDR.W    R6,??DataTable107
        MOVS     R1,#+2
        MOV      R4,R1
        LDR      R0,[R6, #+36]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        VMOV     D0,R0,R1
        MOV      R1,R4
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
// 8872   SERIAL_PROTOCOLPGM(" Y:");
        ADR.N    R0,??DataTable104_3  ;; " Y:"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 8873   SERIAL_PROTOCOL(/*LOGICAL_Y_POSITION*/(current_position[Y_AXIS]));
        LDR      R0,[R6, #+40]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        VMOV     D0,R0,R1
        MOV      R1,R4
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
// 8874 
// 8875   SERIAL_PROTOCOLPGM(" Z:");
        ADR.N    R0,??DataTable104_1  ;; " Z:"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 8876   SERIAL_PROTOCOL(/*LOGICAL_Z_POSITION*/(current_position[Z_AXIS]));
        LDR      R0,[R6, #+44]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        VMOV     D0,R0,R1
        MOV      R1,R4
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
// 8877   SERIAL_PROTOCOLPGM(" E:");
        ADR.N    R0,??DataTable104_4  ;; " E:"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 8878   SERIAL_PROTOCOL(current_position[E_AXIS]);
        LDR      R0,[R6, #+48]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        VMOV     D0,R0,R1
        MOV      R1,R4
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
// 8879 
// 8880   stepper.report_positions();
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Stepper16report_positionsEv
        B.W      _ZN7Stepper16report_positionsEv
          CFI EndBlock cfiBlock41
// 8881 
// 8882   #if IS_SCARA
// 8883     SERIAL_PROTOCOLPAIR("SCARA Theta:", stepper.get_axis_position_degrees(A_AXIS));
// 8884     SERIAL_PROTOCOLLNPAIR("   Psi+Theta:", stepper.get_axis_position_degrees(B_AXIS));
// 8885     SERIAL_EOL();
// 8886   #endif
// 8887 }
// 8888 
// 8889 #ifdef M114_DETAIL
// 8890 
// 8891   void report_xyze(const float pos[], const uint8_t n = 4, const uint8_t precision = 3) {
// 8892     char str[12];
// 8893     for (uint8_t i = 0; i < n; i++) {
// 8894       SERIAL_CHAR(' ');
// 8895       SERIAL_CHAR(axis_codes[i]);
// 8896       SERIAL_CHAR(':');
// 8897       SERIAL_PROTOCOL(dtostrf(pos[i], 8, precision, str));
// 8898     }
// 8899     SERIAL_EOL();
// 8900   }
// 8901 
// 8902   inline void report_xyz(const float pos[]) { report_xyze(pos, 3); }
// 8903 
// 8904   void report_current_position_detail() {
// 8905 
// 8906     stepper.synchronize();
// 8907 
// 8908     SERIAL_PROTOCOLPGM("\nLogical:");
// 8909     const float logical[XYZ] = {
// 8910       LOGICAL_X_POSITION(current_position[X_AXIS]),
// 8911       LOGICAL_Y_POSITION(current_position[Y_AXIS]),
// 8912       LOGICAL_Z_POSITION(current_position[Z_AXIS])
// 8913     };
// 8914     report_xyze(logical);
// 8915 
// 8916     SERIAL_PROTOCOLPGM("Raw:    ");
// 8917     report_xyz(current_position);
// 8918 
// 8919     float leveled[XYZ] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] };
// 8920 
// 8921     #if PLANNER_LEVELING
// 8922       SERIAL_PROTOCOLPGM("Leveled:");
// 8923       planner.apply_leveling(leveled);
// 8924       report_xyz(leveled);
// 8925 
// 8926       SERIAL_PROTOCOLPGM("UnLevel:");
// 8927       float unleveled[XYZ] = { leveled[X_AXIS], leveled[Y_AXIS], leveled[Z_AXIS] };
// 8928       planner.unapply_leveling(unleveled);
// 8929       report_xyz(unleveled);
// 8930     #endif
// 8931 
// 8932     #if IS_KINEMATIC
// 8933       #if IS_SCARA
// 8934         SERIAL_PROTOCOLPGM("ScaraK: ");
// 8935       #else
// 8936         SERIAL_PROTOCOLPGM("DeltaK: ");
// 8937       #endif
// 8938       inverse_kinematics(leveled);  // writes delta[]
// 8939       report_xyz(delta);
// 8940     #endif
// 8941 
// 8942     SERIAL_PROTOCOLPGM("Stepper:");
// 8943     LOOP_XYZE(i) {
// 8944       SERIAL_CHAR(' ');
// 8945       SERIAL_CHAR(axis_codes[i]);
// 8946       SERIAL_CHAR(':');
// 8947       SERIAL_PROTOCOL(stepper.position((AxisEnum)i));
// 8948     }
// 8949     SERIAL_EOL();
// 8950 
// 8951     #if IS_SCARA
// 8952       const float deg[XYZ] = {
// 8953         stepper.get_axis_position_degrees(A_AXIS),
// 8954         stepper.get_axis_position_degrees(B_AXIS)
// 8955       };
// 8956       SERIAL_PROTOCOLPGM("Degrees:");
// 8957       report_xyze(deg, 2);
// 8958     #endif
// 8959 
// 8960     SERIAL_PROTOCOLPGM("FromStp:");
// 8961     get_cartesian_from_steppers();  // writes cartes[XYZ] (with forward kinematics)
// 8962     const float from_steppers[XYZE] = { cartes[X_AXIS], cartes[Y_AXIS], cartes[Z_AXIS], stepper.get_axis_position_mm(E_AXIS) };
// 8963     report_xyze(from_steppers);
// 8964 
// 8965     const float diff[XYZE] = {
// 8966       from_steppers[X_AXIS] - leveled[X_AXIS],
// 8967       from_steppers[Y_AXIS] - leveled[Y_AXIS],
// 8968       from_steppers[Z_AXIS] - leveled[Z_AXIS],
// 8969       from_steppers[E_AXIS] - current_position[E_AXIS]
// 8970     };
// 8971     SERIAL_PROTOCOLPGM("Differ: ");
// 8972     report_xyze(diff);
// 8973   }
// 8974 #endif // M114_DETAIL
// 8975 
// 8976 /**
// 8977  * M114: Report current position to host
// 8978  */
// 8979 inline void gcode_M114() {
// 8980 
// 8981   #ifdef M114_DETAIL
// 8982     if (parser.seen('D')) {
// 8983       report_current_position_detail();
// 8984       return;
// 8985     }
// 8986   #endif
// 8987 
// 8988   stepper.synchronize();
// 8989   report_current_position();
// 8990 }
// 8991 
// 8992 /**
// 8993  * M115: Capabilities string
// 8994  */
// 8995 
// 8996 #if ENABLED(EXTENDED_CAPABILITIES_REPORT)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock42 Using cfiCommon0
          CFI Function _Z8cap_linePKcb
        THUMB
// 8997   static void cap_line(const char * const name, bool ena=false) {
_Z8cap_linePKcb:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        MOV      R5,R1
// 8998     SERIAL_PROTOCOLPGM("Cap:");
        ADR.W    R0,`?<Constant "Cap:">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 8999     serialprintPGM(name);
        MOV      R0,R4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 9000     SERIAL_PROTOCOLPGM(":");
        ADR.N    R0,??DataTable104_5  ;; ":"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 9001     SERIAL_PROTOCOLLN(int(ena ? 1 : 0));
        LDR.W    R4,??DataTable109
        MOVS     R2,#+10
        MOV      R1,R5
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEii
        BL       _ZN5Print5printEii
        MOVS     R1,#+10
        MOV      R0,R4
        POP      {R2,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
          CFI EndBlock cfiBlock42
// 9002   }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable103:
        DC8      "Z",0x0,0x0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable103_1:
        DC32     0x0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Cap:">`:
        DC8 "Cap:"
        DC8 0, 0, 0
// 9003 #endif
// 9004 
// 9005 inline void gcode_M115() {
// 9006   SERIAL_PROTOCOLLNPGM(MSG_M115_REPORT);
// 9007 
// 9008   #if ENABLED(EXTENDED_CAPABILITIES_REPORT)
// 9009 
// 9010     // SERIAL_XON_XOFF
// 9011     cap_line(PSTR("SERIAL_XON_XOFF")
// 9012       #if ENABLED(SERIAL_XON_XOFF)
// 9013         , true
// 9014       #endif
// 9015     );
// 9016 
// 9017     // EEPROM (M500, M501)
// 9018     cap_line(PSTR("EEPROM")
// 9019       #if ENABLED(EEPROM_SETTINGS)
// 9020         , true
// 9021       #endif
// 9022     );
// 9023 
// 9024     // Volumetric Extrusion (M200)
// 9025     cap_line(PSTR("VOLUMETRIC")
// 9026       #if DISABLED(NO_VOLUMETRICS)
// 9027         , true
// 9028       #endif
// 9029     );
// 9030 
// 9031     // AUTOREPORT_TEMP (M155)
// 9032     cap_line(PSTR("AUTOREPORT_TEMP")
// 9033       #if ENABLED(AUTO_REPORT_TEMPERATURES)
// 9034         , true
// 9035       #endif
// 9036     );
// 9037 
// 9038     // PROGRESS (M530 S L, M531 <file>, M532 X L)
// 9039     cap_line(PSTR("PROGRESS"));
// 9040 
// 9041     // Print Job timer M75, M76, M77
// 9042     cap_line(PSTR("PRINT_JOB"), true);
// 9043 
// 9044     // AUTOLEVEL (G29)
// 9045     cap_line(PSTR("AUTOLEVEL")
// 9046       #if HAS_AUTOLEVEL
// 9047         , true
// 9048       #endif
// 9049     );
// 9050 
// 9051     // Z_PROBE (G30)
// 9052     cap_line(PSTR("Z_PROBE")
// 9053       #if HAS_BED_PROBE
// 9054         , true
// 9055       #endif
// 9056     );
// 9057 
// 9058     // MESH_REPORT (M420 V)
// 9059     cap_line(PSTR("LEVELING_DATA")
// 9060       #if HAS_LEVELING
// 9061         , true
// 9062       #endif
// 9063     );
// 9064 
// 9065     // BUILD_PERCENT (M73)
// 9066     cap_line(PSTR("BUILD_PERCENT")
// 9067       #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
// 9068         , true
// 9069       #endif
// 9070     );
// 9071 
// 9072     // SOFTWARE_POWER (M80, M81)
// 9073     cap_line(PSTR("SOFTWARE_POWER")
// 9074       #if HAS_POWER_SWITCH
// 9075         , true
// 9076       #endif
// 9077     );
// 9078 
// 9079     // CASE LIGHTS (M355)
// 9080     cap_line(PSTR("TOGGLE_LIGHTS")
// 9081       #if HAS_CASE_LIGHT
// 9082         , true
// 9083       #endif
// 9084     );
// 9085     cap_line(PSTR("CASE_LIGHT_BRIGHTNESS")
// 9086       #if HAS_CASE_LIGHT
// 9087         , USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN)
// 9088       #endif
// 9089     );
// 9090 
// 9091     // EMERGENCY_PARSER (M108, M112, M410)
// 9092     cap_line(PSTR("EMERGENCY_PARSER")
// 9093       #if ENABLED(EMERGENCY_PARSER)
// 9094         , true
// 9095       #endif
// 9096     );
// 9097 
// 9098   #endif // EXTENDED_CAPABILITIES_REPORT
// 9099 }
// 9100 
// 9101 /**
// 9102  * M117: Set LCD Status Message
// 9103  */
// 9104 inline void gcode_M117() { lcd_setstatus(parser.string_arg); }
// 9105 
// 9106 /**
// 9107  * M118: Display a message in the host console.
// 9108  *
// 9109  *  A1  Append '// ' for an action command, as in OctoPrint
// 9110  *  E1  Have the host 'echo:' the text
// 9111  */
// 9112 inline void gcode_M118() {
// 9113   if (parser.boolval('E')) SERIAL_ECHO_START();
// 9114   if (parser.boolval('A')) SERIAL_ECHOPGM("// ");
// 9115   SERIAL_ECHOLN(parser.string_arg);
// 9116 }
// 9117 
// 9118 /**
// 9119  * M119: Output endstop states to serial output
// 9120  */
// 9121 inline void gcode_M119() { endstops.M119(); }
// 9122 
// 9123 /**
// 9124  * M120: Enable endstops and set non-homing endstop state to "enabled"
// 9125  */
// 9126 inline void gcode_M120() { endstops.enable_globally(true); }
// 9127 
// 9128 /**
// 9129  * M121: Disable endstops and set non-homing endstop state to "disabled"
// 9130  */
// 9131 inline void gcode_M121() { endstops.enable_globally(false); }
// 9132 
// 9133 #if ENABLED(PARK_HEAD_ON_PAUSE)
// 9134 
// 9135   /**
// 9136    * M125: Store current position and move to filament change position.
// 9137    *       Called on pause (by M25) to prevent material leaking onto the
// 9138    *       object. On resume (M24) the head will be moved back and the
// 9139    *       print will resume.
// 9140    *
// 9141    *       If Marlin is compiled without SD Card support, M125 can be
// 9142    *       used directly to pause the print and move to park position,
// 9143    *       resuming with a button click or M108.
// 9144    *
// 9145    *    L = override retract length
// 9146    *    X = override X
// 9147    *    Y = override Y
// 9148    *    Z = override Z raise
// 9149    */
// 9150   inline void gcode_M125() {
// 9151 
// 9152     // Initial retract before move to filament change position
// 9153     const float retract = parser.seen('L') ? parser.value_axis_units(E_AXIS) : 0
// 9154       #ifdef PAUSE_PARK_RETRACT_LENGTH
// 9155         - (PAUSE_PARK_RETRACT_LENGTH)
// 9156       #endif
// 9157     ;
// 9158 
// 9159     point_t park_point = NOZZLE_PARK_POINT;
// 9160 
// 9161     // Move XY axes to filament change position or given position
// 9162     if (parser.seenval('X')) park_point.x = parser.linearval('X');
// 9163     if (parser.seenval('Y')) park_point.y = parser.linearval('Y');
// 9164 
// 9165     // Lift Z axis
// 9166     if (parser.seenval('Z')) park_point.z = parser.linearval('Z');
// 9167 
// 9168     #if HOTENDS > 1 && DISABLED(DUAL_X_CARRIAGE)
// 9169       park_point.x += (active_extruder ? hotend_offset[X_AXIS][active_extruder] : 0);
// 9170       park_point.y += (active_extruder ? hotend_offset[Y_AXIS][active_extruder] : 0);
// 9171     #endif
// 9172 
// 9173     #if DISABLED(SDSUPPORT)
// 9174       const bool job_running = print_job_timer.isRunning();
// 9175     #endif
// 9176 
// 9177     if (pause_print(retract, park_point)) {
// 9178       #if DISABLED(SDSUPPORT)
// 9179         // Wait for lcd click or M108
// 9180         wait_for_filament_reload();
// 9181 
// 9182         // Return to print position and continue
// 9183         resume_print();
// 9184 
// 9185         if (job_running) print_job_timer.start();
// 9186       #endif
// 9187     }
// 9188   }
// 9189 
// 9190 #endif // PARK_HEAD_ON_PAUSE
// 9191 
// 9192 #if HAS_COLOR_LEDS
// 9193 
// 9194   /**
// 9195    * M150: Set Status LED Color - Use R-U-B-W for R-G-B-W
// 9196    *       and Brightness       - Use P (for NEOPIXEL only)
// 9197    *
// 9198    * Always sets all 3 or 4 components. If a component is left out, set to 0.
// 9199    *                                    If brightness is left out, no value changed
// 9200    *
// 9201    * Examples:
// 9202    *
// 9203    *   M150 R255       ; Turn LED red
// 9204    *   M150 R255 U127  ; Turn LED orange (PWM only)
// 9205    *   M150            ; Turn LED off
// 9206    *   M150 R U B      ; Turn LED white
// 9207    *   M150 W          ; Turn LED white using a white LED
// 9208    *   M150 P127       ; Set LED 50% brightness
// 9209    *   M150 P          ; Set LED full brightness
// 9210    */
// 9211   inline void gcode_M150() {
// 9212     leds.set_color(MakeLEDColor(
// 9213       parser.seen('R') ? (parser.has_value() ? parser.value_byte() : 255) : 0,
// 9214       parser.seen('U') ? (parser.has_value() ? parser.value_byte() : 255) : 0,
// 9215       parser.seen('B') ? (parser.has_value() ? parser.value_byte() : 255) : 0,
// 9216       parser.seen('W') ? (parser.has_value() ? parser.value_byte() : 255) : 0,
// 9217       parser.seen('P') ? (parser.has_value() ? parser.value_byte() : 255) : pixels.getBrightness()
// 9218     ));
// 9219   }
// 9220 
// 9221 #endif // HAS_COLOR_LEDS
// 9222 
// 9223 #if DISABLED(NO_VOLUMETRICS)
// 9224 
// 9225   /**
// 9226    * M200: Set filament diameter and set E axis units to cubic units
// 9227    *
// 9228    *    T<extruder> - Optional extruder number. Current extruder if omitted.
// 9229    *    D<linear> - Diameter of the filament. Use "D0" to switch back to linear units on the E axis.
// 9230    */
// 9231   inline void gcode_M200() {
// 9232 
// 9233     if (get_target_extruder_from_command(200)) return;
// 9234 
// 9235     if (parser.seen('D')) {
// 9236       // setting any extruder filament size disables volumetric on the assumption that
// 9237       // slicers either generate in extruder values as cubic mm or as as filament feeds
// 9238       // for all extruders
// 9239       if ( (parser.volumetric_enabled = (parser.value_linear_units() != 0.0)) )
// 9240         planner.set_filament_size(target_extruder, parser.value_linear_units());
// 9241     }
// 9242     planner.calculate_volumetric_multipliers();
// 9243   }
// 9244 
// 9245 #endif // !NO_VOLUMETRICS
// 9246 
// 9247 /**
// 9248  * M201: Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)
// 9249  *
// 9250  *       With multiple extruders use T to specify which one.
// 9251  */
// 9252 inline void gcode_M201() {
// 9253 
// 9254   GET_TARGET_EXTRUDER(201);
// 9255 
// 9256   LOOP_XYZE(i) {
// 9257     if (parser.seen(axis_codes[i])) {
// 9258       const uint8_t a = i + (i == E_AXIS ? TARGET_EXTRUDER : 0);
// 9259       planner.max_acceleration_mm_per_s2[a] = parser.value_axis_units((AxisEnum)a);
// 9260     }
// 9261   }
// 9262   // steps per sq second need to be updated to agree with the units per sq second (as they are what is used in the planner)
// 9263   planner.reset_acceleration_rates();
// 9264 }
// 9265 
// 9266 #if 0 // Not used for Sprinter/grbl gen6
// 9267   inline void gcode_M202() {
// 9268     LOOP_XYZE(i) {
// 9269       if (parser.seen(axis_codes[i])) axis_travel_steps_per_sqr_second[i] = parser.value_axis_units((AxisEnum)i) * planner.axis_steps_per_mm[i];
// 9270     }
// 9271   }
// 9272 #endif
// 9273 
// 9274 
// 9275 /**
// 9276  * M203: Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in units/sec
// 9277  *
// 9278  *       With multiple extruders use T to specify which one.
// 9279  */
// 9280 inline void gcode_M203() {
// 9281 
// 9282   GET_TARGET_EXTRUDER(203);
// 9283 
// 9284   LOOP_XYZE(i)
// 9285     if (parser.seen(axis_codes[i])) {
// 9286       const uint8_t a = i + (i == E_AXIS ? TARGET_EXTRUDER : 0);
// 9287       planner.max_feedrate_mm_s[a] = parser.value_axis_units((AxisEnum)a);
// 9288     }
// 9289 }
// 9290 
// 9291 /**
// 9292  * M204: Set Accelerations in units/sec^2 (M204 P1200 R3000 T3000)
// 9293  *
// 9294  *    P = Printing moves
// 9295  *    R = Retract only (no X, Y, Z) moves
// 9296  *    T = Travel (non printing) moves
// 9297  *
// 9298  *  Also sets minimum segment time in ms (B20000) to prevent buffer under-runs and M20 minimum feedrate
// 9299  */
// 9300 inline void gcode_M204() {
// 9301   if (parser.seen('S')) {  // Kept for legacy compatibility. Should NOT BE USED for new developments.
// 9302     planner.travel_acceleration = planner.acceleration = parser.value_linear_units();
// 9303     SERIAL_ECHOLNPAIR("Setting Print and Travel Acceleration: ", planner.acceleration);
// 9304   }
// 9305   if (parser.seen('P')) {
// 9306     planner.acceleration = parser.value_linear_units();
// 9307     SERIAL_ECHOLNPAIR("Setting Print Acceleration: ", planner.acceleration);
// 9308   }
// 9309   if (parser.seen('R')) {
// 9310     planner.retract_acceleration = parser.value_linear_units();
// 9311     SERIAL_ECHOLNPAIR("Setting Retract Acceleration: ", planner.retract_acceleration);
// 9312   }
// 9313   if (parser.seen('T')) {
// 9314     planner.travel_acceleration = parser.value_linear_units();
// 9315     SERIAL_ECHOLNPAIR("Setting Travel Acceleration: ", planner.travel_acceleration);
// 9316   }
// 9317 }
// 9318 
// 9319 /**
// 9320  * M205: Set Advanced Settings
// 9321  *
// 9322  *    S = Min Feed Rate (units/s)
// 9323  *    T = Min Travel Feed Rate (units/s)
// 9324  *    B = Min Segment Time (Âµs)
// 9325  *    X = Max X Jerk (units/sec^2)
// 9326  *    Y = Max Y Jerk (units/sec^2)
// 9327  *    Z = Max Z Jerk (units/sec^2)
// 9328  *    E = Max E Jerk (units/sec^2)
// 9329  */
// 9330 inline void gcode_M205() {
// 9331   if (parser.seen('S')) planner.min_feedrate_mm_s = parser.value_linear_units();
// 9332   if (parser.seen('T')) planner.min_travel_feedrate_mm_s = parser.value_linear_units();
// 9333   if (parser.seen('B')) planner.min_segment_time_us = parser.value_ulong();
// 9334   if (parser.seen('X')) planner.max_jerk[X_AXIS] = parser.value_linear_units();
// 9335   if (parser.seen('Y')) planner.max_jerk[Y_AXIS] = parser.value_linear_units();
// 9336   if (parser.seen('Z')) planner.max_jerk[Z_AXIS] = parser.value_linear_units();
// 9337   if (parser.seen('E')) planner.max_jerk[E_AXIS] = parser.value_linear_units();
// 9338 }
// 9339 
// 9340 #if HAS_M206_COMMAND
// 9341 
// 9342   /**
// 9343    * M206: Set Additional Homing Offset (X Y Z). SCARA aliases T=X, P=Y
// 9344    *
// 9345    * *** @thinkyhead: I recommend deprecating M206 for SCARA in favor of M665.
// 9346    * ***              M206 for SCARA will remain enabled in 1.1.x for compatibility.
// 9347    * ***              In the next 1.2 release, it will simply be disabled by default.
// 9348    */
// 9349   inline void gcode_M206() {
// 9350     LOOP_XYZ(i)
// 9351       if (parser.seen(axis_codes[i]))
// 9352         set_home_offset((AxisEnum)i, parser.value_linear_units());
// 9353 
// 9354     #if ENABLED(MORGAN_SCARA)
// 9355       if (parser.seen('T')) set_home_offset(A_AXIS, parser.value_float()); // Theta
// 9356       if (parser.seen('P')) set_home_offset(B_AXIS, parser.value_float()); // Psi
// 9357     #endif
// 9358 
// 9359     report_current_position();
// 9360   }
// 9361 
// 9362 #endif // HAS_M206_COMMAND
// 9363 
// 9364 #if ENABLED(DELTA)
// 9365   /**
// 9366    * M665: Set delta configurations
// 9367    *
// 9368    *    H = delta height
// 9369    *    L = diagonal rod
// 9370    *    R = delta radius
// 9371    *    S = segments per second
// 9372    *    B = delta calibration radius
// 9373    *    X = Alpha (Tower 1) angle trim
// 9374    *    Y = Beta (Tower 2) angle trim
// 9375    *    Z = Rotate A and B by this angle
// 9376    */
// 9377   inline void gcode_M665() {
// 9378     if (parser.seen('H')) delta_height                   = parser.value_linear_units();
// 9379     if (parser.seen('L')) delta_diagonal_rod             = parser.value_linear_units();
// 9380     if (parser.seen('R')) delta_radius                   = parser.value_linear_units();
// 9381     if (parser.seen('S')) delta_segments_per_second      = parser.value_float();
// 9382     if (parser.seen('B')) delta_calibration_radius       = parser.value_float();
// 9383     if (parser.seen('X')) delta_tower_angle_trim[A_AXIS] = parser.value_float();
// 9384     if (parser.seen('Y')) delta_tower_angle_trim[B_AXIS] = parser.value_float();
// 9385     if (parser.seen('Z')) delta_tower_angle_trim[C_AXIS] = parser.value_float();
// 9386     recalc_delta_settings();
// 9387   }
// 9388   /**
// 9389    * M666: Set delta endstop adjustment
// 9390    */
// 9391   inline void gcode_M666() {
// 9392     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 9393       if (DEBUGGING(LEVELING)) {
// 9394         SERIAL_ECHOLNPGM(">>> gcode_M666");
// 9395       }
// 9396     #endif
// 9397     LOOP_XYZ(i) {
// 9398       if (parser.seen(axis_codes[i])) {
// 9399         if (parser.value_linear_units() * Z_HOME_DIR <= 0)
// 9400           delta_endstop_adj[i] = parser.value_linear_units();
// 9401         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 9402           if (DEBUGGING(LEVELING)) {
// 9403             SERIAL_ECHOPAIR("delta_endstop_adj[", axis_codes[i]);
// 9404             SERIAL_ECHOLNPAIR("] = ", delta_endstop_adj[i]);
// 9405           }
// 9406         #endif
// 9407       }
// 9408     }
// 9409     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 9410       if (DEBUGGING(LEVELING)) {
// 9411         SERIAL_ECHOLNPGM("<<< gcode_M666");
// 9412       }
// 9413     #endif
// 9414   }
// 9415 
// 9416 #elif IS_SCARA
// 9417 
// 9418   /**
// 9419    * M665: Set SCARA settings
// 9420    *
// 9421    * Parameters:
// 9422    *
// 9423    *   S[segments-per-second] - Segments-per-second
// 9424    *   P[theta-psi-offset]    - Theta-Psi offset, added to the shoulder (A/X) angle
// 9425    *   T[theta-offset]        - Theta     offset, added to the elbow    (B/Y) angle
// 9426    *
// 9427    *   A, P, and X are all aliases for the shoulder angle
// 9428    *   B, T, and Y are all aliases for the elbow angle
// 9429    */
// 9430   inline void gcode_M665() {
// 9431     if (parser.seen('S')) delta_segments_per_second = parser.value_float();
// 9432 
// 9433     const bool hasA = parser.seen('A'), hasP = parser.seen('P'), hasX = parser.seen('X');
// 9434     const uint8_t sumAPX = hasA + hasP + hasX;
// 9435     if (sumAPX == 1)
// 9436       home_offset[A_AXIS] = parser.value_float();
// 9437     else if (sumAPX > 1) {
// 9438       SERIAL_ERROR_START();
// 9439       SERIAL_ERRORLNPGM("Only one of A, P, or X is allowed.");
// 9440       return;
// 9441     }
// 9442 
// 9443     const bool hasB = parser.seen('B'), hasT = parser.seen('T'), hasY = parser.seen('Y');
// 9444     const uint8_t sumBTY = hasB + hasT + hasY;
// 9445     if (sumBTY == 1)
// 9446       home_offset[B_AXIS] = parser.value_float();
// 9447     else if (sumBTY > 1) {
// 9448       SERIAL_ERROR_START();
// 9449       SERIAL_ERRORLNPGM("Only one of B, T, or Y is allowed.");
// 9450       return;
// 9451     }
// 9452   }
// 9453 
// 9454 
// 9455 
// 9456 #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
// 9457 
// 9458   /**
// 9459    * M666: For Z Dual Endstop setup, set z axis offset to the z2 axis.
// 9460    */
// 9461   inline void gcode_M666() {
// 9462     SERIAL_ECHOPGM("Dual Endstop Adjustment (mm): ");
// 9463     #if ENABLED(X_DUAL_ENDSTOPS)
// 9464       if (parser.seen('X')) x_endstop_adj = parser.value_linear_units();
// 9465       SERIAL_ECHOPAIR(" X", x_endstop_adj);
// 9466     #endif
// 9467     #if ENABLED(Y_DUAL_ENDSTOPS)
// 9468       if (parser.seen('Y')) y_endstop_adj = parser.value_linear_units();
// 9469       SERIAL_ECHOPAIR(" Y", y_endstop_adj);
// 9470     #endif
// 9471     #if ENABLED(Z_DUAL_ENDSTOPS)
// 9472       if (parser.seen('Z')) z_endstop_adj = parser.value_linear_units();
// 9473       SERIAL_ECHOPAIR(" Z", z_endstop_adj);
// 9474     #endif
// 9475     SERIAL_EOL();
// 9476   }
// 9477 
// 9478 #endif // !DELTA && Z_DUAL_ENDSTOPS
// 9479 
// 9480 #if ENABLED(FWRETRACT)
// 9481 
// 9482   /**
// 9483    * M207: Set firmware retraction values
// 9484    *
// 9485    *   S[+units]    retract_length
// 9486    *   W[+units]    swap_retract_length (multi-extruder)
// 9487    *   F[units/min] retract_feedrate_mm_s
// 9488    *   Z[units]     retract_zlift
// 9489    */
// 9490   inline void gcode_M207() {
// 9491     if (parser.seen('S')) retract_length = parser.value_axis_units(E_AXIS);
// 9492     if (parser.seen('F')) retract_feedrate_mm_s = MMM_TO_MMS(parser.value_axis_units(E_AXIS));
// 9493     if (parser.seen('Z')) retract_zlift = parser.value_linear_units();
// 9494     if (parser.seen('W')) swap_retract_length = parser.value_axis_units(E_AXIS);
// 9495   }
// 9496 
// 9497   /**
// 9498    * M208: Set firmware un-retraction values
// 9499    *
// 9500    *   S[+units]    retract_recover_length (in addition to M207 S*)
// 9501    *   W[+units]    swap_retract_recover_length (multi-extruder)
// 9502    *   F[units/min] retract_recover_feedrate_mm_s
// 9503    *   R[units/min] swap_retract_recover_feedrate_mm_s
// 9504    */
// 9505   inline void gcode_M208() {
// 9506     if (parser.seen('S')) retract_recover_length = parser.value_axis_units(E_AXIS);
// 9507     if (parser.seen('F')) retract_recover_feedrate_mm_s = MMM_TO_MMS(parser.value_axis_units(E_AXIS));
// 9508     if (parser.seen('R')) swap_retract_recover_feedrate_mm_s = MMM_TO_MMS(parser.value_axis_units(E_AXIS));
// 9509     if (parser.seen('W')) swap_retract_recover_length = parser.value_axis_units(E_AXIS);
// 9510   }
// 9511 
// 9512   /**
// 9513    * M209: Enable automatic retract (M209 S1)
// 9514    *   For slicers that don't support G10/11, reversed extrude-only
// 9515    *   moves will be classified as retraction.
// 9516    */
// 9517   inline void gcode_M209() {
// 9518     if (MIN_AUTORETRACT <= MAX_AUTORETRACT) {
// 9519       if (parser.seen('S')) {
// 9520         autoretract_enabled = parser.value_bool();
// 9521         for (uint8_t i = 0; i < EXTRUDERS; i++) retracted[i] = false;
// 9522       }
// 9523     }
// 9524   }
// 9525 
// 9526 #endif // FWRETRACT
// 9527 
// 9528 /**
// 9529  * M211: Enable, Disable, and/or Report software endstops
// 9530  *
// 9531  * Usage: M211 S1 to enable, M211 S0 to disable, M211 alone for report
// 9532  */
// 9533 inline void gcode_M211() {
// 9534   SERIAL_ECHO_START();
// 9535   #if HAS_SOFTWARE_ENDSTOPS
// 9536     if (parser.seen('S')) soft_endstops_enabled = parser.value_bool();
// 9537     SERIAL_ECHOPGM(MSG_SOFT_ENDSTOPS);
// 9538     serialprintPGM(soft_endstops_enabled ? PSTR(MSG_ON) : PSTR(MSG_OFF));
// 9539   #else
// 9540     SERIAL_ECHOPGM(MSG_SOFT_ENDSTOPS);
// 9541     SERIAL_ECHOPGM(MSG_OFF);
// 9542   #endif
// 9543   SERIAL_ECHOPGM(MSG_SOFT_MIN);
// 9544   SERIAL_ECHOPAIR(    MSG_X, LOGICAL_X_POSITION(soft_endstop_min[X_AXIS]));
// 9545   SERIAL_ECHOPAIR(" " MSG_Y, LOGICAL_Y_POSITION(soft_endstop_min[Y_AXIS]));
// 9546   SERIAL_ECHOPAIR(" " MSG_Z, LOGICAL_Z_POSITION(soft_endstop_min[Z_AXIS]));
// 9547   SERIAL_ECHOPGM(MSG_SOFT_MAX);
// 9548   SERIAL_ECHOPAIR(    MSG_X, LOGICAL_X_POSITION(soft_endstop_max[X_AXIS]));
// 9549   SERIAL_ECHOPAIR(" " MSG_Y, LOGICAL_Y_POSITION(soft_endstop_max[Y_AXIS]));
// 9550   SERIAL_ECHOLNPAIR(" " MSG_Z, LOGICAL_Z_POSITION(soft_endstop_max[Z_AXIS]));
// 9551 }
// 9552 
// 9553 #if HOTENDS > 1
// 9554 
// 9555   /**
// 9556    * M218 - set hotend offset (in linear units)
// 9557    *
// 9558    *   T<tool>
// 9559    *   X<xoffset>
// 9560    *   Y<yoffset>
// 9561    *   Z<zoffset> - Available with DUAL_X_CARRIAGE and SWITCHING_NOZZLE
// 9562    */
// 9563   inline void gcode_M218() {
// 9564     if (get_target_extruder_from_command(218) || target_extruder == 0) return;
// 9565 
// 9566     if (parser.seenval('X')) hotend_offset[X_AXIS][target_extruder] = parser.value_linear_units();
// 9567     if (parser.seenval('Y')) hotend_offset[Y_AXIS][target_extruder] = parser.value_linear_units();
// 9568 
// 9569     #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
// 9570       if (parser.seenval('Z')) hotend_offset[Z_AXIS][target_extruder] = parser.value_linear_units();
// 9571     #endif
// 9572 
// 9573     SERIAL_ECHO_START();
// 9574     SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
// 9575     HOTEND_LOOP() {
// 9576       SERIAL_CHAR(' ');
// 9577       SERIAL_ECHO(hotend_offset[X_AXIS][e]);
// 9578       SERIAL_CHAR(',');
// 9579       SERIAL_ECHO(hotend_offset[Y_AXIS][e]);
// 9580       #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
// 9581         SERIAL_CHAR(',');
// 9582         SERIAL_ECHO(hotend_offset[Z_AXIS][e]);
// 9583       #endif
// 9584     }
// 9585     SERIAL_EOL();
// 9586   }
// 9587 
// 9588 #endif // HOTENDS > 1
// 9589 
// 9590 /**
// 9591  * M220: Set speed percentage factor, aka "Feed Rate" (M220 S95)
// 9592  */
// 9593 inline void gcode_M220() {
// 9594   if (parser.seenval('S')) feedrate_percentage = parser.value_int();
// 9595 }
// 9596 
// 9597 /**
// 9598  * M221: Set extrusion percentage (M221 T0 S95)
// 9599  */
// 9600 inline void gcode_M221() {
// 9601   if (get_target_extruder_from_command(221)) return;
// 9602   if (parser.seenval('S')) {
// 9603     planner.flow_percentage[target_extruder] = parser.value_int();
// 9604     planner.refresh_e_factor(target_extruder);
// 9605   }
// 9606 }
// 9607 
// 9608 /**
// 9609  * M226: Wait until the specified pin reaches the state required (M226 P<pin> S<state>)
// 9610  */
// 9611 inline void gcode_M226() {
// 9612   if (parser.seen('P')) {
// 9613     const int pin_number = parser.value_int(),
// 9614               pin_state = parser.intval('S', -1); // required pin state - default is inverted
// 9615 
// 9616     if (WITHIN(pin_state, -1, 1) && pin_number > -1 && !pin_is_protected(pin_number)) {
// 9617 
// 9618       int target = LOW;
// 9619 
// 9620       stepper.synchronize();
// 9621 
// 9622       pinMode(pin_number, INPUT);
// 9623       switch (pin_state) {
// 9624         case 1:
// 9625           target = HIGH;
// 9626           break;
// 9627         case 0:
// 9628           target = LOW;
// 9629           break;
// 9630         case -1:
// 9631           target = !digitalRead(pin_number);
// 9632           break;
// 9633       }
// 9634 
// 9635       while (digitalRead(pin_number) != target) idle();
// 9636 
// 9637     } // pin_state -1 0 1 && pin_number > -1
// 9638   } // parser.seen('P')
// 9639 }
// 9640 
// 9641 #if ENABLED(EXPERIMENTAL_I2CBUS)
// 9642 
// 9643   /**
// 9644    * M260: Send data to a I2C slave device
// 9645    *
// 9646    * This is a PoC, the formating and arguments for the GCODE will
// 9647    * change to be more compatible, the current proposal is:
// 9648    *
// 9649    *  M260 A<slave device address base 10> ; Sets the I2C slave address the data will be sent to
// 9650    *
// 9651    *  M260 B<byte-1 value in base 10>
// 9652    *  M260 B<byte-2 value in base 10>
// 9653    *  M260 B<byte-3 value in base 10>
// 9654    *
// 9655    *  M260 S1 ; Send the buffered data and reset the buffer
// 9656    *  M260 R1 ; Reset the buffer without sending data
// 9657    *
// 9658    */
// 9659   inline void gcode_M260() {
// 9660     // Set the target address
// 9661     if (parser.seen('A')) i2c.address(parser.value_byte());
// 9662 
// 9663     // Add a new byte to the buffer
// 9664     if (parser.seen('B')) i2c.addbyte(parser.value_byte());
// 9665 
// 9666     // Flush the buffer to the bus
// 9667     if (parser.seen('S')) i2c.send();
// 9668 
// 9669     // Reset and rewind the buffer
// 9670     else if (parser.seen('R')) i2c.reset();
// 9671   }
// 9672 
// 9673   /**
// 9674    * M261: Request X bytes from I2C slave device
// 9675    *
// 9676    * Usage: M261 A<slave device address base 10> B<number of bytes>
// 9677    */
// 9678   inline void gcode_M261() {
// 9679     if (parser.seen('A')) i2c.address(parser.value_byte());
// 9680 
// 9681     uint8_t bytes = parser.byteval('B', 1);
// 9682 
// 9683     if (i2c.addr && bytes && bytes <= TWIBUS_BUFFER_SIZE) {
// 9684       i2c.relay(bytes);
// 9685     }
// 9686     else {
// 9687       SERIAL_ERROR_START();
// 9688       SERIAL_ERRORLN("Bad i2c request");
// 9689     }
// 9690   }
// 9691 
// 9692 #endif // EXPERIMENTAL_I2CBUS
// 9693 
// 9694 #if HAS_SERVOS
// 9695 
// 9696   /**
// 9697    * M280: Get or set servo position. P<index> [S<angle>]
// 9698    */
// 9699   inline void gcode_M280() {
// 9700     if (!parser.seen('P')) return;
// 9701     const int servo_index = parser.value_int();
// 9702     if (WITHIN(servo_index, 0, NUM_SERVOS - 1)) {
// 9703       if (parser.seen('S'))
// 9704         MOVE_SERVO(servo_index, parser.value_int());
// 9705       else {
// 9706         SERIAL_ECHO_START();
// 9707         SERIAL_ECHOPAIR(" Servo ", servo_index);
// 9708         SERIAL_ECHOLNPAIR(": ", servo[servo_index].read());
// 9709       }
// 9710     }
// 9711     else {
// 9712       SERIAL_ERROR_START();
// 9713       SERIAL_ECHOPAIR("Servo ", servo_index);
// 9714       SERIAL_ECHOLNPGM(" out of range");
// 9715     }
// 9716   }
// 9717 
// 9718 #endif // HAS_SERVOS
// 9719 
// 9720 #if ENABLED(BABYSTEPPING)
// 9721 
// 9722   #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
// 9723     FORCE_INLINE void mod_zprobe_zoffset(const float &offs) {
// 9724       zprobe_zoffset += offs;
// 9725       SERIAL_ECHO_START();
// 9726       SERIAL_ECHOLNPAIR(MSG_PROBE_Z_OFFSET ": ", zprobe_zoffset);
// 9727     }
// 9728   #endif
// 9729 
// 9730   /**
// 9731    * M290: Babystepping
// 9732    */
// 9733   inline void gcode_M290() {
// 9734     #if ENABLED(BABYSTEP_XY)
// 9735       for (uint8_t a = X_AXIS; a <= Z_AXIS; a++)
// 9736         if (parser.seenval(axis_codes[a]) || (a == Z_AXIS && parser.seenval('S'))) {
// 9737           const float offs = constrain(parser.value_axis_units((AxisEnum)a), -2, 2);
// 9738           thermalManager.babystep_axis((AxisEnum)a, offs * planner.axis_steps_per_mm[a]);
// 9739           #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
// 9740             if (a == Z_AXIS && (!parser.seen('P') || parser.value_bool())) mod_zprobe_zoffset(offs);
// 9741           #endif
// 9742         }
// 9743     #else
// 9744       if (parser.seenval('Z') || parser.seenval('S')) {
// 9745         const float offs = constrain(parser.value_axis_units(Z_AXIS), -2, 2);
// 9746         thermalManager.babystep_axis(Z_AXIS, offs * planner.axis_steps_per_mm[Z_AXIS]);
// 9747         #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
// 9748           if (!parser.seen('P') || parser.value_bool()) mod_zprobe_zoffset(offs);
// 9749         #endif
// 9750       }
// 9751     #endif
// 9752   }
// 9753 
// 9754 #endif // BABYSTEPPING
// 9755 
// 9756 #if HAS_BUZZER
// 9757 
// 9758   /**
// 9759    * M300: Play beep sound S<frequency Hz> P<duration ms>
// 9760    */
// 9761   inline void gcode_M300() {
// 9762     uint16_t const frequency = parser.ushortval('S', 260);
// 9763     uint16_t duration = parser.ushortval('P', 1000);
// 9764 
// 9765     // Limits the tone duration to 0-5 seconds.
// 9766     NOMORE(duration, 5000);
// 9767 
// 9768     BUZZ(duration, frequency);
// 9769   }
// 9770 
// 9771 #endif // HAS_BUZZER
// 9772 
// 9773 #if ENABLED(PIDTEMP)
// 9774 
// 9775   /**
// 9776    * M301: Set PID parameters P I D (and optionally C, L)
// 9777    *
// 9778    *   P[float] Kp term
// 9779    *   I[float] Ki term (unscaled)
// 9780    *   D[float] Kd term (unscaled)
// 9781    *
// 9782    * With PID_EXTRUSION_SCALING:
// 9783    *
// 9784    *   C[float] Kc term
// 9785    *   L[float] LPQ length
// 9786    */
// 9787   inline void gcode_M301() {
// 9788 
// 9789     // multi-extruder PID patch: M301 updates or prints a single extruder's PID values
// 9790     // default behaviour (omitting E parameter) is to update for extruder 0 only
// 9791     const uint8_t e = parser.byteval('E'); // extruder being updated
// 9792 
// 9793     if (e < HOTENDS) { // catch bad input value
// 9794       if (parser.seen('P')) PID_PARAM(Kp, e) = parser.value_float();
// 9795       if (parser.seen('I')) PID_PARAM(Ki, e) = scalePID_i(parser.value_float());
// 9796       if (parser.seen('D')) PID_PARAM(Kd, e) = scalePID_d(parser.value_float());
// 9797       #if ENABLED(PID_EXTRUSION_SCALING)
// 9798         if (parser.seen('C')) PID_PARAM(Kc, e) = parser.value_float();
// 9799         if (parser.seen('L')) lpq_len = parser.value_float();
// 9800         NOMORE(lpq_len, LPQ_MAX_LEN);
// 9801       #endif
// 9802 
// 9803       thermalManager.updatePID();
// 9804       SERIAL_ECHO_START();
// 9805       #if ENABLED(PID_PARAMS_PER_HOTEND)
// 9806         SERIAL_ECHOPAIR(" e:", e); // specify extruder in serial output
// 9807       #endif // PID_PARAMS_PER_HOTEND
// 9808       SERIAL_ECHOPAIR(" p:", PID_PARAM(Kp, e));
// 9809       SERIAL_ECHOPAIR(" i:", unscalePID_i(PID_PARAM(Ki, e)));
// 9810       SERIAL_ECHOPAIR(" d:", unscalePID_d(PID_PARAM(Kd, e)));
// 9811       #if ENABLED(PID_EXTRUSION_SCALING)
// 9812         //Kc does not have scaling applied above, or in resetting defaults
// 9813         SERIAL_ECHOPAIR(" c:", PID_PARAM(Kc, e));
// 9814       #endif
// 9815       SERIAL_EOL();
// 9816     }
// 9817     else {
// 9818       SERIAL_ERROR_START();
// 9819       SERIAL_ERRORLN(MSG_INVALID_EXTRUDER);
// 9820     }
// 9821   }
// 9822 
// 9823 #endif // PIDTEMP
// 9824 
// 9825 #if ENABLED(PIDTEMPBED)
// 9826 
// 9827   inline void gcode_M304() {
// 9828     if (parser.seen('P')) thermalManager.bedKp = parser.value_float();
// 9829     if (parser.seen('I')) thermalManager.bedKi = scalePID_i(parser.value_float());
// 9830     if (parser.seen('D')) thermalManager.bedKd = scalePID_d(parser.value_float());
// 9831 
// 9832     SERIAL_ECHO_START();
// 9833     SERIAL_ECHOPAIR(" p:", thermalManager.bedKp);
// 9834     SERIAL_ECHOPAIR(" i:", unscalePID_i(thermalManager.bedKi));
// 9835     SERIAL_ECHOLNPAIR(" d:", unscalePID_d(thermalManager.bedKd));
// 9836   }
// 9837 
// 9838 #endif // PIDTEMPBED
// 9839 
// 9840 #if defined(CHDK) || HAS_PHOTOGRAPH
// 9841 
// 9842   /**
// 9843    * M240: Trigger a camera by emulating a Canon RC-1
// 9844    *       See http://www.doc-diy.net/photo/rc-1_hacked/
// 9845    */
// 9846   inline void gcode_M240() {
// 9847     #ifdef CHDK
// 9848 
// 9849       OUT_WRITE(CHDK, HIGH);
// 9850       chdkHigh = millis();
// 9851       chdkActive = true;
// 9852 
// 9853     #elif HAS_PHOTOGRAPH
// 9854 
// 9855       const uint8_t NUM_PULSES = 16;
// 9856       const float PULSE_LENGTH = 0.01524;
// 9857       for (int i = 0; i < NUM_PULSES; i++) {
// 9858         WRITE(PHOTOGRAPH_PIN, HIGH);
// 9859         _delay_ms(PULSE_LENGTH);
// 9860         WRITE(PHOTOGRAPH_PIN, LOW);
// 9861         _delay_ms(PULSE_LENGTH);
// 9862       }
// 9863       delay(7.33);
// 9864       for (int i = 0; i < NUM_PULSES; i++) {
// 9865         WRITE(PHOTOGRAPH_PIN, HIGH);
// 9866         _delay_ms(PULSE_LENGTH);
// 9867         WRITE(PHOTOGRAPH_PIN, LOW);
// 9868         _delay_ms(PULSE_LENGTH);
// 9869       }
// 9870 
// 9871     #endif // !CHDK && HAS_PHOTOGRAPH
// 9872   }
// 9873 
// 9874 #endif // CHDK || PHOTOGRAPH_PIN
// 9875 
// 9876 #if HAS_LCD_CONTRAST
// 9877 
// 9878   /**
// 9879    * M250: Read and optionally set the LCD contrast
// 9880    */
// 9881   inline void gcode_M250() {
// 9882     if (parser.seen('C')) set_lcd_contrast(parser.value_int());
// 9883     SERIAL_PROTOCOLPGM("lcd contrast value: ");
// 9884     SERIAL_PROTOCOL(lcd_contrast);
// 9885     SERIAL_EOL();
// 9886   }
// 9887 
// 9888 #endif // HAS_LCD_CONTRAST
// 9889 
// 9890 #if ENABLED(PREVENT_COLD_EXTRUSION)
// 9891 
// 9892   /**
// 9893    * M302: Allow cold extrudes, or set the minimum extrude temperature
// 9894    *
// 9895    *       S<temperature> sets the minimum extrude temperature
// 9896    *       P<bool> enables (1) or disables (0) cold extrusion
// 9897    *
// 9898    *  Examples:
// 9899    *
// 9900    *       M302         ; report current cold extrusion state
// 9901    *       M302 P0      ; enable cold extrusion checking
// 9902    *       M302 P1      ; disables cold extrusion checking
// 9903    *       M302 S0      ; always allow extrusion (disables checking)
// 9904    *       M302 S170    ; only allow extrusion above 170
// 9905    *       M302 S170 P1 ; set min extrude temp to 170 but leave disabled
// 9906    */
// 9907   inline void gcode_M302() {
// 9908     const bool seen_S = parser.seen('S');
// 9909     if (seen_S) {
// 9910       thermalManager.extrude_min_temp = parser.value_celsius();
// 9911       thermalManager.allow_cold_extrude = (thermalManager.extrude_min_temp == 0);
// 9912     }
// 9913 
// 9914     if (parser.seen('P'))
// 9915       thermalManager.allow_cold_extrude = (thermalManager.extrude_min_temp == 0) || parser.value_bool();
// 9916     else if (!seen_S) {
// 9917       // Report current state
// 9918       SERIAL_ECHO_START();
// 9919       SERIAL_ECHOPAIR("Cold extrudes are ", (thermalManager.allow_cold_extrude ? "en" : "dis"));
// 9920       SERIAL_ECHOPAIR("abled (min temp ", thermalManager.extrude_min_temp);
// 9921       SERIAL_ECHOLNPGM("C)");
// 9922     }
// 9923   }
// 9924 
// 9925 #endif // PREVENT_COLD_EXTRUSION
// 9926 
// 9927 /**
// 9928  * M303: PID relay autotune
// 9929  *
// 9930  *       S<temperature> sets the target temperature. (default 150C)
// 9931  *       E<extruder> (-1 for the bed) (default 0)
// 9932  *       C<cycles>
// 9933  *       U<bool> with a non-zero value will apply the result to current settings
// 9934  */
// 9935 inline void gcode_M303() {
// 9936   #if HAS_PID_HEATING
// 9937     const int e = parser.intval('E'), c = parser.intval('C', 5);
// 9938     const bool u = parser.boolval('U');
// 9939 
// 9940     int16_t temp = parser.celsiusval('S', e < 0 ? 70 : 150);
// 9941 
// 9942     if (WITHIN(e, 0, HOTENDS - 1))
// 9943       target_extruder = e;
// 9944 
// 9945     #if DISABLED(BUSY_WHILE_HEATING)
// 9946       KEEPALIVE_STATE(NOT_BUSY);
// 9947     #endif
// 9948 
// 9949     thermalManager.PID_autotune(temp, e, c, u);
// 9950 
// 9951     #if DISABLED(BUSY_WHILE_HEATING)
// 9952       KEEPALIVE_STATE(IN_HANDLER);
// 9953     #endif
// 9954   #else
// 9955     SERIAL_ERROR_START();
// 9956     SERIAL_ERRORLNPGM(MSG_ERR_M303_DISABLED);
// 9957   #endif
// 9958 }
// 9959 
// 9960 #if ENABLED(MORGAN_SCARA)
// 9961 
// 9962   bool SCARA_move_to_cal(const uint8_t delta_a, const uint8_t delta_b) {
// 9963     if (IsRunning()) {
// 9964       forward_kinematics_SCARA(delta_a, delta_b);
// 9965       destination[X_AXIS] = cartes[X_AXIS];
// 9966       destination[Y_AXIS] = cartes[Y_AXIS];
// 9967       destination[Z_AXIS] = current_position[Z_AXIS];
// 9968       prepare_move_to_destination();
// 9969       return true;
// 9970     }
// 9971     return false;
// 9972   }
// 9973 
// 9974   /**
// 9975    * M360: SCARA calibration: Move to cal-position ThetaA (0 deg calibration)
// 9976    */
// 9977   inline bool gcode_M360() {
// 9978     SERIAL_ECHOLNPGM(" Cal: Theta 0");
// 9979     return SCARA_move_to_cal(0, 120);
// 9980   }
// 9981 
// 9982   /**
// 9983    * M361: SCARA calibration: Move to cal-position ThetaB (90 deg calibration - steps per degree)
// 9984    */
// 9985   inline bool gcode_M361() {
// 9986     SERIAL_ECHOLNPGM(" Cal: Theta 90");
// 9987     return SCARA_move_to_cal(90, 130);
// 9988   }
// 9989 
// 9990   /**
// 9991    * M362: SCARA calibration: Move to cal-position PsiA (0 deg calibration)
// 9992    */
// 9993   inline bool gcode_M362() {
// 9994     SERIAL_ECHOLNPGM(" Cal: Psi 0");
// 9995     return SCARA_move_to_cal(60, 180);
// 9996   }
// 9997 
// 9998   /**
// 9999    * M363: SCARA calibration: Move to cal-position PsiB (90 deg calibration - steps per degree)
// 10000    */
// 10001   inline bool gcode_M363() {
// 10002     SERIAL_ECHOLNPGM(" Cal: Psi 90");
// 10003     return SCARA_move_to_cal(50, 90);
// 10004   }
// 10005 
// 10006   /**
// 10007    * M364: SCARA calibration: Move to cal-position PsiC (90 deg to Theta calibration position)
// 10008    */
// 10009   inline bool gcode_M364() {
// 10010     SERIAL_ECHOLNPGM(" Cal: Theta-Psi 90");
// 10011     return SCARA_move_to_cal(45, 135);
// 10012   }
// 10013 
// 10014 #endif // SCARA
// 10015 
// 10016 #if ENABLED(EXT_SOLENOID)
// 10017 
// 10018   void enable_solenoid(const uint8_t num) {
// 10019     switch (num) {
// 10020       case 0:
// 10021         OUT_WRITE(SOL0_PIN, HIGH);
// 10022         break;
// 10023         #if HAS_SOLENOID_1 && EXTRUDERS > 1
// 10024           case 1:
// 10025             OUT_WRITE(SOL1_PIN, HIGH);
// 10026             break;
// 10027         #endif
// 10028         #if HAS_SOLENOID_2 && EXTRUDERS > 2
// 10029           case 2:
// 10030             OUT_WRITE(SOL2_PIN, HIGH);
// 10031             break;
// 10032         #endif
// 10033         #if HAS_SOLENOID_3 && EXTRUDERS > 3
// 10034           case 3:
// 10035             OUT_WRITE(SOL3_PIN, HIGH);
// 10036             break;
// 10037         #endif
// 10038         #if HAS_SOLENOID_4 && EXTRUDERS > 4
// 10039           case 4:
// 10040             OUT_WRITE(SOL4_PIN, HIGH);
// 10041             break;
// 10042         #endif
// 10043       default:
// 10044         SERIAL_ECHO_START();
// 10045         SERIAL_ECHOLNPGM(MSG_INVALID_SOLENOID);
// 10046         break;
// 10047     }
// 10048   }
// 10049 
// 10050   void enable_solenoid_on_active_extruder() { enable_solenoid(active_extruder); }
// 10051 
// 10052   void disable_all_solenoids() {
// 10053     OUT_WRITE(SOL0_PIN, LOW);
// 10054     #if HAS_SOLENOID_1 && EXTRUDERS > 1
// 10055       OUT_WRITE(SOL1_PIN, LOW);
// 10056     #endif
// 10057     #if HAS_SOLENOID_2 && EXTRUDERS > 2
// 10058       OUT_WRITE(SOL2_PIN, LOW);
// 10059     #endif
// 10060     #if HAS_SOLENOID_3 && EXTRUDERS > 3
// 10061       OUT_WRITE(SOL3_PIN, LOW);
// 10062     #endif
// 10063     #if HAS_SOLENOID_4 && EXTRUDERS > 4
// 10064       OUT_WRITE(SOL4_PIN, LOW);
// 10065     #endif
// 10066   }
// 10067 
// 10068   /**
// 10069    * M380: Enable solenoid on the active extruder
// 10070    */
// 10071   inline void gcode_M380() { enable_solenoid_on_active_extruder(); }
// 10072 
// 10073   /**
// 10074    * M381: Disable all solenoids
// 10075    */
// 10076   inline void gcode_M381() { disable_all_solenoids(); }
// 10077 
// 10078 #endif // EXT_SOLENOID
// 10079 
// 10080 /**
// 10081  * M400: Finish all moves
// 10082  */
// 10083 inline void gcode_M400() { stepper.synchronize(); }
// 10084 
// 10085 #if HAS_BED_PROBE
// 10086 
// 10087   /**
// 10088    * M401: Engage Z Servo endstop if available
// 10089    */
// 10090   inline void gcode_M401() { DEPLOY_PROBE(); }
// 10091 
// 10092   /**
// 10093    * M402: Retract Z Servo endstop if enabled
// 10094    */
// 10095   inline void gcode_M402() { STOW_PROBE(); }
// 10096 
// 10097 #endif // HAS_BED_PROBE
// 10098 
// 10099 #if ENABLED(FILAMENT_WIDTH_SENSOR)
// 10100 
// 10101   /**
// 10102    * M404: Display or set (in current units) the nominal filament width (3mm, 1.75mm ) W<3.0>
// 10103    */
// 10104   inline void gcode_M404() {
// 10105     if (parser.seen('W')) {
// 10106       filament_width_nominal = parser.value_linear_units();
// 10107       planner.volumetric_area_nominal = CIRCLE_AREA(filament_width_nominal * 0.5);
// 10108     }
// 10109     else {
// 10110       SERIAL_PROTOCOLPGM("Filament dia (nominal mm):");
// 10111       SERIAL_PROTOCOLLN(filament_width_nominal);
// 10112     }
// 10113   }
// 10114 
// 10115   /**
// 10116    * M405: Turn on filament sensor for control
// 10117    */
// 10118   inline void gcode_M405() {
// 10119     // This is technically a linear measurement, but since it's quantized to centimeters and is a different
// 10120     // unit than everything else, it uses parser.value_byte() instead of parser.value_linear_units().
// 10121     if (parser.seen('D')) {
// 10122       meas_delay_cm = parser.value_byte();
// 10123       NOMORE(meas_delay_cm, MAX_MEASUREMENT_DELAY);
// 10124     }
// 10125 
// 10126     if (filwidth_delay_index[1] == -1) { // Initialize the ring buffer if not done since startup
// 10127       const int8_t temp_ratio = thermalManager.widthFil_to_size_ratio();
// 10128 
// 10129       for (uint8_t i = 0; i < COUNT(measurement_delay); ++i)
// 10130         measurement_delay[i] = temp_ratio;
// 10131 
// 10132       filwidth_delay_index[0] = filwidth_delay_index[1] = 0;
// 10133     }
// 10134 
// 10135     filament_sensor = true;
// 10136   }
// 10137 
// 10138   /**
// 10139    * M406: Turn off filament sensor for control
// 10140    */
// 10141   inline void gcode_M406() {
// 10142     filament_sensor = false;
// 10143     planner.calculate_volumetric_multipliers();   // Restore correct 'volumetric_multiplier' value
// 10144   }
// 10145 
// 10146   /**
// 10147    * M407: Get measured filament diameter on serial output
// 10148    */
// 10149   inline void gcode_M407() {
// 10150     SERIAL_PROTOCOLPGM("Filament dia (measured mm):");
// 10151     SERIAL_PROTOCOLLN(filament_width_meas);
// 10152   }
// 10153 
// 10154 #endif // FILAMENT_WIDTH_SENSOR
// 10155 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock43 Using cfiCommon0
          CFI Function _Z17quickstop_stepperv
        THUMB
// 10156 void quickstop_stepper() {
_Z17quickstop_stepperv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 10157   stepper.quick_stop();
          CFI FunCall _ZN7Stepper10quick_stopEv
        BL       _ZN7Stepper10quick_stopEv
// 10158   stepper.synchronize();
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
// 10159   set_current_from_steppers_for_axis(ALL_AXES);
        MOVS     R0,#+100
          CFI FunCall _Z34set_current_from_steppers_for_axis8AxisEnum
        BL       _Z34set_current_from_steppers_for_axis8AxisEnum
// 10160   SYNC_PLAN_POSITION_KINEMATIC();
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z18sync_plan_positionv
        B.N      _Z18sync_plan_positionv
          CFI EndBlock cfiBlock43
// 10161 }
// 10162 
// 10163 #if HAS_LEVELING
// 10164   /**
// 10165    * M420: Enable/Disable Bed Leveling and/or set the Z fade height.
// 10166    *
// 10167    *   S[bool]   Turns leveling on or off
// 10168    *   Z[height] Sets the Z fade height (0 or none to disable)
// 10169    *   V[bool]   Verbose - Print the leveling grid
// 10170    *
// 10171    * With AUTO_BED_LEVELING_UBL only:
// 10172    *
// 10173    *   L[index]  Load UBL mesh from index (0 is default)
// 10174    */
// 10175   inline void gcode_M420() {
// 10176 
// 10177     const float oldpos[] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] };
// 10178 
// 10179     #if ENABLED(AUTO_BED_LEVELING_UBL)
// 10180 
// 10181       // L to load a mesh from the EEPROM
// 10182       if (parser.seen('L')) {
// 10183 
// 10184         #if ENABLED(EEPROM_SETTINGS)
// 10185           const int8_t storage_slot = parser.has_value() ? parser.value_int() : ubl.storage_slot;
// 10186           const int16_t a = settings.calc_num_meshes();
// 10187 
// 10188           if (!a) {
// 10189             SERIAL_PROTOCOLLNPGM("?EEPROM storage not available.");
// 10190             return;
// 10191           }
// 10192 
// 10193           if (!WITHIN(storage_slot, 0, a - 1)) {
// 10194             SERIAL_PROTOCOLLNPGM("?Invalid storage slot.");
// 10195             SERIAL_PROTOCOLLNPAIR("?Use 0 to ", a - 1);
// 10196             return;
// 10197           }
// 10198 
// 10199           settings.load_mesh(storage_slot);
// 10200           ubl.storage_slot = storage_slot;
// 10201 
// 10202         #else
// 10203 
// 10204           SERIAL_PROTOCOLLNPGM("?EEPROM storage not available.");
// 10205           return;
// 10206 
// 10207         #endif
// 10208       }
// 10209 
// 10210       // L to load a mesh from the EEPROM
// 10211       if (parser.seen('L') || parser.seen('V')) {
// 10212         ubl.display_map(0);  // Currently only supports one map type
// 10213         SERIAL_ECHOLNPAIR("ubl.mesh_is_valid = ", ubl.mesh_is_valid());
// 10214         SERIAL_ECHOLNPAIR("ubl.storage_slot = ", ubl.storage_slot);
// 10215       }
// 10216 
// 10217     #endif // AUTO_BED_LEVELING_UBL
// 10218 
// 10219     // V to print the matrix or mesh
// 10220     if (parser.seen('V')) {
// 10221       #if ABL_PLANAR
// 10222         planner.bed_level_matrix.debug(PSTR("Bed Level Correction Matrix:"));
// 10223       #else
// 10224         if (leveling_is_valid()) {
// 10225           #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 10226             print_bilinear_leveling_grid();
// 10227             #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 10228               print_bilinear_leveling_grid_virt();
// 10229             #endif
// 10230           #elif ENABLED(MESH_BED_LEVELING)
// 10231             SERIAL_ECHOLNPGM("Mesh Bed Level data:");
// 10232             mbl_mesh_report();
// 10233           #endif
// 10234         }
// 10235       #endif
// 10236     }
// 10237 
// 10238     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
// 10239       if (parser.seen('Z')) set_z_fade_height(parser.value_linear_units(), false);
// 10240     #endif
// 10241 
// 10242     bool to_enable = false;
// 10243     if (parser.seen('S')) {
// 10244       to_enable = parser.value_bool();
// 10245       set_bed_leveling_enabled(to_enable);
// 10246     }
// 10247 
// 10248     const bool new_status = planner.leveling_active;
// 10249 
// 10250     if (to_enable && !new_status) {
// 10251       SERIAL_ERROR_START();
// 10252       SERIAL_ERRORLNPGM(MSG_ERR_M420_FAILED);
// 10253     }
// 10254 
// 10255     SERIAL_ECHO_START();
// 10256     SERIAL_ECHOLNPAIR("Bed Leveling ", new_status ? MSG_ON : MSG_OFF);
// 10257 
// 10258     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
// 10259       SERIAL_ECHO_START();
// 10260       SERIAL_ECHOPGM("Fade Height ");
// 10261       if (planner.z_fade_height > 0.0)
// 10262         SERIAL_ECHOLN(planner.z_fade_height);
// 10263       else
// 10264         SERIAL_ECHOLNPGM(MSG_OFF);
// 10265     #endif
// 10266 
// 10267     // Report change in position
// 10268     if (memcmp(oldpos, current_position, sizeof(oldpos)))
// 10269       report_current_position();
// 10270   }
// 10271 #endif
// 10272 
// 10273 #if ENABLED(MESH_BED_LEVELING)
// 10274 
// 10275   /**
// 10276    * M421: Set a single Mesh Bed Leveling Z coordinate
// 10277    *
// 10278    * Usage:
// 10279    *   M421 X<linear> Y<linear> Z<linear>
// 10280    *   M421 X<linear> Y<linear> Q<offset>
// 10281    *   M421 I<xindex> J<yindex> Z<linear>
// 10282    *   M421 I<xindex> J<yindex> Q<offset>
// 10283    */
// 10284   inline void gcode_M421() {
// 10285     const bool hasX = parser.seen('X'), hasI = parser.seen('I');
// 10286     const int8_t ix = hasI ? parser.value_int() : hasX ? mbl.probe_index_x(parser.value_linear_units()) : -1;
// 10287     const bool hasY = parser.seen('Y'), hasJ = parser.seen('J');
// 10288     const int8_t iy = hasJ ? parser.value_int() : hasY ? mbl.probe_index_y(parser.value_linear_units()) : -1;
// 10289     const bool hasZ = parser.seen('Z'), hasQ = !hasZ && parser.seen('Q');
// 10290 
// 10291     if (int(hasI && hasJ) + int(hasX && hasY) != 1 || !(hasZ || hasQ)) {
// 10292       SERIAL_ERROR_START();
// 10293       SERIAL_ERRORLNPGM(MSG_ERR_M421_PARAMETERS);
// 10294     }
// 10295     else if (ix < 0 || iy < 0) {
// 10296       SERIAL_ERROR_START();
// 10297       SERIAL_ERRORLNPGM(MSG_ERR_MESH_XY);
// 10298     }
// 10299     else
// 10300       mbl.set_z(ix, iy, parser.value_linear_units() + (hasQ ? mbl.z_values[ix][iy] : 0));
// 10301   }
// 10302 
// 10303 #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 10304 
// 10305   /**
// 10306    * M421: Set a single Mesh Bed Leveling Z coordinate
// 10307    *
// 10308    * Usage:
// 10309    *   M421 I<xindex> J<yindex> Z<linear>
// 10310    *   M421 I<xindex> J<yindex> Q<offset>
// 10311    */
// 10312   inline void gcode_M421() {
// 10313     int8_t ix = parser.intval('I', -1), iy = parser.intval('J', -1);
// 10314     const bool hasI = ix >= 0,
// 10315                hasJ = iy >= 0,
// 10316                hasZ = parser.seen('Z'),
// 10317                hasQ = !hasZ && parser.seen('Q');
// 10318 
// 10319     if (!hasI || !hasJ || !(hasZ || hasQ)) {
// 10320       SERIAL_ERROR_START();
// 10321       SERIAL_ERRORLNPGM(MSG_ERR_M421_PARAMETERS);
// 10322     }
// 10323     else if (!WITHIN(ix, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(iy, 0, GRID_MAX_POINTS_Y - 1)) {
// 10324       SERIAL_ERROR_START();
// 10325       SERIAL_ERRORLNPGM(MSG_ERR_MESH_XY);
// 10326     }
// 10327     else {
// 10328       z_values[ix][iy] = parser.value_linear_units() + (hasQ ? z_values[ix][iy] : 0);
// 10329       #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 10330         bed_level_virt_interpolate();
// 10331       #endif
// 10332     }
// 10333   }
// 10334 
// 10335 #elif ENABLED(AUTO_BED_LEVELING_UBL)
// 10336 
// 10337   /**
// 10338    * M421: Set a single Mesh Bed Leveling Z coordinate
// 10339    *
// 10340    * Usage:
// 10341    *   M421 I<xindex> J<yindex> Z<linear>
// 10342    *   M421 I<xindex> J<yindex> Q<offset>
// 10343    *   M421 C Z<linear>
// 10344    *   M421 C Q<offset>
// 10345    */
// 10346   inline void gcode_M421() {
// 10347     int8_t ix = parser.intval('I', -1), iy = parser.intval('J', -1);
// 10348     const bool hasI = ix >= 0,
// 10349                hasJ = iy >= 0,
// 10350                hasC = parser.seen('C'),
// 10351                hasZ = parser.seen('Z'),
// 10352                hasQ = !hasZ && parser.seen('Q');
// 10353 
// 10354     if (hasC) {
// 10355       const mesh_index_pair location = ubl.find_closest_mesh_point_of_type(REAL, current_position[X_AXIS], current_position[Y_AXIS], USE_NOZZLE_AS_REFERENCE, NULL);
// 10356       ix = location.x_index;
// 10357       iy = location.y_index;
// 10358     }
// 10359 
// 10360     if (int(hasC) + int(hasI && hasJ) != 1 || !(hasZ || hasQ)) {
// 10361       SERIAL_ERROR_START();
// 10362       SERIAL_ERRORLNPGM(MSG_ERR_M421_PARAMETERS);
// 10363     }
// 10364     else if (!WITHIN(ix, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(iy, 0, GRID_MAX_POINTS_Y - 1)) {
// 10365       SERIAL_ERROR_START();
// 10366       SERIAL_ERRORLNPGM(MSG_ERR_MESH_XY);
// 10367     }
// 10368     else
// 10369       ubl.z_values[ix][iy] = parser.value_linear_units() + (hasQ ? ubl.z_values[ix][iy] : 0);
// 10370   }
// 10371 
// 10372 #endif // AUTO_BED_LEVELING_UBL
// 10373 
// 10374 #if HAS_M206_COMMAND
// 10375 
// 10376   /**
// 10377    * M428: Set home_offset based on the distance between the
// 10378    *       current_position and the nearest "reference point."
// 10379    *       If an axis is past center its endstop position
// 10380    *       is the reference-point. Otherwise it uses 0. This allows
// 10381    *       the Z offset to be set near the bed when using a max endstop.
// 10382    *
// 10383    *       M428 can't be used more than 2cm away from 0 or an endstop.
// 10384    *
// 10385    *       Use M206 to set these values directly.
// 10386    */
// 10387   inline void gcode_M428() {
// 10388     if (axis_unhomed_error()) return;
// 10389 
// 10390     float diff[XYZ];
// 10391     LOOP_XYZ(i) {
// 10392       diff[i] = base_home_pos((AxisEnum)i) - current_position[i];
// 10393       diff[C_AXIS] = home_offset[C_AXIS] - current_position[C_AXIS];    //mks_dlp
// 10394       
// 10395       if (!WITHIN(diff[i], -200, 200) && home_dir((AxisEnum)i) > 0)
// 10396         diff[i] = -current_position[i];
// 10397       if (!WITHIN(diff[i], -200, 200)) {
// 10398         SERIAL_ERROR_START();
// 10399         SERIAL_ERRORLNPGM(MSG_ERR_M428_TOO_FAR);
// 10400         LCD_ALERTMESSAGEPGM("Err: Too far!");
// 10401         BUZZ(200, 40);
// 10402         return;
// 10403       }
// 10404     }
// 10405     LOOP_XYZ(i) set_home_offset((AxisEnum)i, diff[i]);
// 10406     report_current_position();
// 10407     LCD_MESSAGEPGM(MSG_HOME_OFFSETS_APPLIED);
// 10408     BUZZ(100, 659);
// 10409     BUZZ(100, 698);
// 10410   }
// 10411 
// 10412 #endif // HAS_M206_COMMAND
// 10413 
// 10414 /**
// 10415  * M500: Store settings in EEPROM
// 10416  */
// 10417 inline void gcode_M500() {
// 10418   (void)settings.save();
// 10419 }
// 10420 
// 10421 /**
// 10422  * M501: Read settings from EEPROM
// 10423  */
// 10424 inline void gcode_M501() {
// 10425   (void)settings.load();
// 10426 }
// 10427 
// 10428 /**
// 10429  * M502: Revert to default settings
// 10430  */
// 10431 inline void gcode_M502() {
// 10432   (void)settings.reset();
// 10433 }
// 10434 
// 10435 #if DISABLED(DISABLE_M503)
// 10436   /**
// 10437    * M503: print settings currently in memory
// 10438    */
// 10439   inline void gcode_M503() {
// 10440     (void)settings.report(parser.seen('S') && !parser.value_bool());
// 10441   }
// 10442 #endif
// 10443 
// 10444 #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
// 10445 
// 10446   /**
// 10447    * M540: Set whether SD card print should abort on endstop hit (M540 S<0|1>)
// 10448    */
// 10449   inline void gcode_M540() {
// 10450     if (parser.seen('S')) stepper.abort_on_endstop_hit = parser.value_bool();
// 10451   }
// 10452 
// 10453 #endif // ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
// 10454 
// 10455 #if HAS_BED_PROBE
// 10456 
// 10457   inline void gcode_M851() {
// 10458     SERIAL_ECHO_START();
// 10459     SERIAL_ECHOPGM(MSG_PROBE_Z_OFFSET);
// 10460     if (parser.seen('Z')) {
// 10461       const float value = parser.value_linear_units();
// 10462       if (!WITHIN(value, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
// 10463         SERIAL_ECHOLNPGM(" " MSG_Z_MIN " " STRINGIFY(Z_PROBE_OFFSET_RANGE_MIN) " " MSG_Z_MAX " " STRINGIFY(Z_PROBE_OFFSET_RANGE_MAX));
// 10464         return;
// 10465       }
// 10466       zprobe_zoffset = value;
// 10467     }
// 10468     SERIAL_ECHOLNPAIR(": ", zprobe_zoffset);
// 10469   }
// 10470 
// 10471 #endif // HAS_BED_PROBE
// 10472 
// 10473 #if ENABLED(SKEW_CORRECTION_GCODE)
// 10474 
// 10475   /**
// 10476    * M852: Get or set the machine skew factors. Reports current values with no arguments.
// 10477    *
// 10478    *  S[xy_factor] - Alias for 'I'
// 10479    *  I[xy_factor] - New XY skew factor
// 10480    *  J[xz_factor] - New XZ skew factor
// 10481    *  K[yz_factor] - New YZ skew factor
// 10482    */
// 10483   inline void gcode_M852() {
// 10484     uint8_t ijk = 0, badval = 0, setval = 0;
// 10485 
// 10486     if (parser.seen('I') || parser.seen('S')) {
// 10487       ++ijk;
// 10488       const float value = parser.value_linear_units();
// 10489       if (WITHIN(value, SKEW_FACTOR_MIN, SKEW_FACTOR_MAX)) {
// 10490         if (planner.xy_skew_factor != value) {
// 10491           planner.xy_skew_factor = value;
// 10492           ++setval;
// 10493         }
// 10494       }
// 10495       else
// 10496         ++badval;
// 10497     }
// 10498 
// 10499     #if ENABLED(SKEW_CORRECTION_FOR_Z)
// 10500 
// 10501       if (parser.seen('J')) {
// 10502         ++ijk;
// 10503         const float value = parser.value_linear_units();
// 10504         if (WITHIN(value, SKEW_FACTOR_MIN, SKEW_FACTOR_MAX)) {
// 10505           if (planner.xz_skew_factor != value) {
// 10506             planner.xz_skew_factor = value;
// 10507             ++setval;
// 10508           }
// 10509         }
// 10510         else
// 10511           ++badval;
// 10512       }
// 10513 
// 10514       if (parser.seen('K')) {
// 10515         ++ijk;
// 10516         const float value = parser.value_linear_units();
// 10517         if (WITHIN(value, SKEW_FACTOR_MIN, SKEW_FACTOR_MAX)) {
// 10518           if (planner.yz_skew_factor != value) {
// 10519             planner.yz_skew_factor = value;
// 10520             ++setval;
// 10521           }
// 10522         }
// 10523         else
// 10524           ++badval;
// 10525       }
// 10526 
// 10527     #endif
// 10528 
// 10529     if (badval)
// 10530       SERIAL_ECHOLNPGM(MSG_SKEW_MIN " " STRINGIFY(SKEW_FACTOR_MIN) " " MSG_SKEW_MAX " " STRINGIFY(SKEW_FACTOR_MAX));
// 10531 
// 10532     // When skew is changed the current position changes
// 10533     if (setval) {
// 10534       set_current_from_steppers_for_axis(ALL_AXES);
// 10535       SYNC_PLAN_POSITION_KINEMATIC();
// 10536       report_current_position();
// 10537     }
// 10538 
// 10539     if (!ijk) {
// 10540       SERIAL_ECHO_START();
// 10541       SERIAL_ECHOPAIR(MSG_SKEW_FACTOR " XY: ", planner.xy_skew_factor);
// 10542       #if ENABLED(SKEW_CORRECTION_FOR_Z)
// 10543         SERIAL_ECHOPAIR(" XZ: ", planner.xz_skew_factor);
// 10544         SERIAL_ECHOLNPAIR(" YZ: ", planner.yz_skew_factor);
// 10545       #else
// 10546         SERIAL_EOL();
// 10547       #endif
// 10548     }
// 10549   }
// 10550 
// 10551 #endif // SKEW_CORRECTION_GCODE
// 10552 
// 10553 #if ENABLED(ADVANCED_PAUSE_FEATURE)
// 10554 
// 10555   /**
// 10556    * M600: Pause for filament change
// 10557    *
// 10558    *  E[distance] - Retract the filament this far (negative value)
// 10559    *  Z[distance] - Move the Z axis by this distance
// 10560    *  X[position] - Move to this X position, with Y
// 10561    *  Y[position] - Move to this Y position, with X
// 10562    *  U[distance] - Retract distance for removal (negative value) (manual reload)
// 10563    *  L[distance] - Extrude distance for insertion (positive value) (manual reload)
// 10564    *  B[count]    - Number of times to beep, -1 for indefinite (if equipped with a buzzer)
// 10565    *
// 10566    *  Default values are used for omitted arguments.
// 10567    *
// 10568    */
// 10569   inline void gcode_M600() {
// 10570     point_t park_point = NOZZLE_PARK_POINT;
// 10571 
// 10572     #if ENABLED(HOME_BEFORE_FILAMENT_CHANGE)
// 10573       // Don't allow filament change without homing first
// 10574       if (axis_unhomed_error()) home_all_axes();
// 10575     #endif
// 10576 
// 10577     // Initial retract before move to filament change position
// 10578     const float retract = parser.seen('E') ? parser.value_axis_units(E_AXIS) : 0
// 10579       #ifdef PAUSE_PARK_RETRACT_LENGTH
// 10580         - (PAUSE_PARK_RETRACT_LENGTH)
// 10581       #endif
// 10582     ;
// 10583 
// 10584     // Lift Z axis
// 10585     if (parser.seenval('Z'))
// 10586       park_point.z = parser.linearval('Z');
// 10587 
// 10588     // Move XY axes to filament change position or given position
// 10589     if (parser.seenval('X'))
// 10590       park_point.x = parser.linearval('X');
// 10591 
// 10592     if (parser.seenval('Y'))
// 10593       park_point.y = parser.linearval('Y');
// 10594 
// 10595     #if HOTENDS > 1 && DISABLED(DUAL_X_CARRIAGE)
// 10596       park_point.x += (active_extruder ? hotend_offset[X_AXIS][active_extruder] : 0);
// 10597       park_point.y += (active_extruder ? hotend_offset[Y_AXIS][active_extruder] : 0);
// 10598     #endif
// 10599 
// 10600     // Unload filament
// 10601     const float unload_length = parser.seen('U') ? parser.value_axis_units(E_AXIS) : 0
// 10602       #if defined(FILAMENT_CHANGE_UNLOAD_LENGTH) && FILAMENT_CHANGE_UNLOAD_LENGTH > 0
// 10603         - (FILAMENT_CHANGE_UNLOAD_LENGTH)
// 10604       #endif
// 10605     ;
// 10606 
// 10607     // Load filament
// 10608     const float load_length = parser.seen('L') ? parser.value_axis_units(E_AXIS) : 0
// 10609       #ifdef FILAMENT_CHANGE_LOAD_LENGTH
// 10610         + FILAMENT_CHANGE_LOAD_LENGTH
// 10611       #endif
// 10612     ;
// 10613 
// 10614     const int beep_count = parser.intval('B',
// 10615       #ifdef FILAMENT_CHANGE_NUMBER_OF_ALERT_BEEPS
// 10616         FILAMENT_CHANGE_NUMBER_OF_ALERT_BEEPS
// 10617       #else
// 10618         -1
// 10619       #endif
// 10620     );
// 10621 
// 10622     const bool job_running = print_job_timer.isRunning();
// 10623 
// 10624     if (pause_print(retract, park_point, unload_length, beep_count, true)) {
// 10625       wait_for_filament_reload(beep_count);
// 10626       resume_print(load_length, ADVANCED_PAUSE_EXTRUDE_LENGTH, beep_count);
// 10627     }
// 10628 
// 10629     // Resume the print job timer if it was running
// 10630     if (job_running) print_job_timer.start();
// 10631   }
// 10632 
// 10633 #endif // ADVANCED_PAUSE_FEATURE
// 10634 
// 10635 #if ENABLED(MK2_MULTIPLEXER)
// 10636 
// 10637   inline void select_multiplexed_stepper(const uint8_t e) {
// 10638     stepper.synchronize();
// 10639     disable_e_steppers();
// 10640     WRITE(E_MUX0_PIN, TEST(e, 0) ? HIGH : LOW);
// 10641     WRITE(E_MUX1_PIN, TEST(e, 1) ? HIGH : LOW);
// 10642     WRITE(E_MUX2_PIN, TEST(e, 2) ? HIGH : LOW);
// 10643     safe_delay(100);
// 10644   }
// 10645 
// 10646   /**
// 10647    * M702: Unload all extruders
// 10648    */
// 10649   inline void gcode_M702() {
// 10650     for (uint8_t s = 0; s < E_STEPPERS; s++) {
// 10651       select_multiplexed_stepper(e);
// 10652       // TODO: standard unload filament function
// 10653       // MK2 firmware behavior:
// 10654       //  - Make sure temperature is high enough
// 10655       //  - Raise Z to at least 15 to make room
// 10656       //  - Extrude 1cm of filament in 1 second
// 10657       //  - Under 230C quickly purge ~12mm, over 230C purge ~10mm
// 10658       //  - Change E max feedrate to 80, eject the filament from the tube. Sync.
// 10659       //  - Restore E max feedrate to 50
// 10660     }
// 10661     // Go back to the last active extruder
// 10662     select_multiplexed_stepper(active_extruder);
// 10663     disable_e_steppers();
// 10664   }
// 10665 
// 10666 #endif // MK2_MULTIPLEXER
// 10667 
// 10668 #if ENABLED(DUAL_X_CARRIAGE)
// 10669 
// 10670   /**
// 10671    * M605: Set dual x-carriage movement mode
// 10672    *
// 10673    *    M605 S0: Full control mode. The slicer has full control over x-carriage movement
// 10674    *    M605 S1: Auto-park mode. The inactive head will auto park/unpark without slicer involvement
// 10675    *    M605 S2 [Xnnn] [Rmmm]: Duplication mode. The second extruder will duplicate the first with nnn
// 10676    *                         units x-offset and an optional differential hotend temperature of
// 10677    *                         mmm degrees. E.g., with "M605 S2 X100 R2" the second extruder will duplicate
// 10678    *                         the first with a spacing of 100mm in the x direction and 2 degrees hotter.
// 10679    *
// 10680    *    Note: the X axis should be homed after changing dual x-carriage mode.
// 10681    */
// 10682   inline void gcode_M605() {
// 10683     stepper.synchronize();
// 10684     if (parser.seen('S')) dual_x_carriage_mode = (DualXMode)parser.value_byte();
// 10685     switch (dual_x_carriage_mode) {
// 10686       case DXC_FULL_CONTROL_MODE:
// 10687       case DXC_AUTO_PARK_MODE:
// 10688         break;
// 10689       case DXC_DUPLICATION_MODE:
// 10690         if (parser.seen('X')) duplicate_extruder_x_offset = max(parser.value_linear_units(), X2_MIN_POS - x_home_pos(0));
// 10691         if (parser.seen('R')) duplicate_extruder_temp_offset = parser.value_celsius_diff();
// 10692         SERIAL_ECHO_START();
// 10693         SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
// 10694         SERIAL_CHAR(' ');
// 10695         SERIAL_ECHO(hotend_offset[X_AXIS][0]);
// 10696         SERIAL_CHAR(',');
// 10697         SERIAL_ECHO(hotend_offset[Y_AXIS][0]);
// 10698         SERIAL_CHAR(' ');
// 10699         SERIAL_ECHO(duplicate_extruder_x_offset);
// 10700         SERIAL_CHAR(',');
// 10701         SERIAL_ECHOLN(hotend_offset[Y_AXIS][1]);
// 10702         break;
// 10703       default:
// 10704         dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
// 10705         break;
// 10706     }
// 10707     active_extruder_parked = false;
// 10708     extruder_duplication_enabled = false;
// 10709     delayed_move_time = 0;
// 10710   }
// 10711 
// 10712 #elif ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
// 10713 
// 10714   inline void gcode_M605() {
// 10715     stepper.synchronize();
// 10716     extruder_duplication_enabled = parser.intval('S') == (int)DXC_DUPLICATION_MODE;
// 10717     SERIAL_ECHO_START();
// 10718     SERIAL_ECHOLNPAIR(MSG_DUPLICATION_MODE, extruder_duplication_enabled ? MSG_ON : MSG_OFF);
// 10719   }
// 10720 
// 10721 #endif // DUAL_NOZZLE_DUPLICATION_MODE
// 10722 
// 10723 #if ENABLED(LIN_ADVANCE)
// 10724   /**
// 10725    * M900: Set and/or Get advance K factor and WH/D ratio
// 10726    *
// 10727    *  K<factor>                  Set advance K factor
// 10728    *  R<ratio>                   Set ratio directly (overrides WH/D)
// 10729    *  W<width> H<height> D<diam> Set ratio from WH/D
// 10730    */
// 10731   inline void gcode_M900() {
// 10732     stepper.synchronize();
// 10733 
// 10734     const float newK = parser.floatval('K', -1);
// 10735     if (newK >= 0) planner.extruder_advance_k = newK;
// 10736 
// 10737     float newR = parser.floatval('R', -1);
// 10738     if (newR < 0) {
// 10739       const float newD = parser.floatval('D', -1),
// 10740                   newW = parser.floatval('W', -1),
// 10741                   newH = parser.floatval('H', -1);
// 10742       if (newD >= 0 && newW >= 0 && newH >= 0)
// 10743         newR = newD ? (newW * newH) / (sq(newD * 0.5) * M_PI) : 0;
// 10744     }
// 10745     if (newR >= 0) planner.advance_ed_ratio = newR;
// 10746 
// 10747     SERIAL_ECHO_START();
// 10748     SERIAL_ECHOPAIR("Advance K=", planner.extruder_advance_k);
// 10749     SERIAL_ECHOPGM(" E/D=");
// 10750     const float ratio = planner.advance_ed_ratio;
// 10751     if (ratio) SERIAL_ECHO(ratio); else SERIAL_ECHOPGM("Auto");
// 10752     SERIAL_EOL();
// 10753   }
// 10754 #endif // LIN_ADVANCE
// 10755 
// 10756 #if HAS_TRINAMIC
// 10757   static bool report_tmc_status = false;
// 10758   const char extended_axis_codes[11][3] = { "X", "X2", "Y", "Y2", "Z", "Z2", "E0", "E1", "E2", "E3", "E4" };
// 10759   enum TMC_AxisEnum {
// 10760     TMC_X,
// 10761     TMC_X2,
// 10762     TMC_Y,
// 10763     TMC_Y2,
// 10764     TMC_Z,
// 10765     TMC_Z2,
// 10766     TMC_E0,
// 10767     TMC_E1,
// 10768     TMC_E2,
// 10769     TMC_E3,
// 10770     TMC_E4
// 10771   };
// 10772   #if ENABLED(TMC_DEBUG)
// 10773     enum TMC_debug_enum {
// 10774       TMC_CODES,
// 10775       TMC_ENABLED,
// 10776       TMC_CURRENT,
// 10777       TMC_RMS_CURRENT,
// 10778       TMC_MAX_CURRENT,
// 10779       TMC_IRUN,
// 10780       TMC_IHOLD,
// 10781       TMC_CS_ACTUAL,
// 10782       TMC_PWM_SCALE,
// 10783       TMC_VSENSE,
// 10784       TMC_STEALTHCHOP,
// 10785       TMC_MICROSTEPS,
// 10786       TMC_TSTEP,
// 10787       TMC_TPWMTHRS,
// 10788       TMC_TPWMTHRS_MMS,
// 10789       TMC_OTPW,
// 10790       TMC_OTPW_TRIGGERED,
// 10791       TMC_TOFF,
// 10792       TMC_TBL,
// 10793       TMC_HEND,
// 10794       TMC_HSTRT,
// 10795       TMC_SGT
// 10796     };
// 10797     enum TMC_drv_status_enum {
// 10798       TMC_DRV_CODES,
// 10799       TMC_STST,
// 10800       TMC_OLB,
// 10801       TMC_OLA,
// 10802       TMC_S2GB,
// 10803       TMC_S2GA,
// 10804       TMC_DRV_OTPW,
// 10805       TMC_OT,
// 10806       TMC_STALLGUARD,
// 10807       TMC_DRV_CS_ACTUAL,
// 10808       TMC_FSACTIVE,
// 10809       TMC_SG_RESULT,
// 10810       TMC_DRV_STATUS_HEX,
// 10811       TMC_T157,
// 10812       TMC_T150,
// 10813       TMC_T143,
// 10814       TMC_T120,
// 10815       TMC_STEALTH,
// 10816       TMC_S2VSB,
// 10817       TMC_S2VSA
// 10818     };
// 10819     static void drv_status_print_hex(const char name[], const uint32_t drv_status) {
// 10820       SERIAL_ECHO(name);
// 10821       SERIAL_ECHOPGM(" = 0x");
// 10822       for(int B=24; B>=8; B-=8){
// 10823         MYSERIAL.print((drv_status>>(B+4))&0xF, HEX);
// 10824         MYSERIAL.print((drv_status>>B)&0xF, HEX);
// 10825         MYSERIAL.print(':');
// 10826       }
// 10827       MYSERIAL.print((drv_status>>4)&0xF, HEX);
// 10828       MYSERIAL.print((drv_status)&0xF, HEX);
// 10829       SERIAL_EOL();
// 10830     }
// 10831 
// 10832     #if ENABLED(HAVE_TMC2130)
// 10833       static void tmc_status(TMC2130Stepper &st, const TMC_debug_enum i) {
// 10834         switch(i) {
// 10835           case TMC_PWM_SCALE: MYSERIAL.print(st.PWM_SCALE(), DEC); break;
// 10836           case TMC_TSTEP: SERIAL_ECHO(st.TSTEP()); break;
// 10837           case TMC_SGT: MYSERIAL.print(st.sgt(), DEC); break;
// 10838           case TMC_STEALTHCHOP: serialprintPGM(st.stealthChop() ? PSTR("true") : PSTR("false")); break;
// 10839           default: break;
// 10840         }
// 10841       }
// 10842       static void tmc_parse_drv_status(TMC2130Stepper &st, const TMC_drv_status_enum i) {
// 10843         switch(i) {
// 10844           case TMC_STALLGUARD: if (st.stallguard()) SERIAL_ECHOPGM("X"); break;
// 10845           case TMC_SG_RESULT:  MYSERIAL.print(st.sg_result(), DEC);      break;
// 10846           case TMC_FSACTIVE:   if (st.fsactive())   SERIAL_ECHOPGM("X"); break;
// 10847           default: break;
// 10848         }
// 10849       }
// 10850     #endif
// 10851     #if ENABLED(HAVE_TMC2208)
// 10852       static void tmc_status(TMC2208Stepper &st, const TMC_debug_enum i) {
// 10853         switch(i) {
// 10854           case TMC_TSTEP:
// 10855             {
// 10856               uint32_t data = 0;
// 10857               st.TSTEP(&data);
// 10858               MYSERIAL.print(data);
// 10859               break;
// 10860             }
// 10861           case TMC_PWM_SCALE: MYSERIAL.print(st.pwm_scale_sum(), DEC); break;
// 10862           case TMC_STEALTHCHOP: serialprintPGM(st.stealth() ? PSTR("true") : PSTR("false")); break;
// 10863           case TMC_S2VSA: if (st.s2vsa()) SERIAL_ECHOPGM("X"); break;
// 10864           case TMC_S2VSB: if (st.s2vsb()) SERIAL_ECHOPGM("X"); break;
// 10865           default: break;
// 10866         }
// 10867       }
// 10868       static void tmc_parse_drv_status(TMC2208Stepper &st, const TMC_drv_status_enum i) {
// 10869         switch(i) {
// 10870           case TMC_T157: if (st.t157()) SERIAL_ECHOPGM("X"); break;
// 10871           case TMC_T150: if (st.t150()) SERIAL_ECHOPGM("X"); break;
// 10872           case TMC_T143: if (st.t143()) SERIAL_ECHOPGM("X"); break;
// 10873           case TMC_T120: if (st.t120()) SERIAL_ECHOPGM("X"); break;
// 10874           default: break;
// 10875         }
// 10876       }
// 10877     #endif
// 10878     template <typename TMC>
// 10879     static void tmc_status(TMC &st, TMC_AxisEnum axis, const TMC_debug_enum i, const float spmm) {
// 10880       SERIAL_ECHO('\t');
// 10881       switch(i) {
// 10882         case TMC_CODES: SERIAL_ECHO(extended_axis_codes[axis]); break;
// 10883         case TMC_ENABLED: serialprintPGM(st.isEnabled() ? PSTR("true") : PSTR("false")); break;
// 10884         case TMC_CURRENT: SERIAL_ECHO(st.getCurrent()); break;
// 10885         case TMC_RMS_CURRENT: MYSERIAL.print(st.rms_current()); break;
// 10886         case TMC_MAX_CURRENT: MYSERIAL.print((float)st.rms_current()*1.41, 0); break;
// 10887         case TMC_IRUN:
// 10888           MYSERIAL.print(st.irun(), DEC);
// 10889           SERIAL_ECHOPGM("/31");
// 10890           break;
// 10891         case TMC_IHOLD:
// 10892           MYSERIAL.print(st.ihold(), DEC);
// 10893           SERIAL_ECHOPGM("/31");
// 10894           break;
// 10895         case TMC_CS_ACTUAL:
// 10896           MYSERIAL.print(st.cs_actual(), DEC);
// 10897           SERIAL_ECHOPGM("/31");
// 10898           break;
// 10899 
// 10900         case TMC_VSENSE: serialprintPGM(st.vsense() ? PSTR("1=.18") : PSTR("0=.325")); break;
// 10901 
// 10902         case TMC_MICROSTEPS: SERIAL_ECHO(st.microsteps()); break;
// 10903         case TMC_TPWMTHRS:
// 10904           {
// 10905             uint32_t tpwmthrs_val = st.TPWMTHRS();
// 10906             SERIAL_ECHO(tpwmthrs_val);
// 10907           }
// 10908           break;
// 10909         case TMC_TPWMTHRS_MMS:
// 10910           {
// 10911             uint32_t tpwmthrs_val = st.TPWMTHRS();
// 10912             tpwmthrs_val ? SERIAL_ECHO(12650000UL * st.microsteps() / (256 * tpwmthrs_val * spmm)) : SERIAL_ECHO('-');
// 10913           }
// 10914           break;
// 10915         case TMC_OTPW: serialprintPGM(st.otpw() ? PSTR("true") : PSTR("false")); break;
// 10916         case TMC_OTPW_TRIGGERED: serialprintPGM(st.getOTPW() ? PSTR("true") : PSTR("false")); break;
// 10917         case TMC_TOFF: MYSERIAL.print(st.toff(), DEC); break;
// 10918         case TMC_TBL: MYSERIAL.print(st.blank_time(), DEC); break;
// 10919         case TMC_HEND: MYSERIAL.print(st.hysterisis_end(), DEC); break;
// 10920         case TMC_HSTRT: MYSERIAL.print(st.hysterisis_start(), DEC); break;
// 10921         default: tmc_status(st, i); break;
// 10922       }
// 10923     }
// 10924     template <typename TMC>
// 10925     static void tmc_parse_drv_status(TMC &st, TMC_AxisEnum axis, const TMC_drv_status_enum i) {
// 10926       SERIAL_ECHOPGM("\t");
// 10927       switch(i) {
// 10928         case TMC_DRV_CODES:     SERIAL_ECHO(extended_axis_codes[axis]);  break;
// 10929         case TMC_STST:          if (st.stst())         SERIAL_ECHOPGM("X"); break;
// 10930         case TMC_OLB:           if (st.olb())          SERIAL_ECHOPGM("X"); break;
// 10931         case TMC_OLA:           if (st.ola())          SERIAL_ECHOPGM("X"); break;
// 10932         case TMC_S2GB:          if (st.s2gb())         SERIAL_ECHOPGM("X"); break;
// 10933         case TMC_S2GA:          if (st.s2ga())         SERIAL_ECHOPGM("X"); break;
// 10934         case TMC_DRV_OTPW:      if (st.otpw())         SERIAL_ECHOPGM("X"); break;
// 10935         case TMC_OT:            if (st.ot())           SERIAL_ECHOPGM("X"); break;
// 10936         case TMC_DRV_CS_ACTUAL: MYSERIAL.print(st.cs_actual(), DEC);        break;
// 10937         case TMC_DRV_STATUS_HEX:drv_status_print_hex(extended_axis_codes[axis], st.DRV_STATUS()); break;
// 10938         default: tmc_parse_drv_status(st, i); break;
// 10939       }
// 10940     }
// 10941 
// 10942     static void tmc_debug_loop(const TMC_debug_enum i) {
// 10943       #if X_IS_TRINAMIC
// 10944         tmc_status(stepperX, TMC_X, i, planner.axis_steps_per_mm[X_AXIS]);
// 10945       #endif
// 10946       #if X2_IS_TRINAMIC
// 10947         tmc_status(stepperX2, TMC_X2, i, planner.axis_steps_per_mm[X_AXIS]);
// 10948       #endif
// 10949 
// 10950       #if Y_IS_TRINAMIC
// 10951         tmc_status(stepperY, TMC_Y, i, planner.axis_steps_per_mm[Y_AXIS]);
// 10952       #endif
// 10953       #if Y2_IS_TRINAMIC
// 10954         tmc_status(stepperY2, TMC_Y2, i, planner.axis_steps_per_mm[Y_AXIS]);
// 10955       #endif
// 10956 
// 10957       #if Z_IS_TRINAMIC
// 10958         tmc_status(stepperZ, TMC_Z, i, planner.axis_steps_per_mm[Z_AXIS]);
// 10959       #endif
// 10960       #if Z2_IS_TRINAMIC
// 10961         tmc_status(stepperZ2, TMC_Z2, i, planner.axis_steps_per_mm[Z_AXIS]);
// 10962       #endif
// 10963 
// 10964       #if E0_IS_TRINAMIC
// 10965         tmc_status(stepperE0, TMC_E0, i, planner.axis_steps_per_mm[E_AXIS]);
// 10966       #endif
// 10967       #if E1_IS_TRINAMIC
// 10968         tmc_status(stepperE1, TMC_E1, i, planner.axis_steps_per_mm[E_AXIS+1]);
// 10969       #endif
// 10970       #if E2_IS_TRINAMIC
// 10971         tmc_status(stepperE2, TMC_E2, i, planner.axis_steps_per_mm[E_AXIS+2]);
// 10972       #endif
// 10973       #if E3_IS_TRINAMIC
// 10974         tmc_status(stepperE3, TMC_E3, i, planner.axis_steps_per_mm[E_AXIS+3]);
// 10975       #endif
// 10976       #if E4_IS_TRINAMIC
// 10977         tmc_status(stepperE4, TMC_E4, i, planner.axis_steps_per_mm[E_AXIS+4]);
// 10978       #endif
// 10979 
// 10980       SERIAL_EOL();
// 10981     }
// 10982 
// 10983     static void drv_status_loop(const TMC_drv_status_enum i) {
// 10984       #if X_IS_TRINAMIC
// 10985         tmc_parse_drv_status(stepperX, TMC_X, i);
// 10986       #endif
// 10987       #if X2_IS_TRINAMIC
// 10988         tmc_parse_drv_status(stepperX2, TMC_X2, i);
// 10989       #endif
// 10990 
// 10991       #if Y_IS_TRINAMIC
// 10992         tmc_parse_drv_status(stepperY, TMC_Y, i);
// 10993       #endif
// 10994       #if Y2_IS_TRINAMIC
// 10995         tmc_parse_drv_status(stepperY2, TMC_Y2, i);
// 10996       #endif
// 10997 
// 10998       #if Z_IS_TRINAMIC
// 10999         tmc_parse_drv_status(stepperZ, TMC_Z, i);
// 11000       #endif
// 11001       #if Z2_IS_TRINAMIC
// 11002         tmc_parse_drv_status(stepperZ2, TMC_Z2, i);
// 11003       #endif
// 11004 
// 11005       #if E0_IS_TRINAMIC
// 11006         tmc_parse_drv_status(stepperE0, TMC_E0, i);
// 11007       #endif
// 11008       #if E1_IS_TRINAMIC
// 11009         tmc_parse_drv_status(stepperE1, TMC_E1, i);
// 11010       #endif
// 11011       #if E2_IS_TRINAMIC
// 11012         tmc_parse_drv_status(stepperE2, TMC_E2, i);
// 11013       #endif
// 11014       #if E3_IS_TRINAMIC
// 11015         tmc_parse_drv_status(stepperE3, TMC_E3, i);
// 11016       #endif
// 11017       #if E4_IS_TRINAMIC
// 11018         tmc_parse_drv_status(stepperE4, TMC_E4, i);
// 11019       #endif
// 11020 
// 11021       SERIAL_EOL();
// 11022     }
// 11023 
// 11024     inline void gcode_M122() {
// 11025       if (parser.seen('S')) {
// 11026         if (parser.value_bool()) {
// 11027           SERIAL_ECHOLNPGM("axis:pwm_scale |status_response|");
// 11028           report_tmc_status = true;
// 11029         } else
// 11030           report_tmc_status = false;
// 11031       } else {
// 11032         SERIAL_ECHOPGM("\t");                 tmc_debug_loop(TMC_CODES);
// 11033         SERIAL_ECHOPGM("Enabled\t");          tmc_debug_loop(TMC_ENABLED);
// 11034         SERIAL_ECHOPGM("Set current");        tmc_debug_loop(TMC_CURRENT);
// 11035         SERIAL_ECHOPGM("RMS current");        tmc_debug_loop(TMC_RMS_CURRENT);
// 11036         SERIAL_ECHOPGM("MAX current");        tmc_debug_loop(TMC_MAX_CURRENT);
// 11037         SERIAL_ECHOPGM("Run current");        tmc_debug_loop(TMC_IRUN);
// 11038         SERIAL_ECHOPGM("Hold current");       tmc_debug_loop(TMC_IHOLD);
// 11039         SERIAL_ECHOPGM("CS actual\t");        tmc_debug_loop(TMC_CS_ACTUAL);
// 11040         SERIAL_ECHOPGM("PWM scale");          tmc_debug_loop(TMC_PWM_SCALE);
// 11041         SERIAL_ECHOPGM("vsense\t");           tmc_debug_loop(TMC_VSENSE);
// 11042         SERIAL_ECHOPGM("stealthChop");        tmc_debug_loop(TMC_STEALTHCHOP);
// 11043         SERIAL_ECHOPGM("msteps\t");           tmc_debug_loop(TMC_MICROSTEPS);
// 11044         SERIAL_ECHOPGM("tstep\t");            tmc_debug_loop(TMC_TSTEP);
// 11045         SERIAL_ECHOPGM("pwm\nthreshold\t");   tmc_debug_loop(TMC_TPWMTHRS);
// 11046         SERIAL_ECHOPGM("[mm/s]\t");           tmc_debug_loop(TMC_TPWMTHRS_MMS);
// 11047         SERIAL_ECHOPGM("OT prewarn");         tmc_debug_loop(TMC_OTPW);
// 11048         SERIAL_ECHOPGM("OT prewarn has\nbeen triggered"); tmc_debug_loop(TMC_OTPW_TRIGGERED);
// 11049         SERIAL_ECHOPGM("off time\t");         tmc_debug_loop(TMC_TOFF);
// 11050         SERIAL_ECHOPGM("blank time");         tmc_debug_loop(TMC_TBL);
// 11051         SERIAL_ECHOPGM("hysterisis\n-end\t"); tmc_debug_loop(TMC_HEND);
// 11052         SERIAL_ECHOPGM("-start\t");           tmc_debug_loop(TMC_HSTRT);
// 11053         SERIAL_ECHOPGM("Stallguard thrs");    tmc_debug_loop(TMC_SGT);
// 11054 
// 11055         SERIAL_ECHOPGM("DRVSTATUS");          drv_status_loop(TMC_DRV_CODES);
// 11056         #if ENABLED(HAVE_TMC2130)
// 11057           SERIAL_ECHOPGM("stallguard\t");     drv_status_loop(TMC_STALLGUARD);
// 11058           SERIAL_ECHOPGM("sg_result\t");      drv_status_loop(TMC_SG_RESULT);
// 11059           SERIAL_ECHOPGM("fsactive\t");       drv_status_loop(TMC_FSACTIVE);
// 11060         #endif
// 11061         SERIAL_ECHOPGM("stst\t");             drv_status_loop(TMC_STST);
// 11062         SERIAL_ECHOPGM("olb\t");              drv_status_loop(TMC_OLB);
// 11063         SERIAL_ECHOPGM("ola\t");              drv_status_loop(TMC_OLA);
// 11064         SERIAL_ECHOPGM("s2gb\t");             drv_status_loop(TMC_S2GB);
// 11065         SERIAL_ECHOPGM("s2ga\t");             drv_status_loop(TMC_S2GA);
// 11066         SERIAL_ECHOPGM("otpw\t");             drv_status_loop(TMC_DRV_OTPW);
// 11067         SERIAL_ECHOPGM("ot\t");               drv_status_loop(TMC_OT);
// 11068         #if ENABLED(HAVE_TMC2208)
// 11069           SERIAL_ECHOPGM("157C\t");           drv_status_loop(TMC_T157);
// 11070           SERIAL_ECHOPGM("150C\t");           drv_status_loop(TMC_T150);
// 11071           SERIAL_ECHOPGM("143C\t");           drv_status_loop(TMC_T143);
// 11072           SERIAL_ECHOPGM("120C\t");           drv_status_loop(TMC_T120);
// 11073           SERIAL_ECHOPGM("s2vsa\t");          drv_status_loop(TMC_S2VSA);
// 11074           SERIAL_ECHOPGM("s2vsb\t");          drv_status_loop(TMC_S2VSB);
// 11075         #endif
// 11076         SERIAL_ECHOLNPGM("Driver registers:");drv_status_loop(TMC_DRV_STATUS_HEX);
// 11077       }
// 11078     }
// 11079   #endif
// 11080 
// 11081   template<typename TMC>
// 11082   static void tmc_get_current(TMC &st, const char name[]) {
// 11083     SERIAL_ECHO(name);
// 11084     SERIAL_ECHOPGM(" axis driver current: ");
// 11085     SERIAL_ECHOLN(st.getCurrent());
// 11086   }
// 11087   template<typename TMC>
// 11088   static void tmc_set_current(TMC &st, const char name[], const int mA) {
// 11089     st.setCurrent(mA, R_SENSE, HOLD_MULTIPLIER);
// 11090     tmc_get_current(st, name);
// 11091   }
// 11092 
// 11093   template<typename TMC>
// 11094   static void tmc_report_otpw(TMC &st, const char name[]) {
// 11095     SERIAL_ECHO(name);
// 11096     SERIAL_ECHOPGM(" axis temperature prewarn triggered: ");
// 11097     serialprintPGM(st.getOTPW() ? PSTR("true") : PSTR("false"));
// 11098     SERIAL_EOL();
// 11099   }
// 11100   template<typename TMC>
// 11101   static void tmc_clear_otpw(TMC &st, const char name[]) {
// 11102     st.clear_otpw();
// 11103     SERIAL_ECHO(name);
// 11104     SERIAL_ECHOLNPGM(" prewarn flag cleared");
// 11105   }
// 11106 
// 11107   template<typename TMC>
// 11108   static void tmc_get_pwmthrs(TMC &st, const char name[], const uint16_t spmm) {
// 11109     SERIAL_ECHO(name);
// 11110     SERIAL_ECHOPGM(" stealthChop max speed set to ");
// 11111     SERIAL_ECHOLN(12650000UL * st.microsteps() / (256 * st.TPWMTHRS() * spmm));
// 11112   }
// 11113   template<typename TMC>
// 11114   static void tmc_set_pwmthrs(TMC &st, const char name[], const int32_t thrs, const uint32_t spmm) {
// 11115     st.TPWMTHRS(12650000UL * st.microsteps() / (256 * thrs * spmm));
// 11116     tmc_get_pwmthrs(st, name, spmm);
// 11117   }
// 11118 
// 11119   template<typename TMC>
// 11120   static void tmc_get_sgt(TMC &st, const char name[]) {
// 11121     SERIAL_ECHO(name);
// 11122     SERIAL_ECHOPGM(" driver homing sensitivity set to ");
// 11123     MYSERIAL.println(st.sgt(), DEC);
// 11124   }
// 11125   template<typename TMC>
// 11126   static void tmc_set_sgt(TMC &st, const char name[], const int8_t sgt_val) {
// 11127     st.sgt(sgt_val);
// 11128     tmc_get_sgt(st, name);
// 11129   }
// 11130 
// 11131   /**
// 11132    * M906: Set motor current in milliamps using axis codes X, Y, Z, E
// 11133    * Report driver currents when no axis specified
// 11134    */
// 11135   inline void gcode_M906() {
// 11136     uint16_t values[XYZE];
// 11137     LOOP_XYZE(i)
// 11138       values[i] = parser.intval(axis_codes[i]);
// 11139 
// 11140     #if X_IS_TRINAMIC
// 11141       if (values[X_AXIS]) tmc_set_current(stepperX, extended_axis_codes[TMC_X], values[X_AXIS]);
// 11142       else tmc_get_current(stepperX, extended_axis_codes[TMC_X]);
// 11143     #endif
// 11144     #if X2_IS_TRINAMIC
// 11145       if (values[X_AXIS]) tmc_set_current(stepperX2, extended_axis_codes[TMC_X2], values[X_AXIS]);
// 11146       else tmc_get_current(stepperX2, extended_axis_codes[TMC_X2]);
// 11147     #endif
// 11148     #if Y_IS_TRINAMIC
// 11149       if (values[Y_AXIS]) tmc_set_current(stepperY, extended_axis_codes[TMC_Y], values[Y_AXIS]);
// 11150       else tmc_get_current(stepperY, extended_axis_codes[TMC_Y]);
// 11151     #endif
// 11152     #if Y2_IS_TRINAMIC
// 11153       if (values[Y_AXIS]) tmc_set_current(stepperY2, extended_axis_codes[TMC_Y2], values[Y_AXIS]);
// 11154       else tmc_get_current(stepperY2, extended_axis_codes[TMC_Y2]);
// 11155     #endif
// 11156     #if Z_IS_TRINAMIC
// 11157       if (values[Z_AXIS]) tmc_set_current(stepperZ, extended_axis_codes[TMC_Z], values[Z_AXIS]);
// 11158       else tmc_get_current(stepperZ, extended_axis_codes[TMC_Z]);
// 11159     #endif
// 11160     #if Z2_IS_TRINAMIC
// 11161       if (values[Z_AXIS]) tmc_set_current(stepperZ2, extended_axis_codes[TMC_Z2], values[Z_AXIS]);
// 11162       else tmc_get_current(stepperZ2, extended_axis_codes[TMC_Z2]);
// 11163     #endif
// 11164     #if E0_IS_TRINAMIC
// 11165       if (values[E_AXIS]) tmc_set_current(stepperE0, extended_axis_codes[TMC_E0], values[E_AXIS]);
// 11166       else tmc_get_current(stepperE0, extended_axis_codes[TMC_E0]);
// 11167     #endif
// 11168     #if E1_IS_TRINAMIC
// 11169       if (values[E_AXIS]) tmc_set_current(stepperE1, extended_axis_codes[TMC_E1], values[E_AXIS]);
// 11170       else tmc_get_current(stepperE1, extended_axis_codes[TMC_E1]);
// 11171     #endif
// 11172     #if E2_IS_TRINAMIC
// 11173       if (values[E_AXIS]) tmc_set_current(stepperE2, extended_axis_codes[TMC_E2], values[E_AXIS]);
// 11174       else tmc_get_current(stepperE2, extended_axis_codes[TMC_E2]);
// 11175     #endif
// 11176     #if E3_IS_TRINAMIC
// 11177       if (values[E_AXIS]) tmc_set_current(stepperE3, extended_axis_codes[TMC_E3], values[E_AXIS]);
// 11178       else tmc_get_current(stepperE3, extended_axis_codes[TMC_E3]);
// 11179     #endif
// 11180     #if E4_IS_TRINAMIC
// 11181       if (values[E_AXIS]) tmc_set_current(stepperE4, extended_axis_codes[TMC_E4], values[E_AXIS]);
// 11182       else tmc_get_current(stepperE4, extended_axis_codes[TMC_E4]);
// 11183     #endif
// 11184 
// 11185   }
// 11186 
// 11187   /**
// 11188    * M911: Report TMC stepper driver overtemperature pre-warn flag
// 11189    * The flag is held by the library and persist until manually cleared by M912
// 11190    */
// 11191   inline void gcode_M911() {
// 11192     #if ENABLED(X_IS_TMC2130) || (ENABLED(X_IS_TMC2208) && PIN_EXISTS(X_SERIAL_RX)) || ENABLED(IS_TRAMS)
// 11193       tmc_report_otpw(stepperX, extended_axis_codes[TMC_X]);
// 11194     #endif
// 11195     #if ENABLED(Y_IS_TMC2130) || (ENABLED(Y_IS_TMC2208) && PIN_EXISTS(Y_SERIAL_RX)) || ENABLED(IS_TRAMS)
// 11196       tmc_report_otpw(stepperY, extended_axis_codes[TMC_Y]);
// 11197     #endif
// 11198     #if ENABLED(Z_IS_TMC2130) || (ENABLED(Z_IS_TMC2208) && PIN_EXISTS(Z_SERIAL_RX)) || ENABLED(IS_TRAMS)
// 11199       tmc_report_otpw(stepperZ, extended_axis_codes[TMC_Z]);
// 11200     #endif
// 11201     #if ENABLED(E0_IS_TMC2130) || (ENABLED(E0_IS_TMC2208) && PIN_EXISTS(E0_SERIAL_RX)) || ENABLED(IS_TRAMS)
// 11202       tmc_report_otpw(stepperE0, extended_axis_codes[TMC_E0]);
// 11203     #endif
// 11204   }
// 11205 
// 11206   /**
// 11207    * M912: Clear TMC stepper driver overtemperature pre-warn flag held by the library
// 11208    */
// 11209   inline void gcode_M912() {
// 11210     const bool clearX = parser.seen(axis_codes[X_AXIS]), clearY = parser.seen(axis_codes[Y_AXIS]), clearZ = parser.seen(axis_codes[Z_AXIS]), clearE = parser.seen(axis_codes[E_AXIS]),
// 11211              clearAll = (!clearX && !clearY && !clearZ && !clearE) || (clearX && clearY && clearZ && clearE);
// 11212     #if ENABLED(X_IS_TMC2130) || ENABLED(IS_TRAMS) || (ENABLED(X_IS_TMC2208) && PIN_EXISTS(X_SERIAL_RX))
// 11213       if (clearX || clearAll) tmc_clear_otpw(stepperX, extended_axis_codes[TMC_X]);
// 11214     #endif
// 11215     #if ENABLED(X2_IS_TMC2130) || (ENABLED(X2_IS_TMC2208) && PIN_EXISTS(X_SERIAL_RX))
// 11216       if (clearX || clearAll) tmc_clear_otpw(stepperX, extended_axis_codes[TMC_X]);
// 11217     #endif
// 11218 
// 11219     #if ENABLED(Y_IS_TMC2130) || (ENABLED(Y_IS_TMC2208) && PIN_EXISTS(Y_SERIAL_RX))
// 11220       if (clearY || clearAll) tmc_clear_otpw(stepperY, extended_axis_codes[TMC_Y]);
// 11221     #endif
// 11222 
// 11223     #if ENABLED(Z_IS_TMC2130) || (ENABLED(Z_IS_TMC2208) && PIN_EXISTS(Z_SERIAL_RX))
// 11224       if (clearZ || clearAll) tmc_clear_otpw(stepperZ, extended_axis_codes[TMC_Z]);
// 11225     #endif
// 11226 
// 11227     #if ENABLED(E0_IS_TMC2130) || (ENABLED(E0_IS_TMC2208) && PIN_EXISTS(E0_SERIAL_RX))
// 11228       if (clearE || clearAll) tmc_clear_otpw(stepperE0, extended_axis_codes[TMC_E0]);
// 11229     #endif
// 11230   }
// 11231 
// 11232   /**
// 11233    * M913: Set HYBRID_THRESHOLD speed.
// 11234    */
// 11235   #if ENABLED(HYBRID_THRESHOLD)
// 11236     inline void gcode_M913() {
// 11237       uint16_t values[XYZE];
// 11238       LOOP_XYZE(i)
// 11239         values[i] = parser.intval(axis_codes[i]);
// 11240 
// 11241       #if X_IS_TRINAMIC
// 11242         if (values[X_AXIS]) tmc_set_pwmthrs(stepperX, extended_axis_codes[TMC_X], values[X_AXIS], planner.axis_steps_per_mm[X_AXIS]);
// 11243         else tmc_get_pwmthrs(stepperX, extended_axis_codes[TMC_X], planner.axis_steps_per_mm[X_AXIS]);
// 11244       #endif
// 11245       #if X2_IS_TRINAMIC
// 11246         if (values[X_AXIS]) tmc_set_pwmthrs(stepperX2, extended_axis_codes[TMC_X2], values[X_AXIS], planner.axis_steps_per_mm[X_AXIS]);
// 11247         else tmc_get_pwmthrs(stepperX, extended_axis_codes[TMC_X2], planner.axis_steps_per_mm[X_AXIS]);
// 11248       #endif
// 11249 
// 11250       #if Y_IS_TRINAMIC
// 11251         if (values[Y_AXIS]) tmc_set_pwmthrs(stepperY, extended_axis_codes[TMC_Y], values[Y_AXIS], planner.axis_steps_per_mm[Y_AXIS]);
// 11252         else tmc_get_pwmthrs(stepperY, extended_axis_codes[TMC_Y], planner.axis_steps_per_mm[Y_AXIS]);
// 11253       #endif
// 11254       #if Y2_IS_TRINAMIC
// 11255         if (values[Y_AXIS]) tmc_set_pwmthrs(stepperY2, extended_axis_codes[TMC_Y2], values[Y_AXIS], planner.axis_steps_per_mm[Y_AXIS]);
// 11256         else tmc_get_pwmthrs(stepperY, extended_axis_codes[TMC_Y2], planner.axis_steps_per_mm[Y_AXIS]);
// 11257       #endif
// 11258 
// 11259       #if Z_IS_TRINAMIC
// 11260         if (values[Z_AXIS]) tmc_set_pwmthrs(stepperZ, extended_axis_codes[TMC_Z], values[Z_AXIS], planner.axis_steps_per_mm[Z_AXIS]);
// 11261         else tmc_get_pwmthrs(stepperZ, extended_axis_codes[TMC_Z], planner.axis_steps_per_mm[Z_AXIS]);
// 11262       #endif
// 11263       #if Z2_IS_TRINAMIC
// 11264         if (values[Z_AXIS]) tmc_set_pwmthrs(stepperZ2, extended_axis_codes[TMC_Z2], values[Z_AXIS], planner.axis_steps_per_mm[Z_AXIS]);
// 11265         else tmc_get_pwmthrs(stepperZ, extended_axis_codes[TMC_Z2], planner.axis_steps_per_mm[Z_AXIS]);
// 11266       #endif
// 11267 
// 11268       #if E0_IS_TRINAMIC
// 11269         if (values[E_AXIS]) tmc_set_pwmthrs(stepperE0, extended_axis_codes[TMC_E0], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
// 11270         else tmc_get_pwmthrs(stepperE0, extended_axis_codes[TMC_E0], planner.axis_steps_per_mm[E_AXIS]);
// 11271       #endif
// 11272       #if E1_IS_TRINAMIC
// 11273         if (values[E_AXIS]) tmc_set_pwmthrs(stepperE1, extended_axis_codes[TMC_E1], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
// 11274         else tmc_get_pwmthrs(stepperE1, extended_axis_codes[TMC_E1], planner.axis_steps_per_mm[E_AXIS]);
// 11275       #endif
// 11276       #if E2_IS_TRINAMIC
// 11277         if (values[E_AXIS]) tmc_set_pwmthrs(stepperE2, extended_axis_codes[TMC_E2], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
// 11278         else tmc_get_pwmthrs(stepperE2, extended_axis_codes[TMC_E2], planner.axis_steps_per_mm[E_AXIS]);
// 11279       #endif
// 11280       #if E3_IS_TRINAMIC
// 11281         if (values[E_AXIS]) tmc_set_pwmthrs(stepperE3, extended_axis_codes[TMC_E3], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
// 11282         else tmc_get_pwmthrs(stepperE3, extended_axis_codes[TMC_E3], planner.axis_steps_per_mm[E_AXIS]);
// 11283       #endif
// 11284       #if E4_IS_TRINAMIC
// 11285         if (values[E_AXIS]) tmc_set_pwmthrs(stepperE4, extended_axis_codes[TMC_E4], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
// 11286         else tmc_get_pwmthrs(stepperE4, extended_axis_codes[TMC_E4], planner.axis_steps_per_mm[E_AXIS]);
// 11287       #endif
// 11288     }
// 11289   #endif // HYBRID_THRESHOLD
// 11290 
// 11291   /**
// 11292    * M914: Set SENSORLESS_HOMING sensitivity.
// 11293    */
// 11294   #if ENABLED(SENSORLESS_HOMING)
// 11295     inline void gcode_M914() {
// 11296       #if ENABLED(X_IS_TMC2130) || ENABLED(IS_TRAMS)
// 11297         if (parser.seen(axis_codes[X_AXIS])) tmc_set_sgt(stepperX, extended_axis_codes[TMC_X], parser.value_int());
// 11298         else tmc_get_sgt(stepperX, extended_axis_codes[TMC_X]);
// 11299       #endif
// 11300       #if ENABLED(X2_IS_TMC2130)
// 11301         if (parser.seen(axis_codes[X_AXIS])) tmc_set_sgt(stepperX2, extended_axis_codes[TMC_X2], parser.value_int());
// 11302         else tmc_get_sgt(stepperX2, extended_axis_codes[TMC_X2]);
// 11303       #endif
// 11304       #if ENABLED(Y_IS_TMC2130) || ENABLED(IS_TRAMS)
// 11305         if (parser.seen(axis_codes[Y_AXIS])) tmc_set_sgt(stepperY, extended_axis_codes[TMC_Y], parser.value_int());
// 11306         else tmc_get_sgt(stepperY, extended_axis_codes[TMC_Y]);
// 11307       #endif
// 11308       #if ENABLED(Y2_IS_TMC2130)
// 11309         if (parser.seen(axis_codes[Y_AXIS])) tmc_set_sgt(stepperY2, extended_axis_codes[TMC_Y2], parser.value_int());
// 11310         else tmc_get_sgt(stepperY2, extended_axis_codes[TMC_Y2]);
// 11311       #endif
// 11312     }
// 11313   #endif // SENSORLESS_HOMING
// 11314 
// 11315   /**
// 11316    * TMC Z axis calibration routine
// 11317    */
// 11318   #if ENABLED(TMC_Z_CALIBRATION) && (Z_IS_TRINAMIC || Z2_IS_TRINAMIC)
// 11319     inline void gcode_M915() {
// 11320       uint16_t _rms = parser.seenval('S') ? parser.value_int() : CALIBRATION_CURRENT;
// 11321       uint16_t _z = parser.seenval('Z') ? parser.value_int() : CALIBRATION_EXTRA_HEIGHT;
// 11322 
// 11323       if (!axis_known_position[Z_AXIS]) {
// 11324         SERIAL_ECHOLNPGM("\nPlease home Z axis first");
// 11325         return;
// 11326       }
// 11327 
// 11328       uint16_t Z_current_1 = stepperZ.getCurrent();
// 11329       uint16_t Z2_current_1 = stepperZ.getCurrent();
// 11330 
// 11331       stepperZ.setCurrent(_rms, R_SENSE, HOLD_MULTIPLIER);
// 11332       stepperZ2.setCurrent(_rms, R_SENSE, HOLD_MULTIPLIER);
// 11333       SERIAL_ECHOPAIR("\nCalibration current: Z", _rms);
// 11334 
// 11335       soft_endstops_enabled = false;
// 11336 
// 11337       do_blocking_move_to_z(Z_MAX_POS+_z);
// 11338 
// 11339       stepperZ.setCurrent(Z_current_1, R_SENSE, HOLD_MULTIPLIER);
// 11340       stepperZ2.setCurrent(Z2_current_1, R_SENSE, HOLD_MULTIPLIER);
// 11341 
// 11342       do_blocking_move_to_z(Z_MAX_POS);
// 11343       soft_endstops_enabled = true;
// 11344 
// 11345       SERIAL_ECHOLNPGM("\nHoming Z because we lost steps");
// 11346       home_z_safely();
// 11347     }
// 11348   #endif
// 11349 
// 11350 #endif // HAS_TRINAMIC
// 11351 
// 11352 /**
// 11353  * M907: Set digital trimpot motor current using axis codes X, Y, Z, E, B, S
// 11354  */
// 11355 inline void gcode_M907() {
// 11356   #if HAS_DIGIPOTSS
// 11357 
// 11358     LOOP_XYZE(i) if (parser.seen(axis_codes[i])) stepper.digipot_current(i, parser.value_int());
// 11359     if (parser.seen('B')) stepper.digipot_current(4, parser.value_int());
// 11360     if (parser.seen('S')) for (uint8_t i = 0; i <= 4; i++) stepper.digipot_current(i, parser.value_int());
// 11361 
// 11362   #elif HAS_MOTOR_CURRENT_PWM
// 11363 
// 11364     #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
// 11365       if (parser.seen('X')) stepper.digipot_current(0, parser.value_int());
// 11366     #endif
// 11367     #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
// 11368       if (parser.seen('Z')) stepper.digipot_current(1, parser.value_int());
// 11369     #endif
// 11370     #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
// 11371       if (parser.seen('E')) stepper.digipot_current(2, parser.value_int());
// 11372     #endif
// 11373 
// 11374   #endif
// 11375 
// 11376   #if ENABLED(DIGIPOT_I2C)
// 11377     // this one uses actual amps in floating point
// 11378     LOOP_XYZE(i) if (parser.seen(axis_codes[i])) digipot_i2c_set_current(i, parser.value_float());
// 11379     // for each additional extruder (named B,C,D,E..., channels 4,5,6,7...)
// 11380     for (uint8_t i = NUM_AXIS; i < DIGIPOT_I2C_NUM_CHANNELS; i++) if (parser.seen('B' + i - (NUM_AXIS))) digipot_i2c_set_current(i, parser.value_float());
// 11381   #endif
// 11382 
// 11383   #if ENABLED(DAC_STEPPER_CURRENT)
// 11384     if (parser.seen('S')) {
// 11385       const float dac_percent = parser.value_float();
// 11386       for (uint8_t i = 0; i <= 4; i++) dac_current_percent(i, dac_percent);
// 11387     }
// 11388     LOOP_XYZE(i) if (parser.seen(axis_codes[i])) dac_current_percent(i, parser.value_float());
// 11389   #endif
// 11390 }
// 11391 
// 11392 #if HAS_DIGIPOTSS || ENABLED(DAC_STEPPER_CURRENT)
// 11393 
// 11394   /**
// 11395    * M908: Control digital trimpot directly (M908 P<pin> S<current>)
// 11396    */
// 11397   inline void gcode_M908() {
// 11398     #if HAS_DIGIPOTSS
// 11399       stepper.digitalPotWrite(
// 11400         parser.intval('P'),
// 11401         parser.intval('S')
// 11402       );
// 11403     #endif
// 11404     #ifdef DAC_STEPPER_CURRENT
// 11405       dac_current_raw(
// 11406         parser.byteval('P', -1),
// 11407         parser.ushortval('S', 0)
// 11408       );
// 11409     #endif
// 11410   }
// 11411 
// 11412   #if ENABLED(DAC_STEPPER_CURRENT) // As with Printrbot RevF
// 11413 
// 11414     inline void gcode_M909() { dac_print_values(); }
// 11415 
// 11416     inline void gcode_M910() { dac_commit_eeprom(); }
// 11417 
// 11418   #endif
// 11419 
// 11420 #endif // HAS_DIGIPOTSS || DAC_STEPPER_CURRENT
// 11421 
// 11422 #if HAS_MICROSTEPS
// 11423 
// 11424   // M350 Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.
// 11425   inline void gcode_M350() {
// 11426     if (parser.seen('S')) for (int i = 0; i <= 4; i++) stepper.microstep_mode(i, parser.value_byte());
// 11427     LOOP_XYZE(i) if (parser.seen(axis_codes[i])) stepper.microstep_mode(i, parser.value_byte());
// 11428     if (parser.seen('B')) stepper.microstep_mode(4, parser.value_byte());
// 11429     stepper.microstep_readings();
// 11430   }
// 11431 
// 11432   /**
// 11433    * M351: Toggle MS1 MS2 pins directly with axis codes X Y Z E B
// 11434    *       S# determines MS1 or MS2, X# sets the pin high/low.
// 11435    */
// 11436   inline void gcode_M351() {
// 11437     if (parser.seenval('S')) switch (parser.value_byte()) {
// 11438       case 1:
// 11439         LOOP_XYZE(i) if (parser.seenval(axis_codes[i])) stepper.microstep_ms(i, parser.value_byte(), -1);
// 11440         if (parser.seenval('B')) stepper.microstep_ms(4, parser.value_byte(), -1);
// 11441         break;
// 11442       case 2:
// 11443         LOOP_XYZE(i) if (parser.seenval(axis_codes[i])) stepper.microstep_ms(i, -1, parser.value_byte());
// 11444         if (parser.seenval('B')) stepper.microstep_ms(4, -1, parser.value_byte());
// 11445         break;
// 11446     }
// 11447     stepper.microstep_readings();
// 11448   }
// 11449 
// 11450 #endif // HAS_MICROSTEPS
// 11451 
// 11452 #if HAS_CASE_LIGHT
// 11453   #ifndef INVERT_CASE_LIGHT
// 11454     #define INVERT_CASE_LIGHT false
// 11455   #endif
// 11456   uint8_t case_light_brightness;  // LCD routine wants INT
// 11457   bool case_light_on;
// 11458 
// 11459   void update_case_light() {
// 11460     pinMode(CASE_LIGHT_PIN, OUTPUT); // digitalWrite doesn't set the port mode
// 11461     if (case_light_on) {
// 11462       if (USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN))
// 11463         analogWrite(CASE_LIGHT_PIN, INVERT_CASE_LIGHT ? 255 - case_light_brightness : case_light_brightness);
// 11464       else
// 11465         WRITE(CASE_LIGHT_PIN, INVERT_CASE_LIGHT ? LOW : HIGH);
// 11466     }
// 11467     else {
// 11468       if (USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN))
// 11469         analogWrite(CASE_LIGHT_PIN, INVERT_CASE_LIGHT ? 255 : 0);
// 11470       else
// 11471         WRITE(CASE_LIGHT_PIN, INVERT_CASE_LIGHT ? HIGH : LOW);
// 11472     }
// 11473   }
// 11474 #endif // HAS_CASE_LIGHT
// 11475 
// 11476 /**
// 11477  * M355: Turn case light on/off and set brightness
// 11478  *
// 11479  *   P<byte>  Set case light brightness (PWM pin required - ignored otherwise)
// 11480  *
// 11481  *   S<bool>  Set case light on/off
// 11482  *
// 11483  *   When S turns on the light on a PWM pin then the current brightness level is used/restored
// 11484  *
// 11485  *   M355 P200 S0 turns off the light & sets the brightness level
// 11486  *   M355 S1 turns on the light with a brightness of 200 (assuming a PWM pin)
// 11487  */
// 11488 inline void gcode_M355() {
// 11489   #if HAS_CASE_LIGHT
// 11490     uint8_t args = 0;
// 11491     if (parser.seenval('P')) ++args, case_light_brightness = parser.value_byte();
// 11492     if (parser.seenval('S')) ++args, case_light_on = parser.value_bool();
// 11493     if (args) update_case_light();
// 11494 
// 11495     // always report case light status
// 11496     SERIAL_ECHO_START();
// 11497     if (!case_light_on) {
// 11498       SERIAL_ECHOLN("Case light: off");
// 11499     }
// 11500     else {
// 11501       if (!USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN)) SERIAL_ECHOLN("Case light: on");
// 11502       else SERIAL_ECHOLNPAIR("Case light: ", (int)case_light_brightness);
// 11503     }
// 11504 
// 11505   #else
// 11506     SERIAL_ERROR_START();
// 11507     SERIAL_ERRORLNPGM(MSG_ERR_M355_NONE);
// 11508   #endif // HAS_CASE_LIGHT
// 11509 }
// 11510 
// 11511 #if ENABLED(MIXING_EXTRUDER)
// 11512 
// 11513   /**
// 11514    * M163: Set a single mix factor for a mixing extruder
// 11515    *       This is called "weight" by some systems.
// 11516    *
// 11517    *   S[index]   The channel index to set
// 11518    *   P[float]   The mix value
// 11519    *
// 11520    */
// 11521   inline void gcode_M163() {
// 11522     const int mix_index = parser.intval('S');
// 11523     if (mix_index < MIXING_STEPPERS) {
// 11524       float mix_value = parser.floatval('P');
// 11525       NOLESS(mix_value, 0.0);
// 11526       mixing_factor[mix_index] = RECIPROCAL(mix_value);
// 11527     }
// 11528   }
// 11529 
// 11530   #if MIXING_VIRTUAL_TOOLS > 1
// 11531 
// 11532     /**
// 11533      * M164: Store the current mix factors as a virtual tool.
// 11534      *
// 11535      *   S[index]   The virtual tool to store
// 11536      *
// 11537      */
// 11538     inline void gcode_M164() {
// 11539       const int tool_index = parser.intval('S');
// 11540       if (tool_index < MIXING_VIRTUAL_TOOLS) {
// 11541         normalize_mix();
// 11542         for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
// 11543           mixing_virtual_tool_mix[tool_index][i] = mixing_factor[i];
// 11544       }
// 11545     }
// 11546 
// 11547   #endif
// 11548 
// 11549   #if ENABLED(DIRECT_MIXING_IN_G1)
// 11550     /**
// 11551      * M165: Set multiple mix factors for a mixing extruder.
// 11552      *       Factors that are left out will be set to 0.
// 11553      *       All factors together must add up to 1.0.
// 11554      *
// 11555      *   A[factor] Mix factor for extruder stepper 1
// 11556      *   B[factor] Mix factor for extruder stepper 2
// 11557      *   C[factor] Mix factor for extruder stepper 3
// 11558      *   D[factor] Mix factor for extruder stepper 4
// 11559      *   H[factor] Mix factor for extruder stepper 5
// 11560      *   I[factor] Mix factor for extruder stepper 6
// 11561      *
// 11562      */
// 11563     inline void gcode_M165() { gcode_get_mix(); }
// 11564   #endif
// 11565 
// 11566 #endif // MIXING_EXTRUDER
// 11567 
// 11568 /**
// 11569  * M999: Restart after being stopped
// 11570  *
// 11571  * Default behaviour is to flush the serial buffer and request
// 11572  * a resend to the host starting on the last N line received.
// 11573  *
// 11574  * Sending "M999 S1" will resume printing without flushing the
// 11575  * existing command buffer.
// 11576  *
// 11577  */
// 11578 inline void gcode_M999() {
// 11579   Running = true;
// 11580   lcd_reset_alert_level();
// 11581 
// 11582   if (parser.boolval('S')) return;
// 11583 
// 11584   // gcode_LastN = Stopped_gcode_LastN;
// 11585   FlushSerialRequestResend();
// 11586 }
// 11587 
// 11588 #if ENABLED(SWITCHING_EXTRUDER)
// 11589   #if EXTRUDERS > 3
// 11590     #define REQ_ANGLES 4
// 11591     #define _SERVO_NR (e < 2 ? SWITCHING_EXTRUDER_SERVO_NR : SWITCHING_EXTRUDER_E23_SERVO_NR)
// 11592   #else
// 11593     #define REQ_ANGLES 2
// 11594     #define _SERVO_NR SWITCHING_EXTRUDER_SERVO_NR
// 11595   #endif
// 11596   inline void move_extruder_servo(const uint8_t e) {
// 11597     constexpr int16_t angles[] = SWITCHING_EXTRUDER_SERVO_ANGLES;
// 11598     static_assert(COUNT(angles) == REQ_ANGLES, "SWITCHING_EXTRUDER_SERVO_ANGLES needs " STRINGIFY(REQ_ANGLES) " angles.");
// 11599     stepper.synchronize();
// 11600     #if EXTRUDERS & 1
// 11601       if (e < EXTRUDERS - 1)
// 11602     #endif
// 11603     {
// 11604       MOVE_SERVO(_SERVO_NR, angles[e]);
// 11605       safe_delay(500);
// 11606     }
// 11607   }
// 11608 #endif // SWITCHING_EXTRUDER
// 11609 
// 11610 #if ENABLED(SWITCHING_NOZZLE)
// 11611   inline void move_nozzle_servo(const uint8_t e) {
// 11612     const int16_t angles[2] = SWITCHING_NOZZLE_SERVO_ANGLES;
// 11613     stepper.synchronize();
// 11614     MOVE_SERVO(SWITCHING_NOZZLE_SERVO_NR, angles[e]);
// 11615     safe_delay(500);
// 11616   }
// 11617 #endif
// 11618 
// 11619 inline void invalid_extruder_error(const uint8_t e) {
// 11620   SERIAL_ECHO_START();
// 11621   SERIAL_CHAR('T');
// 11622   SERIAL_ECHO_F(e, DEC);
// 11623   SERIAL_CHAR(' ');
// 11624   SERIAL_ECHOLN(MSG_INVALID_EXTRUDER);
// 11625 }
// 11626 
// 11627 #if ENABLED(PARKING_EXTRUDER)
// 11628 
// 11629   #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
// 11630     #define PE_MAGNET_ON_STATE !PARKING_EXTRUDER_SOLENOIDS_PINS_ACTIVE
// 11631   #else
// 11632     #define PE_MAGNET_ON_STATE PARKING_EXTRUDER_SOLENOIDS_PINS_ACTIVE
// 11633   #endif
// 11634 
// 11635   void pe_set_magnet(const uint8_t extruder_num, const uint8_t state) {
// 11636     switch (extruder_num) {
// 11637       case 1: OUT_WRITE(SOL1_PIN, state); break;
// 11638       default: OUT_WRITE(SOL0_PIN, state); break;
// 11639     }
// 11640     #if PARKING_EXTRUDER_SOLENOIDS_DELAY > 0
// 11641       dwell(PARKING_EXTRUDER_SOLENOIDS_DELAY);
// 11642     #endif
// 11643   }
// 11644 
// 11645   inline void pe_activate_magnet(const uint8_t extruder_num) { pe_set_magnet(extruder_num, PE_MAGNET_ON_STATE); }
// 11646   inline void pe_deactivate_magnet(const uint8_t extruder_num) { pe_set_magnet(extruder_num, !PE_MAGNET_ON_STATE); }
// 11647 
// 11648 #endif // PARKING_EXTRUDER
// 11649 
// 11650 #if HAS_FANMUX
// 11651 
// 11652   void fanmux_switch(const uint8_t e) {
// 11653     WRITE(FANMUX0_PIN, TEST(e, 0) ? HIGH : LOW);
// 11654     #if PIN_EXISTS(FANMUX1)
// 11655       WRITE(FANMUX1_PIN, TEST(e, 1) ? HIGH : LOW);
// 11656       #if PIN_EXISTS(FANMUX2)
// 11657         WRITE(FANMUX2, TEST(e, 2) ? HIGH : LOW);
// 11658       #endif
// 11659     #endif
// 11660   }
// 11661 
// 11662   FORCE_INLINE void fanmux_init(void) {
// 11663     SET_OUTPUT(FANMUX0_PIN);
// 11664     #if PIN_EXISTS(FANMUX1)
// 11665       SET_OUTPUT(FANMUX1_PIN);
// 11666       #if PIN_EXISTS(FANMUX2)
// 11667         SET_OUTPUT(FANMUX2_PIN);
// 11668       #endif
// 11669     #endif
// 11670     fanmux_switch(0);
// 11671   }
// 11672 
// 11673 #endif // HAS_FANMUX
// 11674 
// 11675 /**
// 11676  * Perform a tool-change, which may result in moving the
// 11677  * previous tool out of the way and the new tool into place.
// 11678  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock44 Using cfiCommon0
          CFI Function _Z11tool_changehfb
        THUMB
// 11679 void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
_Z11tool_changehfb:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 11680   #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
// 11681 
// 11682     if (tmp_extruder >= MIXING_VIRTUAL_TOOLS)
// 11683       return invalid_extruder_error(tmp_extruder);
// 11684 
// 11685     // T0-Tnnn: Switch virtual tool by changing the mix
// 11686     for (uint8_t j = 0; j < MIXING_STEPPERS; j++)
// 11687       mixing_factor[j] = mixing_virtual_tool_mix[tmp_extruder][j];
// 11688 
// 11689   #else // !MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
// 11690 
// 11691     if (tmp_extruder >= EXTRUDERS)
        CMP      R0,#+0
        BEQ.N    ??tool_change_0
// 11692       return invalid_extruder_error(tmp_extruder);
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z22invalid_extruder_errorh
        B.W      _Z22invalid_extruder_errorh
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 11693 
// 11694     #if HOTENDS > 1
// 11695 
// 11696       const float old_feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : feedrate_mm_s;
// 11697 
// 11698       feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
// 11699 
// 11700       if (tmp_extruder != active_extruder) {
// 11701         if (!no_move && axis_unhomed_error()) {
// 11702           no_move = true;
// 11703           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11704             if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("No move on toolchange");
// 11705           #endif
// 11706         }
// 11707 
// 11708         // Save current position to destination, for use later
// 11709         set_destination_from_current();
// 11710 
// 11711         #if ENABLED(DUAL_X_CARRIAGE)
// 11712 
// 11713           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11714             if (DEBUGGING(LEVELING)) {
// 11715               SERIAL_ECHOPGM("Dual X Carriage Mode ");
// 11716               switch (dual_x_carriage_mode) {
// 11717                 case DXC_FULL_CONTROL_MODE: SERIAL_ECHOLNPGM("DXC_FULL_CONTROL_MODE"); break;
// 11718                 case DXC_AUTO_PARK_MODE: SERIAL_ECHOLNPGM("DXC_AUTO_PARK_MODE"); break;
// 11719                 case DXC_DUPLICATION_MODE: SERIAL_ECHOLNPGM("DXC_DUPLICATION_MODE"); break;
// 11720               }
// 11721             }
// 11722           #endif
// 11723 
// 11724           const float xhome = x_home_pos(active_extruder);
// 11725           if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE
// 11726               && IsRunning()
// 11727               && (delayed_move_time || current_position[X_AXIS] != xhome)
// 11728           ) {
// 11729             float raised_z = current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT;
// 11730             //#if ENABLED(MAX_SOFTWARE_ENDSTOPS)
// 11731             if(mksCfg.max_software_endstops){
// 11732               NOMORE(raised_z, soft_endstop_max[Z_AXIS]);
// 11733             }
// 11734             //#endif
// 11735             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11736               if (DEBUGGING(LEVELING)) {
// 11737                 SERIAL_ECHOLNPAIR("Raise to ", raised_z);
// 11738                 SERIAL_ECHOLNPAIR("MoveX to ", xhome);
// 11739                 SERIAL_ECHOLNPAIR("Lower to ", current_position[Z_AXIS]);
// 11740               }
// 11741             #endif
// 11742             // Park old head: 1) raise 2) move to park position 3) lower
// 11743             for (uint8_t i = 0; i < 3; i++)
// 11744               planner.buffer_line(
// 11745                 i == 0 ? current_position[X_AXIS] : xhome,
// 11746                 current_position[Y_AXIS],
// 11747                 i == 2 ? current_position[Z_AXIS] : raised_z,
// 11748                 current_position[E_AXIS],
// 11749                 planner.max_feedrate_mm_s[i == 1 ? X_AXIS : Z_AXIS],
// 11750                 active_extruder
// 11751               );
// 11752             stepper.synchronize();
// 11753           }
// 11754 
// 11755           // Apply Y & Z extruder offset (X offset is used as home pos with Dual X)
// 11756           current_position[Y_AXIS] -= hotend_offset[Y_AXIS][active_extruder] - hotend_offset[Y_AXIS][tmp_extruder];
// 11757           current_position[Z_AXIS] -= hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
// 11758 
// 11759           // Activate the new extruder ahead of calling set_axis_is_at_home!
// 11760           active_extruder = tmp_extruder;
// 11761 
// 11762           // This function resets the max/min values - the current position may be overwritten below.
// 11763           set_axis_is_at_home(X_AXIS);
// 11764 
// 11765           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11766             if (DEBUGGING(LEVELING)) DEBUG_POS("New Extruder", current_position);
// 11767           #endif
// 11768 
// 11769           // Only when auto-parking are carriages safe to move
// 11770           if (dual_x_carriage_mode != DXC_AUTO_PARK_MODE) no_move = true;
// 11771 
// 11772           switch (dual_x_carriage_mode) {
// 11773             case DXC_FULL_CONTROL_MODE:
// 11774               // New current position is the position of the activated extruder
// 11775               current_position[X_AXIS] = inactive_extruder_x_pos;
// 11776               // Save the inactive extruder's position (from the old current_position)
// 11777               inactive_extruder_x_pos = destination[X_AXIS];
// 11778               break;
// 11779             case DXC_AUTO_PARK_MODE:
// 11780               // record raised toolhead position for use by unpark
// 11781               COPY(raised_parked_position, current_position);
// 11782               raised_parked_position[Z_AXIS] += TOOLCHANGE_UNPARK_ZLIFT;
// 11783               //#if ENABLED(MAX_SOFTWARE_ENDSTOPS)
// 11784               if(mksCfg.max_software_endstops){
// 11785                 NOMORE(raised_parked_position[Z_AXIS], soft_endstop_max[Z_AXIS]);
// 11786               }
// 11787               //#endif
// 11788               active_extruder_parked = true;
// 11789               delayed_move_time = 0;
// 11790               break;
// 11791             case DXC_DUPLICATION_MODE:
// 11792               // If the new extruder is the left one, set it "parked"
// 11793               // This triggers the second extruder to move into the duplication position
// 11794               active_extruder_parked = (active_extruder == 0);
// 11795 
// 11796               if (active_extruder_parked)
// 11797                 current_position[X_AXIS] = inactive_extruder_x_pos;
// 11798               else
// 11799                 current_position[X_AXIS] = destination[X_AXIS] + duplicate_extruder_x_offset;
// 11800               inactive_extruder_x_pos = destination[X_AXIS];
// 11801               extruder_duplication_enabled = false;
// 11802               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11803                 if (DEBUGGING(LEVELING)) {
// 11804                   SERIAL_ECHOLNPAIR("Set inactive_extruder_x_pos=", inactive_extruder_x_pos);
// 11805                   SERIAL_ECHOLNPGM("Clear extruder_duplication_enabled");
// 11806                 }
// 11807               #endif
// 11808               break;
// 11809           }
// 11810 
// 11811           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11812             if (DEBUGGING(LEVELING)) {
// 11813               SERIAL_ECHOLNPAIR("Active extruder parked: ", active_extruder_parked ? "yes" : "no");
// 11814               DEBUG_POS("New extruder (parked)", current_position);
// 11815             }
// 11816           #endif
// 11817 
// 11818           // No extra case for HAS_ABL in DUAL_X_CARRIAGE. Does that mean they don't work together?
// 11819 
// 11820         #else // !DUAL_X_CARRIAGE
// 11821 
// 11822           #if ENABLED(PARKING_EXTRUDER) // Dual Parking extruder
// 11823             const float z_diff = hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
// 11824             float z_raise = PARKING_EXTRUDER_SECURITY_RAISE;
// 11825             if (!no_move) {
// 11826 
// 11827               const float parkingposx[] = PARKING_EXTRUDER_PARKING_X,
// 11828                           midpos = (parkingposx[0] + parkingposx[1]) * 0.5 + hotend_offset[X_AXIS][active_extruder],
// 11829                           grabpos = parkingposx[tmp_extruder] + hotend_offset[X_AXIS][active_extruder]
// 11830                                     + (tmp_extruder == 0 ? -(PARKING_EXTRUDER_GRAB_DISTANCE) : PARKING_EXTRUDER_GRAB_DISTANCE);
// 11831               /**
// 11832                *  Steps:
// 11833                *    1. Raise Z-Axis to give enough clearance
// 11834                *    2. Move to park position of old extruder
// 11835                *    3. Disengage magnetic field, wait for delay
// 11836                *    4. Move near new extruder
// 11837                *    5. Engage magnetic field for new extruder
// 11838                *    6. Move to parking incl. offset of new extruder
// 11839                *    7. Lower Z-Axis
// 11840                */
// 11841 
// 11842               // STEP 1
// 11843               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11844                 SERIAL_ECHOLNPGM("Starting Autopark");
// 11845                 if (DEBUGGING(LEVELING)) DEBUG_POS("current position:", current_position);
// 11846               #endif
// 11847               current_position[Z_AXIS] += z_raise;
// 11848               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11849                 SERIAL_ECHOLNPGM("(1) Raise Z-Axis ");
// 11850                 if (DEBUGGING(LEVELING)) DEBUG_POS("Moving to Raised Z-Position", current_position);
// 11851               #endif
// 11852               planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
// 11853               stepper.synchronize();
// 11854 
// 11855               // STEP 2
// 11856               current_position[X_AXIS] = parkingposx[active_extruder] + hotend_offset[X_AXIS][active_extruder];
// 11857               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11858                 SERIAL_ECHOLNPAIR("(2) Park extruder ", active_extruder);
// 11859                 if (DEBUGGING(LEVELING)) DEBUG_POS("Moving ParkPos", current_position);
// 11860               #endif
// 11861               planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
// 11862               stepper.synchronize();
// 11863 
// 11864               // STEP 3
// 11865               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11866                 SERIAL_ECHOLNPGM("(3) Disengage magnet ");
// 11867               #endif
// 11868               pe_deactivate_magnet(active_extruder);
// 11869 
// 11870               // STEP 4
// 11871               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11872                 SERIAL_ECHOLNPGM("(4) Move to position near new extruder");
// 11873               #endif
// 11874               current_position[X_AXIS] += (active_extruder == 0 ? 10 : -10); // move 10mm away from parked extruder
// 11875 
// 11876               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11877                 if (DEBUGGING(LEVELING)) DEBUG_POS("Moving away from parked extruder", current_position);
// 11878               #endif
// 11879               planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
// 11880               stepper.synchronize();
// 11881 
// 11882               // STEP 5
// 11883               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11884                 SERIAL_ECHOLNPGM("(5) Engage magnetic field");
// 11885               #endif
// 11886 
// 11887               #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
// 11888                 pe_activate_magnet(active_extruder); //just save power for inverted magnets
// 11889               #endif
// 11890               pe_activate_magnet(tmp_extruder);
// 11891 
// 11892               // STEP 6
// 11893               current_position[X_AXIS] = grabpos + (tmp_extruder == 0 ? (+10) : (-10));
// 11894               planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
// 11895               current_position[X_AXIS] = grabpos;
// 11896               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11897                 SERIAL_ECHOLNPAIR("(6) Unpark extruder ", tmp_extruder);
// 11898                 if (DEBUGGING(LEVELING)) DEBUG_POS("Move UnparkPos", current_position);
// 11899               #endif
// 11900               planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS]/2, active_extruder);
// 11901               stepper.synchronize();
// 11902 
// 11903               // Step 7
// 11904               current_position[X_AXIS] = midpos - hotend_offset[X_AXIS][tmp_extruder];
// 11905               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11906                 SERIAL_ECHOLNPGM("(7) Move midway between hotends");
// 11907                 if (DEBUGGING(LEVELING)) DEBUG_POS("Move midway to new extruder", current_position);
// 11908               #endif
// 11909               planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
// 11910               stepper.synchronize();
// 11911               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11912                 SERIAL_ECHOLNPGM("Autopark done.");
// 11913               #endif
// 11914             }
// 11915             else { // nomove == true
// 11916               // Only engage magnetic field for new extruder
// 11917               pe_activate_magnet(tmp_extruder);
// 11918               #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
// 11919                 pe_activate_magnet(active_extruder); // Just save power for inverted magnets
// 11920               #endif
// 11921             }
// 11922             current_position[Z_AXIS] -= hotend_offset[Z_AXIS][tmp_extruder] - hotend_offset[Z_AXIS][active_extruder]; // Apply Zoffset
// 11923 
// 11924             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11925               if (DEBUGGING(LEVELING)) DEBUG_POS("Applying Z-offset", current_position);
// 11926             #endif
// 11927 
// 11928           #endif // dualParking extruder
// 11929 
// 11930           #if ENABLED(SWITCHING_NOZZLE)
// 11931             #define DONT_SWITCH (SWITCHING_EXTRUDER_SERVO_NR == SWITCHING_NOZZLE_SERVO_NR)
// 11932             // <0 if the new nozzle is higher, >0 if lower. A bigger raise when lower.
// 11933             const float z_diff = hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder],
// 11934                         z_raise = 0.3 + (z_diff > 0.0 ? z_diff : 0.0);
// 11935 
// 11936             // Always raise by some amount (destination copied from current_position earlier)
// 11937             current_position[Z_AXIS] += z_raise;
// 11938             planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
// 11939             move_nozzle_servo(tmp_extruder);
// 11940           #endif
// 11941 
// 11942           /**
// 11943            * Set current_position to the position of the new nozzle.
// 11944            * Offsets are based on linear distance, so we need to get
// 11945            * the resulting position in coordinate space.
// 11946            *
// 11947            * - With grid or 3-point leveling, offset XYZ by a tilted vector
// 11948            * - With mesh leveling, update Z for the new position
// 11949            * - Otherwise, just use the raw linear distance
// 11950            *
// 11951            * Software endstops are altered here too. Consider a case where:
// 11952            *   E0 at X=0 ... E1 at X=10
// 11953            * When we switch to E1 now X=10, but E1 can't move left.
// 11954            * To express this we apply the change in XY to the software endstops.
// 11955            * E1 can move farther right than E0, so the right limit is extended.
// 11956            *
// 11957            * Note that we don't adjust the Z software endstops. Why not?
// 11958            * Consider a case where Z=0 (here) and switching to E1 makes Z=1
// 11959            * because the bed is 1mm lower at the new position. As long as
// 11960            * the first nozzle is out of the way, the carriage should be
// 11961            * allowed to move 1mm lower. This technically "breaks" the
// 11962            * Z software endstop. But this is technically correct (and
// 11963            * there is no viable alternative).
// 11964            */
// 11965           #if ABL_PLANAR
// 11966             // Offset extruder, make sure to apply the bed level rotation matrix
// 11967             vector_3 tmp_offset_vec = vector_3(hotend_offset[X_AXIS][tmp_extruder],
// 11968                                                hotend_offset[Y_AXIS][tmp_extruder],
// 11969                                                0),
// 11970                      act_offset_vec = vector_3(hotend_offset[X_AXIS][active_extruder],
// 11971                                                hotend_offset[Y_AXIS][active_extruder],
// 11972                                                0),
// 11973                      offset_vec = tmp_offset_vec - act_offset_vec;
// 11974 
// 11975             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11976               if (DEBUGGING(LEVELING)) {
// 11977                 tmp_offset_vec.debug(PSTR("tmp_offset_vec"));
// 11978                 act_offset_vec.debug(PSTR("act_offset_vec"));
// 11979                 offset_vec.debug(PSTR("offset_vec (BEFORE)"));
// 11980               }
// 11981             #endif
// 11982 
// 11983             offset_vec.apply_rotation(planner.bed_level_matrix.transpose(planner.bed_level_matrix));
// 11984 
// 11985             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11986               if (DEBUGGING(LEVELING)) offset_vec.debug(PSTR("offset_vec (AFTER)"));
// 11987             #endif
// 11988 
// 11989             // Adjustments to the current position
// 11990             const float xydiff[2] = { offset_vec.x, offset_vec.y };
// 11991             current_position[Z_AXIS] += offset_vec.z;
// 11992 
// 11993           #else // !ABL_PLANAR
// 11994 
// 11995             const float xydiff[2] = {
// 11996               hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder],
// 11997               hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder]
// 11998             };
// 11999 
// 12000             #if ENABLED(MESH_BED_LEVELING)
// 12001 
// 12002               if (planner.leveling_active) {
// 12003                 #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12004                   if (DEBUGGING(LEVELING)) SERIAL_ECHOPAIR("Z before MBL: ", current_position[Z_AXIS]);
// 12005                 #endif
// 12006                 float x2 = current_position[X_AXIS] + xydiff[X_AXIS],
// 12007                       y2 = current_position[Y_AXIS] + xydiff[Y_AXIS],
// 12008                       z1 = current_position[Z_AXIS], z2 = z1;
// 12009                 planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], z1);
// 12010                 planner.apply_leveling(x2, y2, z2);
// 12011                 current_position[Z_AXIS] += z2 - z1;
// 12012                 #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12013                   if (DEBUGGING(LEVELING))
// 12014                     SERIAL_ECHOLNPAIR(" after: ", current_position[Z_AXIS]);
// 12015                 #endif
// 12016               }
// 12017 
// 12018             #endif // MESH_BED_LEVELING
// 12019 
// 12020           #endif // !HAS_ABL
// 12021 
// 12022           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12023             if (DEBUGGING(LEVELING)) {
// 12024               SERIAL_ECHOPAIR("Offset Tool XY by { ", xydiff[X_AXIS]);
// 12025               SERIAL_ECHOPAIR(", ", xydiff[Y_AXIS]);
// 12026               SERIAL_ECHOLNPGM(" }");
// 12027             }
// 12028           #endif
// 12029 
// 12030           // The newly-selected extruder XY is actually at...
// 12031           current_position[X_AXIS] += xydiff[X_AXIS];
// 12032           current_position[Y_AXIS] += xydiff[Y_AXIS];
// 12033 
// 12034           // Set the new active extruder
// 12035           active_extruder = tmp_extruder;
// 12036 
// 12037         #endif // !DUAL_X_CARRIAGE
// 12038 
// 12039         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12040           if (DEBUGGING(LEVELING)) DEBUG_POS("Sync After Toolchange", current_position);
// 12041         #endif
// 12042 
// 12043         // Tell the planner the new "current position"
// 12044         SYNC_PLAN_POSITION_KINEMATIC();
// 12045 
// 12046         // Move to the "old position" (move the extruder into place)
// 12047         #if ENABLED(SWITCHING_NOZZLE)
// 12048           destination[Z_AXIS] += z_diff;  // Include the Z restore with the "move back"
// 12049         #endif
// 12050         if (!no_move && IsRunning()) {
// 12051           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12052             if (DEBUGGING(LEVELING)) DEBUG_POS("Move back", destination);
// 12053           #endif
// 12054           // Move back to the original (or tweaked) position
// 12055           do_blocking_move_to(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS]);
// 12056         }
// 12057         #if ENABLED(SWITCHING_NOZZLE)
// 12058           else {
// 12059             // Move back down. (Including when the new tool is higher.)
// 12060             do_blocking_move_to_z(destination[Z_AXIS], planner.max_feedrate_mm_s[Z_AXIS]);
// 12061           }
// 12062         #endif
// 12063       } // (tmp_extruder != active_extruder)
// 12064 
// 12065       stepper.synchronize();
// 12066 
// 12067       #if ENABLED(EXT_SOLENOID) && !ENABLED(PARKING_EXTRUDER)
// 12068         disable_all_solenoids();
// 12069         enable_solenoid_on_active_extruder();
// 12070       #endif // EXT_SOLENOID
// 12071 
// 12072       feedrate_mm_s = old_feedrate_mm_s;
// 12073 
// 12074     #else // HOTENDS <= 1
// 12075 
// 12076       UNUSED(fr_mm_s);
// 12077       UNUSED(no_move);
// 12078 
// 12079       #if ENABLED(MK2_MULTIPLEXER)
// 12080         if (tmp_extruder >= E_STEPPERS)
// 12081           return invalid_extruder_error(tmp_extruder);
// 12082 
// 12083         select_multiplexed_stepper(tmp_extruder);
// 12084       #endif
// 12085 
// 12086       // Set the new active extruder
// 12087       active_extruder = tmp_extruder;
??tool_change_0:
        LDR.W    R4,??DataTable107
        MOVS     R0,#+0
        STRB     R0,[R4, #+19]
// 12088 
// 12089     #endif // HOTENDS <= 1
// 12090 
// 12091     #if ENABLED(SWITCHING_EXTRUDER) && !DONT_SWITCH
// 12092       stepper.synchronize();
// 12093       move_extruder_servo(active_extruder);
// 12094     #endif
// 12095 
// 12096     #if HAS_FANMUX
// 12097       fanmux_switch(active_extruder);
// 12098     #endif
// 12099 
// 12100     SERIAL_ECHO_START();
        LDR.W    R0,??DataTable107_2
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 12101     SERIAL_ECHOLNPAIR(MSG_ACTIVE_EXTRUDER, (int)active_extruder);
        LDRB     R1,[R4, #+19]
        ADR.W    R0,`?<Constant "Active Extruder: ">`
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        MOVS     R1,#+10
        LDR.W    R0,??DataTable109
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
          CFI EndBlock cfiBlock44
// 12102 
// 12103   #endif // !MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
// 12104 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable104:
        DC32     0x42700000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable104_1:
        DC8      " Z:"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable104_2:
        DC8      0x58, 0x3A, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable104_3:
        DC8      " Y:"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable104_4:
        DC8      " E:"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable104_5:
        DC8      ":",0x0,0x0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable104_6:
        DC32     card

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable104_7:
        DC32     home_dir_P

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable104_8:
        DC32     mksCfg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable104_9:
        DC32     soft_endstops_enabled

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Active Extruder: ">`:
        DC8 "Active Extruder: "
        DC8 0, 0
// 12105 
// 12106 /**
// 12107  * T0-T3: Switch tool, usually switching extruders
// 12108  *
// 12109  *   F[units/min] Set the movement feedrate
// 12110  *   S1           Don't move the tool in XY after change
// 12111  */
// 12112 inline void gcode_T(const uint8_t tmp_extruder) {
// 12113 
// 12114   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12115     if (DEBUGGING(LEVELING)) {
// 12116       SERIAL_ECHOPAIR(">>> gcode_T(", tmp_extruder);
// 12117       SERIAL_CHAR(')');
// 12118       SERIAL_EOL();
// 12119       DEBUG_POS("BEFORE", current_position);
// 12120     }
// 12121   #endif
// 12122 
// 12123   #if HOTENDS == 1 || (ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1)
// 12124 
// 12125     tool_change(tmp_extruder);
// 12126 
// 12127   #elif HOTENDS > 1
// 12128 
// 12129     tool_change(
// 12130       tmp_extruder,
// 12131       MMM_TO_MMS(parser.linearval('F')),
// 12132       (tmp_extruder == active_extruder) || parser.boolval('S')
// 12133     );
// 12134 
// 12135   #endif
// 12136 
// 12137   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12138     if (DEBUGGING(LEVELING)) {
// 12139       DEBUG_POS("AFTER", current_position);
// 12140       SERIAL_ECHOLNPGM("<<< gcode_T");
// 12141     }
// 12142   #endif
// 12143 }
// 12144 
// 12145 /**
// 12146  * Process the parsed command and dispatch it to its handler
// 12147  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock45 Using cfiCommon0
          CFI Function _Z22process_parsed_commandv
        THUMB
// 12148 void process_parsed_command() {
_Z22process_parsed_commandv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 12149   KEEPALIVE_STATE(IN_HANDLER);
// 12150 
// 12151   // Handle a known G, M, or T
// 12152   switch (parser.command_letter) {
        LDR.W    R0,??DataTable121
        LDRSB    R0,[R0, #+0]
        CMP      R0,#+71
        BEQ.N    ??process_parsed_command_0
        CMP      R0,#+77
        BEQ.N    ??process_parsed_command_1
        CMP      R0,#+84
        BEQ.W    ??process_parsed_command_2
        B.N      ??process_parsed_command_3
// 12153     case 'G': switch (parser.codenum) {
??process_parsed_command_0:
        LDR.W    R0,??DataTable121_1
        LDR      R0,[R0, #+0]
        MOVS     R1,R0
        BEQ.N    ??process_parsed_command_4
        CMP      R1,#+1
        BEQ.N    ??process_parsed_command_4
        CMP      R1,#+2
        BEQ.N    ??process_parsed_command_5
        CMP      R1,#+3
        BEQ.N    ??process_parsed_command_5
        CMP      R1,#+4
        BEQ.N    ??process_parsed_command_6
        CMP      R1,#+28
        BEQ.N    ??process_parsed_command_7
        CMP      R1,#+90
        BEQ.N    ??process_parsed_command_8
        CMP      R1,#+91
        BEQ.N    ??process_parsed_command_9
        CMP      R1,#+92
        BEQ.N    ??process_parsed_command_10
        B.N      ??process_parsed_command_11
// 12154 
// 12155       // G0, G1
// 12156       case 0:
// 12157       case 1:
// 12158         #if IS_SCARA
// 12159           gcode_G0_G1(parser.codenum == 0);
// 12160         #else
// 12161           gcode_G0_G1();
??process_parsed_command_4:
          CFI FunCall _Z11gcode_G0_G1v
        BL       _Z11gcode_G0_G1v
// 12162         #endif
// 12163         break;
        B.N      ??process_parsed_command_11
// 12164 
// 12165       // G2, G3
// 12166       #if ENABLED(ARC_SUPPORT) && DISABLED(SCARA)
// 12167         case 2: // G2: CW ARC
// 12168         case 3: // G3: CCW ARC
// 12169           gcode_G2_G3(parser.codenum == 2);
??process_parsed_command_5:
        CMP      R0,#+2
        BNE.N    ??process_parsed_command_12
        MOVS     R0,#+1
        B.N      ??process_parsed_command_13
??process_parsed_command_12:
        MOVS     R0,#+0
??process_parsed_command_13:
          CFI FunCall _Z11gcode_G2_G3b
        BL       _Z11gcode_G2_G3b
// 12170           break;
        B.N      ??process_parsed_command_11
// 12171       #endif
// 12172 
// 12173       // G4 Dwell
// 12174       case 4:
// 12175         gcode_G4();
??process_parsed_command_6:
          CFI FunCall _Z8gcode_G4v
        BL       _Z8gcode_G4v
// 12176         break;
        B.N      ??process_parsed_command_11
// 12177 
// 12178       #if ENABLED(BEZIER_CURVE_SUPPORT)
// 12179         case 5: // G5: Cubic B_spline
// 12180           gcode_G5();
// 12181           break;
// 12182       #endif // BEZIER_CURVE_SUPPORT
// 12183 
// 12184       #if ENABLED(FWRETRACT)
// 12185         case 10: // G10: retract
// 12186           gcode_G10();
// 12187           break;
// 12188         case 11: // G11: retract_recover
// 12189           gcode_G11();
// 12190           break;
// 12191       #endif // FWRETRACT
// 12192 
// 12193       #if ENABLED(NOZZLE_CLEAN_FEATURE)
// 12194         case 12:
// 12195           gcode_G12(); // G12: Nozzle Clean
// 12196           break;
// 12197       #endif // NOZZLE_CLEAN_FEATURE
// 12198 
// 12199       #if ENABLED(CNC_WORKSPACE_PLANES)
// 12200         case 17: // G17: Select Plane XY
// 12201           gcode_G17();
// 12202           break;
// 12203         case 18: // G18: Select Plane ZX
// 12204           gcode_G18();
// 12205           break;
// 12206         case 19: // G19: Select Plane YZ
// 12207           gcode_G19();
// 12208           break;
// 12209       #endif // CNC_WORKSPACE_PLANES
// 12210 
// 12211       #if ENABLED(INCH_MODE_SUPPORT)
// 12212         case 20: // G20: Inch Mode
// 12213           gcode_G20();
// 12214           break;
// 12215 
// 12216         case 21: // G21: MM Mode
// 12217           gcode_G21();
// 12218           break;
// 12219       #endif // INCH_MODE_SUPPORT
// 12220 
// 12221       #if ENABLED(G26_MESH_VALIDATION)
// 12222         case 26: // G26: Mesh Validation Pattern generation
// 12223           gcode_G26();
// 12224           break;
// 12225       #endif // G26_MESH_VALIDATION
// 12226 
// 12227       #if ENABLED(NOZZLE_PARK_FEATURE)
// 12228         case 27: // G27: Nozzle Park
// 12229           gcode_G27();
// 12230           break;
// 12231       #endif // NOZZLE_PARK_FEATURE
// 12232 
// 12233       case 28: // G28: Home all axes, one at a time
// 12234         #if 1
// 12235       	if (gCfgItems.breakpoint_reprint_flg == 1) break;
??process_parsed_command_7:
        LDR.W    R0,??DataTable121_2
        LDRB     R0,[R0, #+296]
        CMP      R0,#+1
        BEQ.W    ??process_parsed_command_11
// 12236         #endif
// 12237         gcode_G28(false);
        MOVS     R0,#+0
          CFI FunCall _Z9gcode_G28b
        BL       _Z9gcode_G28b
// 12238         break;
        B.N      ??process_parsed_command_11
// 12239 
// 12240       #if HAS_LEVELING
// 12241         case 29: // G29 Detailed Z probe, probes the bed at 3 or more points,
// 12242                  // or provides access to the UBL System if enabled.
// 12243           gcode_G29();
// 12244           break;
// 12245       #endif // HAS_LEVELING
// 12246 
// 12247       #if HAS_BED_PROBE
// 12248 
// 12249         case 30: // G30 Single Z probe
// 12250           gcode_G30();
// 12251           break;
// 12252 
// 12253         #if ENABLED(Z_PROBE_SLED)
// 12254 
// 12255             case 31: // G31: dock the sled
// 12256               gcode_G31();
// 12257               break;
// 12258 
// 12259             case 32: // G32: undock the sled
// 12260               gcode_G32();
// 12261               break;
// 12262 
// 12263         #endif // Z_PROBE_SLED
// 12264 
// 12265       #endif // HAS_BED_PROBE
// 12266 
// 12267       #if ENABLED(DELTA_AUTO_CALIBRATION)
// 12268 
// 12269         case 33: // G33: Delta Auto-Calibration
// 12270           gcode_G33();
// 12271           break;
// 12272 
// 12273       #endif // DELTA_AUTO_CALIBRATION
// 12274 
// 12275       #if ENABLED(G38_PROBE_TARGET)
// 12276         case 38: // G38.2 & G38.3
// 12277           if (parser.subcode == 2 || parser.subcode == 3)
// 12278             gcode_G38(parser.subcode == 2);
// 12279           break;
// 12280       #endif
// 12281 
// 12282       case 90: // G90
// 12283         relative_mode = false;
??process_parsed_command_8:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable107
        STRB     R0,[R1, #+20]
// 12284         break;
        B.N      ??process_parsed_command_11
// 12285       case 91: // G91
// 12286         relative_mode = true;
??process_parsed_command_9:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable107
        STRB     R0,[R1, #+20]
// 12287         break;
        B.N      ??process_parsed_command_11
// 12288 
// 12289       case 92: // G92
// 12290         gcode_G92();
??process_parsed_command_10:
          CFI FunCall _Z9gcode_G92v
        BL       _Z9gcode_G92v
// 12291         break;
        B.N      ??process_parsed_command_11
// 12292 
// 12293       #if HAS_MESH
// 12294         case 42:
// 12295           gcode_G42();
// 12296           break;
// 12297       #endif
// 12298 
// 12299       #if ENABLED(DEBUG_GCODE_PARSER)
// 12300         case 800:
// 12301           parser.debug(); // GCode Parser Test for G
// 12302           break;
// 12303       #endif
// 12304     }
// 12305     break;
// 12306 
// 12307     case 'M': switch (parser.codenum) {
??process_parsed_command_1:
        LDR.W    R0,??DataTable121_1
        LDR      R0,[R0, #+0]
        SUBS     R0,R0,#+17
        BEQ.W    ??process_parsed_command_14
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_15
        SUBS     R0,R0,#+2
        BEQ.W    ??process_parsed_command_16
        SUBS     R0,R0,#+1
        CMP      R0,#+1
        BLS.W    ??process_parsed_command_17
        SUBS     R0,R0,#+2
        BEQ.W    ??process_parsed_command_18
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_19
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_20
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_21
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_22
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_23
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_24
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_25
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_26
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_27
        SUBS     R0,R0,#+10
        BEQ.W    ??process_parsed_command_28
        SUBS     R0,R0,#+33
        BEQ.W    ??process_parsed_command_29
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_30
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_31
        SUBS     R0,R0,#+4
        BEQ.W    ??process_parsed_command_32
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_33
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_34
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_15
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_35
        SUBS     R0,R0,#+7
        BEQ.W    ??process_parsed_command_36
        SUBS     R0,R0,#+12
        BEQ.W    ??process_parsed_command_37
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_38
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_39
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_40
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_41
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_42
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_43
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_44
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_45
        SUBS     R0,R0,#+2
        BEQ.W    ??process_parsed_command_46
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_47
        SUBS     R0,R0,#+2
        BEQ.W    ??process_parsed_command_48
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_49
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_50
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_51
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_52
        SUBS     R0,R0,#+19
        BEQ.W    ??process_parsed_command_53
        SUBS     R0,R0,#+60
        BEQ.W    ??process_parsed_command_54
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_55
        SUBS     R0,R0,#+2
        BEQ.W    ??process_parsed_command_56
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_57
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_58
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_59
        SUBS     R0,R0,#+5
        BEQ.W    ??process_parsed_command_60
        SUBS     R0,R0,#+9
        BEQ.W    ??process_parsed_command_61
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_62
        SUBS     R0,R0,#+5
        BEQ.W    ??process_parsed_command_63
        SUBS     R0,R0,#+75
        BEQ.W    ??process_parsed_command_64
        SUBS     R0,R0,#+2
        BEQ.W    ??process_parsed_command_65
        SUBS     R0,R0,#+52
        BEQ.W    ??process_parsed_command_66
        SUBS     R0,R0,#+45
        BEQ.W    ??process_parsed_command_67
        SUBS     R0,R0,#+10
        BEQ.W    ??process_parsed_command_68
        SUBS     R0,R0,#+18
        BEQ.W    ??process_parsed_command_69
        SUBS     R0,R0,#+72
        BEQ.W    ??process_parsed_command_70
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_71
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_72
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_73
        MOV      R1,#+404
        SUBS     R0,R0,R1
        BEQ.W    ??process_parsed_command_74
        SUBS     R0,R0,#+21
        BEQ.N    ??process_parsed_command_75
        SUBS     R0,R0,#+70
        BEQ.N    ??process_parsed_command_76
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_77
        B.N      ??process_parsed_command_11
// 12308       #if HAS_RESUME_CONTINUE
// 12309         case 0: // M0: Unconditional stop - Wait for user button press on LCD
// 12310         case 1: // M1: Conditional stop - Wait for user button press on LCD
// 12311           gcode_M0_M1();
// 12312           break;
// 12313       #endif // ULTIPANEL
// 12314 
// 12315       #if ENABLED(SPINDLE_LASER_ENABLE)
// 12316         case 3:
// 12317           gcode_M3_M4(true);   // M3: turn spindle/laser on, set laser/spindle power/speed, set rotation direction CW
// 12318           break;               // synchronizes with movement commands
// 12319         case 4:
// 12320           gcode_M3_M4(false);  // M4: turn spindle/laser on, set laser/spindle power/speed, set rotation direction CCW
// 12321           break;               // synchronizes with movement commands
// 12322         case 5:
// 12323           gcode_M5();     // M5 - turn spindle/laser off
// 12324           break;          // synchronizes with movement commands
// 12325       #endif
// 12326       case 17: // M17: Enable all stepper motors
// 12327         gcode_M17();
??process_parsed_command_14:
          CFI FunCall _Z9gcode_M17v
        BL       _Z9gcode_M17v
// 12328         break;
        B.N      ??process_parsed_command_11
// 12329 
// 12330       #if ENABLED(SDSUPPORT)
// 12331         case 20: // M20: list SD card
// 12332           gcode_M20(); break;
??process_parsed_command_16:
          CFI FunCall _Z9gcode_M20v
        BL       _Z9gcode_M20v
        B.N      ??process_parsed_command_11
// 12333         case 21: // M21: init SD card
// 12334           //gcode_M21(); break;
// 12335         case 22: // M22: release SD card
// 12336           gcode_M22(); break;
??process_parsed_command_17:
          CFI FunCall _Z9gcode_M22v
        BL       _Z9gcode_M22v
        B.N      ??process_parsed_command_11
// 12337         case 23: // M23: Select file
// 12338           gcode_M23(); break;
??process_parsed_command_18:
          CFI FunCall _Z9gcode_M23v
        BL       _Z9gcode_M23v
        B.N      ??process_parsed_command_11
// 12339         case 24: // M24: Start SD print
// 12340           gcode_M24(); 
??process_parsed_command_19:
          CFI FunCall _Z9gcode_M24v
        BL       _Z9gcode_M24v
// 12341 
// 12342           if(mksReprint.mks_printer_state == MKS_WORKING)
        LDR.W    R0,??DataTable122
        LDRB     R0,[R0, #+3344]
        CMP      R0,#+167
        BNE.W    ??process_parsed_command_11
// 12343           {
// 12344             clear_cur_ui();
          CFI FunCall clear_cur_ui
        BL       clear_cur_ui
// 12345             reset_file_info();
          CFI FunCall reset_file_info
        BL       reset_file_info
// 12346             reset_print_time();
          CFI FunCall reset_print_time
        BL       reset_print_time
// 12347             start_print_time();
          CFI FunCall start_print_time
        BL       start_print_time
// 12348             
// 12349             preview_gcode_prehandle(curFileName);
        LDR.W    R0,??DataTable122_1
          CFI FunCall preview_gcode_prehandle
        BL       preview_gcode_prehandle
// 12350             
// 12351             draw_printing();            
          CFI FunCall draw_printing
        BL       draw_printing
        B.N      ??process_parsed_command_11
// 12352            }
// 12353           break;
// 12354         case 25: // M25: Pause SD print
// 12355             gcode_M25(); 
??process_parsed_command_20:
          CFI FunCall _Z9gcode_M25v
        BL       _Z9gcode_M25v
// 12356             if(mksReprint.mks_printer_state == MKS_PAUSING)
        LDR.W    R4,??DataTable122
        LDRB     R0,[R4, #+3344]
        CMP      R0,#+168
        BNE.W    ??process_parsed_command_11
// 12357             {
// 12358             	stop_print_time();							
          CFI FunCall stop_print_time
        BL       stop_print_time
// 12359             	clear_cur_ui();
          CFI FunCall clear_cur_ui
        BL       clear_cur_ui
// 12360             
// 12361             	card.pauseSDPrint();
        MOV      R0,R4
          CFI FunCall _ZN10CardReader12pauseSDPrintEv
        BL       _ZN10CardReader12pauseSDPrintEv
// 12362             	print_job_timer.pause();
        ADD      R0,R4,#+3584
          CFI FunCall _ZN9Stopwatch5pauseEv
        BL       _ZN9Stopwatch5pauseEv
// 12363 
// 12364             	if(from_flash_pic==1)
        LDR.W    R0,??DataTable123
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??process_parsed_command_78
// 12365             		flash_preview_begin = 1;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable124
        STRB     R0,[R1, #+0]
        B.N      ??process_parsed_command_79
// 12366             	else
// 12367             		default_preview_flg = 1;							
??process_parsed_command_78:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable124_1
        STRB     R0,[R1, #+0]
// 12368 
// 12369             	draw_printing();
??process_parsed_command_79:
          CFI FunCall draw_printing
        BL       draw_printing
        B.N      ??process_parsed_command_11
// 12370             }          
// 12371           break;
// 12372         case 998:	//M998: Stop SD print
// 12373           gcode_M998(); break;			  
??process_parsed_command_76:
          CFI FunCall _Z10gcode_M998v
        BL       _Z10gcode_M998v
        B.N      ??process_parsed_command_11
// 12374         case 26: // M26: Set SD index
// 12375           gcode_M26(); break;
??process_parsed_command_21:
          CFI FunCall _Z9gcode_M26v
        BL       _Z9gcode_M26v
        B.N      ??process_parsed_command_11
// 12376         case 27: // M27: Get SD status
// 12377           gcode_M27(); break;
??process_parsed_command_22:
          CFI FunCall _Z9gcode_M27v
        BL       _Z9gcode_M27v
        B.N      ??process_parsed_command_11
// 12378         case 28: // M28: Start SD write
// 12379           gcode_M28(); break;
??process_parsed_command_23:
          CFI FunCall _Z9gcode_M28v
        BL       _Z9gcode_M28v
        B.N      ??process_parsed_command_11
// 12380         case 29: // M29: Stop SD write
// 12381           gcode_M29(); break;
??process_parsed_command_24:
          CFI FunCall _Z9gcode_M29v
        BL       _Z9gcode_M29v
        B.N      ??process_parsed_command_11
// 12382         case 30: // M30 <filename> Delete File
// 12383           gcode_M30(); break;
??process_parsed_command_25:
          CFI FunCall _Z9gcode_M30v
        BL       _Z9gcode_M30v
        B.N      ??process_parsed_command_11
// 12384         case 32: // M32: Select file and start SD print
// 12385           gcode_M32(); break;
??process_parsed_command_27:
          CFI FunCall _Z9gcode_M32v
        BL       _Z9gcode_M32v
        B.N      ??process_parsed_command_11
// 12386 
// 12387         #if ENABLED(LONG_FILENAME_HOST_SUPPORT)
// 12388           case 33: // M33: Get the long full path to a file or folder
// 12389             gcode_M33(); break;
// 12390         #endif
// 12391 
// 12392         #if ENABLED(SDCARD_SORT_ALPHA) && ENABLED(SDSORT_GCODE)
// 12393           case 34: // M34: Set SD card sorting options
// 12394             gcode_M34(); break;
// 12395         #endif // SDCARD_SORT_ALPHA && SDSORT_GCODE
// 12396 
// 12397         case 928: // M928: Start SD write
// 12398           gcode_M928(); break;
??process_parsed_command_75:
          CFI FunCall _Z10gcode_M928v
        BL       _Z10gcode_M928v
        B.N      ??process_parsed_command_11
// 12399       #endif // SDSUPPORT
// 12400 
// 12401       case 31: // M31: Report time since the start of SD print or last M109
// 12402         gcode_M31(); break;
??process_parsed_command_26:
          CFI FunCall _Z9gcode_M31v
        BL       _Z9gcode_M31v
        B.N      ??process_parsed_command_11
// 12403 
// 12404       case 42: // M42: Change pin state
// 12405         gcode_M42(); break;
??process_parsed_command_28:
          CFI FunCall _Z9gcode_M42v
        BL       _Z9gcode_M42v
        B.N      ??process_parsed_command_11
// 12406 
// 12407       #if ENABLED(PINS_DEBUGGING)
// 12408         case 43: // M43: Read pin state
// 12409           gcode_M43(); break;
// 12410       #endif
// 12411 
// 12412 
// 12413       #if ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
// 12414         case 48: // M48: Z probe repeatability test
// 12415           gcode_M48();
// 12416           break;
// 12417       #endif // Z_MIN_PROBE_REPEATABILITY_TEST
// 12418 
// 12419       #if ENABLED(G26_MESH_VALIDATION)
// 12420         case 49: // M49: Turn on or off G26 debug flag for verbose output
// 12421           gcode_M49();
// 12422           break;
// 12423       #endif // G26_MESH_VALIDATION
// 12424 
// 12425       #if ENABLED(ULTRA_LCD) && ENABLED(LCD_SET_PROGRESS_MANUALLY)
// 12426         case 73: // M73: Set print progress percentage
// 12427           gcode_M73(); break;
// 12428       #endif
// 12429 
// 12430       case 75: // M75: Start print timer
// 12431         gcode_M75(); break;
??process_parsed_command_29:
          CFI FunCall _Z9gcode_M75v
        BL       _Z9gcode_M75v
        B.N      ??process_parsed_command_11
// 12432       case 76: // M76: Pause print timer
// 12433         gcode_M76(); break;
??process_parsed_command_30:
          CFI FunCall _Z9gcode_M76v
        BL       _Z9gcode_M76v
        B.N      ??process_parsed_command_11
// 12434       case 77: // M77: Stop print timer
// 12435         gcode_M77(); break;
??process_parsed_command_31:
          CFI FunCall _Z9gcode_M77v
        BL       _Z9gcode_M77v
        B.N      ??process_parsed_command_11
// 12436 
// 12437       #if ENABLED(PRINTCOUNTER)
// 12438         case 78: // M78: Show print statistics
// 12439           gcode_M78(); break;
// 12440       #endif
// 12441 
// 12442       #if ENABLED(M100_FREE_MEMORY_WATCHER)
// 12443         case 100: // M100: Free Memory Report
// 12444           gcode_M100();
// 12445           break;
// 12446       #endif
// 12447 
// 12448       case 104: // M104: Set hot end temperature
// 12449         gcode_M104();
??process_parsed_command_37:
          CFI FunCall _Z10gcode_M104v
        BL       _Z10gcode_M104v
// 12450         break;
        B.N      ??process_parsed_command_11
// 12451 
// 12452       case 110: // M110: Set Current Line Number
// 12453         gcode_M110();
??process_parsed_command_43:
          CFI FunCall _Z10gcode_M110v
        BL       _Z10gcode_M110v
// 12454         break;
        B.N      ??process_parsed_command_11
// 12455 
// 12456       case 111: // M111: Set debug level
// 12457         gcode_M111();
??process_parsed_command_44:
          CFI FunCall _Z10gcode_M111v
        BL       _Z10gcode_M111v
// 12458         break;
        B.N      ??process_parsed_command_11
// 12459 
// 12460       #if DISABLED(EMERGENCY_PARSER)
// 12461 
// 12462         case 108: // M108: Cancel Waiting
// 12463           gcode_M108();
??process_parsed_command_41:
          CFI FunCall _Z10gcode_M108v
        BL       _Z10gcode_M108v
// 12464           break;
        B.N      ??process_parsed_command_11
// 12465 
// 12466         case 112: // M112: Emergency Stop
// 12467           gcode_M112();
??process_parsed_command_45:
          CFI FunCall _Z10gcode_M112v
        BL       _Z10gcode_M112v
// 12468           break;
        B.N      ??process_parsed_command_11
// 12469 
// 12470         case 410: // M410 quickstop - Abort all the planned moves.
// 12471           gcode_M410();
??process_parsed_command_68:
          CFI FunCall _Z10gcode_M410v
        BL       _Z10gcode_M410v
// 12472           break;
        B.N      ??process_parsed_command_11
// 12473 
// 12474       #endif
// 12475 
// 12476       #if ENABLED(HOST_KEEPALIVE_FEATURE)
// 12477         case 113: // M113: Set Host Keepalive interval
// 12478           gcode_M113();
// 12479           break;
// 12480       #endif
// 12481 
// 12482       case 140: // M140: Set bed temperature
// 12483         gcode_M140();
??process_parsed_command_53:
          CFI FunCall _Z10gcode_M140v
        BL       _Z10gcode_M140v
// 12484         break;
        B.N      ??process_parsed_command_11
// 12485 
// 12486       case 105: // M105: Report current temperature
// 12487       	mksdlp.buzzer_tone(500,100,2);
??process_parsed_command_38:
        MOVS     R3,#+2
        MOVS     R2,#+100
        MOV      R1,#+500
        LDR.W    R0,??DataTable115_1
          CFI FunCall _ZN7MKS_DLP11buzzer_toneEtth
        BL       _ZN7MKS_DLP11buzzer_toneEtth
// 12488         gcode_M105();
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z10gcode_M105v
        B.W      _Z10gcode_M105v
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 12489         KEEPALIVE_STATE(NOT_BUSY);
// 12490         return; // "ok" already printed
// 12491 
// 12492       #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
// 12493         case 155: // M155: Set temperature auto-report interval
// 12494           gcode_M155();
// 12495           break;
// 12496       #endif
// 12497 
// 12498       case 109: // M109: Wait for hotend temperature to reach target
// 12499         gcode_M109();
??process_parsed_command_42:
          CFI FunCall _Z10gcode_M109v
        BL       _Z10gcode_M109v
// 12500         break;
        B.N      ??process_parsed_command_11
// 12501 
// 12502       #if HAS_TEMP_BED
// 12503         case 190: // M190: Wait for bed temperature to reach target
// 12504           gcode_M190();
// 12505           break;
// 12506       #endif // HAS_TEMP_BED
// 12507 
// 12508       #if FAN_COUNT > 0
// 12509         case 106: // M106: Fan On
// 12510         mksdlp.buzzer_enable(1);
??process_parsed_command_39:
        LDR.W    R4,??DataTable122
        ADDW     R4,R4,#+2500
        MOVS     R1,#+1
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP13buzzer_enableEh
        BL       _ZN7MKS_DLP13buzzer_enableEh
// 12511 		//mksdlp.buzzer_tone(1000,1000,5);
// 12512 		mksdlp.bank2disp_enable(CLEAN_USED_BANK,0,0);
        MOVS     R3,#+0
        MOV      R2,R3
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
// 12513           gcode_M106();
          CFI FunCall _Z10gcode_M106v
        BL       _Z10gcode_M106v
// 12514           break;
        B.N      ??process_parsed_command_11
// 12515         case 107: // M107: Fan Off
// 12516         mksdlp.buzzer_enable(0);
??process_parsed_command_40:
        MOVS     R1,#+0
        LDR.W    R0,??DataTable115_1
          CFI FunCall _ZN7MKS_DLP13buzzer_enableEh
        BL       _ZN7MKS_DLP13buzzer_enableEh
// 12517           gcode_M107();
          CFI FunCall _Z10gcode_M107v
        BL       _Z10gcode_M107v
// 12518           break;
        B.N      ??process_parsed_command_11
// 12519       #endif // FAN_COUNT > 0
// 12520 
// 12521       #if ENABLED(PARK_HEAD_ON_PAUSE)
// 12522         case 125: // M125: Store current position and move to filament change position
// 12523           gcode_M125(); break;
// 12524       #endif
// 12525 
// 12526       #if ENABLED(BARICUDA)
// 12527         // PWM for HEATER_1_PIN
// 12528         #if HAS_HEATER_1
// 12529           case 126: // M126: valve open
// 12530             gcode_M126();
// 12531             break;
// 12532           case 127: // M127: valve closed
// 12533             gcode_M127();
// 12534             break;
// 12535         #endif // HAS_HEATER_1
// 12536 
// 12537         // PWM for HEATER_2_PIN
// 12538         #if HAS_HEATER_2
// 12539           case 128: // M128: valve open
// 12540             gcode_M128();
// 12541             break;
// 12542           case 129: // M129: valve closed
// 12543             gcode_M129();
// 12544             break;
// 12545         #endif // HAS_HEATER_2
// 12546       #endif // BARICUDA
// 12547 
// 12548       #if HAS_POWER_SWITCH
// 12549 
// 12550         case 80: // M80: Turn on Power Supply
// 12551           gcode_M80();
// 12552           break;
// 12553 
// 12554       #endif // HAS_POWER_SWITCH
// 12555 
// 12556       case 81: // M81: Turn off Power, including Power Supply, if possible
// 12557         gcode_M81();
??process_parsed_command_32:
          CFI FunCall _Z9gcode_M81v
        BL       _Z9gcode_M81v
// 12558         break;
        B.N      ??process_parsed_command_11
// 12559 
// 12560       case 82: // M82: Set E axis normal mode (same as other axes)
// 12561         gcode_M82();
??process_parsed_command_33:
          CFI FunCall _Z9gcode_M82v
        BL       _Z9gcode_M82v
// 12562         break;
        B.N      ??process_parsed_command_11
// 12563       case 83: // M83: Set E axis relative mode
// 12564         gcode_M83();
??process_parsed_command_34:
          CFI FunCall _Z9gcode_M83v
        BL       _Z9gcode_M83v
// 12565         break;
        B.N      ??process_parsed_command_11
// 12566       case 18: // M18 => M84
// 12567       case 84: // M84: Disable all steppers or set timeout
// 12568         gcode_M18_M84();
??process_parsed_command_15:
          CFI FunCall _Z13gcode_M18_M84v
        BL       _Z13gcode_M18_M84v
// 12569         break;
        B.N      ??process_parsed_command_11
// 12570       case 85: // M85: Set inactivity stepper shutdown timeout
// 12571         gcode_M85();
??process_parsed_command_35:
          CFI FunCall _Z9gcode_M85v
        BL       _Z9gcode_M85v
// 12572         break;
        B.N      ??process_parsed_command_11
// 12573       case 92: // M92: Set the steps-per-unit for one or more axes
// 12574         gcode_M92();
??process_parsed_command_36:
          CFI FunCall _Z9gcode_M92v
        BL       _Z9gcode_M92v
// 12575         break;
        B.N      ??process_parsed_command_11
// 12576       case 114: // M114: Report current position
// 12577         gcode_M114();
??process_parsed_command_46:
          CFI FunCall _Z10gcode_M114v
        BL       _Z10gcode_M114v
// 12578         break;
        B.N      ??process_parsed_command_11
// 12579       case 115: // M115: Report capabilities
// 12580         gcode_M115();
??process_parsed_command_47:
          CFI FunCall _Z10gcode_M115v
        BL       _Z10gcode_M115v
// 12581         break;
        B.N      ??process_parsed_command_11
// 12582       case 117: // M117: Set LCD message text, if possible
// 12583         gcode_M117();
??process_parsed_command_48:
          CFI FunCall _Z10gcode_M117v
        BL       _Z10gcode_M117v
// 12584         break;
        B.N      ??process_parsed_command_11
// 12585       case 118: // M118: Display a message in the host console
// 12586         gcode_M118();
??process_parsed_command_49:
          CFI FunCall _Z10gcode_M118v
        BL       _Z10gcode_M118v
// 12587         break;
        B.N      ??process_parsed_command_11
// 12588       case 119: // M119: Report endstop states
// 12589         gcode_M119();
??process_parsed_command_50:
          CFI FunCall _Z10gcode_M119v
        BL       _Z10gcode_M119v
// 12590         break;
        B.N      ??process_parsed_command_11
// 12591       case 120: // M120: Enable endstops
// 12592         gcode_M120();
??process_parsed_command_51:
          CFI FunCall _Z10gcode_M120v
        BL       _Z10gcode_M120v
// 12593         break;
        B.N      ??process_parsed_command_11
// 12594       case 121: // M121: Disable endstops
// 12595         gcode_M121();
??process_parsed_command_52:
          CFI FunCall _Z10gcode_M121v
        BL       _Z10gcode_M121v
// 12596         break;
        B.N      ??process_parsed_command_11
// 12597 
// 12598       #if ENABLED(ULTIPANEL)
// 12599 
// 12600         case 145: // M145: Set material heatup parameters
// 12601           gcode_M145();
// 12602           break;
// 12603 
// 12604       #endif
// 12605 
// 12606       #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
// 12607         case 149: // M149: Set temperature units
// 12608           gcode_M149();
// 12609           break;
// 12610       #endif
// 12611 
// 12612       #if HAS_COLOR_LEDS
// 12613 
// 12614         case 150: // M150: Set Status LED Color
// 12615           gcode_M150();
// 12616           break;
// 12617 
// 12618       #endif // HAS_COLOR_LEDS
// 12619 
// 12620       #if ENABLED(MIXING_EXTRUDER)
// 12621         case 163: // M163: Set a component weight for mixing extruder
// 12622           gcode_M163();
// 12623           break;
// 12624         #if MIXING_VIRTUAL_TOOLS > 1
// 12625           case 164: // M164: Save current mix as a virtual extruder
// 12626             gcode_M164();
// 12627             break;
// 12628         #endif
// 12629         #if ENABLED(DIRECT_MIXING_IN_G1)
// 12630           case 165: // M165: Set multiple mix weights
// 12631             gcode_M165();
// 12632             break;
// 12633         #endif
// 12634       #endif
// 12635 
// 12636       #if DISABLED(NO_VOLUMETRICS)
// 12637         case 200: // M200: Set filament diameter, E to cubic units
// 12638           gcode_M200();
??process_parsed_command_54:
          CFI FunCall _Z10gcode_M200v
        BL       _Z10gcode_M200v
// 12639           break;
        B.N      ??process_parsed_command_11
// 12640       #endif
// 12641 
// 12642       case 201: // M201: Set max acceleration for print moves (units/s^2)
// 12643         gcode_M201();
??process_parsed_command_55:
          CFI FunCall _Z10gcode_M201v
        BL       _Z10gcode_M201v
// 12644         break;
        B.N      ??process_parsed_command_11
// 12645       #if 0 // Not used for Sprinter/grbl gen6
// 12646         case 202: // M202
// 12647           gcode_M202();
// 12648           break;
// 12649       #endif
// 12650       case 203: // M203: Set max feedrate (units/sec)
// 12651         gcode_M203();
??process_parsed_command_56:
          CFI FunCall _Z10gcode_M203v
        BL       _Z10gcode_M203v
// 12652         break;
        B.N      ??process_parsed_command_11
// 12653       case 204: // M204: Set acceleration
// 12654         gcode_M204();
??process_parsed_command_57:
          CFI FunCall _Z10gcode_M204v
        BL       _Z10gcode_M204v
// 12655         break;
        B.N      ??process_parsed_command_11
// 12656       case 205: // M205: Set advanced settings
// 12657         gcode_M205();
??process_parsed_command_58:
          CFI FunCall _Z10gcode_M205v
        BL       _Z10gcode_M205v
// 12658         break;
        B.N      ??process_parsed_command_11
// 12659 
// 12660       #if HAS_M206_COMMAND
// 12661         case 206: // M206: Set home offsets
// 12662           gcode_M206();
??process_parsed_command_59:
          CFI FunCall _Z10gcode_M206v
        BL       _Z10gcode_M206v
// 12663           break;
        B.N      ??process_parsed_command_11
// 12664       #endif
// 12665 
// 12666       #if ENABLED(DELTA)
// 12667         case 665: // M665: Set delta configurations
// 12668           gcode_M665();
// 12669           break;
// 12670       #endif
// 12671 
// 12672       #if ENABLED(DELTA) || ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
// 12673         case 666: // M666: Set delta or dual endstop adjustment
// 12674           gcode_M666();
// 12675           break;
// 12676       #endif
// 12677 
// 12678       #if ENABLED(FWRETRACT)
// 12679         case 207: // M207: Set Retract Length, Feedrate, and Z lift
// 12680           gcode_M207();
// 12681           break;
// 12682         case 208: // M208: Set Recover (unretract) Additional Length and Feedrate
// 12683           gcode_M208();
// 12684           break;
// 12685         case 209: // M209: Turn Automatic Retract Detection on/off
// 12686           if (MIN_AUTORETRACT <= MAX_AUTORETRACT) gcode_M209();
// 12687           break;
// 12688       #endif // FWRETRACT
// 12689 
// 12690       case 211: // M211: Enable, Disable, and/or Report software endstops
// 12691         gcode_M211();
??process_parsed_command_60:
          CFI FunCall _Z10gcode_M211v
        BL       _Z10gcode_M211v
// 12692         break;
        B.N      ??process_parsed_command_11
// 12693 
// 12694       #if HOTENDS > 1
// 12695         case 218: // M218: Set a tool offset
// 12696           gcode_M218();
// 12697           break;
// 12698       #endif // HOTENDS > 1
// 12699 
// 12700       case 220: // M220: Set Feedrate Percentage: S<percent> ("FR" on your LCD)
// 12701         gcode_M220();
??process_parsed_command_61:
          CFI FunCall _Z10gcode_M220v
        BL       _Z10gcode_M220v
// 12702         break;
        B.N      ??process_parsed_command_11
// 12703 
// 12704       case 221: // M221: Set Flow Percentage
// 12705         gcode_M221();
??process_parsed_command_62:
          CFI FunCall _Z10gcode_M221v
        BL       _Z10gcode_M221v
// 12706         break;
        B.N      ??process_parsed_command_11
// 12707 
// 12708       case 226: // M226: Wait until a pin reaches a state
// 12709         gcode_M226();
??process_parsed_command_63:
          CFI FunCall _Z10gcode_M226v
        BL       _Z10gcode_M226v
// 12710         break;
        B.N      ??process_parsed_command_11
// 12711 
// 12712       #if HAS_SERVOS
// 12713         case 280: // M280: Set servo position absolute
// 12714           gcode_M280();
// 12715           break;
// 12716       #endif // HAS_SERVOS
// 12717 
// 12718       #if ENABLED(BABYSTEPPING)
// 12719         case 290: // M290: Babystepping
// 12720           gcode_M290();
// 12721           break;
// 12722       #endif // BABYSTEPPING
// 12723 
// 12724       #if HAS_BUZZER
// 12725         case 300: // M300: Play beep tone
// 12726           gcode_M300();
// 12727           break;
// 12728       #endif // HAS_BUZZER
// 12729 
// 12730       #if ENABLED(PIDTEMP)
// 12731         case 301: // M301: Set hotend PID parameters
// 12732           gcode_M301();
??process_parsed_command_64:
          CFI FunCall _Z10gcode_M301v
        BL       _Z10gcode_M301v
// 12733           break;
        B.N      ??process_parsed_command_11
// 12734       #endif // PIDTEMP
// 12735 
// 12736       #if ENABLED(PIDTEMPBED)
// 12737         case 304: // M304: Set bed PID parameters
// 12738           gcode_M304();
// 12739           break;
// 12740       #endif // PIDTEMPBED
// 12741 
// 12742       #if defined(CHDK) || HAS_PHOTOGRAPH
// 12743         case 240: // M240: Trigger a camera by emulating a Canon RC-1 : http://www.doc-diy.net/photo/rc-1_hacked/
// 12744           gcode_M240();
// 12745           break;
// 12746       #endif // CHDK || PHOTOGRAPH_PIN
// 12747 
// 12748       #if HAS_LCD_CONTRAST
// 12749         case 250: // M250: Set LCD contrast
// 12750           gcode_M250();
// 12751           break;
// 12752       #endif // HAS_LCD_CONTRAST
// 12753 
// 12754       #if ENABLED(EXPERIMENTAL_I2CBUS)
// 12755 
// 12756         case 260: // M260: Send data to an i2c slave
// 12757           gcode_M260();
// 12758           break;
// 12759 
// 12760         case 261: // M261: Request data from an i2c slave
// 12761           gcode_M261();
// 12762           break;
// 12763 
// 12764       #endif // EXPERIMENTAL_I2CBUS
// 12765 
// 12766       #if ENABLED(PREVENT_COLD_EXTRUSION)
// 12767         case 302: // M302: Allow cold extrudes (set the minimum extrude temperature)
// 12768           gcode_M302();
// 12769           break;
// 12770       #endif // PREVENT_COLD_EXTRUSION
// 12771 
// 12772       case 303: // M303: PID autotune
// 12773         gcode_M303();
??process_parsed_command_65:
          CFI FunCall _Z10gcode_M303v
        BL       _Z10gcode_M303v
// 12774         break;
        B.N      ??process_parsed_command_11
// 12775 
// 12776       #if ENABLED(MORGAN_SCARA)
// 12777         case 360:  // M360: SCARA Theta pos1
// 12778           if (gcode_M360()) return;
// 12779           break;
// 12780         case 361:  // M361: SCARA Theta pos2
// 12781           if (gcode_M361()) return;
// 12782           break;
// 12783         case 362:  // M362: SCARA Psi pos1
// 12784           if (gcode_M362()) return;
// 12785           break;
// 12786         case 363:  // M363: SCARA Psi pos2
// 12787           if (gcode_M363()) return;
// 12788           break;
// 12789         case 364:  // M364: SCARA Psi pos3 (90 deg to Theta)
// 12790           if (gcode_M364()) return;
// 12791           break;
// 12792       #endif // SCARA
// 12793 
// 12794       case 400: // M400: Finish all moves
// 12795         gcode_M400();
??process_parsed_command_67:
          CFI FunCall _Z10gcode_M400v
        BL       _Z10gcode_M400v
// 12796         break;
        B.N      ??process_parsed_command_11
// 12797 
// 12798       #if HAS_BED_PROBE
// 12799         case 401: // M401: Deploy probe
// 12800           gcode_M401();
// 12801           break;
// 12802         case 402: // M402: Stow probe
// 12803           gcode_M402();
// 12804           break;
// 12805       #endif // HAS_BED_PROBE
// 12806 
// 12807       #if ENABLED(FILAMENT_WIDTH_SENSOR)
// 12808         case 404:  // M404: Enter the nominal filament width (3mm, 1.75mm ) N<3.0> or display nominal filament width
// 12809           gcode_M404();
// 12810           break;
// 12811         case 405:  // M405: Turn on filament sensor for control
// 12812           gcode_M405();
// 12813           break;
// 12814         case 406:  // M406: Turn off filament sensor for control
// 12815           gcode_M406();
// 12816           break;
// 12817         case 407:   // M407: Display measured filament diameter
// 12818           gcode_M407();
// 12819           break;
// 12820       #endif // FILAMENT_WIDTH_SENSOR
// 12821 
// 12822       #if HAS_LEVELING
// 12823         case 420: // M420: Enable/Disable Bed Leveling
// 12824           gcode_M420();
// 12825           break;
// 12826       #endif
// 12827 
// 12828       #if HAS_MESH
// 12829         case 421: // M421: Set a Mesh Bed Leveling Z coordinate
// 12830           gcode_M421();
// 12831           break;
// 12832       #endif
// 12833 
// 12834       #if HAS_M206_COMMAND
// 12835         case 428: // M428: Apply current_position to home_offset
// 12836           gcode_M428();
??process_parsed_command_69:
          CFI FunCall _Z10gcode_M428v
        BL       _Z10gcode_M428v
// 12837           break;
        B.N      ??process_parsed_command_11
// 12838       #endif
// 12839 
// 12840       case 500: // M500: Store settings in EEPROM
// 12841         gcode_M500();
??process_parsed_command_70:
          CFI FunCall _Z10gcode_M500v
        BL       _Z10gcode_M500v
// 12842         break;
        B.N      ??process_parsed_command_11
// 12843       case 501: // M501: Read settings from EEPROM
// 12844         gcode_M501();
??process_parsed_command_71:
          CFI FunCall _Z10gcode_M501v
        BL       _Z10gcode_M501v
// 12845         break;
        B.N      ??process_parsed_command_11
// 12846       case 502: // M502: Revert to default settings
// 12847         gcode_M502();
??process_parsed_command_72:
          CFI FunCall _Z10gcode_M502v
        BL       _Z10gcode_M502v
// 12848         break;
        B.N      ??process_parsed_command_11
// 12849 
// 12850       #if DISABLED(DISABLE_M503)
// 12851         case 503: // M503: print settings currently in memory
// 12852           gcode_M503();
??process_parsed_command_73:
          CFI FunCall _Z10gcode_M503v
        BL       _Z10gcode_M503v
// 12853           break;
        B.N      ??process_parsed_command_11
// 12854       #endif
// 12855 
// 12856       #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
// 12857         case 540: // M540: Set abort on endstop hit for SD printing
// 12858           gcode_M540();
// 12859           break;
// 12860       #endif
// 12861 
// 12862       #if HAS_BED_PROBE
// 12863         case 851: // M851: Set Z Probe Z Offset
// 12864           gcode_M851();
// 12865           break;
// 12866       #endif // HAS_BED_PROBE
// 12867 
// 12868       #if ENABLED(SKEW_CORRECTION_GCODE)
// 12869         case 852: // M852: Set Skew factors
// 12870           gcode_M852();
// 12871           break;
// 12872       #endif
// 12873 
// 12874       #if ENABLED(ADVANCED_PAUSE_FEATURE)
// 12875         case 600: // M600: Pause for filament change
// 12876           gcode_M600();
// 12877           break;
// 12878       #endif // ADVANCED_PAUSE_FEATURE
// 12879 
// 12880       #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
// 12881         case 605: // M605: Set Dual X Carriage movement mode
// 12882           gcode_M605();
// 12883           break;
// 12884       #endif // DUAL_X_CARRIAGE
// 12885 
// 12886       #if ENABLED(MK2_MULTIPLEXER)
// 12887         case 702: // M702: Unload all extruders
// 12888           gcode_M702();
// 12889           break;
// 12890       #endif
// 12891 
// 12892       #if ENABLED(LIN_ADVANCE)
// 12893         case 900: // M900: Set advance K factor.
// 12894           gcode_M900();
// 12895           break;
// 12896       #endif
// 12897 
// 12898       case 907: // M907: Set digital trimpot motor current using axis codes.
// 12899         gcode_M907();
??process_parsed_command_74:
          CFI FunCall _Z10gcode_M907v
        BL       _Z10gcode_M907v
// 12900         break;
        B.N      ??process_parsed_command_11
// 12901 
// 12902       #if HAS_DIGIPOTSS || ENABLED(DAC_STEPPER_CURRENT)
// 12903 
// 12904         case 908: // M908: Control digital trimpot directly.
// 12905           gcode_M908();
// 12906           break;
// 12907 
// 12908         #if ENABLED(DAC_STEPPER_CURRENT) // As with Printrbot RevF
// 12909 
// 12910           case 909: // M909: Print digipot/DAC current value
// 12911             gcode_M909();
// 12912             break;
// 12913 
// 12914           case 910: // M910: Commit digipot/DAC value to external EEPROM
// 12915             gcode_M910();
// 12916             break;
// 12917 
// 12918         #endif
// 12919 
// 12920       #endif // HAS_DIGIPOTSS || DAC_STEPPER_CURRENT
// 12921 
// 12922       #if ENABLED(HAVE_TMC2130) || ENABLED(HAVE_TMC2208)
// 12923         case 906: // M906: Set motor current in milliamps using axis codes X, Y, Z, E
// 12924           gcode_M906();
// 12925           break;
// 12926 
// 12927         case 911: // M911: Report TMC prewarn triggered flags
// 12928           gcode_M911();
// 12929           break;
// 12930 
// 12931         case 912: // M911: Clear TMC prewarn triggered flags
// 12932           gcode_M912();
// 12933           break;
// 12934 
// 12935         #if ENABLED(TMC_DEBUG)
// 12936           case 122:  // Debug TMC steppers
// 12937             gcode_M122();
// 12938             break;
// 12939         #endif
// 12940 
// 12941         #if ENABLED(HYBRID_THRESHOLD)
// 12942           case 913: // M913: Set HYBRID_THRESHOLD speed.
// 12943             gcode_M913();
// 12944             break;
// 12945         #endif
// 12946 
// 12947         #if ENABLED(SENSORLESS_HOMING)
// 12948           case 914: // M914: Set SENSORLESS_HOMING sensitivity.
// 12949             gcode_M914();
// 12950             break;
// 12951         #endif
// 12952 
// 12953         #if ENABLED(TMC_Z_CALIBRATION) && (Z_IS_TRINAMIC || Z2_IS_TRINAMIC)
// 12954           case 915: // M915: TMC Z axis calibration routine
// 12955             gcode_M915();
// 12956             break;
// 12957         #endif
// 12958       #endif
// 12959 
// 12960       #if HAS_MICROSTEPS
// 12961 
// 12962         case 350: // M350: Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.
// 12963           gcode_M350();
// 12964           break;
// 12965 
// 12966         case 351: // M351: Toggle MS1 MS2 pins directly, S# determines MS1 or MS2, X# sets the pin high/low.
// 12967           gcode_M351();
// 12968           break;
// 12969 
// 12970       #endif // HAS_MICROSTEPS
// 12971 
// 12972       case 355: // M355 set case light brightness
// 12973         gcode_M355();
??process_parsed_command_66:
          CFI FunCall _Z10gcode_M355v
        BL       _Z10gcode_M355v
// 12974         break;
        B.N      ??process_parsed_command_11
// 12975 
// 12976       #if ENABLED(DEBUG_GCODE_PARSER)
// 12977         case 800:
// 12978           parser.debug(); // GCode Parser Test for M
// 12979           break;
// 12980       #endif
// 12981 
// 12982       #if ENABLED(I2C_POSITION_ENCODERS)
// 12983 
// 12984         case 860: // M860 Report encoder module position
// 12985           gcode_M860();
// 12986           break;
// 12987 
// 12988         case 861: // M861 Report encoder module status
// 12989           gcode_M861();
// 12990           break;
// 12991 
// 12992         case 862: // M862 Perform axis test
// 12993           gcode_M862();
// 12994           break;
// 12995 
// 12996         case 863: // M863 Calibrate steps/mm
// 12997           gcode_M863();
// 12998           break;
// 12999 
// 13000         case 864: // M864 Change module address
// 13001           gcode_M864();
// 13002           break;
// 13003 
// 13004         case 865: // M865 Check module firmware version
// 13005           gcode_M865();
// 13006           break;
// 13007 
// 13008         case 866: // M866 Report axis error count
// 13009           gcode_M866();
// 13010           break;
// 13011 
// 13012         case 867: // M867 Toggle error correction
// 13013           gcode_M867();
// 13014           break;
// 13015 
// 13016         case 868: // M868 Set error correction threshold
// 13017           gcode_M868();
// 13018           break;
// 13019 
// 13020         case 869: // M869 Report axis error
// 13021           gcode_M869();
// 13022           break;
// 13023 
// 13024       #endif // I2C_POSITION_ENCODERS
// 13025 
// 13026       case 999: // M999: Restart after being Stopped
// 13027         gcode_M999();
??process_parsed_command_77:
          CFI FunCall _Z10gcode_M999v
        BL       _Z10gcode_M999v
// 13028         break;
        B.N      ??process_parsed_command_11
// 13029     }
// 13030     break;
// 13031 
// 13032     case 'T':
// 13033       gcode_T(parser.codenum);
??process_parsed_command_2:
        LDR.W    R0,??DataTable121_1
        LDR      R0,[R0, #+0]
        UXTB     R0,R0
          CFI FunCall _Z7gcode_Th
        BL       _Z7gcode_Th
// 13034       break;
        B.N      ??process_parsed_command_11
// 13035 
// 13036     default: parser.unknown_command_error();
??process_parsed_command_3:
        LDR.W    R0,??DataTable125_1
          CFI FunCall _ZN11GCodeParser21unknown_command_errorEv
        BL       _ZN11GCodeParser21unknown_command_errorEv
// 13037   }
// 13038 
// 13039   KEEPALIVE_STATE(NOT_BUSY);
// 13040 
// 13041   ok_to_send();
??process_parsed_command_11:
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z10ok_to_sendv
        B.N      _Z10ok_to_sendv
          CFI EndBlock cfiBlock45
// 13042 }
// 13043 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock46 Using cfiCommon0
          CFI Function _Z20process_next_commandv
        THUMB
// 13044 void process_next_command() {
_Z20process_next_commandv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
// 13045   char * const current_command = command_queue[cmd_queue_index_r];
        LDR.N    R0,??DataTable107
        LDRB     R1,[R0, #+17]
        ADD      R2,R1,R1, LSL #+1
        ADD      R1,R0,R2, LSL #+5
        ADD      R4,R1,#+140
// 13046 
// 13047   if (DEBUGGING(ECHO)) {
        LDRB     R0,[R0, #+15]
        LSLS     R0,R0,#+31
        BPL.N    ??process_next_command_0
// 13048     SERIAL_ECHO_START();
        LDR.N    R0,??DataTable107_2
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 13049     SERIAL_ECHOLN(current_command);
        LDR.N    R5,??DataTable109
        MOV      R1,R4
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEPKc
        BL       _ZN5Print5printEPKc
        MOVS     R1,#+10
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 13050     #if ENABLED(M100_FREE_MEMORY_WATCHER)
// 13051       SERIAL_ECHOPAIR("slot:", cmd_queue_index_r);
// 13052       M100_dump_routine("   Command Queue:", (const char*)command_queue, (const char*)(command_queue + sizeof(command_queue)));
// 13053     #endif
// 13054   }
// 13055 
// 13056   // Parse the next command in the queue
// 13057   parser.parse(current_command);
??process_next_command_0:
        MOV      R0,R4
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
// 13058   process_parsed_command();
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z22process_parsed_commandv
        B.N      _Z22process_parsed_commandv
          CFI EndBlock cfiBlock46
// 13059 }
// 13060 
// 13061 /**
// 13062  * Send a "Resend: nnn" message to the host to
// 13063  * indicate that a command needs to be re-sent.
// 13064  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock47 Using cfiCommon0
          CFI Function _Z24FlushSerialRequestResendv
          CFI FunCall _Z10ok_to_sendv
        THUMB
// 13065 void FlushSerialRequestResend() {
_Z24FlushSerialRequestResendv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 13066   //char command_queue[cmd_queue_index_r][100]="Resend:";
// 13067   MYSERIAL.flush();
        LDR.N    R4,??DataTable109
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5flushEv
        BL       _ZN10USARTClass5flushEv
// 13068   SERIAL_PROTOCOLPGM(MSG_RESEND);
        ADR.W    R0,`?<Constant "Resend: ">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 13069   SERIAL_PROTOCOLLN(gcode_LastN + 1);
        MOVS     R2,#+10
        LDR.N    R0,??DataTable107
        LDR      R0,[R0, #+112]
        ADDS     R1,R0,#+1
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEli
        BL       _ZN5Print5printEli
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 13070   ok_to_send();
        POP      {R4,LR}
          CFI EndBlock cfiBlock47
        REQUIRE _Z10ok_to_sendv
        ;; // Fall through to label ok_to_send()
// 13071 }
// 13072 
// 13073 /**
// 13074  * Send an "ok" message to the host, indicating
// 13075  * that a command was successfully processed.
// 13076  *
// 13077  * If ADVANCED_OK is enabled also include:
// 13078  *   N<int>  Line number of the command, if any
// 13079  *   P<int>  Planner space remaining
// 13080  *   B<int>  Block queue space remaining
// 13081  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock48 Using cfiCommon0
          CFI Function _Z10ok_to_sendv
        THUMB
// 13082 void ok_to_send() {
_Z10ok_to_sendv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 13083   refresh_cmd_timeout();
          CFI FunCall _Z19refresh_cmd_timeoutv
        BL       _Z19refresh_cmd_timeoutv
// 13084   if (!send_ok[cmd_queue_index_r]) return;
        LDR.N    R0,??DataTable107
        LDRB     R1,[R0, #+17]
        ADDS     R0,R1,R0
        LDRB     R0,[R0, #+28]
        CMP      R0,#+0
        BEQ.N    ??ok_to_send_0
// 13085   SERIAL_PROTOCOLPGM(MSG_OK);
        ADR.N    R0,??DataTable111_3  ;; 0x6F, 0x6B, 0x00, 0x00
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 13086   #if ENABLED(ADVANCED_OK)
// 13087     char* p = command_queue[cmd_queue_index_r];
// 13088     if (*p == 'N') {
// 13089       SERIAL_PROTOCOL(' ');
// 13090       SERIAL_ECHO(*p++);
// 13091       while (NUMERIC_SIGNED(*p))
// 13092         SERIAL_ECHO(*p++);
// 13093     }
// 13094     SERIAL_PROTOCOLPGM(" P"); SERIAL_PROTOCOL(int(BLOCK_BUFFER_SIZE - planner.movesplanned() - 1));
// 13095     SERIAL_PROTOCOLPGM(" B"); SERIAL_PROTOCOL(BUFSIZE - commands_in_queue);
// 13096   #endif
// 13097   SERIAL_EOL();
        MOVS     R1,#+10
        LDR.N    R0,??DataTable109
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??ok_to_send_0:
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock48
// 13098 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable107:
        DC32     axis_relative_modes

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable107_1:
        DC32     injected_commands_P

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable107_2:
        DC32     echomagic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable107_3:
        DC32     errormagic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Resend: ">`:
        DC8 "Resend: "
        DC8 0, 0, 0
// 13099 
// 13100 #if HAS_SOFTWARE_ENDSTOPS
// 13101 
// 13102   /**
// 13103    * Constrain the given coordinates to the software endstops.
// 13104    *
// 13105    * For DELTA/SCARA the XY constraint is based on the smallest
// 13106    * radius within the set software endstops.
// 13107    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock49 Using cfiCommon0
          CFI Function _Z26clamp_to_software_endstopsPf
          CFI NoCalls
        THUMB
// 13108   void clamp_to_software_endstops(float target[XYZ]) {
// 13109     if (!soft_endstops_enabled) return;
_Z26clamp_to_software_endstopsPf:
        LDR.W    R1,??DataTable125_2
        LDRB     R2,[R1, #+0]
        CMP      R2,#+0
        BEQ.N    ??clamp_to_software_endstops_0
// 13110     #if IS_KINEMATIC
// 13111       const float dist_2 = HYPOT2(target[X_AXIS], target[Y_AXIS]);
// 13112       if (dist_2 > soft_endstop_radius_2) {
// 13113         const float ratio = soft_endstop_radius / SQRT(dist_2); // 200 / 300 = 0.66
// 13114         target[X_AXIS] *= ratio;
// 13115         target[Y_AXIS] *= ratio;
// 13116       }
// 13117     #else
// 13118 		if(mksCfg.min_software_endstops)
        LDR.W    R2,??DataTable126
        LDRB     R3,[R2, #+12]
        CMP      R3,#+0
        BEQ.N    ??clamp_to_software_endstops_1
// 13119 		{
// 13120       		//#if ENABLED(MIN_SOFTWARE_ENDSTOP_X)
// 13121        	 	NOLESS(target[X_AXIS], soft_endstop_min[X_AXIS]);
        VLDR     S0,[R1, #+16]
        VLDR     S1,[R0, #0]
        VCMP.F32 S1,S0
        FMSTAT   
        BPL.N    ??clamp_to_software_endstops_2
        VSTR     S0,[R0, #0]
// 13122       		//#endif
// 13123       		//#if ENABLED(MIN_SOFTWARE_ENDSTOP_Y)
// 13124         	NOLESS(target[Y_AXIS], soft_endstop_min[Y_AXIS]);
??clamp_to_software_endstops_2:
        VLDR     S0,[R1, #+20]
        VLDR     S1,[R0, #+4]
        VCMP.F32 S1,S0
        FMSTAT   
        BPL.N    ??clamp_to_software_endstops_1
        VSTR     S0,[R0, #+4]
// 13125       		//#endif
// 13126 		}
// 13127 		if(mksCfg.max_software_endstops)
??clamp_to_software_endstops_1:
        LDRB     R3,[R2, #+13]
        CMP      R3,#+0
        BEQ.N    ??clamp_to_software_endstops_3
// 13128 		{	
// 13129       		//#if ENABLED(MAX_SOFTWARE_ENDSTOP_X)
// 13130         	NOMORE(target[X_AXIS], soft_endstop_max[X_AXIS]);
        VLDR     S0,[R1, #+28]
        VLDR     S1,[R0, #0]
        VCMP.F32 S0,S1
        FMSTAT   
        BPL.N    ??clamp_to_software_endstops_4
        VSTR     S0,[R0, #0]
// 13131       		//#endif
// 13132       		//#if ENABLED(MAX_SOFTWARE_ENDSTOP_Y)
// 13133         	NOMORE(target[Y_AXIS], soft_endstop_max[Y_AXIS]);
??clamp_to_software_endstops_4:
        VLDR     S0,[R1, #+32]
        VLDR     S1,[R0, #+4]
        VCMP.F32 S0,S1
        FMSTAT   
        BPL.N    ??clamp_to_software_endstops_3
        VSTR     S0,[R0, #+4]
// 13134       		//#endif
// 13135 		}
// 13136     #endif
// 13137 	if(mksCfg.min_software_endstops)
??clamp_to_software_endstops_3:
        LDRB     R3,[R2, #+12]
        CMP      R3,#+0
        BEQ.N    ??clamp_to_software_endstops_5
// 13138 	{
// 13139     //#if ENABLED(MIN_SOFTWARE_ENDSTOP_Z)
// 13140       NOLESS(target[Z_AXIS], soft_endstop_min[Z_AXIS]);
        VLDR     S0,[R1, #+24]
        VLDR     S1,[R0, #+8]
        VCMP.F32 S1,S0
        FMSTAT   
        BPL.N    ??clamp_to_software_endstops_5
        VSTR     S0,[R0, #+8]
// 13141     //#endif
// 13142 	}
// 13143 	if(mksCfg.max_software_endstops)
??clamp_to_software_endstops_5:
        LDRB     R2,[R2, #+13]
        CMP      R2,#+0
        BEQ.N    ??clamp_to_software_endstops_0
// 13144 	{
// 13145     //#if ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
// 13146       NOMORE(target[Z_AXIS], soft_endstop_max[Z_AXIS]);
        VLDR     S0,[R1, #+36]
        VLDR     S1,[R0, #+8]
        VCMP.F32 S0,S1
        FMSTAT   
        BPL.N    ??clamp_to_software_endstops_0
        VSTR     S0,[R0, #+8]
// 13147     //#endif
// 13148 	}
// 13149 }  
??clamp_to_software_endstops_0:
        BX       LR               ;; return
          CFI EndBlock cfiBlock49
// 13150 
// 13151 #endif
// 13152 
// 13153 #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 13154 
// 13155   #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 13156     #define ABL_BG_SPACING(A) bilinear_grid_spacing_virt[A]
// 13157     #define ABL_BG_FACTOR(A)  bilinear_grid_factor_virt[A]
// 13158     #define ABL_BG_POINTS_X   ABL_GRID_POINTS_VIRT_X
// 13159     #define ABL_BG_POINTS_Y   ABL_GRID_POINTS_VIRT_Y
// 13160     #define ABL_BG_GRID(X,Y)  z_values_virt[X][Y]
// 13161   #else
// 13162     #define ABL_BG_SPACING(A) bilinear_grid_spacing[A]
// 13163     #define ABL_BG_FACTOR(A)  bilinear_grid_factor[A]
// 13164     #define ABL_BG_POINTS_X   GRID_MAX_POINTS_X
// 13165     #define ABL_BG_POINTS_Y   GRID_MAX_POINTS_Y
// 13166     #define ABL_BG_GRID(X,Y)  z_values[X][Y]
// 13167   #endif
// 13168 
// 13169   // Get the Z adjustment for non-linear bed leveling
// 13170   float bilinear_z_offset(const float raw[XYZ]) {
// 13171 
// 13172     static float z1, d2, z3, d4, L, D, ratio_x, ratio_y,
// 13173                  last_x = -999.999, last_y = -999.999;
// 13174 
// 13175     // Whole units for the grid line indices. Constrained within bounds.
// 13176     static int8_t gridx, gridy, nextx, nexty,
// 13177                   last_gridx = -99, last_gridy = -99;
// 13178 
// 13179     // XY relative to the probed area
// 13180     const float rx = raw[X_AXIS] - bilinear_start[X_AXIS],
// 13181                 ry = raw[Y_AXIS] - bilinear_start[Y_AXIS];
// 13182 
// 13183     #if ENABLED(EXTRAPOLATE_BEYOND_GRID)
// 13184       // Keep using the last grid box
// 13185       #define FAR_EDGE_OR_BOX 2
// 13186     #else
// 13187       // Just use the grid far edge
// 13188       #define FAR_EDGE_OR_BOX 1
// 13189     #endif
// 13190 
// 13191     if (last_x != rx) {
// 13192       last_x = rx;
// 13193       ratio_x = rx * ABL_BG_FACTOR(X_AXIS);
// 13194       const float gx = constrain(FLOOR(ratio_x), 0, ABL_BG_POINTS_X - FAR_EDGE_OR_BOX);
// 13195       ratio_x -= gx;      // Subtract whole to get the ratio within the grid box
// 13196 
// 13197       #if DISABLED(EXTRAPOLATE_BEYOND_GRID)
// 13198         // Beyond the grid maintain height at grid edges
// 13199         NOLESS(ratio_x, 0); // Never < 0.0. (> 1.0 is ok when nextx==gridx.)
// 13200       #endif
// 13201 
// 13202       gridx = gx;
// 13203       nextx = min(gridx + 1, ABL_BG_POINTS_X - 1);
// 13204     }
// 13205 
// 13206     if (last_y != ry || last_gridx != gridx) {
// 13207 
// 13208       if (last_y != ry) {
// 13209         last_y = ry;
// 13210         ratio_y = ry * ABL_BG_FACTOR(Y_AXIS);
// 13211         const float gy = constrain(FLOOR(ratio_y), 0, ABL_BG_POINTS_Y - FAR_EDGE_OR_BOX);
// 13212         ratio_y -= gy;
// 13213 
// 13214         #if DISABLED(EXTRAPOLATE_BEYOND_GRID)
// 13215           // Beyond the grid maintain height at grid edges
// 13216           NOLESS(ratio_y, 0); // Never < 0.0. (> 1.0 is ok when nexty==gridy.)
// 13217         #endif
// 13218 
// 13219         gridy = gy;
// 13220         nexty = min(gridy + 1, ABL_BG_POINTS_Y - 1);
// 13221       }
// 13222 
// 13223       if (last_gridx != gridx || last_gridy != gridy) {
// 13224         last_gridx = gridx;
// 13225         last_gridy = gridy;
// 13226         // Z at the box corners
// 13227         z1 = ABL_BG_GRID(gridx, gridy);       // left-front
// 13228         d2 = ABL_BG_GRID(gridx, nexty) - z1;  // left-back (delta)
// 13229         z3 = ABL_BG_GRID(nextx, gridy);       // right-front
// 13230         d4 = ABL_BG_GRID(nextx, nexty) - z3;  // right-back (delta)
// 13231       }
// 13232 
// 13233       // Bilinear interpolate. Needed since ry or gridx has changed.
// 13234                   L = z1 + d2 * ratio_y;   // Linear interp. LF -> LB
// 13235       const float R = z3 + d4 * ratio_y;   // Linear interp. RF -> RB
// 13236 
// 13237       D = R - L;
// 13238     }
// 13239 
// 13240     const float offset = L + ratio_x * D;   // the offset almost always changes
// 13241 
// 13242     /*
// 13243     static float last_offset = 0;
// 13244     if (FABS(last_offset - offset) > 0.2) {
// 13245       SERIAL_ECHOPGM("Sudden Shift at ");
// 13246       SERIAL_ECHOPAIR("x=", rx);
// 13247       SERIAL_ECHOPAIR(" / ", bilinear_grid_spacing[X_AXIS]);
// 13248       SERIAL_ECHOLNPAIR(" -> gridx=", gridx);
// 13249       SERIAL_ECHOPAIR(" y=", ry);
// 13250       SERIAL_ECHOPAIR(" / ", bilinear_grid_spacing[Y_AXIS]);
// 13251       SERIAL_ECHOLNPAIR(" -> gridy=", gridy);
// 13252       SERIAL_ECHOPAIR(" ratio_x=", ratio_x);
// 13253       SERIAL_ECHOLNPAIR(" ratio_y=", ratio_y);
// 13254       SERIAL_ECHOPAIR(" z1=", z1);
// 13255       SERIAL_ECHOPAIR(" z2=", z2);
// 13256       SERIAL_ECHOPAIR(" z3=", z3);
// 13257       SERIAL_ECHOLNPAIR(" z4=", z4);
// 13258       SERIAL_ECHOPAIR(" L=", L);
// 13259       SERIAL_ECHOPAIR(" R=", R);
// 13260       SERIAL_ECHOLNPAIR(" offset=", offset);
// 13261     }
// 13262     last_offset = offset;
// 13263     //*/
// 13264 
// 13265     return offset;
// 13266   }
// 13267 
// 13268 #endif // AUTO_BED_LEVELING_BILINEAR
// 13269 
// 13270 #if ENABLED(DELTA)
// 13271 
// 13272   /**
// 13273    * Recalculate factors used for delta kinematics whenever
// 13274    * settings have been changed (e.g., by M665).
// 13275    */
// 13276   void recalc_delta_settings() {
// 13277     const float trt[ABC] = DELTA_RADIUS_TRIM_TOWER,
// 13278                 drt[ABC] = DELTA_DIAGONAL_ROD_TRIM_TOWER;
// 13279     delta_tower[A_AXIS][X_AXIS] = cos(RADIANS(210 + delta_tower_angle_trim[A_AXIS])) * (delta_radius + trt[A_AXIS]); // front left tower
// 13280     delta_tower[A_AXIS][Y_AXIS] = sin(RADIANS(210 + delta_tower_angle_trim[A_AXIS])) * (delta_radius + trt[A_AXIS]);
// 13281     delta_tower[B_AXIS][X_AXIS] = cos(RADIANS(330 + delta_tower_angle_trim[B_AXIS])) * (delta_radius + trt[B_AXIS]); // front right tower
// 13282     delta_tower[B_AXIS][Y_AXIS] = sin(RADIANS(330 + delta_tower_angle_trim[B_AXIS])) * (delta_radius + trt[B_AXIS]);
// 13283     delta_tower[C_AXIS][X_AXIS] = cos(RADIANS( 90 + delta_tower_angle_trim[C_AXIS])) * (delta_radius + trt[C_AXIS]); // back middle tower
// 13284     delta_tower[C_AXIS][Y_AXIS] = sin(RADIANS( 90 + delta_tower_angle_trim[C_AXIS])) * (delta_radius + trt[C_AXIS]);
// 13285     delta_diagonal_rod_2_tower[A_AXIS] = sq(delta_diagonal_rod + drt[A_AXIS]);
// 13286     delta_diagonal_rod_2_tower[B_AXIS] = sq(delta_diagonal_rod + drt[B_AXIS]);
// 13287     delta_diagonal_rod_2_tower[C_AXIS] = sq(delta_diagonal_rod + drt[C_AXIS]);
// 13288     update_software_endstops(Z_AXIS);
// 13289     axis_homed[X_AXIS] = axis_homed[Y_AXIS] = axis_homed[Z_AXIS] = false;
// 13290   }
// 13291 
// 13292   #if ENABLED(DELTA_FAST_SQRT)
// 13293     /**
// 13294      * Fast inverse sqrt from Quake III Arena
// 13295      * See: https://en.wikipedia.org/wiki/Fast_inverse_square_root
// 13296      */
// 13297     float Q_rsqrt(const float number) {
// 13298       long i;
// 13299       float x2, y;
// 13300       const float threehalfs = 1.5f;
// 13301       x2 = number * 0.5f;
// 13302       y  = number;
// 13303       i  = * ( long * ) &y;                       // evil floating point bit level hacking
// 13304       i  = 0x5F3759DF - ( i >> 1 );               // what the f***?
// 13305       y  = * ( float * ) &i;
// 13306       y  = y * ( threehalfs - ( x2 * y * y ) );   // 1st iteration
// 13307       // y  = y * ( threehalfs - ( x2 * y * y ) );   // 2nd iteration, this can be removed
// 13308       return y;
// 13309     }
// 13310 
// 13311   #endif
// 13312 
// 13313   /**
// 13314    * Delta Inverse Kinematics
// 13315    *
// 13316    * Calculate the tower positions for a given machine
// 13317    * position, storing the result in the delta[] array.
// 13318    *
// 13319    * This is an expensive calculation, requiring 3 square
// 13320    * roots per segmented linear move, and strains the limits
// 13321    * of a Mega2560 with a Graphical Display.
// 13322    *
// 13323    * Suggested optimizations include:
// 13324    *
// 13325    * - Disable the home_offset (M206) and/or position_shift (G92)
// 13326    *   features to remove up to 12 float additions.
// 13327    *
// 13328    * - Use a fast-inverse-sqrt function and add the reciprocal.
// 13329    *   (see above)
// 13330    */
// 13331 
// 13332   #define DELTA_DEBUG() do { \ 
// 13333       SERIAL_ECHOPAIR("cartesian X:", raw[X_AXIS]); \ 
// 13334       SERIAL_ECHOPAIR(" Y:", raw[Y_AXIS]);          \ 
// 13335       SERIAL_ECHOLNPAIR(" Z:", raw[Z_AXIS]);        \ 
// 13336       SERIAL_ECHOPAIR("delta A:", delta[A_AXIS]);   \ 
// 13337       SERIAL_ECHOPAIR(" B:", delta[B_AXIS]);        \ 
// 13338       SERIAL_ECHOLNPAIR(" C:", delta[C_AXIS]);      \ 
// 13339     }while(0)
// 13340 
// 13341   void inverse_kinematics(const float raw[XYZ]) {
// 13342     DELTA_IK(raw);
// 13343     // DELTA_DEBUG();
// 13344   }
// 13345 
// 13346   /**
// 13347    * Calculate the highest Z position where the
// 13348    * effector has the full range of XY motion.
// 13349    */
// 13350   float delta_safe_distance_from_top() {
// 13351     float cartesian[XYZ] = { 0, 0, 0 };
// 13352     inverse_kinematics(cartesian);
// 13353     float distance = delta[A_AXIS];
// 13354     cartesian[Y_AXIS] = DELTA_PRINTABLE_RADIUS;
// 13355     inverse_kinematics(cartesian);
// 13356     return FABS(distance - delta[A_AXIS]);
// 13357   }
// 13358 
// 13359   /**
// 13360    * Delta Forward Kinematics
// 13361    *
// 13362    * See the Wikipedia article "Trilateration"
// 13363    * https://en.wikipedia.org/wiki/Trilateration
// 13364    *
// 13365    * Establish a new coordinate system in the plane of the
// 13366    * three carriage points. This system has its origin at
// 13367    * tower1, with tower2 on the X axis. Tower3 is in the X-Y
// 13368    * plane with a Z component of zero.
// 13369    * We will define unit vectors in this coordinate system
// 13370    * in our original coordinate system. Then when we calculate
// 13371    * the Xnew, Ynew and Znew values, we can translate back into
// 13372    * the original system by moving along those unit vectors
// 13373    * by the corresponding values.
// 13374    *
// 13375    * Variable names matched to Marlin, c-version, and avoid the
// 13376    * use of any vector library.
// 13377    *
// 13378    * by Andreas Hardtung 2016-06-07
// 13379    * based on a Java function from "Delta Robot Kinematics V3"
// 13380    * by Steve Graves
// 13381    *
// 13382    * The result is stored in the cartes[] array.
// 13383    */
// 13384   void forward_kinematics_DELTA(float z1, float z2, float z3) {
// 13385     // Create a vector in old coordinates along x axis of new coordinate
// 13386     const float p12[] = {
// 13387       delta_tower[B_AXIS][X_AXIS] - delta_tower[A_AXIS][X_AXIS],
// 13388       delta_tower[B_AXIS][Y_AXIS] - delta_tower[A_AXIS][Y_AXIS],
// 13389       z2 - z1
// 13390     },
// 13391 
// 13392     // Get the Magnitude of vector.
// 13393     d = SQRT(sq(p12[0]) + sq(p12[1]) + sq(p12[2])),
// 13394 
// 13395     // Create unit vector by dividing by magnitude.
// 13396     ex[3] = { p12[0] / d, p12[1] / d, p12[2] / d },
// 13397 
// 13398     // Get the vector from the origin of the new system to the third point.
// 13399     p13[3] = {
// 13400       delta_tower[C_AXIS][X_AXIS] - delta_tower[A_AXIS][X_AXIS],
// 13401       delta_tower[C_AXIS][Y_AXIS] - delta_tower[A_AXIS][Y_AXIS],
// 13402       z3 - z1
// 13403     },
// 13404 
// 13405     // Use the dot product to find the component of this vector on the X axis.
// 13406     i = ex[0] * p13[0] + ex[1] * p13[1] + ex[2] * p13[2],
// 13407 
// 13408     // Create a vector along the x axis that represents the x component of p13.
// 13409     iex[] = { ex[0] * i, ex[1] * i, ex[2] * i };
// 13410 
// 13411     // Subtract the X component from the original vector leaving only Y. We use the
// 13412     // variable that will be the unit vector after we scale it.
// 13413     float ey[3] = { p13[0] - iex[0], p13[1] - iex[1], p13[2] - iex[2] };
// 13414 
// 13415     // The magnitude of Y component
// 13416     const float j = SQRT(sq(ey[0]) + sq(ey[1]) + sq(ey[2]));
// 13417 
// 13418     // Convert to a unit vector
// 13419     ey[0] /= j; ey[1] /= j;  ey[2] /= j;
// 13420 
// 13421     // The cross product of the unit x and y is the unit z
// 13422     // float[] ez = vectorCrossProd(ex, ey);
// 13423     const float ez[3] = {
// 13424       ex[1] * ey[2] - ex[2] * ey[1],
// 13425       ex[2] * ey[0] - ex[0] * ey[2],
// 13426       ex[0] * ey[1] - ex[1] * ey[0]
// 13427     },
// 13428     // We now have the d, i and j values defined in Wikipedia.
// 13429     // Plug them into the equations defined in Wikipedia for Xnew, Ynew and Znew
// 13430     Xnew = (delta_diagonal_rod_2_tower[A_AXIS] - delta_diagonal_rod_2_tower[B_AXIS] + sq(d)) / (d * 2),
// 13431     Ynew = ((delta_diagonal_rod_2_tower[A_AXIS] - delta_diagonal_rod_2_tower[C_AXIS] + HYPOT2(i, j)) / 2 - i * Xnew) / j,
// 13432     Znew = SQRT(delta_diagonal_rod_2_tower[A_AXIS] - HYPOT2(Xnew, Ynew));
// 13433 
// 13434     // Start from the origin of the old coordinates and add vectors in the
// 13435     // old coords that represent the Xnew, Ynew and Znew to find the point
// 13436     // in the old system.
// 13437     cartes[X_AXIS] = delta_tower[A_AXIS][X_AXIS] + ex[0] * Xnew + ey[0] * Ynew - ez[0] * Znew;
// 13438     cartes[Y_AXIS] = delta_tower[A_AXIS][Y_AXIS] + ex[1] * Xnew + ey[1] * Ynew - ez[1] * Znew;
// 13439     cartes[Z_AXIS] =             z1 + ex[2] * Xnew + ey[2] * Ynew - ez[2] * Znew;
// 13440   }
// 13441 
// 13442   void forward_kinematics_DELTA(float point[ABC]) {
// 13443     forward_kinematics_DELTA(point[A_AXIS], point[B_AXIS], point[C_AXIS]);
// 13444   }
// 13445 
// 13446 #endif // DELTA
// 13447 
// 13448 /**
// 13449  * Get the stepper positions in the cartes[] array.
// 13450  * Forward kinematics are applied for DELTA and SCARA.
// 13451  *
// 13452  * The result is in the current coordinate space with
// 13453  * leveling applied. The coordinates need to be run through
// 13454  * unapply_leveling to obtain machine coordinates suitable
// 13455  * for current_position, etc.
// 13456  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock50 Using cfiCommon0
          CFI Function _Z27get_cartesian_from_steppersv
        THUMB
// 13457 void get_cartesian_from_steppers() {
_Z27get_cartesian_from_steppersv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 13458   #if ENABLED(DELTA)
// 13459     forward_kinematics_DELTA(
// 13460       stepper.get_axis_position_mm(A_AXIS),
// 13461       stepper.get_axis_position_mm(B_AXIS),
// 13462       stepper.get_axis_position_mm(C_AXIS)
// 13463     );
// 13464   #else
// 13465     #if IS_SCARA
// 13466       forward_kinematics_SCARA(
// 13467         stepper.get_axis_position_degrees(A_AXIS),
// 13468         stepper.get_axis_position_degrees(B_AXIS)
// 13469       );
// 13470     #else
// 13471       cartes[X_AXIS] = stepper.get_axis_position_mm(X_AXIS);
        LDR.W    R4,??DataTable126_1
        MOVS     R0,#+0
          CFI FunCall _ZN7Stepper20get_axis_position_mmE8AxisEnum
        BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
        VSTR     S0,[R4, #0]
// 13472       cartes[Y_AXIS] = stepper.get_axis_position_mm(Y_AXIS);
        MOVS     R0,#+1
          CFI FunCall _ZN7Stepper20get_axis_position_mmE8AxisEnum
        BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
        VSTR     S0,[R4, #+4]
// 13473     #endif
// 13474     cartes[Z_AXIS] = stepper.get_axis_position_mm(Z_AXIS);
        MOVS     R0,#+2
          CFI FunCall _ZN7Stepper20get_axis_position_mmE8AxisEnum
        BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
        VSTR     S0,[R4, #+8]
// 13475   #endif
// 13476 }
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock50

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable109:
        DC32     Serial6
// 13477 
// 13478 /**
// 13479  * Set the current_position for an axis based on
// 13480  * the stepper positions, removing any leveling that
// 13481  * may have been applied.
// 13482  *
// 13483  * To prevent small shifts in axis position always call
// 13484  * SYNC_PLAN_POSITION_KINEMATIC after updating axes with this.
// 13485  *
// 13486  * To keep hosts in sync, always call report_current_position
// 13487  * after updating the current_position.
// 13488  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock51 Using cfiCommon0
          CFI Function _Z34set_current_from_steppers_for_axis8AxisEnum
        THUMB
// 13489 void set_current_from_steppers_for_axis(const AxisEnum axis) {
_Z34set_current_from_steppers_for_axis8AxisEnum:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
// 13490   get_cartesian_from_steppers();
          CFI FunCall _Z27get_cartesian_from_steppersv
        BL       _Z27get_cartesian_from_steppersv
// 13491   #if PLANNER_LEVELING
// 13492     planner.unapply_leveling(cartes);
// 13493   #endif
// 13494   if (axis == ALL_AXES)
        LDR.N    R0,??DataTable111_1
        LDR.W    R1,??DataTable126_1
        CMP      R4,#+100
        BNE.N    ??set_current_from_steppers_for_axis_0
// 13495     COPY(current_position, cartes);
        MOVS     R2,#+12
        ADDS     R0,R0,#+36
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall memcpy
        B.W      memcpy
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 13496   else
// 13497     current_position[axis] = cartes[axis];
??set_current_from_steppers_for_axis_0:
        ADD      R0,R0,R4, LSL #+2
        LDR      R1,[R1, R4, LSL #+2]
        STR      R1,[R0, #+36]
// 13498 }
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock51
// 13499 
// 13500 #if IS_CARTESIAN
// 13501 #if ENABLED(SEGMENT_LEVELED_MOVES)
// 13502 
// 13503   /**
// 13504    * Prepare a segmented move on a CARTESIAN setup.
// 13505    *
// 13506    * This calls planner.buffer_line several times, adding
// 13507    * small incremental moves. This allows the planner to
// 13508    * apply more detailed bed leveling to the full move.
// 13509    */
// 13510   inline void segmented_line_to_destination(const float &fr_mm_s, const float segment_size=LEVELED_SEGMENT_LENGTH) {
// 13511 
// 13512     const float xdiff = destination[X_AXIS] - current_position[X_AXIS],
// 13513                 ydiff = destination[Y_AXIS] - current_position[Y_AXIS];
// 13514 
// 13515     // If the move is only in Z/E don't split up the move
// 13516     if (!xdiff && !ydiff) {
// 13517       planner.buffer_line_kinematic(destination, fr_mm_s, active_extruder);
// 13518       return;
// 13519     }
// 13520 
// 13521     // Remaining cartesian distances
// 13522     const float zdiff = destination[Z_AXIS] - current_position[Z_AXIS],
// 13523                 ediff = destination[E_AXIS] - current_position[E_AXIS];
// 13524 
// 13525     // Get the linear distance in XYZ
// 13526     // If the move is very short, check the E move distance
// 13527     // No E move either? Game over.
// 13528     float cartesian_mm = SQRT(sq(xdiff) + sq(ydiff) + sq(zdiff));
// 13529     if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = FABS(ediff);
// 13530     if (UNEAR_ZERO(cartesian_mm)) return;
// 13531 
// 13532     // The length divided by the segment size
// 13533     // At least one segment is required
// 13534     uint16_t segments = cartesian_mm / segment_size;
// 13535     NOLESS(segments, 1);
// 13536 
// 13537     // The approximate length of each segment
// 13538     const float inv_segments = 1.0 / float(segments),
// 13539                 segment_distance[XYZE] = {
// 13540                   xdiff * inv_segments,
// 13541                   ydiff * inv_segments,
// 13542                   zdiff * inv_segments,
// 13543                   ediff * inv_segments
// 13544                 };
// 13545 
// 13546     // SERIAL_ECHOPAIR("mm=", cartesian_mm);
// 13547     // SERIAL_ECHOLNPAIR(" segments=", segments);
// 13548 
// 13549     // Get the raw current position as starting point
// 13550     float raw[XYZE];
// 13551     COPY(raw, current_position);
// 13552 
// 13553     // Calculate and execute the segments
// 13554     while (--segments) {
// 13555       static millis_t next_idle_ms = millis() + 200UL;
// 13556       thermalManager.manage_heater();  // This returns immediately if not really needed.
// 13557       if (ELAPSED(millis(), next_idle_ms)) {
// 13558         next_idle_ms = millis() + 200UL;
// 13559         idle();
// 13560       }
// 13561       LOOP_XYZE(i) raw[i] += segment_distance[i];
// 13562       planner.buffer_line_kinematic(raw, fr_mm_s, active_extruder);
// 13563     }
// 13564 
// 13565     // Since segment_distance is only approximate,
// 13566     // the final move must be to the exact destination.
// 13567     planner.buffer_line_kinematic(destination, fr_mm_s, active_extruder);
// 13568   }
// 13569 
// 13570 #elif ENABLED(MESH_BED_LEVELING)
// 13571 
// 13572   /**
// 13573    * Prepare a mesh-leveled linear move in a Cartesian setup,
// 13574    * splitting the move where it crosses mesh borders.
// 13575    */
// 13576   void mesh_line_to_destination(const float fr_mm_s, uint8_t x_splits=0xFF, uint8_t y_splits=0xFF) {
// 13577     // Get current and destination cells for this line
// 13578     int cx1 = mbl.cell_index_x(current_position[X_AXIS]),
// 13579         cy1 = mbl.cell_index_y(current_position[Y_AXIS]),
// 13580         cx2 = mbl.cell_index_x(destination[X_AXIS]),
// 13581         cy2 = mbl.cell_index_y(destination[Y_AXIS]);
// 13582     NOMORE(cx1, GRID_MAX_POINTS_X - 2);
// 13583     NOMORE(cy1, GRID_MAX_POINTS_Y - 2);
// 13584     NOMORE(cx2, GRID_MAX_POINTS_X - 2);
// 13585     NOMORE(cy2, GRID_MAX_POINTS_Y - 2);
// 13586 
// 13587     // Start and end in the same cell? No split needed.
// 13588     if (cx1 == cx2 && cy1 == cy2) {
// 13589       buffer_line_to_destination(fr_mm_s);
// 13590       set_current_from_destination();
// 13591       return;
// 13592     }
// 13593 
// 13594     #define MBL_SEGMENT_END(A) (current_position[A ##_AXIS] + (destination[A ##_AXIS] - current_position[A ##_AXIS]) * normalized_dist)
// 13595 
// 13596     float normalized_dist, end[XYZE];
// 13597     const int8_t gcx = max(cx1, cx2), gcy = max(cy1, cy2);
// 13598 
// 13599     // Crosses on the X and not already split on this X?
// 13600     // The x_splits flags are insurance against rounding errors.
// 13601     if (cx2 != cx1 && TEST(x_splits, gcx)) {
// 13602       // Split on the X grid line
// 13603       CBI(x_splits, gcx);
// 13604       COPY(end, destination);
// 13605       destination[X_AXIS] = mbl.index_to_xpos[gcx];
// 13606       normalized_dist = (destination[X_AXIS] - current_position[X_AXIS]) / (end[X_AXIS] - current_position[X_AXIS]);
// 13607       destination[Y_AXIS] = MBL_SEGMENT_END(Y);
// 13608     }
// 13609     // Crosses on the Y and not already split on this Y?
// 13610     else if (cy2 != cy1 && TEST(y_splits, gcy)) {
// 13611       // Split on the Y grid line
// 13612       CBI(y_splits, gcy);
// 13613       COPY(end, destination);
// 13614       destination[Y_AXIS] = mbl.index_to_ypos[gcy];
// 13615       normalized_dist = (destination[Y_AXIS] - current_position[Y_AXIS]) / (end[Y_AXIS] - current_position[Y_AXIS]);
// 13616       destination[X_AXIS] = MBL_SEGMENT_END(X);
// 13617     }
// 13618     else {
// 13619       // Must already have been split on these border(s)
// 13620       buffer_line_to_destination(fr_mm_s);
// 13621       set_current_from_destination();
// 13622       return;
// 13623     }
// 13624 
// 13625     destination[Z_AXIS] = MBL_SEGMENT_END(Z);
// 13626     destination[E_AXIS] = MBL_SEGMENT_END(E);
// 13627 
// 13628     // Do the split and look for more borders
// 13629     mesh_line_to_destination(fr_mm_s, x_splits, y_splits);
// 13630 
// 13631     // Restore destination from stack
// 13632     COPY(destination, end);
// 13633     mesh_line_to_destination(fr_mm_s, x_splits, y_splits);
// 13634   }
// 13635 
// 13636 #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 13637 
// 13638   #define CELL_INDEX(A,V) ((V - bilinear_start[A##_AXIS]) * ABL_BG_FACTOR(A##_AXIS))
// 13639 
// 13640   /**
// 13641    * Prepare a bilinear-leveled linear move on Cartesian,
// 13642    * splitting the move where it crosses grid borders.
// 13643    */
// 13644   void bilinear_line_to_destination(const float fr_mm_s, uint16_t x_splits=0xFFFF, uint16_t y_splits=0xFFFF) {
// 13645     // Get current and destination cells for this line
// 13646     int cx1 = CELL_INDEX(X, current_position[X_AXIS]),
// 13647         cy1 = CELL_INDEX(Y, current_position[Y_AXIS]),
// 13648         cx2 = CELL_INDEX(X, destination[X_AXIS]),
// 13649         cy2 = CELL_INDEX(Y, destination[Y_AXIS]);
// 13650     cx1 = constrain(cx1, 0, ABL_BG_POINTS_X - 2);
// 13651     cy1 = constrain(cy1, 0, ABL_BG_POINTS_Y - 2);
// 13652     cx2 = constrain(cx2, 0, ABL_BG_POINTS_X - 2);
// 13653     cy2 = constrain(cy2, 0, ABL_BG_POINTS_Y - 2);
// 13654 
// 13655     // Start and end in the same cell? No split needed.
// 13656     if (cx1 == cx2 && cy1 == cy2) {
// 13657       buffer_line_to_destination(fr_mm_s);
// 13658       set_current_from_destination();
// 13659       return;
// 13660     }
// 13661 
// 13662     #define LINE_SEGMENT_END(A) (current_position[A ##_AXIS] + (destination[A ##_AXIS] - current_position[A ##_AXIS]) * normalized_dist)
// 13663 
// 13664     float normalized_dist, end[XYZE];
// 13665     const int8_t gcx = max(cx1, cx2), gcy = max(cy1, cy2);
// 13666 
// 13667     // Crosses on the X and not already split on this X?
// 13668     // The x_splits flags are insurance against rounding errors.
// 13669     if (cx2 != cx1 && TEST(x_splits, gcx)) {
// 13670       // Split on the X grid line
// 13671       CBI(x_splits, gcx);
// 13672       COPY(end, destination);
// 13673       destination[X_AXIS] = bilinear_start[X_AXIS] + ABL_BG_SPACING(X_AXIS) * gcx;
// 13674       normalized_dist = (destination[X_AXIS] - current_position[X_AXIS]) / (end[X_AXIS] - current_position[X_AXIS]);
// 13675       destination[Y_AXIS] = LINE_SEGMENT_END(Y);
// 13676     }
// 13677     // Crosses on the Y and not already split on this Y?
// 13678     else if (cy2 != cy1 && TEST(y_splits, gcy)) {
// 13679       // Split on the Y grid line
// 13680       CBI(y_splits, gcy);
// 13681       COPY(end, destination);
// 13682       destination[Y_AXIS] = bilinear_start[Y_AXIS] + ABL_BG_SPACING(Y_AXIS) * gcy;
// 13683       normalized_dist = (destination[Y_AXIS] - current_position[Y_AXIS]) / (end[Y_AXIS] - current_position[Y_AXIS]);
// 13684       destination[X_AXIS] = LINE_SEGMENT_END(X);
// 13685     }
// 13686     else {
// 13687       // Must already have been split on these border(s)
// 13688       buffer_line_to_destination(fr_mm_s);
// 13689       set_current_from_destination();
// 13690       return;
// 13691     }
// 13692 
// 13693     destination[Z_AXIS] = LINE_SEGMENT_END(Z);
// 13694     destination[E_AXIS] = LINE_SEGMENT_END(E);
// 13695 
// 13696     // Do the split and look for more borders
// 13697     bilinear_line_to_destination(fr_mm_s, x_splits, y_splits);
// 13698 
// 13699     // Restore destination from stack
// 13700     COPY(destination, end);
// 13701     bilinear_line_to_destination(fr_mm_s, x_splits, y_splits);
// 13702   }
// 13703 
// 13704 #endif // AUTO_BED_LEVELING_BILINEAR
// 13705 #endif // IS_CARTESIAN
// 13706 
// 13707 #if !UBL_SEGMENTED
// 13708 #if IS_KINEMATIC
// 13709 
// 13710   /**
// 13711    * Prepare a linear move in a DELTA or SCARA setup.
// 13712    *
// 13713    * This calls planner.buffer_line several times, adding
// 13714    * small incremental moves for DELTA or SCARA.
// 13715    *
// 13716    * For Unified Bed Leveling (Delta or Segmented Cartesian)
// 13717    * the ubl.prepare_segmented_line_to method replaces this.
// 13718    */
// 13719   inline bool prepare_kinematic_move_to(const float (&rtarget)[XYZE]) {
// 13720 
// 13721     // Get the top feedrate of the move in the XY plane
// 13722     const float _feedrate_mm_s = MMS_SCALED(feedrate_mm_s);
// 13723 
// 13724     const float xdiff = rtarget[X_AXIS] - current_position[X_AXIS],
// 13725                 ydiff = rtarget[Y_AXIS] - current_position[Y_AXIS];
// 13726 
// 13727     // If the move is only in Z/E don't split up the move
// 13728     if (!xdiff && !ydiff) {
// 13729       planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder);
// 13730       return false; // caller will update current_position
// 13731     }
// 13732 
// 13733     // Fail if attempting move outside printable radius
// 13734     if (!position_is_reachable(rtarget[X_AXIS], rtarget[Y_AXIS])) return true;
// 13735 
// 13736     // Remaining cartesian distances
// 13737     const float zdiff = rtarget[Z_AXIS] - current_position[Z_AXIS],
// 13738                 ediff = rtarget[E_AXIS] - current_position[E_AXIS];
// 13739 
// 13740     // Get the linear distance in XYZ
// 13741     // If the move is very short, check the E move distance
// 13742     // No E move either? Game over.
// 13743     float cartesian_mm = SQRT(sq(xdiff) + sq(ydiff) + sq(zdiff));
// 13744     if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = FABS(ediff);
// 13745     if (UNEAR_ZERO(cartesian_mm)) return true;
// 13746 
// 13747     // Minimum number of seconds to move the given distance
// 13748     const float seconds = cartesian_mm / _feedrate_mm_s;
// 13749 
// 13750     // The number of segments-per-second times the duration
// 13751     // gives the number of segments
// 13752     uint16_t segments = delta_segments_per_second * seconds;
// 13753 
// 13754     // For SCARA minimum segment size is 0.25mm
// 13755     #if IS_SCARA
// 13756       NOMORE(segments, cartesian_mm * 4);
// 13757     #endif
// 13758 
// 13759     // At least one segment is required
// 13760     NOLESS(segments, 1);
// 13761 
// 13762     // The approximate length of each segment
// 13763     const float inv_segments = 1.0 / float(segments),
// 13764                 segment_distance[XYZE] = {
// 13765                   xdiff * inv_segments,
// 13766                   ydiff * inv_segments,
// 13767                   zdiff * inv_segments,
// 13768                   ediff * inv_segments
// 13769                 };
// 13770 
// 13771     // SERIAL_ECHOPAIR("mm=", cartesian_mm);
// 13772     // SERIAL_ECHOPAIR(" seconds=", seconds);
// 13773     // SERIAL_ECHOLNPAIR(" segments=", segments);
// 13774 
// 13775     #if ENABLED(SCARA_FEEDRATE_SCALING)
// 13776       // SCARA needs to scale the feed rate from mm/s to degrees/s
// 13777       // i.e., Complete the angular vector in the given time.
// 13778       const float inv_segment_length = min(10.0, float(segments) / cartesian_mm), // 1/mm/segs
// 13779                   inverse_secs = inv_segment_length * _feedrate_mm_s;
// 13780       float oldA = stepper.get_axis_position_degrees(A_AXIS),
// 13781             oldB = stepper.get_axis_position_degrees(B_AXIS);
// 13782     #endif
// 13783 
// 13784     // Get the current position as starting point
// 13785     float raw[XYZE];
// 13786     COPY(raw, current_position);
// 13787 
// 13788 
// 13789     // Calculate and execute the segments
// 13790     while (--segments) {
// 13791 
// 13792       static millis_t next_idle_ms = millis() + 200UL;
// 13793       thermalManager.manage_heater();  // This returns immediately if not really needed.
// 13794       if (ELAPSED(millis(), next_idle_ms)) {
// 13795         next_idle_ms = millis() + 200UL;
// 13796         idle();
// 13797       }
// 13798 
// 13799       LOOP_XYZE(i) raw[i] += segment_distance[i];
// 13800       #if ENABLED(DELTA)
// 13801         DELTA_IK(raw); // Delta can inline its kinematics
// 13802       #else
// 13803         inverse_kinematics(raw);
// 13804       #endif
// 13805 
// 13806       ADJUST_DELTA(raw); // Adjust Z if bed leveling is enabled
// 13807 
// 13808       #if ENABLED(SCARA_FEEDRATE_SCALING)
// 13809         // For SCARA scale the feed rate from mm/s to degrees/s
// 13810         // i.e., Complete the angular vector in the given time.
// 13811         planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
// 13812         oldA = delta[A_AXIS]; oldB = delta[B_AXIS];
// 13813       #else
// 13814           if (gCfgItems.breakpoint_reprint_flg == 1) 
// 13815           {
// 13816               if (rtarget[Z_AXIS] < gCfgItems.breakpoint_z_pos) 
// 13817               {
// 13818                   current_position[Z_AXIS] = rtarget[Z_AXIS];
// 13819                   current_position[E_AXIS] = destination[E_AXIS];
// 13820                   return;
// 13821               }
// 13822           }
// 13823         //gCfgItems.breakpoint_reprint_flg = 0;
// 13824         planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], _feedrate_mm_s, active_extruder);
// 13825       #endif
// 13826     }
// 13827 
// 13828     // Ensure last segment arrives at target location.
// 13829     #if ENABLED(SCARA_FEEDRATE_SCALING)
// 13830       inverse_kinematics(rtarget);
// 13831       ADJUST_DELTA(rtarget);
// 13832       planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], rtarget[Z_AXIS], rtarget[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
// 13833     #else
// 13834       planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder);
// 13835     #endif
// 13836 
// 13837     return false; // caller will update current_position
// 13838   }
// 13839 
// 13840 #else // !IS_KINEMATIC
// 13841 
// 13842   /**
// 13843    * Prepare a linear move in a Cartesian setup.
// 13844    *
// 13845    * When a mesh-based leveling system is active, moves are segmented
// 13846    * according to the configuration of the leveling system.
// 13847    *
// 13848    * Returns true if current_position[] was set to destination[]
// 13849    */
// 13850   inline bool prepare_move_to_destination_cartesian() {
// 13851     #if HAS_MESH
// 13852       if (planner.leveling_active && planner.leveling_active_at_z(destination[Z_AXIS])) {
// 13853         #if ENABLED(AUTO_BED_LEVELING_UBL)
// 13854           ubl.line_to_destination_cartesian(MMS_SCALED(feedrate_mm_s), active_extruder);  // UBL's motion routine needs to know about
// 13855           return true;                                                                    // all moves, including Z-only moves.
// 13856         #elif ENABLED(SEGMENT_LEVELED_MOVES)
// 13857           segmented_line_to_destination(MMS_SCALED(feedrate_mm_s));
// 13858           return false; // caller will update current_position
// 13859         #else
// 13860           /**
// 13861            * For MBL and ABL-BILINEAR only segment moves when X or Y are involved.
// 13862            * Otherwise fall through to do a direct single move.
// 13863            */
// 13864           if (current_position[X_AXIS] != destination[X_AXIS] || current_position[Y_AXIS] != destination[Y_AXIS]) {
// 13865             #if ENABLED(MESH_BED_LEVELING)
// 13866               mesh_line_to_destination(MMS_SCALED(feedrate_mm_s));
// 13867             #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 13868               bilinear_line_to_destination(MMS_SCALED(feedrate_mm_s));
// 13869             #endif
// 13870             return true;
// 13871           }
// 13872         #endif
// 13873       }
// 13874     #endif // HAS_MESH
// 13875 
// 13876     buffer_line_to_destination(MMS_SCALED(feedrate_mm_s));
// 13877     return false; // caller will update current_position
// 13878   }
// 13879 
// 13880 #endif // !IS_KINEMATIC
// 13881 #endif // !UBL_SEGMENTED
// 13882 
// 13883 #if ENABLED(DUAL_X_CARRIAGE)
// 13884 
// 13885   /**
// 13886    * Unpark the carriage, if needed
// 13887    */
// 13888   inline bool dual_x_carriage_unpark() {
// 13889     if (active_extruder_parked)
// 13890       switch (dual_x_carriage_mode) {
// 13891 
// 13892         case DXC_FULL_CONTROL_MODE: break;
// 13893 
// 13894         case DXC_AUTO_PARK_MODE:
// 13895           if (current_position[E_AXIS] == destination[E_AXIS]) {
// 13896             // This is a travel move (with no extrusion)
// 13897             // Skip it, but keep track of the current position
// 13898             // (so it can be used as the start of the next non-travel move)
// 13899             if (delayed_move_time != 0xFFFFFFFFUL) {
// 13900               set_current_from_destination();
// 13901               NOLESS(raised_parked_position[Z_AXIS], destination[Z_AXIS]);
// 13902               delayed_move_time = millis();
// 13903               return true;
// 13904             }
// 13905           }
// 13906           // unpark extruder: 1) raise, 2) move into starting XY position, 3) lower
// 13907           for (uint8_t i = 0; i < 3; i++)
// 13908             planner.buffer_line(
// 13909               i == 0 ? raised_parked_position[X_AXIS] : current_position[X_AXIS],
// 13910               i == 0 ? raised_parked_position[Y_AXIS] : current_position[Y_AXIS],
// 13911               i == 2 ? current_position[Z_AXIS] : raised_parked_position[Z_AXIS],
// 13912               current_position[E_AXIS],
// 13913               i == 1 ? PLANNER_XY_FEEDRATE() : planner.max_feedrate_mm_s[Z_AXIS],
// 13914               active_extruder
// 13915             );
// 13916           delayed_move_time = 0;
// 13917           active_extruder_parked = false;
// 13918           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 13919             if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Clear active_extruder_parked");
// 13920           #endif
// 13921           break;
// 13922 
// 13923         case DXC_DUPLICATION_MODE:
// 13924           if (active_extruder == 0) {
// 13925             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 13926               if (DEBUGGING(LEVELING)) {
// 13927                 SERIAL_ECHOPAIR("Set planner X", inactive_extruder_x_pos);
// 13928                 SERIAL_ECHOLNPAIR(" ... Line to X", current_position[X_AXIS] + duplicate_extruder_x_offset);
// 13929               }
// 13930             #endif
// 13931             // move duplicate extruder into correct duplication position.
// 13932             planner.set_position_mm(
// 13933               inactive_extruder_x_pos,
// 13934               current_position[Y_AXIS],
// 13935               current_position[Z_AXIS],
// 13936               current_position[E_AXIS]
// 13937             );
// 13938             planner.buffer_line(
// 13939               current_position[X_AXIS] + duplicate_extruder_x_offset,
// 13940               current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS],
// 13941               planner.max_feedrate_mm_s[X_AXIS], 1
// 13942             );
// 13943             SYNC_PLAN_POSITION_KINEMATIC();
// 13944             stepper.synchronize();
// 13945             extruder_duplication_enabled = true;
// 13946             active_extruder_parked = false;
// 13947             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 13948               if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Set extruder_duplication_enabled\nClear active_extruder_parked");
// 13949             #endif
// 13950           }
// 13951           else {
// 13952             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 13953               if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Active extruder not 0");
// 13954             #endif
// 13955           }
// 13956           break;
// 13957       }
// 13958     return false;
// 13959   }
// 13960 
// 13961 #endif // DUAL_X_CARRIAGE
// 13962 
// 13963 /**
// 13964  * Prepare a single move and get ready for the next one
// 13965  *
// 13966  * This may result in several calls to planner.buffer_line to
// 13967  * do smaller moves for DELTA, SCARA, mesh moves, etc.
// 13968  *
// 13969  * Make sure current_position[E] and destination[E] are good
// 13970  * before calling or cold/lengthy extrusion may get missed.
// 13971  */

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock52 Using cfiCommon0
          CFI Function _Z27prepare_move_to_destinationv
        THUMB
// 13972 void prepare_move_to_destination() {
_Z27prepare_move_to_destinationv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 13973   clamp_to_software_endstops(destination);
        LDR.N    R4,??DataTable111_1
        ADD      R0,R4,#+52
          CFI FunCall _Z26clamp_to_software_endstopsPf
        BL       _Z26clamp_to_software_endstopsPf
// 13974   refresh_cmd_timeout();
          CFI FunCall _Z19refresh_cmd_timeoutv
        BL       _Z19refresh_cmd_timeoutv
// 13975 
// 13976   #if ENABLED(PREVENT_COLD_EXTRUSION) || ENABLED(PREVENT_LENGTHY_EXTRUDE)
// 13977 
// 13978     if (!DEBUGGING(DRYRUN)) {
        LDRB     R0,[R4, #+15]
        LSLS     R0,R0,#+28
        BMI.N    ??prepare_move_to_destination_0
// 13979       if (destination[E_AXIS] != current_position[E_AXIS]) {
        VLDR     S0,[R4, #+48]
        VLDR     S1,[R4, #+64]
        VCMP.F32 S1,S0
        FMSTAT   
        BEQ.N    ??prepare_move_to_destination_0
// 13980         #if ENABLED(PREVENT_COLD_EXTRUSION)
// 13981           if (thermalManager.tooColdToExtrude(active_extruder)) {
// 13982             current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
// 13983             SERIAL_ECHO_START();
// 13984             SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
// 13985           }
// 13986         #endif // PREVENT_COLD_EXTRUSION
// 13987         #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
// 13988           if (FABS(destination[E_AXIS] - current_position[E_AXIS]) * planner.e_factor[active_extruder] > (EXTRUDE_MAXLENGTH)) {
        VSUB.F32 S0,S1,S0
        VABS.F32 S0,S0
        LDRB     R0,[R4, #+19]
        LDR.W    R1,??DataTable126_2
        ADD      R0,R1,R0, LSL #+2
        VLDR     S1,[R0, #0]
        VMUL.F32 S0,S0,S1
        VLDR.W   S1,??DataTable111_5  ;; 0x43480001
        VCMP.F32 S0,S1
        FMSTAT   
        BLT.N    ??prepare_move_to_destination_0
// 13989             current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
        LDR      R0,[R4, #+64]
        STR      R0,[R4, #+48]
// 13990             SERIAL_ECHO_START();
        LDR.W    R0,??DataTable127
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 13991             SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
        ADR.W    R0,`?<Constant " too long extrusion p...">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 13992           }
// 13993         #endif // PREVENT_LENGTHY_EXTRUDE
// 13994       }
// 13995     }
// 13996 
// 13997   #endif
// 13998 
// 13999   #if ENABLED(DUAL_X_CARRIAGE)
// 14000     if (dual_x_carriage_unpark()) return;
// 14001   #endif
// 14002 
// 14003   if (
// 14004     #if UBL_SEGMENTED
// 14005       ubl.prepare_segmented_line_to(destination, MMS_SCALED(feedrate_mm_s))
// 14006     #elif IS_KINEMATIC
// 14007       prepare_kinematic_move_to(destination)
// 14008     #else
// 14009       prepare_move_to_destination_cartesian()
// 14010     #endif
// 14011   ) return;
??prepare_move_to_destination_0:
          CFI FunCall _Z37prepare_move_to_destination_cartesianv
        BL       _Z37prepare_move_to_destination_cartesianv
        CMP      R0,#+0
        BNE.N    ??prepare_move_to_destination_1
// 14012 
// 14013   set_current_from_destination();
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z28set_current_from_destinationv
        B.W      _Z28set_current_from_destinationv
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??prepare_move_to_destination_1:
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock52
// 14014 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable111:
        DC32     serial_count

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable111_1:
        DC32     axis_relative_modes

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable111_2:
        DC32     0x43055555

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable111_3:
        DC8      0x6F, 0x6B, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable111_4:
        DC32     axis_relative_modes+0x2C

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable111_5:
        DC32     0x43480001

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable111_6:
        DC32     0x3ff80000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant " too long extrusion p...">`:
        DC8 " too long extrusion prevented\012"
        DC8 0
// 14015 
// 14016 #if ENABLED(ARC_SUPPORT)
// 14017 
// 14018   #if N_ARC_CORRECTION < 1
// 14019     #undef N_ARC_CORRECTION
// 14020     #define N_ARC_CORRECTION 1
// 14021   #endif
// 14022 
// 14023   /**
// 14024    * Plan an arc in 2 dimensions
// 14025    *
// 14026    * The arc is approximated by generating many small linear segments.
// 14027    * The length of each segment is configured in MM_PER_ARC_SEGMENT (Default 1mm)
// 14028    * Arcs should only be made relatively large (over 5mm), as larger arcs with
// 14029    * larger segments will tend to be more efficient. Your slicer should have
// 14030    * options for G2/G3 arc generation. In future these options may be GCode tunable.
// 14031    */

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock53 Using cfiCommon0
          CFI Function _Z8plan_arcRA4_KfRA2_S_b
        THUMB
// 14032   void plan_arc(
// 14033     const float (&cart)[XYZE], // Destination position
// 14034     const float (&offset)[2], // Center of rotation relative to current_position
// 14035     const bool clockwise      // Clockwise?
// 14036   ) {
_Z8plan_arcRA4_KfRA2_S_b:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        VPUSH    {D8-D12}
          CFI D12 Frame(CFA, -48)
          CFI D11 Frame(CFA, -56)
          CFI D10 Frame(CFA, -64)
          CFI D9 Frame(CFA, -72)
          CFI D8 Frame(CFA, -80)
          CFI CFA R13+80
        SUB      SP,SP,#+24
          CFI CFA R13+104
        MOV      R4,R0
        MOV      R8,R1
        MOV      R6,R2
// 14037     #if ENABLED(CNC_WORKSPACE_PLANES)
// 14038       AxisEnum p_axis, q_axis, l_axis;
// 14039       switch (workspace_plane) {
// 14040         default:
// 14041         case PLANE_XY: p_axis = X_AXIS; q_axis = Y_AXIS; l_axis = Z_AXIS; break;
// 14042         case PLANE_ZX: p_axis = Z_AXIS; q_axis = X_AXIS; l_axis = Y_AXIS; break;
// 14043         case PLANE_YZ: p_axis = Y_AXIS; q_axis = Z_AXIS; l_axis = X_AXIS; break;
// 14044       }
// 14045     #else
// 14046       constexpr AxisEnum p_axis = X_AXIS, q_axis = Y_AXIS, l_axis = Z_AXIS;
// 14047     #endif
// 14048 
// 14049     // Radius vector from center to current location
// 14050     float r_P = -offset[0], r_Q = -offset[1];
        VLDR     S0,[R8, #0]
        VNEG.F32 S16,S0
        VLDR     S0,[R8, #+4]
        VNEG.F32 S17,S0
// 14051 
// 14052     const float radius = HYPOT(r_P, r_Q),
        VMOV.F32 S0,S16
        MOVS     R0,#+2
        VMOV.F32 S18,#1.0
        VMOV.F32 S1,S18
        B.N      ??plan_arc_0
??plan_arc_1:
        VMUL.F32 S0,S0,S0
??plan_arc_0:
        LSLS     R1,R0,#+31
        BPL.N    ??plan_arc_2
        VMUL.F32 S1,S1,S0
??plan_arc_2:
        LSRS     R0,R0,#+1
        BNE.N    ??plan_arc_1
        VMOV.F32 S0,S17
        MOVS     R0,#+2
        VMOV.F32 S2,S18
        B.N      ??plan_arc_3
??plan_arc_4:
        VMUL.F32 S0,S0,S0
??plan_arc_3:
        LSLS     R1,R0,#+31
        BPL.N    ??plan_arc_5
        VMUL.F32 S2,S2,S0
??plan_arc_5:
        LSRS     R0,R0,#+1
        BNE.N    ??plan_arc_4
        VADD.F32 S0,S1,S2
          CFI FunCall sqrtf
        BL       sqrtf
        VMOV.F32 S23,S0
// 14053                 center_P = current_position[p_axis] - r_P,
        LDR.W    R5,??DataTable127_1
        VLDR     S0,[R5, #+36]
        VSUB.F32 S19,S0,S16
// 14054                 center_Q = current_position[q_axis] - r_Q,
        VLDR     S0,[R5, #+40]
        VSUB.F32 S20,S0,S17
// 14055                 rt_X = cart[p_axis] - center_P,
        VLDR     S0,[R4, #0]
        VSUB.F32 S2,S0,S19
// 14056                 rt_Y = cart[q_axis] - center_Q,
        VLDR     S0,[R4, #+4]
        VSUB.F32 S0,S0,S20
// 14057                 linear_travel = cart[l_axis] - current_position[l_axis],
        VLDR     S1,[R4, #+8]
        VLDR     S3,[R5, #+44]
        VSUB.F32 S22,S1,S3
// 14058                 extruder_travel = cart[E_AXIS] - current_position[E_AXIS];
        VLDR     S1,[R4, #+12]
        VLDR     S3,[R5, #+48]
        VSUB.F32 S21,S1,S3
// 14059 
// 14060     // CCW angle of rotation between position and target from the circle center. Only one atan2() trig computation required.
// 14061     float angular_travel = ATAN2(r_P * rt_Y - r_Q * rt_X, r_P * rt_X + r_Q * rt_Y);
        VMUL.F32 S1,S16,S2
        VMLA.F32 S1,S17,S0
        VMUL.F32 S0,S16,S0
        VMLS.F32 S0,S17,S2
          CFI FunCall atan2f
        BL       atan2f
        VMOV.F32 S24,S0
// 14062     if (angular_travel < 0) angular_travel += RADIANS(360);
        VCMP.F32 S24,#0.0
        FMSTAT   
        BPL.N    ??plan_arc_6
        VMOV     R0,S24
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable127_2  ;; 0x54442d18
        LDR.W    R3,??DataTable127_3  ;; 0x401921fb
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        VMOV     S24,R0
// 14063     if (clockwise) angular_travel -= RADIANS(360);
??plan_arc_6:
        CMP      R6,#+0
        BEQ.N    ??plan_arc_7
        VMOV     R0,S24
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable127_2  ;; 0x54442d18
        LDR.W    R3,??DataTable127_4  ;; 0xc01921fb
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        VMOV     S24,R0
// 14064 
// 14065     // Make a circle if the angular rotation is 0 and the target is current position
// 14066     if (angular_travel == 0 && current_position[p_axis] == cart[p_axis] && current_position[q_axis] == cart[q_axis])
??plan_arc_7:
        VCMP.F32 S24,#0.0
        FMSTAT   
        BNE.N    ??plan_arc_8
        VLDR     S0,[R5, #+36]
        VLDR     S1,[R4, #0]
        VCMP.F32 S0,S1
        FMSTAT   
        BNE.N    ??plan_arc_8
        VLDR     S0,[R5, #+40]
        VLDR     S1,[R4, #+4]
        VCMP.F32 S0,S1
        FMSTAT   
        BNE.N    ??plan_arc_8
// 14067       angular_travel = RADIANS(360);
        VLDR.W   S24,??DataTable115  ;; 0x40c90fdb
// 14068 
// 14069     const float mm_of_travel = HYPOT(angular_travel * radius, FABS(linear_travel));
??plan_arc_8:
        VMUL.F32 S0,S24,S23
        MOVS     R0,#+2
        VMOV.F32 S1,S18
        B.N      ??plan_arc_9
??plan_arc_10:
        VMUL.F32 S0,S0,S0
??plan_arc_9:
        LSLS     R1,R0,#+31
        BPL.N    ??plan_arc_11
        VMUL.F32 S1,S1,S0
??plan_arc_11:
        LSRS     R0,R0,#+1
        BNE.N    ??plan_arc_10
        VABS.F32 S0,S22
        MOVS     R0,#+2
        VMOV.F32 S2,S18
        B.N      ??plan_arc_12
??plan_arc_13:
        VMUL.F32 S0,S0,S0
??plan_arc_12:
        LSLS     R1,R0,#+31
        BPL.N    ??plan_arc_14
        VMUL.F32 S2,S2,S0
??plan_arc_14:
        LSRS     R0,R0,#+1
        BNE.N    ??plan_arc_13
        VADD.F32 S0,S1,S2
          CFI FunCall sqrtf
        BL       sqrtf
// 14070     if (mm_of_travel < 0.001) return;
        VLDR.W   S1,??DataTable116  ;; 0x3a83126f
        VCMP.F32 S0,S1
        FMSTAT   
        BMI.W    ??plan_arc_15
// 14071 
// 14072     uint16_t segments = FLOOR(mm_of_travel / (MM_PER_ARC_SEGMENT));
          CFI FunCall floorf
        BL       floorf
        VCVT.S32.F32 S0,S0
        VMOV     R6,S0
        UXTH     R6,R6
// 14073     NOLESS(segments, 1);
        CMP      R6,#+0
        BNE.N    ??plan_arc_16
        MOVS     R6,#+1
// 14074 
// 14075     /**
// 14076      * Vector rotation by transformation matrix: r is the original vector, r_T is the rotated vector,
// 14077      * and phi is the angle of rotation. Based on the solution approach by Jens Geisler.
// 14078      *     r_T = [cos(phi) -sin(phi);
// 14079      *            sin(phi)  cos(phi)] * r ;
// 14080      *
// 14081      * For arc generation, the center of the circle is the axis of rotation and the radius vector is
// 14082      * defined from the circle center to the initial position. Each line segment is formed by successive
// 14083      * vector rotations. This requires only two cos() and sin() computations to form the rotation
// 14084      * matrix for the duration of the entire arc. Error may accumulate from numerical round-off, since
// 14085      * all double numbers are single precision on the Arduino. (True double precision will not have
// 14086      * round off issues for CNC applications.) Single precision error can accumulate to be greater than
// 14087      * tool precision in some cases. Therefore, arc path correction is implemented.
// 14088      *
// 14089      * Small angle approximation may be used to reduce computation overhead further. This approximation
// 14090      * holds for everything, but very small circles and large MM_PER_ARC_SEGMENT values. In other words,
// 14091      * theta_per_segment would need to be greater than 0.1 rad and N_ARC_CORRECTION would need to be large
// 14092      * to cause an appreciable drift error. N_ARC_CORRECTION~=25 is more than small enough to correct for
// 14093      * numerical drift error. N_ARC_CORRECTION may be on the order a hundred(s) before error becomes an
// 14094      * issue for CNC machines with the single precision Arduino calculations.
// 14095      *
// 14096      * This approximation also allows plan_arc to immediately insert a line segment into the planner
// 14097      * without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
// 14098      * a correction, the planner should have caught up to the lag caused by the initial plan_arc overhead.
// 14099      * This is important when there are successive arc motions.
// 14100      */
// 14101     // Vector rotation matrix values
// 14102     float raw[XYZE];
// 14103     const float theta_per_segment = angular_travel / segments,
??plan_arc_16:
        MOV      R0,R6
        VMOV     S0,R0
        VCVT.F32.U32 S0,S0
        VDIV.F32 S23,S24,S0
// 14104                 linear_per_segment = linear_travel / segments,
        VDIV.F32 S22,S22,S0
// 14105                 extruder_per_segment = extruder_travel / segments,
        VDIV.F32 S21,S21,S0
// 14106                 sin_T = theta_per_segment,
// 14107                 cos_T = 1 - 0.5 * sq(theta_per_segment); // Small angle approximation
        VMOV.F32 S0,S23
        MOVS     R0,#+2
        B.N      ??plan_arc_17
??plan_arc_18:
        VMUL.F32 S0,S0,S0
??plan_arc_17:
        LSLS     R1,R0,#+31
        BPL.N    ??plan_arc_19
        VMUL.F32 S18,S18,S0
??plan_arc_19:
        LSRS     R0,R0,#+1
        BNE.N    ??plan_arc_18
        VMOV     R0,S18
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        LDR.W    R3,??DataTable127_5  ;; 0x3fe00000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R0
        MOV      R3,R1
        MOVS     R0,#+0
        LDR.W    R1,??DataTable127_6  ;; 0x3ff00000
          CFI FunCall __aeabi_dsub
        BL       __aeabi_dsub
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        VMOV     S18,R0
// 14108 
// 14109     // Initialize the linear axis
// 14110     raw[l_axis] = current_position[l_axis];
        ADD      R7,SP,#+4
        LDR      R0,[R5, #+44]
        STR      R0,[R7, #+8]
// 14111 
// 14112     // Initialize the extruder axis
// 14113     raw[E_AXIS] = current_position[E_AXIS];
        LDR      R0,[R5, #+48]
        STR      R0,[R7, #+12]
// 14114 
// 14115     const float fr_mm_s = MMS_SCALED(feedrate_mm_s);
        LDRSH    R0,[R5, #+32]
        VMOV     S0,R0
        VCVT.F32.S32 S0,S0
        VLDR     S1,[R5, #+120]
        VMUL.F32 S0,S0,S1
        VMOV     R0,S0
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable127_7  ;; 0x47ae147b
        LDR.W    R3,??DataTable131  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+0]
// 14116 
// 14117     millis_t next_idle_ms = millis() + 200UL;
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        ADD      R9,R0,#+200
// 14118 
// 14119     #if N_ARC_CORRECTION > 1
// 14120       int8_t arc_recalc_count = N_ARC_CORRECTION;
        MOV      R10,#+25
// 14121     #endif
// 14122 
// 14123     #if ENABLED(SCARA_FEEDRATE_SCALING)
// 14124       // SCARA needs to scale the feed rate from mm/s to degrees/s
// 14125       const float inv_segment_length = 1.0 / (MM_PER_ARC_SEGMENT),
// 14126                   inverse_secs = inv_segment_length * fr_mm_s;
// 14127       float oldA = stepper.get_axis_position_degrees(A_AXIS),
// 14128             oldB = stepper.get_axis_position_degrees(B_AXIS);
// 14129     #endif
// 14130 
// 14131     for (uint16_t i = 1; i < segments; i++) { // Iterate (segments-1) times
        MOV      R11,#+1
        B.N      ??plan_arc_20
// 14132 
// 14133       thermalManager.manage_heater();
// 14134       if (ELAPSED(millis(), next_idle_ms)) {
// 14135         next_idle_ms = millis() + 200UL;
// 14136         idle();
// 14137       }
// 14138 
// 14139       #if N_ARC_CORRECTION > 1
// 14140         if (--arc_recalc_count) {
// 14141           // Apply vector rotation matrix to previous r_P / 1
// 14142           const float r_new_Y = r_P * sin_T + r_Q * cos_T;
// 14143           r_P = r_P * cos_T - r_Q * sin_T;
// 14144           r_Q = r_new_Y;
// 14145         }
// 14146         else
// 14147       #endif
// 14148       {
// 14149         #if N_ARC_CORRECTION > 1
// 14150           arc_recalc_count = N_ARC_CORRECTION;
??plan_arc_21:
        MOV      R10,#+25
// 14151         #endif
// 14152 
// 14153         // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments.
// 14154         // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
// 14155         // To reduce stuttering, the sin and cos could be computed at different times.
// 14156         // For now, compute both at the same time.
// 14157         const float cos_Ti = cos(i * theta_per_segment), sin_Ti = sin(i * theta_per_segment);
        MOV      R0,R11
        VMOV     S0,R0
        VCVT.F32.U32 S0,S0
        VMUL.F32 S16,S0,S23
        VMOV.F32 S0,S16
          CFI FunCall cosf
        BL       cosf
        VMOV.F32 S24,S0
        VMOV.F32 S0,S16
          CFI FunCall sinf
        BL       sinf
// 14158         r_P = -offset[0] * cos_Ti + offset[1] * sin_Ti;
        VLDR     S1,[R8, #+4]
        VLDR     S2,[R8, #0]
        VMUL.F32 S16,S1,S0
        VMLS.F32 S16,S2,S24
// 14159         r_Q = -offset[0] * sin_Ti - offset[1] * cos_Ti;
        VNMUL.F32 S17,S2,S0
        VMLS.F32 S17,S1,S24
// 14160       }
// 14161 
// 14162       // Update raw location
// 14163       raw[p_axis] = center_P + r_P;
??plan_arc_22:
        VADD.F32 S0,S19,S16
        VSTR     S0,[SP, #+4]
// 14164       raw[q_axis] = center_Q + r_Q;
        VADD.F32 S0,S20,S17
        VSTR     S0,[R7, #+4]
// 14165       raw[l_axis] += linear_per_segment;
        VLDR     S0,[R7, #+8]
        VADD.F32 S0,S0,S22
        VSTR     S0,[R7, #+8]
// 14166       raw[E_AXIS] += extruder_per_segment;
        VLDR     S0,[R7, #+12]
        VADD.F32 S0,S0,S21
        VSTR     S0,[R7, #+12]
// 14167 
// 14168       clamp_to_software_endstops(raw);
        ADD      R0,SP,#+4
          CFI FunCall _Z26clamp_to_software_endstopsPf
        BL       _Z26clamp_to_software_endstopsPf
// 14169 
// 14170       #if ENABLED(SCARA_FEEDRATE_SCALING)
// 14171         // For SCARA scale the feed rate from mm/s to degrees/s
// 14172         // i.e., Complete the angular vector in the given time.
// 14173         inverse_kinematics(raw);
// 14174         ADJUST_DELTA(raw);
// 14175         planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
// 14176         oldA = delta[A_AXIS]; oldB = delta[B_AXIS];
// 14177       #else
// 14178         planner.buffer_line_kinematic(raw, fr_mm_s, active_extruder);
        LDRB     R2,[R5, #+19]
        ADD      R1,SP,#+0
        ADD      R0,SP,#+4
          CFI FunCall _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
        BL       _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
        ADD      R11,R11,#+1
        UXTH     R11,R11
??plan_arc_20:
        CMP      R11,R6
        BGE.N    ??plan_arc_23
          CFI FunCall _ZN11Temperature13manage_heaterEv
        BL       _ZN11Temperature13manage_heaterEv
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        SUBS     R0,R0,R9
        BMI.N    ??plan_arc_24
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        ADD      R9,R0,#+200
          CFI FunCall _Z4idlev
        BL       _Z4idlev
??plan_arc_24:
        SUB      R10,R10,#+1
        SXTB     R10,R10
        CMP      R10,#+0
        BEQ.N    ??plan_arc_21
        VMUL.F32 S0,S16,S23
        VMLA.F32 S0,S17,S18
        VMUL.F32 S16,S16,S18
        VMLS.F32 S16,S17,S23
        VMOV.F32 S17,S0
        B.N      ??plan_arc_22
// 14179       #endif
// 14180     }
// 14181 
// 14182     // Ensure last segment arrives at target location.
// 14183     #if ENABLED(SCARA_FEEDRATE_SCALING)
// 14184       inverse_kinematics(cart);
// 14185       ADJUST_DELTA(cart);
// 14186       planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], cart[Z_AXIS], cart[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
// 14187     #else
// 14188       planner.buffer_line_kinematic(cart, fr_mm_s, active_extruder);
??plan_arc_23:
        LDRB     R2,[R5, #+19]
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
        BL       _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
// 14189     #endif
// 14190 
// 14191     // As far as the parser is concerned, the position is now == target. In reality the
// 14192     // motion control system might still be processing the action and the real tool position
// 14193     // in any intermediate location.
// 14194     set_current_from_destination();
          CFI FunCall _Z28set_current_from_destinationv
        BL       _Z28set_current_from_destinationv
// 14195   } // plan_arc
??plan_arc_15:
        ADD      SP,SP,#+24
          CFI CFA R13+80
        VPOP     {D8-D12}
          CFI D8 SameValue
          CFI D9 SameValue
          CFI D10 SameValue
          CFI D11 SameValue
          CFI D12 SameValue
          CFI CFA R13+40
        POP      {R0,R4-R11,PC}   ;; return
          CFI EndBlock cfiBlock53
// 14196 
// 14197 #endif // ARC_SUPPORT
// 14198 
// 14199 #if ENABLED(BEZIER_CURVE_SUPPORT)
// 14200 
// 14201   void plan_cubic_move(const float (&offset)[4]) {
// 14202     cubic_b_spline(current_position, destination, offset, MMS_SCALED(feedrate_mm_s), active_extruder);
// 14203 
// 14204     // As far as the parser is concerned, the position is now == destination. In reality the
// 14205     // motion control system might still be processing the action and the real tool position
// 14206     // in any intermediate location.
// 14207     set_current_from_destination();
// 14208   }
// 14209 
// 14210 #endif // BEZIER_CURVE_SUPPORT
// 14211 
// 14212 #if ENABLED(USE_CONTROLLER_FAN)
// 14213 
// 14214   void controllerFan() {
// 14215     static millis_t lastMotorOn = 0, // Last time a motor was turned on
// 14216                     nextMotorCheck = 0; // Last time the state was checked
// 14217     const millis_t ms = millis();
// 14218     if (ELAPSED(ms, nextMotorCheck)) {
// 14219       nextMotorCheck = ms + 2500UL; // Not a time critical function, so only check every 2.5s
// 14220       if (X_ENABLE_READ == X_ENABLE_ON || Y_ENABLE_READ == Y_ENABLE_ON || Z_ENABLE_READ == Z_ENABLE_ON || thermalManager.soft_pwm_amount_bed > 0
// 14221           || E0_ENABLE_READ == E_ENABLE_ON // If any of the drivers are enabled...
// 14222           #if E_STEPPERS > 1
// 14223             || E1_ENABLE_READ == E_ENABLE_ON
// 14224             #if HAS_X2_ENABLE
// 14225               || X2_ENABLE_READ == X_ENABLE_ON
// 14226             #endif
// 14227             #if E_STEPPERS > 2
// 14228               || E2_ENABLE_READ == E_ENABLE_ON
// 14229               #if E_STEPPERS > 3
// 14230                 || E3_ENABLE_READ == E_ENABLE_ON
// 14231                 #if E_STEPPERS > 4
// 14232                   || E4_ENABLE_READ == E_ENABLE_ON
// 14233                 #endif // E_STEPPERS > 4
// 14234               #endif // E_STEPPERS > 3
// 14235             #endif // E_STEPPERS > 2
// 14236           #endif // E_STEPPERS > 1
// 14237       ) {
// 14238         lastMotorOn = ms; //... set time to NOW so the fan will turn on
// 14239       }
// 14240 
// 14241       // Fan off if no steppers have been enabled for CONTROLLERFAN_SECS seconds
// 14242       uint8_t speed = (!lastMotorOn || ELAPSED(ms, lastMotorOn + (CONTROLLERFAN_SECS) * 1000UL)) ? 0 : CONTROLLERFAN_SPEED;
// 14243 
// 14244       // allows digital or PWM fan output to be used (see M42 handling)
// 14245       WRITE(CONTROLLER_FAN_PIN, speed);
// 14246       analogWrite(CONTROLLER_FAN_PIN, speed);
// 14247     }
// 14248   }
// 14249 
// 14250 #endif // USE_CONTROLLER_FAN
// 14251 
// 14252 #if ENABLED(MORGAN_SCARA)
// 14253 
// 14254   /**
// 14255    * Morgan SCARA Forward Kinematics. Results in cartes[].
// 14256    * Maths and first version by QHARLEY.
// 14257    * Integrated into Marlin and slightly restructured by Joachim Cerny.
// 14258    */
// 14259   void forward_kinematics_SCARA(const float &a, const float &b) {
// 14260 
// 14261     float a_sin = sin(RADIANS(a)) * L1,
// 14262           a_cos = cos(RADIANS(a)) * L1,
// 14263           b_sin = sin(RADIANS(b)) * L2,
// 14264           b_cos = cos(RADIANS(b)) * L2;
// 14265 
// 14266     cartes[X_AXIS] = a_cos + b_cos + SCARA_OFFSET_X;  //theta
// 14267     cartes[Y_AXIS] = a_sin + b_sin + SCARA_OFFSET_Y;  //theta+phi
// 14268 
// 14269     /*
// 14270       SERIAL_ECHOPAIR("SCARA FK Angle a=", a);
// 14271       SERIAL_ECHOPAIR(" b=", b);
// 14272       SERIAL_ECHOPAIR(" a_sin=", a_sin);
// 14273       SERIAL_ECHOPAIR(" a_cos=", a_cos);
// 14274       SERIAL_ECHOPAIR(" b_sin=", b_sin);
// 14275       SERIAL_ECHOLNPAIR(" b_cos=", b_cos);
// 14276       SERIAL_ECHOPAIR(" cartes[X_AXIS]=", cartes[X_AXIS]);
// 14277       SERIAL_ECHOLNPAIR(" cartes[Y_AXIS]=", cartes[Y_AXIS]);
// 14278     //*/
// 14279   }
// 14280 
// 14281   /**
// 14282    * Morgan SCARA Inverse Kinematics. Results in delta[].
// 14283    *
// 14284    * See http://forums.reprap.org/read.php?185,283327
// 14285    *
// 14286    * Maths and first version by QHARLEY.
// 14287    * Integrated into Marlin and slightly restructured by Joachim Cerny.
// 14288    */
// 14289   void inverse_kinematics(const float raw[XYZ]) {
// 14290 
// 14291     static float C2, S2, SK1, SK2, THETA, PSI;
// 14292 
// 14293     float sx = raw[X_AXIS] - SCARA_OFFSET_X,  // Translate SCARA to standard X Y
// 14294           sy = raw[Y_AXIS] - SCARA_OFFSET_Y;  // With scaling factor.
// 14295 
// 14296     if (L1 == L2)
// 14297       C2 = HYPOT2(sx, sy) / L1_2_2 - 1;
// 14298     else
// 14299       C2 = (HYPOT2(sx, sy) - (L1_2 + L2_2)) / (2.0 * L1 * L2);
// 14300 
// 14301     S2 = SQRT(1 - sq(C2));
// 14302 
// 14303     // Unrotated Arm1 plus rotated Arm2 gives the distance from Center to End
// 14304     SK1 = L1 + L2 * C2;
// 14305 
// 14306     // Rotated Arm2 gives the distance from Arm1 to Arm2
// 14307     SK2 = L2 * S2;
// 14308 
// 14309     // Angle of Arm1 is the difference between Center-to-End angle and the Center-to-Elbow
// 14310     THETA = ATAN2(SK1, SK2) - ATAN2(sx, sy);
// 14311 
// 14312     // Angle of Arm2
// 14313     PSI = ATAN2(S2, C2);
// 14314 
// 14315     delta[A_AXIS] = DEGREES(THETA);        // theta is support arm angle
// 14316     delta[B_AXIS] = DEGREES(THETA + PSI);  // equal to sub arm angle (inverted motor)
// 14317     delta[C_AXIS] = raw[Z_AXIS];
// 14318 
// 14319     /*
// 14320       DEBUG_POS("SCARA IK", raw);
// 14321       DEBUG_POS("SCARA IK", delta);
// 14322       SERIAL_ECHOPAIR("  SCARA (x,y) ", sx);
// 14323       SERIAL_ECHOPAIR(",", sy);
// 14324       SERIAL_ECHOPAIR(" C2=", C2);
// 14325       SERIAL_ECHOPAIR(" S2=", S2);
// 14326       SERIAL_ECHOPAIR(" Theta=", THETA);
// 14327       SERIAL_ECHOLNPAIR(" Phi=", PHI);
// 14328     //*/
// 14329   }
// 14330 
// 14331 #endif // MORGAN_SCARA
// 14332 
// 14333 #if ENABLED(TEMP_STAT_LEDS)
// 14334 
// 14335   static bool red_led = false;
// 14336   static millis_t next_status_led_update_ms = 0;
// 14337 
// 14338   void handle_status_leds(void) {
// 14339     if (ELAPSED(millis(), next_status_led_update_ms)) {
// 14340       next_status_led_update_ms += 500; // Update every 0.5s
// 14341       float max_temp = 0.0;
// 14342       #if HAS_TEMP_BED
// 14343         max_temp = MAX3(max_temp, thermalManager.degTargetBed(), thermalManager.degBed());
// 14344       #endif
// 14345       HOTEND_LOOP()
// 14346         max_temp = MAX3(max_temp, thermalManager.degHotend(e), thermalManager.degTargetHotend(e));
// 14347       const bool new_led = (max_temp > 55.0) ? true : (max_temp < 54.0) ? false : red_led;
// 14348       if (new_led != red_led) {
// 14349         red_led = new_led;
// 14350         #if PIN_EXISTS(STAT_LED_RED)
// 14351           WRITE(STAT_LED_RED_PIN, new_led ? HIGH : LOW);
// 14352           #if PIN_EXISTS(STAT_LED_BLUE)
// 14353             WRITE(STAT_LED_BLUE_PIN, new_led ? LOW : HIGH);
// 14354           #endif
// 14355         #else
// 14356           WRITE(STAT_LED_BLUE_PIN, new_led ? HIGH : LOW);
// 14357         #endif
// 14358       }
// 14359     }
// 14360   }
// 14361 
// 14362 #endif
// 14363 
// 14364 #if ENABLED(FILAMENT_RUNOUT_SENSOR)
// 14365 
// 14366   void handle_filament_runout() {
// 14367     if (!filament_ran_out) {
// 14368       filament_ran_out = true;
// 14369       enqueue_and_echo_commands_P(PSTR(FILAMENT_RUNOUT_SCRIPT));
// 14370       stepper.synchronize();
// 14371     }
// 14372   }
// 14373 
// 14374 #endif // FILAMENT_RUNOUT_SENSOR
// 14375 
// 14376 #if ENABLED(FAST_PWM_FAN)
// 14377 
// 14378   void setPwmFrequency(uint8_t pin, int val) {
// 14379     val &= 0x07;
// 14380     switch (digitalPinToTimer(pin)) {
// 14381       #ifdef TCCR0A
// 14382         #if !AVR_AT90USB1286_FAMILY
// 14383           case TIMER0A:
// 14384         #endif
// 14385         case TIMER0B:                           //_SET_CS(0, val);
// 14386                                                   break;
// 14387       #endif
// 14388       #ifdef TCCR1A
// 14389         case TIMER1A: case TIMER1B:             //_SET_CS(1, val);
// 14390                                                   break;
// 14391       #endif
// 14392       #if defined(TCCR2) || defined(TCCR2A)
// 14393         #ifdef TCCR2
// 14394           case TIMER2:
// 14395         #endif
// 14396         #ifdef TCCR2A
// 14397           case TIMER2A: case TIMER2B:
// 14398         #endif
// 14399                                                   _SET_CS(2, val); break;
// 14400       #endif
// 14401       #ifdef TCCR3A
// 14402         case TIMER3A: case TIMER3B: case TIMER3C: _SET_CS(3, val); break;
// 14403       #endif
// 14404       #ifdef TCCR4A
// 14405         case TIMER4A: case TIMER4B: case TIMER4C: _SET_CS(4, val); break;
// 14406       #endif
// 14407       #ifdef TCCR5A
// 14408         case TIMER5A: case TIMER5B: case TIMER5C: _SET_CS(5, val); break;
// 14409       #endif
// 14410     }
// 14411   }
// 14412 
// 14413 #endif // FAST_PWM_FAN
// 14414 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock54 Using cfiCommon0
          CFI Function _Z19enable_all_steppersv
        THUMB
// 14415 void enable_all_steppers() {
// 14416   enable_X();
// 14417   enable_Y();
// 14418   enable_Z();
_Z19enable_all_steppersv:
        MOVS     R2,#+0
        LDR.W    R0,??DataTable128
        LDRH     R1,[R0, #+4]
        LDR.W    R0,??DataTable128_1
        LDR      R0,[R0, #+8]
          CFI FunCall HAL_GPIO_WritePin
        B.W      HAL_GPIO_WritePin
          CFI EndBlock cfiBlock54
// 14419   enable_E0();
// 14420   enable_E1();
// 14421   enable_E2();
// 14422   enable_E3();
// 14423   enable_E4();
// 14424 }
// 14425 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock55 Using cfiCommon0
          CFI Function _Z18disable_e_steppersv
          CFI NoCalls
        THUMB
// 14426 void disable_e_steppers() {
// 14427   disable_E0();
// 14428   disable_E1();
// 14429   disable_E2();
// 14430   disable_E3();
// 14431   disable_E4();
// 14432 }
_Z18disable_e_steppersv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock55
// 14433 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock56 Using cfiCommon0
          CFI Function _Z20disable_all_steppersv
        THUMB
// 14434 void disable_all_steppers() {
_Z20disable_all_steppersv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 14435   disable_X();
// 14436   disable_Y();
// 14437   disable_Z();
        MOVS     R2,#+1
        LDR.W    R0,??DataTable128
        LDRH     R1,[R0, #+4]
        LDR.W    R0,??DataTable128_1
        LDR      R0,[R0, #+8]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        LDR.W    R1,??DataTable127_1
        STRB     R0,[R1, #+10]
// 14438   disable_e_steppers();
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z18disable_e_steppersv
        B.N      _Z18disable_e_steppersv
          CFI EndBlock cfiBlock56
// 14439 }
// 14440 
// 14441 #if ENABLED(MONITOR_DRIVER_STATUS)
// 14442   /*
// 14443    * Check for over temperature or short to ground error flags.
// 14444    * Report and log warning of overtemperature condition.
// 14445    * Reduce driver current in a persistent otpw condition.
// 14446    * Keep track of otpw counter so we don't reduce current on a single instance,
// 14447    * and so we don't repeatedly report warning before the condition is cleared.
// 14448    */
// 14449 
// 14450   struct TMC_driver_data {
// 14451     uint32_t drv_status;
// 14452     bool is_otpw;
// 14453     bool is_ot;
// 14454     bool is_error;
// 14455   };
// 14456   #if ENABLED(HAVE_TMC2130)
// 14457     static uint32_t get_pwm_scale(TMC2130Stepper &st) { return st.PWM_SCALE(); }
// 14458     static uint8_t get_status_response(TMC2130Stepper &st) { return st.status_response&0xF; }
// 14459     static TMC_driver_data get_driver_data(TMC2130Stepper &st) {
// 14460       constexpr uint32_t OTPW_bm = 0x4000000UL;
// 14461       constexpr uint8_t OTPW_bp = 26;
// 14462       constexpr uint32_t OT_bm = 0x2000000UL;
// 14463       constexpr uint8_t OT_bp = 25;
// 14464       constexpr uint8_t DRIVER_ERROR_bm = 0x2UL;
// 14465       constexpr uint8_t DRIVER_ERROR_bp = 1;
// 14466       TMC_driver_data data;
// 14467       data.drv_status = st.DRV_STATUS();
// 14468       data.is_otpw = (data.drv_status & OTPW_bm)>>OTPW_bp;
// 14469       data.is_ot = (data.drv_status & OT_bm)>>OT_bp;
// 14470       data.is_error = (st.status_response & DRIVER_ERROR_bm)>>DRIVER_ERROR_bp;
// 14471       return data;
// 14472     }
// 14473   #endif
// 14474   #if ENABLED(HAVE_TMC2208)
// 14475     static uint32_t get_pwm_scale(TMC2208Stepper &st) { return st.pwm_scale_sum(); }
// 14476     static uint8_t get_status_response(TMC2208Stepper &st) {
// 14477       uint32_t drv_status = st.DRV_STATUS();
// 14478       uint8_t gstat = st.GSTAT();
// 14479       uint8_t response = 0;
// 14480       response |= (drv_status >> (31-3)) & 0b1000;
// 14481       response |= gstat & 0b11;
// 14482       return response;
// 14483     }
// 14484     static TMC_driver_data get_driver_data(TMC2208Stepper &st) {
// 14485       constexpr uint32_t OTPW_bm = 0b1ul;
// 14486       constexpr uint8_t OTPW_bp = 0;
// 14487       constexpr uint32_t OT_bm = 0b10ul;
// 14488       constexpr uint8_t OT_bp = 1;
// 14489       TMC_driver_data data;
// 14490       data.drv_status = st.DRV_STATUS();
// 14491       data.is_otpw = (data.drv_status & OTPW_bm)>>OTPW_bp;
// 14492       data.is_ot = (data.drv_status & OT_bm)>>OT_bp;
// 14493       data.is_error = st.drv_err();
// 14494       return data;
// 14495     }
// 14496   #endif
// 14497 
// 14498   template<typename TMC>
// 14499   uint8_t monitor_tmc_driver(TMC &st, const char axisID, uint8_t otpw_cnt) {
// 14500     TMC_driver_data data = get_driver_data(st);
// 14501 
// 14502     #if ENABLED(STOP_ON_ERROR)
// 14503       if (data.is_error) {
// 14504         SERIAL_EOL();
// 14505         SERIAL_ECHO(axisID);
// 14506         SERIAL_ECHO(" driver error detected:");
// 14507         if (data.is_ot) SERIAL_ECHO("\novertemperature");
// 14508         if (st.s2ga()) SERIAL_ECHO("\nshort to ground (coil A)");
// 14509         if (st.s2gb()) SERIAL_ECHO("\nshort to ground (coil B)");
// 14510         SERIAL_EOL();
// 14511         #if ENABLED(TMC_DEBUG)
// 14512           gcode_M122();
// 14513         #endif
// 14514         kill(PSTR("Driver error"));
// 14515       }
// 14516     #endif
// 14517 
// 14518     // Report if a warning was triggered
// 14519     if (data.is_otpw && otpw_cnt==0) {
// 14520       char timestamp[10];
// 14521       duration_t elapsed = print_job_timer.duration();
// 14522       const bool has_days = (elapsed.value > 60*60*24L);
// 14523       (void)elapsed.toDigital(timestamp, has_days);
// 14524       SERIAL_EOL();
// 14525       SERIAL_ECHO(timestamp);
// 14526       SERIAL_ECHOPGM(": ");
// 14527       SERIAL_ECHO(axisID);
// 14528       SERIAL_ECHOPGM(" driver overtemperature warning! (");
// 14529       SERIAL_ECHO(st.getCurrent());
// 14530       SERIAL_ECHOLN("mA)");
// 14531     }
// 14532     #if CURRENT_STEP_DOWN > 0
// 14533       // Decrease current if is_otpw is true and driver is enabled and there's been more then 4 warnings
// 14534       if (data.is_otpw && !st.isEnabled() && otpw_cnt > 4) {
// 14535         st.setCurrent(st.getCurrent() - CURRENT_STEP_DOWN, R_SENSE, HOLD_MULTIPLIER);
// 14536         #if ENABLED(REPORT_CURRENT_CHANGE)
// 14537           SERIAL_ECHO(axisID);
// 14538           SERIAL_ECHOLNPAIR(" current decreased to ", st.getCurrent());
// 14539         #endif
// 14540       }
// 14541     #endif
// 14542 
// 14543     if (data.is_otpw) {
// 14544       otpw_cnt++;
// 14545       st.flag_otpw = true;
// 14546     }
// 14547     else if (otpw_cnt>0) otpw_cnt--;
// 14548 
// 14549     if (report_tmc_status) {
// 14550       const uint32_t pwm_scale = get_pwm_scale(st);
// 14551       SERIAL_ECHO(axisID);
// 14552       SERIAL_ECHOPAIR(":", pwm_scale);
// 14553       SERIAL_ECHO(" |0b"); MYSERIAL.print(get_status_response(st), BIN);
// 14554       SERIAL_ECHO("| ");
// 14555       if (data.is_error) SERIAL_ECHO('E');
// 14556       else if (data.is_ot) SERIAL_ECHO('O');
// 14557       else if (data.is_otpw) SERIAL_ECHO('W');
// 14558       else if (otpw_cnt>0) MYSERIAL.print(otpw_cnt, DEC);
// 14559       else if (st.flag_otpw) SERIAL_ECHO('F');
// 14560       SERIAL_ECHO("\t");
// 14561     }
// 14562 
// 14563     return otpw_cnt;
// 14564   }
// 14565 
// 14566   void monitor_tmc_driver() {
// 14567     static millis_t next_cOT = 0;
// 14568     if (ELAPSED(millis(), next_cOT)) {
// 14569       next_cOT = millis() + 500;
// 14570       #if ENABLED(X_IS_TMC2130)|| (ENABLED(X_IS_TMC2208) && defined(X_HARDWARE_SERIAL)) || ENABLED(IS_TRAMS)
// 14571         static uint8_t x_otpw_cnt = 0;
// 14572         x_otpw_cnt = monitor_tmc_driver(stepperX, axis_codes[X_AXIS], x_otpw_cnt);
// 14573       #endif
// 14574       #if ENABLED(Y_IS_TMC2130)|| (ENABLED(Y_IS_TMC2208) && defined(Y_HARDWARE_SERIAL)) || ENABLED(IS_TRAMS)
// 14575         static uint8_t y_otpw_cnt = 0;
// 14576         y_otpw_cnt = monitor_tmc_driver(stepperY, axis_codes[Y_AXIS], y_otpw_cnt);
// 14577       #endif
// 14578       #if ENABLED(Z_IS_TMC2130)|| (ENABLED(Z_IS_TMC2208) && defined(Z_HARDWARE_SERIAL)) || ENABLED(IS_TRAMS)
// 14579         static uint8_t z_otpw_cnt = 0;
// 14580         z_otpw_cnt = monitor_tmc_driver(stepperZ, axis_codes[Z_AXIS], z_otpw_cnt);
// 14581       #endif
// 14582       #if ENABLED(X2_IS_TMC2130) || (ENABLED(X2_IS_TMC2208) && defined(X2_HARDWARE_SERIAL))
// 14583         static uint8_t x2_otpw_cnt = 0;
// 14584         x2_otpw_cnt = monitor_tmc_driver(stepperX2, axis_codes[X_AXIS], x2_otpw_cnt);
// 14585       #endif
// 14586       #if ENABLED(Y2_IS_TMC2130) || (ENABLED(Y2_IS_TMC2208) && defined(Y2_HARDWARE_SERIAL))
// 14587         static uint8_t y2_otpw_cnt = 0;
// 14588         y2_otpw_cnt = monitor_tmc_driver(stepperY2, axis_codes[Y_AXIS], y2_otpw_cnt);
// 14589       #endif
// 14590       #if ENABLED(Z2_IS_TMC2130) || (ENABLED(Z2_IS_TMC2208) && defined(Z2_HARDWARE_SERIAL))
// 14591         static uint8_t z2_otpw_cnt = 0;
// 14592         z2_otpw_cnt = monitor_tmc_driver(stepperZ2, axis_codes[Z_AXIS], z2_otpw_cnt);
// 14593       #endif
// 14594       #if ENABLED(E0_IS_TMC2130)|| (ENABLED(E0_IS_TMC2208) && defined(E0_HARDWARE_SERIAL)) || ENABLED(IS_TRAMS)
// 14595         static uint8_t e0_otpw_cnt = 0;
// 14596         e0_otpw_cnt = monitor_tmc_driver(stepperE0, axis_codes[E_AXIS], e0_otpw_cnt);
// 14597       #endif
// 14598       #if ENABLED(E1_IS_TMC2130) || (ENABLED(E1_IS_TMC2208) && defined(E1_HARDWARE_SERIAL))
// 14599         static uint8_t e1_otpw_cnt = 0;
// 14600         e1_otpw_cnt = monitor_tmc_driver(stepperE1, axis_codes[E_AXIS], e1_otpw_cnt);
// 14601       #endif
// 14602       #if ENABLED(E2_IS_TMC2130) || (ENABLED(E2_IS_TMC2208) && defined(E2_HARDWARE_SERIAL))
// 14603         static uint8_t e2_otpw_cnt = 0;
// 14604         e2_otpw_cnt = monitor_tmc_driver(stepperE2, axis_codes[E_AXIS], e2_otpw_cnt);
// 14605       #endif
// 14606       #if ENABLED(E3_IS_TMC2130) || (ENABLED(E3_IS_TMC2208) && defined(E3_HARDWARE_SERIAL))
// 14607         static uint8_t e3_otpw_cnt = 0;
// 14608         e3_otpw_cnt = monitor_tmc_driver(stepperE3, axis_codes[E_AXIS], e3_otpw_cnt);
// 14609       #endif
// 14610       #if ENABLED(E4_IS_TMC2130) || (ENABLED(E4_IS_TMC2208) && defined(E4_HARDWARE_SERIAL))
// 14611         static uint8_t e4_otpw_cnt = 0;
// 14612         e4_otpw_cnt = monitor_tmc_driver(stepperE4, axis_codes[E_AXIS], e4_otpw_cnt);
// 14613       #endif
// 14614 
// 14615       if (report_tmc_status) SERIAL_EOL();
// 14616     }
// 14617   }
// 14618 
// 14619 #endif // MONITOR_DRIVER_STATUS
// 14620 
// 14621 /**
// 14622  * Manage several activities:
// 14623  *  - Check for Filament Runout
// 14624  *  - Keep the command buffer full
// 14625  *  - Check for maximum inactive time between commands
// 14626  *  - Check for maximum inactive time between stepper commands
// 14627  *  - Check if pin CHDK needs to go LOW
// 14628  *  - Check for KILL button held down
// 14629  *  - Check for HOME button held down
// 14630  *  - Check if cooling fan needs to be switched on
// 14631  *  - Check if an idle but hot extruder needs filament extruded (EXTRUDER_RUNOUT_PREVENT)
// 14632  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock57 Using cfiCommon0
          CFI Function _Z17manage_inactivityb
        THUMB
// 14633 void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
_Z17manage_inactivityb:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        MOV      R4,R0
// 14634 
// 14635   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
// 14636     if ((IS_SD_PRINTING || print_job_timer.isRunning()) && (READ(FIL_RUNOUT_PIN) == FIL_RUNOUT_INVERTING))
// 14637       handle_filament_runout();
// 14638   #endif
// 14639 
// 14640   if (commands_in_queue < BUFSIZE) get_available_commands();
        LDR.W    R5,??DataTable127_1
        LDRB     R0,[R5, #+16]
        CMP      R0,#+4
        BGE.N    ??manage_inactivity_0
          CFI FunCall _Z22get_available_commandsv
        BL       _Z22get_available_commandsv
// 14641 
// 14642   const millis_t ms = millis();
??manage_inactivity_0:
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        MOV      R6,R0
// 14643 
// 14644   if (max_inactive_time && ELAPSED(ms, previous_cmd_ms + max_inactive_time)) {
        LDR.N    R7,??DataTable118
        LDR      R0,[R7, #+4]
        CMP      R0,#+0
        BEQ.N    ??manage_inactivity_1
        LDR      R1,[R7, #+0]
        SUBS     R1,R6,R1
        SUBS     R0,R1,R0
        BMI.N    ??manage_inactivity_1
// 14645     SERIAL_ERROR_START();
        LDR.W    R0,??DataTable132
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 14646     SERIAL_ECHOLNPAIR(MSG_KILL_INACTIVE_TIME, parser.command_ptr);
        LDR.W    R0,??DataTable130
        LDR      R1,[R0, #+0]
        ADR.W    R0,`?<Constant "KILL caused by too mu...">`
          CFI FunCall _Z17serial_echopair_PPKcS0_
        BL       _Z17serial_echopair_PPKcS0_
        MOVS     R1,#+10
        LDR.W    R0,??DataTable130_1
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 14647     kill(PSTR(MSG_KILLED));
        ADR.W    R0,`?<Constant "KILLED. ">`
          CFI FunCall _Z4killPKc
        BL       _Z4killPKc
// 14648   }
// 14649 
// 14650   // Prevent steppers timing-out in the middle of M600
// 14651   #if ENABLED(ADVANCED_PAUSE_FEATURE) && ENABLED(PAUSE_PARK_NO_STEPPER_TIMEOUT)
// 14652     #define MOVE_AWAY_TEST !move_away_flag
// 14653   #else
// 14654     #define MOVE_AWAY_TEST true
// 14655   #endif
// 14656 
// 14657   if (MOVE_AWAY_TEST && stepper_inactive_time && ELAPSED(ms, previous_cmd_ms + stepper_inactive_time)
// 14658       && !ignore_stepper_queue && !planner.blocks_queued()) {
??manage_inactivity_1:
        LDR      R0,[R7, #+8]
        CMP      R0,#+0
        BEQ.N    ??manage_inactivity_2
        LDR      R1,[R7, #+0]
        SUBS     R1,R6,R1
        SUBS     R0,R1,R0
        BMI.N    ??manage_inactivity_2
        CMP      R4,#+0
        BNE.N    ??manage_inactivity_2
          CFI FunCall _ZN7Planner13blocks_queuedEv
        BL       _ZN7Planner13blocks_queuedEv
        CMP      R0,#+0
        BNE.N    ??manage_inactivity_2
// 14659     #if ENABLED(DISABLE_INACTIVE_X)
// 14660       disable_X();
// 14661     #endif
// 14662     #if ENABLED(DISABLE_INACTIVE_Y)
// 14663       disable_Y();
// 14664     #endif
// 14665     #if ENABLED(DISABLE_INACTIVE_Z)
// 14666       disable_Z();
        MOVS     R2,#+1
        LDR.W    R0,??DataTable128
        LDRH     R1,[R0, #+4]
        LDR.W    R0,??DataTable128_1
        LDR      R0,[R0, #+8]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        STRB     R0,[R5, #+10]
// 14667     #endif
// 14668     #if ENABLED(DISABLE_INACTIVE_E)
// 14669       disable_e_steppers();
          CFI FunCall _Z18disable_e_steppersv
        BL       _Z18disable_e_steppersv
// 14670     #endif
// 14671     #if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(ULTIPANEL)  // Only needed with an LCD
// 14672       ubl.lcd_map_control = defer_return_to_status = false;
// 14673     #endif
// 14674   }
// 14675 
// 14676   #ifdef CHDK // Check if pin should be set to LOW after M240 set it to HIGH
// 14677     if (chdkActive && ELAPSED(ms, chdkHigh + CHDK_DELAY)) {
// 14678       chdkActive = false;
// 14679       WRITE(CHDK, LOW);
// 14680     }
// 14681   #endif
// 14682 
// 14683   #if HAS_KILL
// 14684 
// 14685     // Check if the kill button was pressed and wait just in case it was an accidental
// 14686     // key kill key press
// 14687     // -------------------------------------------------------------------------------
// 14688     static int killCount = 0;   // make the inactivity button a bit less responsive
// 14689     const int KILL_DELAY = 750;
// 14690     if (!READ(KILL_PIN))
// 14691       killCount++;
// 14692     else if (killCount > 0)
// 14693       killCount--;
// 14694 
// 14695     // Exceeded threshold and we can confirm that it was not accidental
// 14696     // KILL the machine
// 14697     // ----------------------------------------------------------------
// 14698     if (killCount >= KILL_DELAY) {
// 14699       SERIAL_ERROR_START();
// 14700       SERIAL_ERRORLNPGM(MSG_KILL_BUTTON);
// 14701       kill(PSTR(MSG_KILLED));
// 14702     }
// 14703   #endif
// 14704 
// 14705   #if HAS_HOME
// 14706     // Check to see if we have to home, use poor man's debouncer
// 14707     // ---------------------------------------------------------
// 14708     static int homeDebounceCount = 0;   // poor man's debouncing count
// 14709     const int HOME_DEBOUNCE_DELAY = 2500;
// 14710     if (!IS_SD_PRINTING && !READ(HOME_PIN)) {
// 14711       if (!homeDebounceCount) {
// 14712         enqueue_and_echo_commands_P(PSTR("G28"));
// 14713         LCD_MESSAGEPGM(MSG_AUTO_HOME);
// 14714       }
// 14715       if (homeDebounceCount < HOME_DEBOUNCE_DELAY)
// 14716         homeDebounceCount++;
// 14717       else
// 14718         homeDebounceCount = 0;
// 14719     }
// 14720   #endif
// 14721 
// 14722   #if ENABLED(USE_CONTROLLER_FAN)
// 14723     controllerFan(); // Check if fan should be turned on to cool stepper drivers down
// 14724   #endif
// 14725 
// 14726   #if ENABLED(EXTRUDER_RUNOUT_PREVENT)
// 14727     if (ELAPSED(ms, previous_cmd_ms + (EXTRUDER_RUNOUT_SECONDS) * 1000UL)
// 14728       && thermalManager.degHotend(active_extruder) > EXTRUDER_RUNOUT_MINTEMP) {
// 14729       #if ENABLED(SWITCHING_EXTRUDER)
// 14730         const bool oldstatus = E0_ENABLE_READ;
// 14731         enable_E0();
// 14732       #else // !SWITCHING_EXTRUDER
// 14733         bool oldstatus;
// 14734         switch (active_extruder) {
// 14735           default: oldstatus = E0_ENABLE_READ; enable_E0(); break;
// 14736           #if E_STEPPERS > 1
// 14737             case 1: oldstatus = E1_ENABLE_READ; enable_E1(); break;
// 14738             #if E_STEPPERS > 2
// 14739               case 2: oldstatus = E2_ENABLE_READ; enable_E2(); break;
// 14740               #if E_STEPPERS > 3
// 14741                 case 3: oldstatus = E3_ENABLE_READ; enable_E3(); break;
// 14742                 #if E_STEPPERS > 4
// 14743                   case 4: oldstatus = E4_ENABLE_READ; enable_E4(); break;
// 14744                 #endif // E_STEPPERS > 4
// 14745               #endif // E_STEPPERS > 3
// 14746             #endif // E_STEPPERS > 2
// 14747           #endif // E_STEPPERS > 1
// 14748         }
// 14749       #endif // !SWITCHING_EXTRUDER
// 14750 
// 14751       previous_cmd_ms = ms; // refresh_cmd_timeout()
// 14752 
// 14753       const float olde = current_position[E_AXIS];
// 14754       current_position[E_AXIS] += EXTRUDER_RUNOUT_EXTRUDE;
// 14755       planner.buffer_line_kinematic(current_position, MMM_TO_MMS(EXTRUDER_RUNOUT_SPEED), active_extruder);
// 14756       current_position[E_AXIS] = olde;
// 14757       planner.set_e_position_mm(olde);
// 14758       stepper.synchronize();
// 14759       #if ENABLED(SWITCHING_EXTRUDER)
// 14760         E0_ENABLE_WRITE(oldstatus);
// 14761       #else
// 14762         switch (active_extruder) {
// 14763           case 0: E0_ENABLE_WRITE(oldstatus); break;
// 14764           #if E_STEPPERS > 1
// 14765             case 1: E1_ENABLE_WRITE(oldstatus); break;
// 14766             #if E_STEPPERS > 2
// 14767               case 2: E2_ENABLE_WRITE(oldstatus); break;
// 14768               #if E_STEPPERS > 3
// 14769                 case 3: E3_ENABLE_WRITE(oldstatus); break;
// 14770                 #if E_STEPPERS > 4
// 14771                   case 4: E4_ENABLE_WRITE(oldstatus); break;
// 14772                 #endif // E_STEPPERS > 4
// 14773               #endif // E_STEPPERS > 3
// 14774             #endif // E_STEPPERS > 2
// 14775           #endif // E_STEPPERS > 1
// 14776         }
// 14777       #endif // !SWITCHING_EXTRUDER
// 14778     }
// 14779   #endif // EXTRUDER_RUNOUT_PREVENT
// 14780 
// 14781   #if ENABLED(DUAL_X_CARRIAGE)
// 14782     // handle delayed move timeout
// 14783     if (delayed_move_time && ELAPSED(ms, delayed_move_time + 1000UL) && IsRunning()) {
// 14784       // travel moves have been received so enact them
// 14785       delayed_move_time = 0xFFFFFFFFUL; // force moves to be done
// 14786       set_destination_from_current();
// 14787       prepare_move_to_destination();
// 14788     }
// 14789   #endif
// 14790 
// 14791   #if ENABLED(TEMP_STAT_LEDS)
// 14792     handle_status_leds();
// 14793   #endif
// 14794 
// 14795   #if ENABLED(MONITOR_DRIVER_STATUS)
// 14796     monitor_tmc_driver();
// 14797   #endif
// 14798 
// 14799   planner.check_axes_activity();
??manage_inactivity_2:
        POP      {R0,R4-R7,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Planner19check_axes_activityEv
        B.W      _ZN7Planner19check_axes_activityEv
          CFI EndBlock cfiBlock57
// 14800 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable115:
        DC32     0x40c90fdb

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable115_1:
        DC32     card+0x9C4

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "KILL caused by too mu...">`:
        DC8 4BH, 49H, 4CH, 4CH, 20H, 63H, 61H, 75H
        DC8 73H, 65H, 64H, 20H, 62H, 79H, 20H, 74H
        DC8 6FH, 6FH, 20H, 6DH, 75H, 63H, 68H, 20H
        DC8 69H, 6EH, 61H, 63H, 74H, 69H, 76H, 65H
        DC8 20H, 74H, 69H, 6DH, 65H, 20H, 2DH, 20H
        DC8 63H, 75H, 72H, 72H, 65H, 6EH, 74H, 20H
        DC8 63H, 6FH, 6DH, 6DH, 61H, 6EH, 64H, 3AH
        DC8 20H, 0
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "KILLED. ">`:
        DC8 "KILLED. "
        DC8 0, 0, 0
// 14801 
// 14802 /**
// 14803  * Standard idle routine keeps the machine alive
// 14804  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock58 Using cfiCommon0
          CFI Function _Z4idlev
        THUMB
// 14805 void idle(
// 14806   #if ENABLED(ADVANCED_PAUSE_FEATURE)
// 14807     bool no_stepper_sleep/*=false*/
// 14808   #endif
// 14809 ) {
_Z4idlev:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 14810   #if ENABLED(MAX7219_DEBUG)
// 14811     Max7219_idle_tasks();
// 14812   #endif  // MAX7219_DEBUG
// 14813 
// 14814 #if  DISABLED(MKS_DLP_BOARD)
// 14815   lcd_update();
// 14816 #endif
// 14817 
// 14818   host_keepalive();
// 14819 
// 14820   #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
// 14821     thermalManager.auto_report_temperatures();
// 14822   no use
// 14823   #endif
// 14824 
// 14825   manage_inactivity(
// 14826     #if ENABLED(ADVANCED_PAUSE_FEATURE)
// 14827       no_stepper_sleep
// 14828     #endif
// 14829   );
        MOVS     R0,#+0
          CFI FunCall _Z17manage_inactivityb
        BL       _Z17manage_inactivityb
// 14830 
// 14831 #if  DISABLED(MKS_DLP_BOARD)
// 14832   thermalManager.manage_heater();
// 14833 #endif
// 14834 
// 14835   #if ENABLED(PRINTCOUNTER)
// 14836     print_job_timer.tick();
// 14837   #endif
// 14838 
// 14839   #if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
// 14840     buzzer.tick();
// 14841   no use
// 14842   #endif
// 14843   
// 14844 #if  DISABLED(MKS_DLP_BOARD)
// 14845   display_temper_error();
// 14846 #endif
// 14847 
// 14848   wifi_looping();
          CFI FunCall _Z12wifi_loopingv
        BL       _Z12wifi_loopingv
// 14849   
// 14850   if(wifi_link_state != WIFI_TRANS_FILE)
        LDR.W    R0,??DataTable132_1
        LDRSB    R0,[R0, #+0]
        CMP      R0,#+16
        BEQ.N    ??idle_0
// 14851   {
// 14852 	  GUI_RefreshPage();
          CFI FunCall GUI_RefreshPage
        BL       GUI_RefreshPage
// 14853   }
// 14854   #if defined(TFT70)
// 14855   disp_pre_gcode(3,40);
// 14856   #elif defined(TFT35)
// 14857   if(preview_no_display != 1)
??idle_0:
        LDR.W    R0,??DataTable132_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BEQ.N    ??idle_1
// 14858   {
// 14859 	  disp_pre_gcode(25,15);
        MOVS     R1,#+15
        MOVS     R0,#+25
          CFI FunCall disp_pre_gcode
        BL       disp_pre_gcode
// 14860   }
// 14861   #endif
// 14862   
// 14863   GUI_TOUCH_Exec(); 	  
??idle_1:
          CFI FunCall GUI_TOUCH_Exec
        BL       GUI_TOUCH_Exec
// 14864   GUI_Exec(); 
          CFI FunCall GUI_Exec
        BL       GUI_Exec
// 14865   //mksdlp.buzzer_polling();
// 14866   mksdlp.PrintStatePolling();
        LDR.W    R0,??DataTable135
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7MKS_DLP17PrintStatePollingEv
        B.W      _ZN7MKS_DLP17PrintStatePollingEv
          CFI EndBlock cfiBlock58
// 14867   #if ENABLED(I2C_POSITION_ENCODERS)
// 14868     if (planner.blocks_queued() &&
// 14869         ( (blockBufferIndexRef != planner.block_buffer_head) ||
// 14870           ((lastUpdateMillis + I2CPE_MIN_UPD_TIME_MS) < millis())) ) {
// 14871       blockBufferIndexRef = planner.block_buffer_head;
// 14872       I2CPEM.update();
// 14873       lastUpdateMillis = millis();
// 14874     }
// 14875   #endif
// 14876 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable116:
        DC32     0x3a83126f
// 14877 
// 14878 extern "C" void kill_c(const char* lcd_msg);

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock59 Using cfiCommon0
          CFI Function kill_c
        THUMB
// 14879 void kill_c(const char* lcd_msg) {
kill_c:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 14880   SERIAL_ERROR_START();
        LDR.W    R0,??DataTable132
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 14881   SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
        ADR.W    R0,`?<Constant "Printer halted. kill(...">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 14882 
// 14883   thermalManager.disable_all_heaters();
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
// 14884   disable_all_steppers();
          CFI FunCall _Z20disable_all_steppersv
        BL       _Z20disable_all_steppersv
// 14885 
// 14886   #if ENABLED(ULTRA_LCD)
// 14887     kill_screen(lcd_msg);
// 14888   #else
// 14889     UNUSED(lcd_msg);
// 14890   #endif
// 14891 
// 14892   _delay_ms(600); // Wait a short time (allows messages to get out before shutting down.
        MOV      R0,#+600
          CFI FunCall HAL_Delay
        BL       HAL_Delay
// 14893   cli(); // Stop interrupts
        cpsid i
// 14894 
// 14895   _delay_ms(250); //Wait to ensure all interrupts routines stopped
        MOVS     R0,#+250
          CFI FunCall HAL_Delay
        BL       HAL_Delay
// 14896   thermalManager.disable_all_heaters(); //turn off heaters again
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
// 14897 
// 14898   #if HAS_POWER_SWITCH
// 14899     SET_INPUT(PS_ON_PIN);
// 14900   #endif
// 14901 
// 14902   suicide();
          CFI FunCall _Z7suicidev
        BL       _Z7suicidev
// 14903   while (1) {
??kill_c_0:
        B.N      ??kill_c_0
          CFI EndBlock cfiBlock59
// 14904     #if ENABLED(USE_WATCHDOG)
// 14905       watchdog_reset();
// 14906     #endif
// 14907   } // Wait for reset
// 14908 }
// 14909 #if 1

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock60 Using cfiCommon0
          CFI Function _Z17temper_error_killv
        THUMB
// 14910 void temper_error_kill()
// 14911 {
_Z17temper_error_killv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 14912   SERIAL_ERROR_START();
        LDR.W    R0,??DataTable132
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 14913   SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
        ADR.W    R0,`?<Constant "Printer halted. kill(...">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 14914 
// 14915   thermalManager.disable_all_heaters();
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
// 14916   disable_all_steppers();	
          CFI FunCall _Z20disable_all_steppersv
        BL       _Z20disable_all_steppersv
// 14917 
// 14918   _delay_ms(600);
        MOV      R0,#+600
          CFI FunCall HAL_Delay
        BL       HAL_Delay
// 14919 
// 14920   temper_error_flg = 1;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable128_2
        STRB     R0,[R1, #+12]
// 14921 }
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock60

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable118:
        DC32     previous_cmd_ms
// 14922 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock61 Using cfiCommon0
          CFI Function _Z20display_temper_errorv
        THUMB
// 14923 void display_temper_error()
// 14924 {
_Z20display_temper_errorv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 14925 	if(temper_error_flg == 1)
        LDR.W    R0,??DataTable127_1
        LDRB     R1,[R0, #+12]
        CMP      R1,#+1
        BNE.N    ??display_temper_error_0
// 14926 	{
// 14927 		card.sdprinting = false;
        MOVS     R1,#+0
        LDR.N    R2,??DataTable122
        STRB     R1,[R2, #+2488]
// 14928 		wait_for_heatup = false;
        STRB     R1,[R0, #+21]
// 14929 		
// 14930 		GUI_SetBkColor(gCfgItems.background_color);
        LDR.N    R4,??DataTable121_2
        LDR      R0,[R4, #+4]
          CFI FunCall GUI_SetBkColor
        BL       GUI_SetBkColor
// 14931 		GUI_SetColor(0X0000ff);//	o¨¬¨¦?¡Á?¨¬?
        MOVS     R0,#+255
          CFI FunCall GUI_SetColor
        BL       GUI_SetColor
// 14932 		GUI_DispStringAt("Error",380, TITLE_YPOS);
        LDR.W    R0,??DataTable136
        LDRH     R2,[R0, #+14]
        MOV      R1,#+380
        ADR.W    R0,`?<Constant "Error">`
          CFI FunCall GUI_DispStringAt
        BL       GUI_DispStringAt
// 14933 		GUI_SetBkColor(gCfgItems.background_color);
        LDR      R0,[R4, #+4]
          CFI FunCall GUI_SetBkColor
        BL       GUI_SetBkColor
// 14934 		GUI_SetColor(gCfgItems.title_color);			
        LDR      R0,[R4, #+88]
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall GUI_SetColor
        B.W      GUI_SetColor
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 14935 	}
// 14936 }
??display_temper_error_0:
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock61

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Error">`:
        DC8 "Error"
        DC8 0, 0
// 14937 
// 14938 #endif
// 14939 
// 14940 /**
// 14941  * Kill all activity and lock the machine.
// 14942  * After this the machine will need to be reset.
// 14943  */

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock62 Using cfiCommon0
          CFI Function _Z4killPKc
        THUMB
// 14944 void kill(const char* lcd_msg) {
_Z4killPKc:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 14945   SERIAL_ERROR_START();
        LDR.W    R0,??DataTable132
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 14946   SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
        ADR.W    R0,`?<Constant "Printer halted. kill(...">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 14947 
// 14948   thermalManager.disable_all_heaters();
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
// 14949   disable_all_steppers();
          CFI FunCall _Z20disable_all_steppersv
        BL       _Z20disable_all_steppersv
// 14950 
// 14951   #if ENABLED(ULTRA_LCD)
// 14952     kill_screen(lcd_msg);
// 14953   #else
// 14954     UNUSED(lcd_msg);
// 14955   #endif
// 14956 
// 14957   _delay_ms(600); // Wait a short time (allows messages to get out before shutting down.
        MOV      R0,#+600
          CFI FunCall HAL_Delay
        BL       HAL_Delay
// 14958  
// 14959 
// 14960   _delay_ms(250); //Wait to ensure all interrupts routines stopped
        MOVS     R0,#+250
          CFI FunCall HAL_Delay
        BL       HAL_Delay
// 14961    cli(); // Stop interrupts
        cpsid i
// 14962   thermalManager.disable_all_heaters(); //turn off heaters again
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
// 14963 
// 14964   #ifdef ACTION_ON_KILL
// 14965     SERIAL_ECHOLNPGM("//action:" ACTION_ON_KILL);
// 14966   #endif
// 14967 
// 14968   #if HAS_POWER_SWITCH
// 14969     SET_INPUT(PS_ON_PIN);
// 14970   #endif
// 14971 
// 14972   suicide();
          CFI FunCall _Z7suicidev
        BL       _Z7suicidev
// 14973   while (1) {
??kill_0:
        B.N      ??kill_0
          CFI EndBlock cfiBlock62
// 14974     #if ENABLED(USE_WATCHDOG)
// 14975       watchdog_reset();
// 14976     #endif
// 14977   } // Wait for reset
// 14978 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Printer halted. kill(...">`:
        DC8 "Printer halted. kill() called!\012"
// 14979 
// 14980 /**
// 14981  * Turn off heaters and stop the print in progress
// 14982  * After a stop the machine may be resumed with M999
// 14983  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock63 Using cfiCommon0
          CFI Function _Z4stopv
        THUMB
// 14984 void stop() {
_Z4stopv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 14985   thermalManager.disable_all_heaters(); // 'unpause' taken care of in here
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
// 14986 
// 14987   #if ENABLED(PROBING_FANS_OFF)
// 14988     if (fans_paused) fans_pause(false); // put things back the way they were
// 14989   #endif
// 14990 
// 14991   if (IsRunning()) {
          CFI FunCall _Z9IsRunningv
        BL       _Z9IsRunningv
        CMP      R0,#+0
        BEQ.N    ??stop_0
// 14992     Stopped_gcode_LastN = gcode_LastN; // Save last g_code for restart
        LDR.W    R4,??DataTable127_1
        LDR      R0,[R4, #+112]
        STR      R0,[R4, #+116]
// 14993     SERIAL_ERROR_START();
        LDR.W    R0,??DataTable132
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 14994     SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
        ADR.W    R0,`?<Constant "Printer stopped due t...">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 14995     LCD_MESSAGEPGM(MSG_STOPPED);
        MOVS     R1,#+0
        ADR.W    R0,`?<Constant "STOPPED. ">`
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
// 14996     safe_delay(350);       // allow enough time for messages to get out before stopping
        MOV      R0,#+350
          CFI FunCall _Z10safe_delaym
        BL       _Z10safe_delaym
// 14997     Running = false;
        MOVS     R0,#+0
        STRB     R0,[R4, #+14]
// 14998   }
// 14999 }
??stop_0:
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock63

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable121:
        DC32     _ZN11GCodeParser14command_letterE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable121_1:
        DC32     _ZN11GCodeParser7codenumE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable121_2:
        DC32     gCfgItems

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Printer stopped due t...">`:
        DC8 50H, 72H, 69H, 6EH, 74H, 65H, 72H, 20H
        DC8 73H, 74H, 6FH, 70H, 70H, 65H, 64H, 20H
        DC8 64H, 75H, 65H, 20H, 74H, 6FH, 20H, 65H
        DC8 72H, 72H, 6FH, 72H, 73H, 2EH, 20H, 46H
        DC8 69H, 78H, 20H, 74H, 68H, 65H, 20H, 65H
        DC8 72H, 72H, 6FH, 72H, 20H, 61H, 6EH, 64H
        DC8 20H, 75H, 73H, 65H, 20H, 4DH, 39H, 39H
        DC8 39H, 20H, 74H, 6FH, 20H, 72H, 65H, 73H
        DC8 74H, 61H, 72H, 74H, 2EH, 20H, 28H, 54H
        DC8 65H, 6DH, 70H, 65H, 72H, 61H, 74H, 75H
        DC8 72H, 65H, 20H, 69H, 73H, 20H, 72H, 65H
        DC8 73H, 65H, 74H, 2EH, 20H, 53H, 65H, 74H
        DC8 20H, 69H, 74H, 20H, 61H, 66H, 74H, 65H
        DC8 72H, 20H, 72H, 65H, 73H, 74H, 61H, 72H
        DC8 74H, 69H, 6EH, 67H, 29H, 0AH, 0
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "STOPPED. ">`:
        DC8 "STOPPED. "
        DC8 0, 0
// 15000 
// 15001 /**
// 15002  * Marlin entry-point: Set up before the program loop
// 15003  *  - Set up the kill pin, filament runout, power hold
// 15004  *  - Start the serial port
// 15005  *  - Print startup messages and diagnostics
// 15006  *  - Get EEPROM or default settings
// 15007  *  - Initialize managers for:
// 15008  *    â¢ temperature
// 15009  *    â¢ planner
// 15010  *    â¢ watchdog
// 15011  *    â¢ stepper
// 15012  *    â¢ photo pin
// 15013  *    â¢ servos
// 15014  *    â¢ LCD controller
// 15015  *    â¢ Digipot I2C
// 15016  *    â¢ Z probe sled
// 15017  *    â¢ status LEDs
// 15018  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock64 Using cfiCommon0
          CFI Function setup
        THUMB
// 15019 void setup() {
setup:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
// 15020 
// 15021   #if ENABLED(MAX7219_DEBUG)
// 15022     Max7219_init();
// 15023   #endif
// 15024 /*
// 15025   #if ENABLED(DISABLE_JTAG)
// 15026     // Disable JTAG on AT90USB chips to free up pins for IO
// 15027     MCUCR = 0x80;
// 15028     MCUCR = 0x80;
// 15029   #endif
// 15030   */
// 15031 
// 15032   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
// 15033     setup_filrunoutpin();
// 15034   #endif
// 15035 
// 15036   setup_killpin();
          CFI FunCall _Z13setup_killpinv
        BL       _Z13setup_killpinv
// 15037 
// 15038   //setup_powerhold();
// 15039 
// 15040   #if HAS_STEPPER_RESET
// 15041     disableStepperDrivers();
// 15042   #endif
// 15043 
// 15044   //MYSERIAL.begin(BAUDRATE);
// 15045   //SERIAL_PROTOCOLLNPGM("start");
// 15046   //SERIAL_ECHO_START();
// 15047 
// 15048   #if ENABLED(HAVE_TMC2208)
// 15049     tmc2208_serial_begin();
// 15050   #endif
// 15051 
// 15052   // Check startup - does nothing if bootloader sets MCUSR to 0
// 15053   byte mcu = MCUSR;
// 15054   if (mcu &  1) SERIAL_ECHOLNPGM(MSG_POWERUP);
// 15055   if (mcu &  2) SERIAL_ECHOLNPGM(MSG_EXTERNAL_RESET);
// 15056   if (mcu &  4) SERIAL_ECHOLNPGM(MSG_BROWNOUT_RESET);
// 15057   if (mcu &  8) SERIAL_ECHOLNPGM(MSG_WATCHDOG_RESET);
// 15058   if (mcu & 32) SERIAL_ECHOLNPGM(MSG_SOFTWARE_RESET);
// 15059   //MCUSR = 0;
// 15060 
// 15061   SERIAL_ECHOPGM(MSG_MARLIN);
        ADR.W    R0,`?<Constant "MKS DLP">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15062   SERIAL_CHAR(' ');
        LDR.W    R4,??DataTable130_1
        MOVS     R1,#+32
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 15063   SERIAL_ECHOLNPGM(SHORT_BUILD_VERSION);
        ADR.W    R0,`?<Constant "1.0.0\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15064   SERIAL_EOL();
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 15065 
// 15066   #if defined(STRING_DISTRIBUTION_DATE) && defined(STRING_CONFIG_H_AUTHOR)
// 15067     SERIAL_ECHO_START();
        LDR.W    R5,??DataTable127
        MOV      R0,R5
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15068     SERIAL_ECHOPGM(MSG_CONFIGURATION_VER);
        ADR.W    R0,`?<Constant " Last Updated: ">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15069     SERIAL_ECHOPGM(STRING_DISTRIBUTION_DATE);
        ADR.W    R0,`?<Constant "2017-12-25 12:00">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15070     SERIAL_ECHOLNPGM(MSG_AUTHOR STRING_CONFIG_H_AUTHOR);
        ADR.W    R0,`?<Constant " | Author: (none, def...">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15071     SERIAL_ECHO_START();
        MOV      R0,R5
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15072     SERIAL_ECHOLNPGM("Compiled: " __DATE__);
        ADR.W    R0,`?<Constant "Compiled: Apr 16 2020\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15073   #endif
// 15074 
// 15075   SERIAL_ECHO_START();
        MOV      R0,R5
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15076   SERIAL_ECHOPAIR(MSG_FREE_MEMORY, freeMemory());
          CFI FunCall _Z10freeMemoryv
        BL       _Z10freeMemoryv
        MOV      R1,R0
        ADR.W    R0,`?<Constant " Free Memory: ">`
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
// 15077   SERIAL_ECHOLNPAIR(MSG_PLANNER_BUFFER_BYTES, (int)sizeof(block_t)*BLOCK_BUFFER_SIZE);
        MOV      R1,#+1344
        ADR.W    R0,`?<Constant "  PlannerBufferBytes: ">`
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 15078 
// 15079   // Send "ok" after commands by default
// 15080   for (int8_t i = 0; i < BUFSIZE; i++) send_ok[i] = true;
        MOVS     R0,#+0
        MOVS     R2,#+1
        LDR.W    R4,??DataTable127_1
        B.N      ??setup_0
??setup_1:
        ADDS     R1,R1,R4
        STRB     R2,[R1, #+28]
        ADDS     R0,R0,#+1
??setup_0:
        SXTB     R0,R0
        MOV      R1,R0
        CMP      R1,#+4
        BLT.N    ??setup_1
// 15081 
// 15082   // Load data from EEPROM if available (or use defaults)
// 15083   // This also updates variables in the planner, elsewhere
// 15084   (void)settings.load();
          CFI FunCall _ZN14MarlinSettings4loadEv
        BL       _ZN14MarlinSettings4loadEv
// 15085 
// 15086   #if HAS_M206_COMMAND
// 15087     // Initialize current position based on home_offset
// 15088     COPY(current_position, home_offset);
        MOVS     R2,#+12
        ADD      R1,R4,#+84
        ADD      R0,R4,#+36
          CFI FunCall memcpy
        BL       memcpy
// 15089   #else
// 15090     ZERO(current_position);
// 15091   #endif
// 15092 
// 15093   // Vital to init stepper/planner equivalent for current_position
// 15094   SYNC_PLAN_POSITION_KINEMATIC();
          CFI FunCall _Z18sync_plan_positionv
        BL       _Z18sync_plan_positionv
// 15095 
// 15096   thermalManager.init();    // Initialize temperature loop
        LDR.W    R0,??DataTable142
          CFI FunCall _ZN11Temperature4initEv
        BL       _ZN11Temperature4initEv
// 15097 
// 15098   #if ENABLED(USE_WATCHDOG)
// 15099     watchdog_init();
// 15100   #endif
// 15101   //tan add
// 15102   soft_endstop_min_init();
          CFI FunCall _Z21soft_endstop_min_initv
        BL       _Z21soft_endstop_min_initv
// 15103 
// 15104   stepper.init();    // Initialize stepper, this enables interrupts!
          CFI FunCall _ZN7Stepper4initEv
        BL       _ZN7Stepper4initEv
// 15105   servo_init();
          CFI FunCall _Z10servo_initv
        BL       _Z10servo_initv
// 15106 
// 15107   #if HAS_PHOTOGRAPH
// 15108     OUT_WRITE(PHOTOGRAPH_PIN, LOW);
// 15109   #endif
// 15110 
// 15111   #if HAS_CASE_LIGHT
// 15112     case_light_on = CASE_LIGHT_DEFAULT_ON;
// 15113     case_light_brightness = CASE_LIGHT_DEFAULT_BRIGHTNESS;
// 15114     update_case_light();
// 15115   #endif
// 15116 
// 15117   #if ENABLED(SPINDLE_LASER_ENABLE)
// 15118     OUT_WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);  // init spindle to off
// 15119     #if SPINDLE_DIR_CHANGE
// 15120       OUT_WRITE(SPINDLE_DIR_PIN, SPINDLE_INVERT_DIR ? 255 : 0);  // init rotation to clockwise (M3)
// 15121     #endif
// 15122     #if ENABLED(SPINDLE_LASER_PWM)
// 15123       SET_OUTPUT(SPINDLE_LASER_PWM_PIN);
// 15124       analogWrite(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);  // set to lowest speed
// 15125     #endif
// 15126   #endif
// 15127 
// 15128   #if HAS_BED_PROBE
// 15129     endstops.enable_z_probe(false);
// 15130   #endif
// 15131 
// 15132   #if ENABLED(USE_CONTROLLER_FAN)
// 15133     SET_OUTPUT(CONTROLLER_FAN_PIN); //Set pin used for driver cooling fan
// 15134   #endif
// 15135 
// 15136   #if HAS_STEPPER_RESET
// 15137     enableStepperDrivers();
// 15138   #endif
// 15139 
// 15140   #if ENABLED(DIGIPOT_I2C)
// 15141     digipot_i2c_init();
// 15142   #endif
// 15143 
// 15144   #if ENABLED(DAC_STEPPER_CURRENT)
// 15145     dac_init();
// 15146   #endif
// 15147 
// 15148   #if (ENABLED(Z_PROBE_SLED) || ENABLED(SOLENOID_PROBE)) && HAS_SOLENOID_1
// 15149     OUT_WRITE(SOL1_PIN, LOW); // turn it off
// 15150   #endif
// 15151 
// 15152   #if HAS_HOME
// 15153     SET_INPUT_PULLUP(HOME_PIN);
// 15154   #endif
// 15155 
// 15156   #if PIN_EXISTS(STAT_LED_RED)
// 15157     OUT_WRITE(STAT_LED_RED_PIN, LOW); // turn it off
// 15158   #endif
// 15159 
// 15160   #if PIN_EXISTS(STAT_LED_BLUE)
// 15161     OUT_WRITE(STAT_LED_BLUE_PIN, LOW); // turn it off
// 15162   #endif
// 15163 
// 15164   #if HAS_COLOR_LEDS
// 15165     leds.setup();
// 15166   #endif
// 15167 
// 15168   #if ENABLED(RGB_LED) || ENABLED(RGBW_LED)
// 15169     SET_OUTPUT(RGB_LED_R_PIN);
// 15170     SET_OUTPUT(RGB_LED_G_PIN);
// 15171     SET_OUTPUT(RGB_LED_B_PIN);
// 15172     #if ENABLED(RGBW_LED)
// 15173       SET_OUTPUT(RGB_LED_W_PIN);
// 15174     #endif
// 15175   #endif
// 15176 
// 15177   #if ENABLED(MK2_MULTIPLEXER)
// 15178     SET_OUTPUT(E_MUX0_PIN);
// 15179     SET_OUTPUT(E_MUX1_PIN);
// 15180     SET_OUTPUT(E_MUX2_PIN);
// 15181   #endif
// 15182 
// 15183   #if HAS_FANMUX
// 15184     fanmux_init();
// 15185   #endif
// 15186 
// 15187   lcd_init();
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z8lcd_initv
        B.W      _Z8lcd_initv
          CFI EndBlock cfiBlock64
// 15188 
// 15189   #if ENABLED(SHOW_BOOTSCREEN)
// 15190     lcd_bootscreen();
// 15191   #endif
// 15192 
// 15193   #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
// 15194     // Virtual Tools 0, 1, 2, 3 = Filament 1, 2, 3, 4, etc.
// 15195     for (uint8_t t = 0; t < MIXING_VIRTUAL_TOOLS && t < MIXING_STEPPERS; t++)
// 15196       for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
// 15197         mixing_virtual_tool_mix[t][i] = (t == i) ? 1.0 : 0.0;
// 15198 
// 15199     // Remaining virtual tools are 100% filament 1
// 15200     #if MIXING_STEPPERS < MIXING_VIRTUAL_TOOLS
// 15201       for (uint8_t t = MIXING_STEPPERS; t < MIXING_VIRTUAL_TOOLS; t++)
// 15202         for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
// 15203           mixing_virtual_tool_mix[t][i] = (i == 0) ? 1.0 : 0.0;
// 15204     #endif
// 15205 
// 15206     // Initialize mixing to tool 0 color
// 15207     for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
// 15208       mixing_factor[i] = mixing_virtual_tool_mix[0][i];
// 15209   #endif
// 15210 
// 15211   #if ENABLED(BLTOUCH)
// 15212     // Make sure any BLTouch error condition is cleared
// 15213     bltouch_command(BLTOUCH_RESET);
// 15214     set_bltouch_deployed(true);
// 15215     set_bltouch_deployed(false);
// 15216   #endif
// 15217 
// 15218   #if ENABLED(I2C_POSITION_ENCODERS)
// 15219     I2CPEM.init();
// 15220   #endif
// 15221 
// 15222   #if ENABLED(EXPERIMENTAL_I2CBUS) && I2C_SLAVE_ADDRESS > 0
// 15223     i2c.onReceive(i2c_on_receive);
// 15224     i2c.onRequest(i2c_on_request);
// 15225   #endif
// 15226 
// 15227   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
// 15228     setup_endstop_interrupts();
// 15229   #endif
// 15230 
// 15231   #if ENABLED(SWITCHING_EXTRUDER) && !DONT_SWITCH
// 15232     move_extruder_servo(0);  // Initialize extruder servo
// 15233   #endif
// 15234 
// 15235   #if ENABLED(SWITCHING_NOZZLE)
// 15236     move_nozzle_servo(0);  // Initialize nozzle servo
// 15237   #endif
// 15238 
// 15239   #if ENABLED(PARKING_EXTRUDER)
// 15240     #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
// 15241       pe_activate_magnet(0);
// 15242       pe_activate_magnet(1);
// 15243     #else
// 15244       pe_deactivate_magnet(0);
// 15245       pe_deactivate_magnet(1);
// 15246     #endif
// 15247   #endif
// 15248   #if ENABLED(MKS_12864OLED) || ENABLED(MKS_12864OLED_SSD1306)
// 15249     SET_OUTPUT(LCD_PINS_DC);
// 15250     OUT_WRITE(LCD_PINS_RS, LOW);
// 15251     delay(1000);
// 15252     WRITE(LCD_PINS_RS, HIGH);
// 15253   #endif
// 15254 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable122:
        DC32     card

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable122_1:
        DC32     curFileName

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "MKS DLP">`:
        DC8 "MKS DLP"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "1.0.0\\n">`:
        DC8 "1.0.0\012"
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant " Last Updated: ">`:
        DC8 " Last Updated: "

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "2017-12-25 12:00">`:
        DC8 "2017-12-25 12:00"
        DC8 0, 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant " | Author: (none, def...">`:
        DC8 " | Author: (none, default config)\012"
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Compiled: Apr 16 2020\\n">`:
        DC8 "Compiled: Apr 16 2020\012"
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant " Free Memory: ">`:
        DC8 " Free Memory: "
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "  PlannerBufferBytes: ">`:
        DC8 "  PlannerBufferBytes: "
        DC8 0
// 15255 
// 15256 /**
// 15257  * The main Marlin program loop
// 15258  *
// 15259  *  - Save or log commands to SD
// 15260  *  - Process available commands (if not saving)
// 15261  *  - Call heater manager
// 15262  *  - Call inactivity manager
// 15263  *  - Call endstop manager
// 15264  *  - Call LCD update
// 15265  */
// 15266 
// 15267 
// 15268 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock65 Using cfiCommon0
          CFI Function loop
        THUMB
// 15269 void loop() {
loop:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
// 15270 #if 0
// 15271 	display_temper_error();
// 15272 	
// 15273 	PowerOff_Filament_Check();
// 15274 	
// 15275 	MYSERIAL.MoremenuCmd();
// 15276 
// 15277 #endif
// 15278   if (commands_in_queue < BUFSIZE) get_available_commands();
        LDR.W    R4,??DataTable127_1
        LDRB     R0,[R4, #+16]
        CMP      R0,#+4
        BGE.N    ??loop_0
          CFI FunCall _Z22get_available_commandsv
        BL       _Z22get_available_commandsv
// 15279 
// 15280   mksdlp.get_available_bmps();
??loop_0:
        LDR.W    R5,??DataTable142_2
        ADDW     R0,R5,#+2500
          CFI FunCall _ZN7MKS_DLP18get_available_bmpsEv
        BL       _ZN7MKS_DLP18get_available_bmpsEv
// 15281 
// 15282 	
// 15283   #if 0//ENABLED(SDSUPPORT)
// 15284     card.checkautostart(false);
// 15285   #endif
// 15286   card.checkFilesys(gCfgItems.fileSysType);
        LDR.W    R0,??DataTable138
        LDRB     R1,[R0, #+218]
        MOV      R0,R5
          CFI FunCall _ZN10CardReader12checkFilesysEh
        BL       _ZN10CardReader12checkFilesysEh
// 15287 
// 15288   if (commands_in_queue) {
        LDRB     R0,[R4, #+16]
        CMP      R0,#+0
        BEQ.N    ??loop_1
// 15289 
// 15290     #if ENABLED(SDSUPPORT)
// 15291 
// 15292       if (card.saving) {
        LDRB     R0,[R5, #+2489]
        CMP      R0,#+0
        BEQ.N    ??loop_2
// 15293         char* command = command_queue[cmd_queue_index_r];
        LDRB     R0,[R4, #+17]
        ADD      R1,R0,R0, LSL #+1
        ADD      R0,R4,R1, LSL #+5
        ADD      R6,R0,#+140
// 15294         if (strstr_P(command, PSTR("M29"))) {
        ADR.N    R1,??DataTable125  ;; "M29"
        MOV      R0,R6
          CFI FunCall _Z6strstrPcPKc
        BL       _Z6strstrPcPKc
        CMP      R0,#+0
        BEQ.N    ??loop_3
// 15295           // M29 closes the file
// 15296           card.closefile();
        MOVS     R1,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader9closefileEb
        BL       _ZN10CardReader9closefileEb
// 15297           SERIAL_PROTOCOLLNPGM(MSG_FILE_SAVED);
        ADR.W    R0,`?<Constant "Done saving file.\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15298 
// 15299           #if ENABLED(SERIAL_STATS_DROPPED_RX)
// 15300             SERIAL_ECHOLNPAIR("Dropped bytes: ", customizedSerial.dropped());
// 15301           #endif
// 15302 
// 15303           #if ENABLED(SERIAL_STATS_MAX_RX_QUEUED)
// 15304             SERIAL_ECHOLNPAIR("Max RX Queue Size: ", customizedSerial.rxMaxEnqueued());
// 15305           #endif
// 15306 
// 15307           ok_to_send();
          CFI FunCall _Z10ok_to_sendv
        BL       _Z10ok_to_sendv
        B.N      ??loop_4
// 15308         }
// 15309         else {
// 15310           // Write the string from the read buffer to SD
// 15311           card.write_command(command);
??loop_3:
        MOV      R1,R6
        MOV      R0,R5
          CFI FunCall _ZN10CardReader13write_commandEPc
        BL       _ZN10CardReader13write_commandEPc
// 15312           if (card.logging)
        LDRB     R0,[R5, #+2490]
        CMP      R0,#+0
        BEQ.N    ??loop_5
// 15313             process_next_command(); // The card is saving because it's logging
          CFI FunCall _Z20process_next_commandv
        BL       _Z20process_next_commandv
        B.N      ??loop_4
// 15314           else
// 15315             ok_to_send();
??loop_5:
          CFI FunCall _Z10ok_to_sendv
        BL       _Z10ok_to_sendv
        B.N      ??loop_4
// 15316         }
// 15317       }
// 15318       else
// 15319         process_next_command();
??loop_2:
          CFI FunCall _Z20process_next_commandv
        BL       _Z20process_next_commandv
// 15320 
// 15321     #else
// 15322 
// 15323       process_next_command();
// 15324 
// 15325     #endif // SDSUPPORT
// 15326 
// 15327     // The queue may be reset by a command handler or by code invoked by idle() within a handler
// 15328     if (commands_in_queue) {
??loop_4:
        LDRB     R0,[R4, #+16]
        CMP      R0,#+0
        BEQ.N    ??loop_1
// 15329       --commands_in_queue;
        SUBS     R0,R0,#+1
        STRB     R0,[R4, #+16]
// 15330       if (++cmd_queue_index_r >= BUFSIZE) cmd_queue_index_r = 0;
        LDRB     R0,[R4, #+17]
        ADDS     R0,R0,#+1
        STRB     R0,[R4, #+17]
        UXTB     R0,R0
        CMP      R0,#+4
        BLT.N    ??loop_1
        MOVS     R0,#+0
        STRB     R0,[R4, #+17]
// 15331     }
// 15332   }
// 15333   endstops.report_state();
??loop_1:
          CFI FunCall _ZN8Endstops12report_stateEv
        BL       _ZN8Endstops12report_stateEv
// 15334   idle();
          CFI FunCall _Z4idlev
        BL       _Z4idlev
// 15335 
// 15336   
// 15337   mks_PrintStatePolling();
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall mks_PrintStatePolling
        B.W      mks_PrintStatePolling
          CFI EndBlock cfiBlock65
// 15338 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable123:
        DC32     from_flash_pic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Done saving file.\\n">`:
        DC8 "Done saving file.\012"
        DC8 0

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
printing_rate_update_flag:
        DS8 1
// 15339 #if 1
// 15340 uint16_t z_high_count;
// 15341 
// 15342 extern uint8_t poweroff_det_flg;
// 15343 extern uint32_t poweroff_det_cnt;
// 15344 extern uint8_t poweroff_det_low_flg;
// 15345 extern uint32_t poweroff_det_low_cnt;
// 15346 extern uint8_t poweroff_det_high_flg;
// 15347 extern uint32_t poweroff_det_high_cnt;
// 15348 
// 15349 extern uint8_t filament_det1_flg;
// 15350 extern uint32_t filament_det1_cnt;
// 15351 extern uint8_t filament_det1_low_flg;
// 15352 extern uint32_t filament_det1_low_cnt;
// 15353 extern uint8_t filament_det1_high_flg;
// 15354 extern uint32_t filament_det1_high_cnt;
// 15355 extern uint8_t filament_det1_check;
// 15356 
// 15357 extern uint8_t filament_det2_flg;
// 15358 extern uint32_t filament_det2_cnt;
// 15359 extern uint8_t filament_det2_low_flg;
// 15360 extern uint32_t filament_det2_low_cnt;
// 15361 extern uint8_t filament_det2_high_flg;
// 15362 extern uint32_t filament_det2_high_cnt;
// 15363 extern uint8_t filament_det2_check;
// 15364 
// 15365 uint32_t wifi_loop_cycle = 500;
// 15366 extern char wifi_check_time;
// 15367 uint8_t wifi_init_flg = 0;
wifi_init_flg:
        DS8 1
// 15368 uint8_t wifi_init_state = 0;
// 15369 uint8_t wifi_refresh_flg = 0, cloud_refresh_flg = 0;
wifi_refresh_flg:
        DS8 1
cloud_refresh_flg:
        DS8 1
// 15370 uint8_t waiting_wifi_time = 0;
waiting_wifi_time:
        DS8 1
// 15371 
// 15372 uint8_t btn_flg;
btn_flg:
        DS8 1
z_high_count:
        DS8 2
        DS8 4
TimeIncrease:
        DS8 4
// 15373 uint32_t btn_beep_cnt;
btn_beep_cnt:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
preview_no_display:
        DS8 1
// 15374 
// 15375 extern void mksBeeperAlarm(void);
// 15376 
// 15377 extern uint8_t clean_time_flg;
// 15378 extern uint8_t time_1s_flg;
// 15379 
// 15380 #if defined(__cplusplus)
// 15381 extern "C" {     /* Make sure we have C-declarations in C++ programs */
// 15382 #endif

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock66 Using cfiCommon0
          CFI Function btn_beeper
          CFI NoCalls
        THUMB
// 15383 void btn_beeper(uint32_t beeper)
// 15384 {
// 15385     btn_flg = 1;
btn_beeper:
        LDR.W    R1,??DataTable141
        MOVS     R2,#+1
        STRB     R2,[R1, #+5]
// 15386     btn_beep_cnt = beeper;
        STR      R0,[R1, #+16]
// 15387     BEEPER_OP=1;
        MOV      R0,R2
        LDR.W    R1,??DataTable143_1  ;; 0x424082b4
        STR      R0,[R1, #+0]
// 15388 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock66

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable124:
        DC32     flash_preview_begin

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable124_1:
        DC32     default_preview_flg
// 15389 #if defined(__cplusplus)
// 15390 }     /* Make sure we have C-declarations in C++ programs */
// 15391 #endif
// 15392 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock67 Using cfiCommon0
          CFI Function _Z20SysTick_Handler_Userv
        THUMB
// 15393 void SysTick_Handler_User()
// 15394 {
_Z20SysTick_Handler_Userv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 15395 		TimeIncrease++;
        LDR.W    R4,??DataTable141
        LDR      R0,[R4, #+12]
        ADDS     R0,R0,#+1
        STR      R0,[R4, #+12]
// 15396 
// 15397         if(clean_time_flg==1)
        MOV      R0,#+1000
        LDR.W    R1,??DataTable142_3
        LDRB     R2,[R1, #+0]
        CMP      R2,#+1
        BNE.N    ??SysTick_Handler_User_0
// 15398         {
// 15399     		if(!(TimeIncrease * TICK_CYCLE % 1000))	// 1s
        LDR      R2,[R4, #+12]
        MOV      R3,R0
        UDIV     R3,R2,R3
        MLS      R2,R0,R3,R2
        CMP      R2,#+0
        BNE.N    ??SysTick_Handler_User_0
// 15400     		{		
// 15401     			time_1s_flg = 1;
        MOVS     R2,#+1
        LDR.W    R3,??DataTable142_4
        STRB     R2,[R3, #+0]
// 15402                 gCfgItems.clean_time_bak--;
        LDR.W    R2,??DataTable138
        LDRH     R3,[R2, #+636]
        SUBS     R3,R3,#+1
        STRH     R3,[R2, #+636]
// 15403                 if(gCfgItems.clean_time_bak == 0)
        LDRH     R2,[R2, #+636]
        CMP      R2,#+0
        BNE.N    ??SysTick_Handler_User_0
// 15404                    clean_time_flg = 0; 
        MOVS     R2,#+0
        STRB     R2,[R1, #+0]
// 15405     		}            
// 15406         }
// 15407 	
// 15408 		temperature_change_frequency_cnt++;
??SysTick_Handler_User_0:
        LDR      R1,[R4, #+8]
        ADDS     R1,R1,#+1
        STR      R1,[R4, #+8]
// 15409 		if((temperature_change_frequency_cnt>=2000)&&(temperature_change_frequency!=1))
        CMP      R1,#+2000
        BCC.N    ??SysTick_Handler_User_1
        LDR.W    R1,??DataTable142_5
        LDRB     R2,[R1, #+0]
        CMP      R2,#+1
        BEQ.N    ??SysTick_Handler_User_1
// 15410 		{
// 15411 			temperature_change_frequency_cnt = 0;
        MOVS     R2,#+0
        STR      R2,[R4, #+8]
// 15412 			temperature_change_frequency = 1;
        MOVS     R2,#+1
        STRB     R2,[R1, #+0]
// 15413 		}
// 15414 		
// 15415 		if(!(TimeIncrease * TICK_CYCLE % 3000))	// 3s
??SysTick_Handler_User_1:
        LDR      R1,[R4, #+12]
        MOVW     R2,#+3000
        UDIV     R2,R1,R2
        MOVW     R3,#+3000
        MLS      R1,R3,R2,R1
        CMP      R1,#+0
        BNE.N    ??SysTick_Handler_User_2
// 15416 		{		
// 15417 			printing_rate_update_flag = 1;
        MOVS     R1,#+1
        STRB     R1,[R4, #+0]
// 15418 		}	
// 15419 
// 15420 		if((TimeIncrease * TICK_CYCLE % 1000) == 0) 
??SysTick_Handler_User_2:
        LDR      R1,[R4, #+12]
        MOV      R2,R0
        UDIV     R2,R1,R2
        MLS      R1,R0,R2,R1
        CMP      R1,#+0
        BNE.N    ??SysTick_Handler_User_3
// 15421 		{		
// 15422 			if(print_time.start == 1)
        LDR.W    R1,??DataTable142_6
        LDRSB    R2,[R1, #+7]
        CMP      R2,#+1
        BNE.N    ??SysTick_Handler_User_3
// 15423 			{
// 15424 				print_time.seconds++;
        LDRB     R2,[R1, #+5]
        ADDS     R2,R2,#+1
        STRB     R2,[R1, #+5]
// 15425 			}
// 15426 		}
// 15427 		if((TimeIncrease * TICK_CYCLE % 1000) == 0)
??SysTick_Handler_User_3:
        LDR      R1,[R4, #+12]
        MOV      R2,R0
        UDIV     R2,R1,R2
        MLS      R0,R0,R2,R1
        CMP      R0,#+0
        BNE.N    ??SysTick_Handler_User_4
// 15428 		{
// 15429 			z_high_count=1;
        MOVS     R0,#+1
        STRH     R0,[R4, #+6]
// 15430 		}
// 15431 
// 15432 	if(poweroff_det_flg==1)
??SysTick_Handler_User_4:
        LDR.W    R0,??DataTable142_7
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_5
// 15433 	{
// 15434 		poweroff_det_cnt++;
        LDR.W    R0,??DataTable142_8
        LDR      R1,[R0, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 15435 	}
// 15436 		
// 15437 	if(filament_det1_flg==1)
??SysTick_Handler_User_5:
        LDR.W    R0,??DataTable142_9
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_6
// 15438 	{
// 15439 		filament_det1_cnt++;
        LDR.W    R0,??DataTable142_10
        LDR      R1,[R0, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 15440 	}
// 15441 
// 15442 	if(filament_det1_low_flg==1)
??SysTick_Handler_User_6:
        LDR.W    R0,??DataTable143_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_7
// 15443 	{
// 15444 		filament_det1_low_cnt++;
        LDR.W    R0,??DataTable143_3
        LDR      R1,[R0, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 15445 	}
// 15446 
// 15447 	if(filament_det1_high_flg==1)
??SysTick_Handler_User_7:
        LDR.W    R0,??DataTable143_4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_8
// 15448 	{
// 15449 		filament_det1_high_cnt++;
        LDR.W    R0,??DataTable143_5
        LDR      R1,[R0, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 15450 	}
// 15451 	if(filament_det2_flg==1)
??SysTick_Handler_User_8:
        LDR.W    R0,??DataTable143_6
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_9
// 15452 	{
// 15453 		filament_det2_cnt++;
        LDR.W    R0,??DataTable143_7
        LDR      R1,[R0, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 15454 	}
// 15455 
// 15456 	if(filament_det2_low_flg==1)
??SysTick_Handler_User_9:
        LDR.W    R0,??DataTable143_8
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_10
// 15457 	{
// 15458 		filament_det2_low_cnt++;
        LDR.W    R0,??DataTable143_9
        LDR      R1,[R0, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 15459 	}
// 15460 
// 15461 	if(filament_det2_high_flg==1)
??SysTick_Handler_User_10:
        LDR.W    R0,??DataTable143_10
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_11
// 15462 	{
// 15463 		filament_det2_high_cnt++;
        LDR.W    R0,??DataTable143_11
        LDR      R1,[R0, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 15464 	}
// 15465 
// 15466 	if(poweroff_det_low_flg==1)
??SysTick_Handler_User_11:
        LDR.W    R0,??DataTable143_12
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_12
// 15467 	{
// 15468 		poweroff_det_low_cnt++;
        LDR.W    R0,??DataTable143_13
        LDR      R1,[R0, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 15469 	}
// 15470 	
// 15471 	if(poweroff_det_high_flg==1)
??SysTick_Handler_User_12:
        LDR.W    R0,??DataTable143_14
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_13
// 15472 	{
// 15473 		poweroff_det_high_cnt++;
        LDR.W    R0,??DataTable143_15
        LDR      R1,[R0, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 15474 	}		
// 15475 
// 15476 	if(!(TimeIncrease * TICK_CYCLE % 5000))	//5s
??SysTick_Handler_User_13:
        LDR      R0,[R4, #+12]
        MOVW     R1,#+5000
        UDIV     R1,R0,R1
        MOVW     R2,#+5000
        MLS      R0,R2,R1,R0
        CMP      R0,#+0
        BNE.N    ??SysTick_Handler_User_14
// 15477 	{
// 15478 		wifi_check_time = 1;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable144_1
        STRB     R0,[R1, #+0]
// 15479 		waiting_wifi_time ++;
        LDRB     R0,[R4, #+4]
        ADDS     R0,R0,#+1
        STRB     R0,[R4, #+4]
// 15480 		if((waiting_wifi_time == 8) || (gCfgItems.wifi_type == ESP_WIFI))//40s
        UXTB     R0,R0
        CMP      R0,#+8
        BEQ.N    ??SysTick_Handler_User_15
        LDR.W    R0,??DataTable138
        LDRB     R0,[R0, #+520]
        CMP      R0,#+2
        BNE.N    ??SysTick_Handler_User_16
// 15481 		{
// 15482 			if(wifi_init_flg == 0)
??SysTick_Handler_User_15:
        LDRB     R0,[R4, #+1]
        CMP      R0,#+0
        BNE.N    ??SysTick_Handler_User_16
// 15483 			{
// 15484 				wifi_init_flg = 1;
        MOVS     R0,#+1
        STRB     R0,[R4, #+1]
// 15485 			}
// 15486 			
// 15487 		}
// 15488 		if(wifi_refresh_flg == 0)
??SysTick_Handler_User_16:
        LDRB     R0,[R4, #+2]
        CMP      R0,#+0
        BNE.N    ??SysTick_Handler_User_17
// 15489 			wifi_refresh_flg = 1;
        MOVS     R0,#+1
        STRB     R0,[R4, #+2]
// 15490 		
// 15491 		if(cloud_refresh_flg == 0)
??SysTick_Handler_User_17:
        LDRB     R0,[R4, #+3]
        CMP      R0,#+0
        BNE.N    ??SysTick_Handler_User_14
// 15492 			cloud_refresh_flg = 1;
        MOVS     R0,#+1
        STRB     R0,[R4, #+3]
// 15493 
// 15494 	}
// 15495 	
// 15496 
// 15497 	mksBeeperAlarm();
??SysTick_Handler_User_14:
          CFI FunCall _Z14mksBeeperAlarmv
        BL       _Z14mksBeeperAlarmv
// 15498 
// 15499     if(btn_flg==1)
        LDRB     R0,[R4, #+5]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_18
// 15500     {
// 15501         btn_beep_cnt--;
        LDR      R0,[R4, #+16]
        SUBS     R0,R0,#+1
        STR      R0,[R4, #+16]
// 15502         if(btn_beep_cnt==0)
        BNE.N    ??SysTick_Handler_User_18
// 15503         {
// 15504             btn_beep_cnt=0;
// 15505             BEEPER_OP=0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable143_1  ;; 0x424082b4
        STR      R0,[R1, #+0]
// 15506         }
// 15507     }
// 15508 }
??SysTick_Handler_User_18:
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock67

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable125:
        DC8      "M29"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable125_1:
        DC32     parser

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable125_2:
        DC32     soft_endstops_enabled
// 15509 #endif
// 15510 
// 15511 #include "mks_reprint.cpp"

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock68 Using cfiCommon0
          CFI Function mkstft_ui_load
        THUMB
// __interwork __softfp void mkstft_ui_load()
mkstft_ui_load:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.W    R4,??DataTable138
        MOVS     R2,#+4
        ADDS     R1,R4,#+4
        MOVW     R0,#+1479
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+8
        MOVW     R0,#+1503
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+12
        MOVW     R0,#+1595
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+16
        MOVW     R0,#+1507
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+104
        MOVW     R0,#+1495
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+100
        MOVW     R0,#+1499
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+20
        MOVW     R0,#+1599
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+24
        MOVW     R0,#+1603
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+28
        MOVW     R0,#+1607
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+32
        MOVW     R0,#+1527
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+36
        MOVW     R0,#+1611
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+40
        MOVW     R0,#+1531
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+60
        MOVW     R0,#+1615
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+64
        MOVW     R0,#+1619
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+68
        MOVW     R0,#+1535
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+72
        MOVW     R0,#+1539
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+76
        MOVW     R0,#+1623
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R4,#+80
        MOVW     R0,#+1627
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R4,#+84
        MOVW     R0,#+1631
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDW     R1,R4,#+411
        MOVW     R0,#+1543
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R4,#+216
        MOV      R0,#+1544
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDRSB    R0,[R4, #+216]
        CMP      R0,#+1
        BEQ.N    ??mkstft_ui_load_0
        LDRSB    R0,[R4, #+216]
        CMP      R0,#+2
        BEQ.N    ??mkstft_ui_load_0
        LDRSB    R0,[R4, #+216]
        CMP      R0,#+3
        BEQ.N    ??mkstft_ui_load_0
        LDRSB    R0,[R4, #+216]
        CMP      R0,#+6
        BEQ.N    ??mkstft_ui_load_0
        LDRSB    R0,[R4, #+216]
        CMP      R0,#+7
        BEQ.N    ??mkstft_ui_load_0
        LDRSB    R0,[R4, #+216]
        CMP      R0,#+10
        BEQ.N    ??mkstft_ui_load_0
        LDRSB    R0,[R4, #+216]
        CMP      R0,#+12
        BEQ.N    ??mkstft_ui_load_0
        MOVS     R0,#+3
        STRB     R0,[R4, #+216]
??mkstft_ui_load_0:
        MOVS     R2,#+1
        ADDW     R1,R4,#+638
        MOVW     R0,#+1639
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall epr_read_data
        B.W      epr_read_data
          CFI EndBlock cfiBlock68

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable126:
        DC32     mksCfg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable126_1:
        DC32     cartes

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable126_2:
        DC32     _ZN7Planner8e_factorE

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock69 Using cfiCommon0
          CFI Function _Z17mkstft_ui_set_eprv
        THUMB
// __interwork __softfp void mkstft_ui_set_epr()
_Z17mkstft_ui_set_eprv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+8
          CFI CFA R13+24
        MOVW     R4,#+1450
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDR.W    R5,??DataTable147  ;; 0x76313030
        LDR      R0,[SP, #+0]
        CMP      R0,R5
        BEQ.W    ??mkstft_ui_set_epr_0
        LDR.W    R6,??DataTable138
        MOVS     R2,#+4
        ADDS     R1,R6,#+4
        MOVW     R0,#+1479
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+8
        MOVW     R0,#+1503
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+16
        MOVW     R0,#+1595
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+16
        MOVW     R0,#+1507
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+104
        MOVW     R0,#+1495
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+100
        MOVW     R0,#+1499
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+20
        MOVW     R0,#+1599
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+24
        MOVW     R0,#+1603
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+28
        MOVW     R0,#+1607
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+32
        MOVW     R0,#+1527
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+36
        MOVW     R0,#+1611
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+40
        MOVW     R0,#+1531
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+60
        MOVW     R0,#+1615
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+64
        MOVW     R0,#+1619
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+68
        MOVW     R0,#+1535
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+72
        MOVW     R0,#+1539
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+76
        MOVW     R0,#+1623
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+80
        MOVW     R0,#+1627
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+84
        MOVW     R0,#+1631
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDW     R1,R6,#+411
        MOVW     R0,#+1543
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,R6,#+216
        MOV      R0,#+1544
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDW     R1,R6,#+638
        MOVW     R0,#+1639
          CFI FunCall epr_write_data
        BL       epr_write_data
        STR      R5,[SP, #+0]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall epr_write_data
        BL       epr_write_data
??mkstft_ui_set_epr_0:
        POP      {R0,R1,R4-R6,PC}  ;; return
          CFI EndBlock cfiBlock69

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable127:
        DC32     echomagic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable127_1:
        DC32     axis_relative_modes

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable127_2:
        DC32     0x54442d18

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable127_3:
        DC32     0x401921fb

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable127_4:
        DC32     0xc01921fb

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable127_5:
        DC32     0x3fe00000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable127_6:
        DC32     0x3ff00000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable127_7:
        DC32     0x47ae147b

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock70 Using cfiCommon0
          CFI Function mkstft_ui_init
        THUMB
// __interwork __softfp void mkstft_ui_init()
mkstft_ui_init:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
        LDR.W    R4,??DataTable138
        ADDS     R0,R4,#+4
        MVN      R1,#-16777216
        STR      R1,[R0, #+84]
        STR      R1,[R4, #+4]
        LDR.W    R2,??DataTable150  ;; 0x8db937
        STR      R2,[R0, #+4]
        MOVS     R3,#+0
        STR      R3,[R0, #+8]
        STR      R2,[R0, #+12]
        STR      R3,[R0, #+100]
        STR      R1,[R0, #+96]
        STR      R2,[R0, #+16]
        STR      R1,[R0, #+20]
        STR      R2,[R0, #+24]
        STR      R1,[R0, #+28]
        STR      R1,[R0, #+32]
        LDR.W    R3,??DataTable150_1  ;; 0x43cdff
        STR      R3,[R0, #+36]
        MOV      R3,#+65280
        STR      R3,[R0, #+40]
        LDR.W    R3,??DataTable150_2  ;; 0xaaaaaa
        STR      R3,[R0, #+44]
        MOVS     R3,#+0
        STR      R3,[R0, #+48]
        STR      R3,[R0, #+52]
        STR      R3,[R0, #+56]
        STR      R1,[R0, #+60]
        MOV      R3,#+16711680
        STR      R3,[R0, #+64]
        STR      R1,[R0, #+68]
        STR      R2,[R0, #+72]
        STR      R1,[R0, #+76]
        STR      R2,[R0, #+80]
        MOVS     R0,#+1
        STRB     R0,[R4, #+411]
        ADD      R0,R4,#+188
        MOVS     R1,#+3
        STRB     R1,[R0, #+28]
        MOVW     R1,#+3919
        STR      R1,[R0, #+32]
        MOVS     R1,#+201
        STR      R1,[R0, #+36]
        MOVS     R1,#+164
        STR      R1,[R0, #+40]
        MOV      R1,#+3776
        STR      R1,[R0, #+44]
        MOVS     R1,#+1
        STRB     R1,[R0, #+30]
        MOVS     R1,#+5
        STRB     R1,[R0, #+3]
        MOVS     R1,#+0
        STRB     R1,[R4, #+188]
        MOV      R1,#+1065353216
        STR      R1,[R0, #+24]
        MOVW     R1,#+3000
        STRH     R1,[R0, #+18]
        MOVS     R1,#+1
        STRB     R1,[R0, #+16]
        MOVS     R1,#+5
        STRB     R1,[R0, #+15]
        STRB     R1,[R0, #+14]
        MOVS     R1,#+100
        STRH     R1,[R0, #+8]
        STRH     R1,[R0, #+10]
        ADDW     R0,R4,#+379
        MOVS     R1,#+0
        STRB     R1,[R0, #+29]
        STRB     R1,[R4, #+237]
        STRB     R1,[R0, #+30]
        STRB     R1,[R0, #+31]
        MOV      R0,R1
        STRB     R0,[R4, #+422]
        ADDW     R5,R4,#+237
        STRB     R0,[R5, #+12]
        MOVS     R2,#+6
        ADR.W    R1,`?<Constant "0.000">`
        ADD      R0,R4,#+316
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R0,#+1
        STRB     R0,[R5, #+26]
        MOVS     R0,#+0
        STRB     R0,[R5, #+7]
        MOVS     R0,#+1
        STRB     R0,[R5, #+8]
        STRB     R0,[R4, #+519]
        LDR.W    R7,??DataTable151
        MOVS     R2,#+108
        MOVS     R1,#+0
        MOV      R0,R7
          CFI FunCall memset
        BL       memset
        LDR.W    R5,??DataTable151_1
        MOVS     R2,#+162
        MOVS     R1,#+0
        MOV      R0,R5
          CFI FunCall memset
        BL       memset
        MOVS     R6,#+12
        MOV      R2,R6
        ADR.W    R1,`?<Constant "TP-LINK_MKS">`
        MOV      R0,R7
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        MOVS     R2,#+10
        ADR.W    R1,`?<Constant "makerbase">`
        ADD      R0,R7,#+32
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        ADR.W    R7,`?<Constant "192.168.3.100">`
        MOV      R8,#+14
        MOV      R2,R8
        MOV      R1,R7
        ADDS     R0,R5,#+1
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        ADR.W    R9,`?<Constant "255.255.255.0">`
        MOV      R2,R8
        MOV      R1,R9
        ADD      R0,R5,#+17
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        ADR.W    R10,`?<Constant "192.168.3.1">`
        MOV      R2,R6
        MOV      R1,R10
        ADD      R0,R5,#+33
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOV      R2,R6
        MOV      R1,R10
        ADD      R0,R5,#+49
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R0,#+1
        STRB     R0,[R5, #+0]
        MOV      R2,R8
        MOV      R1,R7
        ADD      R0,R5,#+66
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOV      R2,R8
        MOV      R1,R9
        ADD      R0,R5,#+82
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOV      R2,R6
        MOV      R1,R10
        ADD      R0,R5,#+98
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOV      R2,R6
        MOV      R1,R10
        ADD      R0,R5,#+114
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOV      R2,R6
        MOV      R1,R10
        ADD      R0,R5,#+130
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOV      R2,R8
        ADR.W    R1,`?<Constant "192.168.3.255">`
        ADD      R0,R5,#+146
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R0,#+1
        STRB     R0,[R5, #+65]
        ADDW     R5,R4,#+519
        MOVS     R0,#+2
        STRB     R0,[R5, #+1]
        MOVS     R2,#+15
        ADR.W    R1,`?<Constant "baizhongyun.cn">`
        ADDW     R0,R4,#+522
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVW     R0,#+10086
        STR      R0,[R4, #+620]
        MOVS     R0,#+1
        STRB     R0,[R5, #+2]
        ADD      R5,R4,#+620
        MOVS     R0,#+23
        STRB     R0,[R5, #+4]
        MOVS     R0,#+1
        STRB     R0,[R5, #+5]
        MOVS     R0,#+0
        STRB     R0,[R4, #+379]
        STRB     R0,[R4, #+296]
        MOVS     R0,#+100
        STRH     R0,[R5, #+14]
        MOVS     R0,#+0
        STRB     R0,[R5, #+18]
          CFI FunCall _Z17mkstft_ui_set_eprv
        BL       _Z17mkstft_ui_set_eprv
        MOVS     R0,#+0
        LDR.W    R1,??DataTable152
        STRB     R0,[R1, #+0]
        LDR.W    R1,??DataTable153_1
        STRB     R0,[R1, #+0]
        STRB     R0,[R5, #+4]
        POP      {R4-R10,PC}      ;; return
          CFI EndBlock cfiBlock70

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable128:
        DC32     gArrayGpioPin

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable128_1:
        DC32     gArrayGpioPort

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable128_2:
        DC32     axis_relative_modes

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "0.000">`:
        DC8 "0.000"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "TP-LINK_MKS">`:
        DC8 "TP-LINK_MKS"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "makerbase">`:
        DC8 "makerbase"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "192.168.3.100">`:
        DC8 "192.168.3.100"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "255.255.255.0">`:
        DC8 "255.255.255.0"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "192.168.3.1">`:
        DC8 "192.168.3.1"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "192.168.3.255">`:
        DC8 "192.168.3.255"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "baizhongyun.cn">`:
        DC8 "baizhongyun.cn"
        DC8 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock71 Using cfiCommon0
          CFI Function mks_initPrint
        THUMB
// __interwork __softfp void mks_initPrint()
mks_initPrint:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.W    R4,??DataTable142_2
        LDR.W    R0,??DataTable153_2
        LDR      R0,[R0, #+24]
        STR      R0,[R4, #+3308]
        MOVS     R0,#+166
        STRB     R0,[R4, #+3344]
        ADDW     R5,R4,#+3344
        MOVS     R0,#+0
        STR      R0,[R5, #+4]
        MOVS     R2,#+20
        MOV      R1,R0
        ADDW     R0,R4,#+3256
          CFI FunCall memset
        BL       memset
        MOVS     R2,#+30
        MOVS     R1,#+0
        ADDW     R0,R4,#+3276
          CFI FunCall memset
        BL       memset
        MOVS     R0,#+0
        STRH     R0,[R5, #+26]
        STRB     R0,[R4, #+3468]
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock71

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock72 Using cfiCommon0
          CFI Function _Z14mks_WriteToEprv
          CFI NoCalls
        THUMB
// __interwork __softfp void mks_WriteToEpr()
_Z14mks_WriteToEprv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock72

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock73 Using cfiCommon0
          CFI Function mks_ReadFromEpr
        THUMB
// __interwork __softfp void mks_ReadFromEpr()
mks_ReadFromEpr:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.W    R4,??DataTable142_2
        MOVS     R2,#+30
        ADDW     R1,R4,#+3276
        MOVW     R0,#+1001
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADDW     R1,R4,#+3348
        MOVW     R0,#+1053
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall epr_read_data
        B.W      epr_read_data
          CFI EndBlock cfiBlock73

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable130:
        DC32     _ZN11GCodeParser11command_ptrE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable130_1:
        DC32     Serial6

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock74 Using cfiCommon0
          CFI Function mks_resumePrint
        THUMB
// __interwork __softfp void mks_resumePrint()
mks_resumePrint:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.W    R4,??DataTable142_2
        LDRB     R0,[R4, #+3344]
        CMP      R0,#+169
        BNE.N    ??mks_resumePrint_0
        MOVS     R0,#+167
        STRB     R0,[R4, #+3344]
        ADDW     R0,R4,#+2500
          CFI FunCall _ZN7MKS_DLP11resumePrintEv
        BL       _ZN7MKS_DLP11resumePrintEv
        MOVS     R1,#+0
        ADDW     R0,R4,#+3276
          CFI FunCall _Z13lcd_setstatusPKcb
        BL       _Z13lcd_setstatusPKcb
??mks_resumePrint_0:
        LDRB     R0,[R4, #+3344]
        CMP      R0,#+170
        BNE.N    ??mks_resumePrint_1
        MOVS     R0,#+171
        STRB     R0,[R4, #+3344]
??mks_resumePrint_1:
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock74

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable131:
        DC32     0x3f847ae1

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock75 Using cfiCommon0
          CFI Function mks_pausePrint
        THUMB
// __interwork __softfp void mks_pausePrint()
mks_pausePrint:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        MOVS     R0,#+166
        STRB     R0,[SP, #+0]
        MOVW     R4,#+1059
        MOVS     R2,#+1
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall epr_write_data
        BL       epr_write_data
        LDR.W    R5,??DataTable142_2
        LDR.W    R0,??DataTable153_2
        VLDR     S0,[R0, #+16]
        VLDR.W   S1,??DataTable136_1  ;; 0x42f00000
        VDIV.F32 S1,S0,S1
        LDR      R0,[R5, #+3308]
        VMOV     S0,R0
        ADDW     R0,R5,#+2500
          CFI FunCall _ZN7MKS_DLP14moveRelative_ZEff
        BL       _ZN7MKS_DLP14moveRelative_ZEff
        LDR.W    R0,??DataTable157
        LDR      R0,[R0, #+44]
        STR      R0,[R5, #+3320]
        MOVS     R0,#+167
        STRB     R0,[SP, #+0]
        MOVS     R2,#+1
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall epr_write_data
        BL       epr_write_data
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock75

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable132:
        DC32     errormagic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable132_1:
        DC32     wifi_link_state

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable132_2:
        DC32     preview_no_display

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock76 Using cfiCommon0
          CFI Function mks_PrintStatePolling
        THUMB
// __interwork __softfp void mks_PrintStatePolling()
mks_PrintStatePolling:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.W    R4,??DataTable142_2
        LDRB     R0,[R4, #+3344]
        CMP      R0,#+168
        BNE.N    ??mks_PrintStatePolling_0
        ADDW     R5,R4,#+2500
        MOV      R0,R5
          CFI FunCall _ZN7MKS_DLP10pausePrintEv
        BL       _ZN7MKS_DLP10pausePrintEv
        CMP      R0,#+0
        BNE.N    ??mks_PrintStatePolling_0
        ADR.W    R0,`?<Constant "paused:">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
        MOVS     R0,#+169
        STRB     R0,[R4, #+3344]
        MOVS     R2,#+1
        ADD      R1,R4,#+3344
        MOV      R0,#+1000
          CFI FunCall epr_write_data
        BL       epr_write_data
          CFI FunCall mks_pausePrint
        BL       mks_pausePrint
        MOV      R0,R5
          CFI FunCall _ZN7MKS_DLP24write_Information_pausedEv
        BL       _ZN7MKS_DLP24write_Information_pausedEv
        MOVS     R3,#+2
        MOV      R2,#+1000
        MOV      R1,R2
        MOV      R0,R5
          CFI FunCall _ZN7MKS_DLP11buzzer_toneEtth
        BL       _ZN7MKS_DLP11buzzer_toneEtth
??mks_PrintStatePolling_0:
        LDRB     R0,[R4, #+3344]
        CMP      R0,#+167
        BNE.N    ??mks_PrintStatePolling_1
        LDR.W    R0,??DataTable156
        LDRB     R1,[R0, #+0]
        CMP      R1,#+1
        BNE.N    ??mks_PrintStatePolling_2
        MOVS     R1,#+0
        STRB     R1,[R0, #+0]
        ADDW     R0,R4,#+2500
          CFI FunCall _ZN7MKS_DLP11resumePrintEv
        BL       _ZN7MKS_DLP11resumePrintEv
        MOV      R0,R4
          CFI FunCall _ZN10CardReader14startFileprintEv
        BL       _ZN10CardReader14startFileprintEv
        ADD      R0,R4,#+3584
          CFI FunCall _ZN9Stopwatch5startEv
        BL       _ZN9Stopwatch5startEv
??mks_PrintStatePolling_2:
        ADDW     R1,R4,#+3344
        LDRB     R0,[R4, #+2488]
        CMP      R0,#+0
        BNE.N    ??mks_PrintStatePolling_3
        LDRH     R0,[R1, #+26]
        ADDS     R0,R0,#+1
        STRH     R0,[R1, #+26]
        B.N      ??mks_PrintStatePolling_4
??mks_PrintStatePolling_3:
        MOVS     R0,#+0
        STRH     R0,[R1, #+26]
??mks_PrintStatePolling_4:
        LDRH     R0,[R1, #+26]
        CMP      R0,#+21
        BLT.N    ??mks_PrintStatePolling_1
        MOVS     R0,#+0
        STRH     R0,[R1, #+26]
        MOVS     R0,#+166
        STRB     R0,[R4, #+3344]
        MOVS     R2,#+1
        MOV      R0,#+1000
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_PrintStatePolling_1:
        LDRB     R0,[R4, #+3344]
        CMP      R0,#+172
        BNE.N    ??mks_PrintStatePolling_5
        MOVS     R0,#+166
        STRB     R0,[R4, #+3344]
        MOVS     R2,#+1
        ADD      R1,R4,#+3344
        MOV      R0,#+1000
          CFI FunCall epr_write_data
        BL       epr_write_data
          CFI FunCall _Z19clear_command_queuev
        BL       _Z19clear_command_queuev
        ADDW     R5,R4,#+2500
        MOV      R0,R5
          CFI FunCall _ZN7MKS_DLP9stopPrintEv
        BL       _ZN7MKS_DLP9stopPrintEv
        LDR.W    R0,??DataTable153_2
        VLDR     S0,[R0, #+16]
        VLDR.W   S1,??DataTable136_1  ;; 0x42f00000
        VDIV.F32 S1,S0,S1
        LDR      R0,[R4, #+3308]
        VMOV     S0,R0
        MOV      R0,R5
          CFI FunCall _ZN7MKS_DLP14moveRelative_ZEff
        BL       _ZN7MKS_DLP14moveRelative_ZEff
        MOVS     R2,#+1
        LDR.W    R0,??DataTable157_1
        LDRH     R1,[R0, #+4]
        LDR.W    R0,??DataTable157_2
        LDR      R0,[R0, #+8]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        LDR.W    R1,??DataTable157
        STRB     R0,[R1, #+10]
        MOVS     R3,#+2
        MOV      R2,#+1000
        MOV      R1,R2
        MOV      R0,R5
          CFI FunCall _ZN7MKS_DLP11buzzer_toneEtth
        BL       _ZN7MKS_DLP11buzzer_toneEtth
        ADD      R0,R4,#+3584
          CFI FunCall _ZN9Stopwatch4stopEv
        BL       _ZN9Stopwatch4stopEv
??mks_PrintStatePolling_5:
        LDRB     R0,[R4, #+3344]
        CMP      R0,#+171
        BNE.N    ??mks_PrintStatePolling_6
        LDRSB    R0,[R4, #+3468]
        CMP      R0,#+1
        BNE.N    ??mks_PrintStatePolling_7
        ADDW     R0,R4,#+2500
        POP      {R1,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7MKS_DLP19contiuePrint_pausedEv
        B.W      _ZN7MKS_DLP19contiuePrint_pausedEv
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??mks_PrintStatePolling_7:
        CMP      R0,#+2
        BNE.N    ??mks_PrintStatePolling_6
        ADDW     R0,R4,#+2500
        POP      {R1,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7MKS_DLP18contiuePrint_PwdwnEv
        B.W      _ZN7MKS_DLP18contiuePrint_PwdwnEv
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??mks_PrintStatePolling_6:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock76

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "paused:">`:
        DC8 "paused:"

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock77 Using cfiCommon0
          CFI Function _Z18mks_setTemperaturev
          CFI NoCalls
        THUMB
// __interwork __softfp void mks_setTemperature()
_Z18mks_setTemperaturev:
        BX       LR               ;; return
          CFI EndBlock cfiBlock77

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock78 Using cfiCommon0
          CFI Function mks_setPositionZ
        THUMB
// __interwork __softfp void mks_setPositionZ()
mks_setPositionZ:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        SUB      SP,SP,#+20
          CFI CFA R13+32
        LDR.N    R4,??DataTable142_2
        MOVS     R2,#+96
        MOVS     R1,#+0
        ADDW     R0,R4,#+3372
          CFI FunCall memset
        BL       memset
        ADDW     R5,R4,#+3372
        MOVS     R2,#+6
        ADR.W    R1,`?<Constant "G92 Z">`
        MOV      R0,R5
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        LDR      R0,[R4, #+3320]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        ADR.N    R1,??DataTable142_1  ;; 0x25, 0x66, 0x00, 0x00
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R5
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z9gcode_G92v
        BL       _Z9gcode_G92v
        LDR.W    R0,??DataTable159
        MOVS     R1,#+0
        STR      R1,[R0, #+24]
        ADD      SP,SP,#+20
          CFI CFA R13+12
        POP      {R4,R5,PC}       ;; return
          CFI EndBlock cfiBlock78

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "G92 Z">`:
        DC8 "G92 Z"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock79 Using cfiCommon0
          CFI Function _Z15mks_setFeedratev
          CFI NoCalls
        THUMB
// __interwork __softfp void mks_setFeedrate()
_Z15mks_setFeedratev:
        LDR.W    R0,??DataTable157
        LDR.W    R1,??DataTable152_1
        LDR      R1,[R1, #+3364]
        STR      R1,[R0, #+120]
        BX       LR               ;; return
          CFI EndBlock cfiBlock79

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable135:
        DC32     card+0x9C4

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock80 Using cfiCommon0
          CFI Function mks_preExtrude
          CFI NoCalls
        THUMB
// __interwork __vfp void mks_preExtrude(float)
mks_preExtrude:
        BX       LR               ;; return
          CFI EndBlock cfiBlock80

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock81 Using cfiCommon0
          CFI Function mks_moveXY
        THUMB
// __interwork __vfp void mks_moveXY(float, float)
mks_moveXY:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        VPUSH    {D8}
          CFI D8 Frame(CFA, -24)
          CFI CFA R13+24
        SUB      SP,SP,#+24
          CFI CFA R13+48
        VMOV.F32 S16,S0
        VMOV.F32 S17,S1
        LDR.N    R4,??DataTable142_2
        MOVS     R2,#+96
        MOVS     R1,#+0
        ADDW     R0,R4,#+3372
          CFI FunCall memset
        BL       memset
        ADDW     R4,R4,#+3372
        MOVS     R2,#+5
        ADR.W    R1,`?<Constant "G1 X">`
        MOV      R0,R4
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        ADR.N    R5,??DataTable142_1  ;; 0x25, 0x66, 0x00, 0x00
        VMOV     R0,S16
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R1,R5
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall strcat
        BL       strcat
        ADR.N    R1,??DataTable143  ;; 0x20, 0x59, 0x00, 0x00
        MOV      R0,R4
          CFI FunCall strcat
        BL       strcat
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        VMOV     R0,S17
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R1,R5
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R4
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z11gcode_G0_G1v
        BL       _Z11gcode_G0_G1v
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        ADD      SP,SP,#+24
          CFI CFA R13+24
        VPOP     {D8}
          CFI D8 SameValue
          CFI CFA R13+16
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock81

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable136:
        DC32     TFT_screen

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable136_1:
        DC32     0x42f00000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "G1 X">`:
        DC8 "G1 X"
        DC8 0, 0, 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock82 Using cfiCommon0
          CFI Function mks_moveZ
        THUMB
// __interwork __vfp void mks_moveZ(float)
mks_moveZ:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        VPUSH    {D8}
          CFI D8 Frame(CFA, -24)
          CFI CFA R13+24
        SUB      SP,SP,#+24
          CFI CFA R13+48
        VMOV.F32 S16,S0
        LDR.N    R4,??DataTable142_2
        MOVS     R2,#+96
        MOVS     R1,#+0
        ADDW     R0,R4,#+3372
          CFI FunCall memset
        BL       memset
        ADDW     R5,R4,#+3372
        MOVS     R2,#+5
        ADR.W    R1,`?<Constant "G1 Z">`
        MOV      R0,R5
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        LDR      R0,[R4, #+3336]
        VMOV     S0,R0
        VADD.F32 S0,S0,S16
        VMOV     R0,S0
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        ADR.N    R1,??DataTable142_1  ;; 0x25, 0x66, 0x00, 0x00
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R5
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z11gcode_G0_G1v
        BL       _Z11gcode_G0_G1v
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        ADD      SP,SP,#+24
          CFI CFA R13+24
        VPOP     {D8}
          CFI D8 SameValue
          CFI CFA R13+16
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock82

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "G1 Z">`:
        DC8 "G1 Z"
        DC8 0, 0, 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock83 Using cfiCommon0
          CFI Function _Z7mks_G28Pc
        THUMB
// __interwork __softfp void mks_G28(char *)
_Z7mks_G28Pc:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        LDR.W    R5,??DataTable152_1
        MOVS     R2,#+96
        MOVS     R1,#+0
        ADDW     R0,R5,#+3372
          CFI FunCall memset
        BL       memset
        ADDW     R5,R5,#+3372
        MOV      R1,R4
        MOV      R0,R5
          CFI FunCall strcpy
        BL       strcpy
        MOV      R0,R5
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
        MOVS     R0,#+0
        POP      {R1,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z9gcode_G28b
        B.W      _Z9gcode_G28b
          CFI EndBlock cfiBlock83

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable138:
        DC32     gCfgItems

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock84 Using cfiCommon0
          CFI Function mks_manual_leveling
        THUMB
// __interwork __softfp void mks_manual_leveling(int16_t, int16_t)
mks_manual_leveling:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        MOV      R5,R1
        LDR.W    R0,??DataTable160
        LDRB     R1,[R0, #+0]
        CMP      R1,#+1
        BNE.N    ??mks_manual_leveling_0
        MOVS     R1,#+0
        STRB     R1,[R0, #+0]
        ADR.N    R0,??DataTable144  ;; "G28"
          CFI FunCall _Z7mks_G28Pc
        BL       _Z7mks_G28Pc
??mks_manual_leveling_0:
        LDR.N    R0,??DataTable142_2
        LDR.W    R1,??DataTable157
        LDR      R1,[R1, #+44]
        STR      R1,[R0, #+3336]
        VMOV.F32 S0,#10.0
          CFI FunCall mks_moveZ
        BL       mks_moveZ
        VMOV     S0,R5
        VCVT.F32.S32 S1,S0
        VMOV     S0,R4
        VCVT.F32.S32 S0,S0
          CFI FunCall mks_moveXY
        BL       mks_moveXY
        ADR.W    R0,`?<Constant "G1 Z0">`
        POP      {R1,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z27enqueue_and_echo_commands_PPKc
        B.W      _Z27enqueue_and_echo_commands_PPKc
          CFI EndBlock cfiBlock84

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "G1 Z0">`:
        DC8 "G1 Z0"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock85 Using cfiCommon0
          CFI Function mks_contiuePrintPause
        THUMB
// __interwork __softfp void mks_contiuePrintPause()
mks_contiuePrintPause:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R4,??DataTable142_2
        MOVS     R0,#+1
        STRB     R0,[R4, #+2488]
          CFI FunCall mks_setPositionZ
        BL       mks_setPositionZ
        VLDR.W   S0,??DataTable145  ;; 0x0
          CFI FunCall mks_moveZ
        BL       mks_moveZ
        MOVS     R0,#+167
        STRB     R0,[R4, #+3344]
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z9gcode_M24v
        B.W      _Z9gcode_M24v
          CFI EndBlock cfiBlock85

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock86 Using cfiCommon0
          CFI Function mks_contiuePrintPwdwn
          CFI NoCalls
        THUMB
// __interwork __softfp void mks_contiuePrintPwdwn()
mks_contiuePrintPwdwn:
        BX       LR               ;; return
          CFI EndBlock cfiBlock86

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock87 Using cfiCommon0
          CFI Function mks_contiuePrintDelta
        THUMB
// __interwork __softfp void mks_contiuePrintDelta()
mks_contiuePrintDelta:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R4,??DataTable142_2
        MOVS     R0,#+1
        STRB     R0,[R4, #+2488]
        LDR      R0,[R4, #+3308]
        VMOV     S0,R0
          CFI FunCall mks_moveZ
        BL       mks_moveZ
        VLDR.W   S0,??DataTable145  ;; 0x0
          CFI FunCall mks_moveZ
        BL       mks_moveZ
        MOVS     R0,#+167
        STRB     R0,[R4, #+3344]
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z9gcode_M24v
        B.W      _Z9gcode_M24v
          CFI EndBlock cfiBlock87

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable141:
        DC32     printing_rate_update_flag

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock88 Using cfiCommon0
          CFI Function mks_getPositionXYZE
          CFI NoCalls
        THUMB
// __interwork __softfp void mks_getPositionXYZE()
mks_getPositionXYZE:
        SUB      SP,SP,#+4
          CFI CFA R13+4
        MOVS     R0,#+0
        STRB     R0,[SP, #+0]
        ADD      SP,SP,#+4
          CFI CFA R13+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock88

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock89 Using cfiCommon0
          CFI Function mks_clearDir
        THUMB
// __interwork __softfp void mks_clearDir()
mks_clearDir:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        SUB      SP,SP,#+32
          CFI CFA R13+40
        LDR.W    R4,??DataTable161
        B.N      ??mks_clearDir_0
??mks_clearDir_1:
        ADDS     R1,R0,#+1
        ADD      R0,SP,#+0
          CFI FunCall strcpy
        BL       strcpy
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall strcpy
        BL       strcpy
??mks_clearDir_0:
        ADR.N    R1,??DataTable146  ;; "/"
        MOV      R0,R4
          CFI FunCall _Z6strstrPcPKc
        BL       _Z6strstrPcPKc
        CMP      R0,#+0
        BNE.N    ??mks_clearDir_1
        ADD      SP,SP,#+32
          CFI CFA R13+8
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock89

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable142:
        DC32     thermalManager

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable142_1:
        DC8      0x25, 0x66, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable142_2:
        DC32     card

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable142_3:
        DC32     clean_time_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable142_4:
        DC32     time_1s_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable142_5:
        DC32     temperature_change_frequency

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable142_6:
        DC32     print_time

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable142_7:
        DC32     poweroff_det_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable142_8:
        DC32     poweroff_det_cnt

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable142_9:
        DC32     filament_det1_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable142_10:
        DC32     filament_det1_cnt

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock90 Using cfiCommon0
          CFI Function mks_contiuePrint_UI
        THUMB
// __interwork __softfp void mks_contiuePrint_UI()
mks_contiuePrint_UI:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOVS     R1,#+0
        ADR.W    R0,`?<Constant "Resume print?">`
          CFI FunCall _Z13lcd_setstatusPKcb
        BL       _Z13lcd_setstatusPKcb
        LDR.W    R4,??DataTable152_1
        ADDW     R5,R4,#+3276
        MOVS     R3,#+1
        MOV      R2,R3
        MOV      R1,R5
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8openFileEPcbb
        BL       _ZN10CardReader8openFileEPcbb
        LDR.W    R6,??DataTable162
        MOV      R1,R5
        MOV      R0,R6
          CFI FunCall strcpy
        BL       strcpy
        ADR.W    R1,`?<Constant ".cbddlp">`
          CFI FunCall _Z6strstrPcPKc
        BL       _Z6strstrPcPKc
        CMP      R0,#+0
        BNE.N    ??mks_contiuePrint_UI_0
        ADR.W    R1,`?<Constant ".CBDDLP">`
        MOV      R0,R6
          CFI FunCall _Z6strstrPcPKc
        BL       _Z6strstrPcPKc
        CMP      R0,#+0
        BNE.N    ??mks_contiuePrint_UI_0
        ADR.W    R1,`?<Constant ".photon">`
        MOV      R0,R6
          CFI FunCall _Z6strstrPcPKc
        BL       _Z6strstrPcPKc
        CMP      R0,#+0
        BNE.N    ??mks_contiuePrint_UI_0
        ADR.W    R1,`?<Constant ".PHOTON">`
        MOV      R0,R6
          CFI FunCall _Z6strstrPcPKc
        BL       _Z6strstrPcPKc
        CMP      R0,#+0
        BEQ.N    ??mks_contiuePrint_UI_1
??mks_contiuePrint_UI_0:
        MOVS     R0,#+2
        STRB     R0,[R4, #+3255]
        B.N      ??mks_contiuePrint_UI_2
??mks_contiuePrint_UI_1:
        MOVS     R0,#+1
        STRB     R0,[R4, #+3255]
??mks_contiuePrint_UI_2:
        MOV      R0,R4
          CFI FunCall _ZN10CardReader10isFileOpenEv
        BL       _ZN10CardReader10isFileOpenEv
        CMP      R0,#+0
        BNE.N    ??mks_contiuePrint_UI_3
        MOVS     R0,#+2
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall draw_dialog
        B.W      draw_dialog
          CFI R4 Frame(CFA, -16)
          CFI R5 Frame(CFA, -12)
          CFI R6 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??mks_contiuePrint_UI_3:
        MOVS     R2,#+30
        ADDW     R1,R4,#+3276
        MOVW     R0,#+1001
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R0,#+0
        STRB     R0,[R4, #+2488]
          CFI FunCall mks_clearDir
        BL       mks_clearDir
??mks_contiuePrint_UI_4:
          CFI FunCall getTick
        BL       getTick
        LDR.W    R1,??DataTable163
        STR      R0,[R1, #+0]
        LDR.W    R1,??DataTable163_1
        LDR      R1,[R1, #+0]
          CFI FunCall getTickDiff
        BL       getTickDiff
        MOVW     R1,#+3000
        CMP      R0,R1
        BCS.N    ??mks_contiuePrint_UI_5
        LDR.W    R0,??DataTable163_2
        LDRSB    R0,[R0, #+218]
        CMP      R0,#+0
        BNE.N    ??mks_contiuePrint_UI_4
??mks_contiuePrint_UI_5:
        LDR.W    R5,??DataTable163_3
        MOVS     R2,#+1
        MOV      R1,R5
        MOVW     R0,#+1577
          CFI FunCall AT24CXX_Read
        BL       AT24CXX_Read
        LDRB     R0,[R5, #+0]
        CMP      R0,#+0
        BEQ.N    ??mks_contiuePrint_UI_6
        MOVS     R0,#+1
        LDR.W    R1,??DataTable163_4
        STRB     R0,[R1, #+0]
        B.N      ??mks_contiuePrint_UI_7
??mks_contiuePrint_UI_6:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable163_5
        STRB     R0,[R1, #+0]
??mks_contiuePrint_UI_7:
          CFI FunCall draw_printing
        BL       draw_printing
        ADDW     R0,R4,#+2500
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7MKS_DLP13draw_printingEv
        B.W      _ZN7MKS_DLP13draw_printingEv
          CFI EndBlock cfiBlock90

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable143:
        DC8      0x20, 0x59, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable143_1:
        DC32     0x424082b4

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable143_2:
        DC32     filament_det1_low_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable143_3:
        DC32     filament_det1_low_cnt

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable143_4:
        DC32     filament_det1_high_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable143_5:
        DC32     filament_det1_high_cnt

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable143_6:
        DC32     filament_det2_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable143_7:
        DC32     filament_det2_cnt

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable143_8:
        DC32     filament_det2_low_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable143_9:
        DC32     filament_det2_low_cnt

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable143_10:
        DC32     filament_det2_high_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable143_11:
        DC32     filament_det2_high_cnt

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable143_12:
        DC32     poweroff_det_low_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable143_13:
        DC32     poweroff_det_low_cnt

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable143_14:
        DC32     poweroff_det_high_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable143_15:
        DC32     poweroff_det_high_cnt

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Resume print?">`:
        DC8 "Resume print?"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant ".cbddlp">`:
        DC8 ".cbddlp"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant ".CBDDLP">`:
        DC8 ".CBDDLP"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant ".photon">`:
        DC8 ".photon"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant ".PHOTON">`:
        DC8 ".PHOTON"

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock91 Using cfiCommon0
          CFI Function mks_rePrintCheck
        THUMB
// __interwork __softfp void mks_rePrintCheck()
mks_rePrintCheck:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        LDR.W    R5,??DataTable152_1
        ADDW     R6,R5,#+3344
        MOVS     R2,#+1
        MOV      R1,R6
        MOV      R0,#+1000
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDR.W    R4,??DataTable163_6
        LDRB     R0,[R5, #+3344]
        STRB     R0,[R4, #+1]
        CMP      R0,#+169
        BNE.N    ??mks_rePrintCheck_0
        ADDW     R7,R5,#+2500
        MOV      R0,R7
          CFI FunCall _ZN7MKS_DLP18Is_Paused_FinishedEv
        BL       _ZN7MKS_DLP18Is_Paused_FinishedEv
        CMP      R0,#+0
        BEQ.N    ??mks_rePrintCheck_0
        MOVS     R0,#+170
        STRB     R0,[R5, #+3344]
        MOV      R0,R7
          CFI FunCall _ZN7MKS_DLP23read_Information_pausedEv
        BL       _ZN7MKS_DLP23read_Information_pausedEv
        MOVS     R0,#+1
        STRB     R0,[R5, #+3468]
          CFI FunCall mks_contiuePrint_UI
        BL       mks_contiuePrint_UI
        B.N      ??mks_rePrintCheck_1
??mks_rePrintCheck_0:
        LDRB     R0,[R5, #+3344]
        CMP      R0,#+167
        BNE.N    ??mks_rePrintCheck_2
        ADDW     R0,R5,#+2500
          CFI FunCall _ZN7MKS_DLP22read_Information_layerEv
        BL       _ZN7MKS_DLP22read_Information_layerEv
        CMP      R0,#+0
        BEQ.N    ??mks_rePrintCheck_2
        MOVS     R0,#+170
        STRB     R0,[R5, #+3344]
        MOVS     R0,#+2
        STRB     R0,[R5, #+3468]
          CFI FunCall mks_contiuePrint_UI
        BL       mks_contiuePrint_UI
        B.N      ??mks_rePrintCheck_1
??mks_rePrintCheck_2:
        MOVS     R0,#+166
        STRB     R0,[R5, #+3344]
        MOVS     R2,#+1
        MOV      R1,R6
        MOV      R0,#+1000
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R0,#+1
        STRB     R0,[R4, #+0]
??mks_rePrintCheck_1:
        LDRB     R0,[R4, #+0]
        CMP      R0,#+1
        BNE.N    ??mks_rePrintCheck_3
        MOVS     R0,#+0
        STRB     R0,[R4, #+0]
??mks_rePrintCheck_4:
          CFI FunCall getTick
        BL       getTick
        LDR.W    R1,??DataTable163
        STR      R0,[R1, #+0]
        LDR.W    R1,??DataTable163_1
        LDR      R1,[R1, #+0]
          CFI FunCall getTickDiff
        BL       getTickDiff
        MOVW     R1,#+3000
        CMP      R0,R1
        BCC.N    ??mks_rePrintCheck_4
        POP      {R0,R4-R7,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall draw_ready_print
        B.W      draw_ready_print
          CFI R4 Frame(CFA, -20)
          CFI R5 Frame(CFA, -16)
          CFI R6 Frame(CFA, -12)
          CFI R7 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+24
??mks_rePrintCheck_3:
        POP      {R0,R4-R7,PC}    ;; return
          CFI EndBlock cfiBlock91

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable144:
        DC8      "G28"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable144_1:
        DC32     wifi_check_time

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock92 Using cfiCommon0
          CFI Function mks_WriteToFile
          CFI NoCalls
        THUMB
// __interwork __softfp void mks_WriteToFile()
mks_WriteToFile:
        BX       LR               ;; return
          CFI EndBlock cfiBlock92

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock93 Using cfiCommon0
          CFI Function _Z21mks_WriteToEpr_pwroffv
          CFI NoCalls
        THUMB
// __interwork __softfp void mks_WriteToEpr_pwroff()
_Z21mks_WriteToEpr_pwroffv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock93

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock94 Using cfiCommon0
          CFI Function _Z22mks_ReadFromEpr_pwroffv
          CFI NoCalls
        THUMB
// __interwork __softfp void mks_ReadFromEpr_pwroff()
_Z22mks_ReadFromEpr_pwroffv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock94

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock95 Using cfiCommon0
          CFI Function _Z7pft_getv
          CFI NoCalls
        THUMB
// __interwork __softfp int16_t pft_get()
_Z7pft_getv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock95

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock96 Using cfiCommon0
          CFI Function _Z16mks_get_commandsv
          CFI NoCalls
        THUMB
// __interwork __softfp bool mks_get_commands()
_Z16mks_get_commandsv:
        MOVS     R0,#+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock96

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock97 Using cfiCommon0
          CFI Function mks_ReadFromFile
          CFI NoCalls
        THUMB
// __interwork __softfp bool mks_ReadFromFile()
mks_ReadFromFile:
        BX       LR               ;; return
          CFI EndBlock cfiBlock97

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock98 Using cfiCommon0
          CFI Function mks_clearFile
          CFI NoCalls
        THUMB
// __interwork __softfp void mks_clearFile()
mks_clearFile:
        BX       LR               ;; return
          CFI EndBlock cfiBlock98

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock99 Using cfiCommon0
          CFI Function mks_saveFileName
        THUMB
// __interwork __softfp void mks_saveFileName(char *)
mks_saveFileName:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        LDR.W    R5,??DataTable152_1
        MOVS     R2,#+30
        MOVS     R1,#+0
        ADDW     R0,R5,#+3276
          CFI FunCall memset
        BL       memset
        MOV      R1,R4
        ADDW     R0,R5,#+3276
          CFI FunCall strcpy
        BL       strcpy
        MOVS     R2,#+30
        ADDW     R1,R5,#+3276
        MOVW     R0,#+1001
        POP      {R3-R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall epr_write_data
        B.W      epr_write_data
          CFI EndBlock cfiBlock99

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable145:
        DC32     0x0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock100 Using cfiCommon0
          CFI Function EXTI9_5_IRQHandler
          CFI NoCalls
        THUMB
// __interwork __softfp void EXTI9_5_IRQHandler()
EXTI9_5_IRQHandler:
        BX       LR               ;; return
          CFI EndBlock cfiBlock100
// 15512 #include "mks_dlp_main.cpp"

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock101 Using cfiCommon0
          CFI Function _Z13strting2floatPhh
        THUMB
// __interwork __vfp float strting2float(BYTE *, BYTE)
_Z13strting2floatPhh:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        SUB      SP,SP,#+20
          CFI CFA R13+32
        MOV      R4,R0
        MOV      R5,R1
        MOVS     R2,#+16
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        MOVS     R0,#+0
        ADD      R2,SP,#+0
        B.N      ??strting2float_0
??strting2float_1:
        ADD      R1,R4,R0, LSL #+1
        LDRSB    R1,[R1, #+1]
        STRB     R1,[R0, R2]
        ADDS     R0,R0,#+1
??strting2float_0:
        CMP      R0,R5, LSR #+1
        BLT.N    ??strting2float_1
        ADD      R0,SP,#+0
          CFI FunCall atof
        BL       atof
        VMOV     R0,R1,D0
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        VMOV     S0,R0
        ADD      SP,SP,#+20
          CFI CFA R13+12
        POP      {R4,R5,PC}       ;; return
          CFI EndBlock cfiBlock101

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock102 Using cfiCommon0
          CFI Function _Z13find_next_bmpv
        THUMB
// __interwork __softfp void find_next_bmp()
_Z13find_next_bmpv:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        SUB      SP,SP,#+36
          CFI CFA R13+48
        MOVS     R0,#+0
        STRH     R0,[SP, #+0]
        ADD      R4,SP,#+0
        LDR.W    R5,??DataTable152_1
        B.N      ??find_next_bmp_0
??find_next_bmp_1:
        LDRB     R0,[SP, #+0]
        STRB     R0,[R4, #+1]
??find_next_bmp_0:
        MOV      R0,R5
          CFI FunCall _ZN10CardReader3eofEv
        BL       _ZN10CardReader3eofEv
        CMP      R0,#+0
        BNE.N    ??find_next_bmp_2
        MOVS     R2,#+1
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R0,[SP, #+0]
        CMP      R0,#+10
        BNE.N    ??find_next_bmp_1
        LDRB     R0,[R4, #+1]
        CMP      R0,#+13
        BNE.N    ??find_next_bmp_1
??find_next_bmp_2:
        ADD      SP,SP,#+36
          CFI CFA R13+12
        POP      {R4,R5,PC}       ;; return
          CFI EndBlock cfiBlock102

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable146:
        DC8      "/",0x0,0x0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock103 Using cfiCommon0
          CFI Function _Z11InvertUint8PhS_
          CFI NoCalls
        THUMB
// __interwork __softfp void InvertUint8(unsigned char *, unsigned char *)
_Z11InvertUint8PhS_:
        PUSH     {R4-R6}
          CFI R6 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        MOVS     R2,#+0
        MOV      R3,R2
        B.N      ??InvertUint8_0
??InvertUint8_1:
        MOVS     R4,#+1
        LDRB     R5,[R1, #+0]
        LSL      R6,R4,R3
        TST      R5,R6
        BEQ.N    ??InvertUint8_2
        RSB      R5,R3,#+7
        LSLS     R4,R4,R5
        ORRS     R2,R4,R2
        UXTB     R2,R2
??InvertUint8_2:
        ADDS     R3,R3,#+1
??InvertUint8_0:
        CMP      R3,#+8
        BLT.N    ??InvertUint8_1
        STRB     R2,[R0, #+0]
        POP      {R4-R6}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI CFA R13+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock103

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock104 Using cfiCommon0
          CFI Function _Z12InvertUint16PtS_
          CFI NoCalls
        THUMB
// __interwork __softfp void InvertUint16(unsigned short *, unsigned short *)
_Z12InvertUint16PtS_:
        PUSH     {R4-R6}
          CFI R6 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        MOVS     R2,#+0
        MOV      R3,R2
        B.N      ??InvertUint16_0
??InvertUint16_1:
        MOVS     R4,#+1
        LDRH     R5,[R1, #+0]
        LSL      R6,R4,R3
        TST      R5,R6
        BEQ.N    ??InvertUint16_2
        RSB      R5,R3,#+15
        LSLS     R4,R4,R5
        ORRS     R2,R4,R2
        UXTH     R2,R2
??InvertUint16_2:
        ADDS     R3,R3,#+1
??InvertUint16_0:
        CMP      R3,#+16
        BLT.N    ??InvertUint16_1
        STRH     R2,[R0, #+0]
        POP      {R4-R6}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI CFA R13+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock104

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock105 Using cfiCommon0
          CFI Function _ZN7MKS_DLPC1Ev
        THUMB
// __code __interwork __softfp MKS_DLP::MKS_DLP()
_ZN7MKS_DLPC1Ev:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
        ADDW     R0,R4,#+754
          CFI FunCall _ZN7SSD2828C1Ev
        BL       _ZN7SSD2828C1Ev
        ADD      R0,R4,#+476
        MOVS     R1,#+0
        STRB     R1,[R0, #+23]
        STRH     R1,[R4, #+476]
        STRB     R1,[R0, #+2]
        STRB     R1,[R0, #+3]
        STRB     R1,[R0, #+12]
        STRB     R1,[R0, #+4]
        STR      R1,[R4, #+728]
        MOVW     R1,#+5000
        STR      R1,[R0, #+8]
        MOVS     R1,#+0
        STRB     R1,[R0, #+13]
        STR      R1,[R0, #+16]
        MOV      R0,R1
        B.N      ??MKS_DLP_0
??MKS_DLP_1:
        ADD      R1,R4,R0, LSL #+2
        MOVS     R2,#+0
        STR      R2,[R1, #+504]
        ADD      R3,R4,R0, LSL #+1
        STRH     R2,[R3, #+584]
        MOVS     R2,#+166
        ADDS     R3,R0,R4
        STRB     R2,[R3, #+624]
        MOVS     R2,#+0
        STR      R2,[R1, #+644]
        ADDS     R0,R0,#+1
??MKS_DLP_0:
        CMP      R0,#+20
        BLT.N    ??MKS_DLP_1
        MOV      R0,R4
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock105

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock106 Using cfiCommon0
          CFI Function _ZN7MKS_DLP11status_initEv
        THUMB
// __interwork __softfp void MKS_DLP::status_init()
_ZN7MKS_DLP11status_initEv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
        MOVS     R0,#+0
        STRH     R0,[R4, #+476]
        ADD      R0,R4,#+476
        MOVS     R1,#+0
        STRB     R1,[R0, #+2]
        STRB     R1,[R0, #+3]
        STRB     R1,[R0, #+4]
        STRB     R1,[R0, #+13]
          CFI FunCall _Z10clr_ticketv
        BL       _Z10clr_ticketv
        LDR.W    R0,??DataTable164
          CFI FunCall _ZN9Stopwatch5startEv
        BL       _ZN9Stopwatch5startEv
        ADR.W    R0,`?<Constant "totalTime(s):">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP18get_totalPrintTimeEv
        BL       _ZN7MKS_DLP18get_totalPrintTimeEv
        MOVS     R2,#+10
        MOV      R1,R0
        LDR.W    R0,??DataTable164_1
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN5Print5printEji
        B.W      _ZN5Print5printEji
          CFI EndBlock cfiBlock106

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable147:
        DC32     0x76313030

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "totalTime(s):">`:
        DC8 "totalTime(s):"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock107 Using cfiCommon0
          CFI Function _ZN7MKS_DLP14moveRelative_ZEff
        THUMB
// __interwork __vfp void MKS_DLP::moveRelative_Z(float, float)
_ZN7MKS_DLP14moveRelative_ZEff:
        PUSH     {LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+4
        VPUSH    {S1}
          CFI CFA R13+8
        MOVS     R1,#+0
        STRB     R1,[R0, #+490]
        LDR.W    R0,??DataTable157
        VLDR     S1,[R0, #+60]
        VADD.F32 S0,S1,S0
        VSTR     S0,[R0, #+60]
        ADD      R1,SP,#+0
        ADDS     R0,R0,#+60
          CFI FunCall _Z21do_blocking_move_to_zRKfS0_
        BL       _Z21do_blocking_move_to_zRKfS0_
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock107

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock108 Using cfiCommon0
          CFI Function _ZN7MKS_DLP22moveRelativeZandGetBmpEff
        THUMB
// __interwork __vfp void MKS_DLP::moveRelativeZandGetBmp(float, float)
_ZN7MKS_DLP22moveRelativeZandGetBmpEff:
        PUSH     {R4-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+20
        VPUSH    {S1}
          CFI CFA R13+24
        MOV      R4,R0
        MOVS     R0,#+0
        STRB     R0,[R4, #+490]
        LDR.W    R0,??DataTable157
        VLDR     S1,[R0, #+60]
        VADD.F32 S0,S1,S0
        VSTR     S0,[R0, #+60]
        ADD      R1,SP,#+0
        ADDS     R0,R0,#+60
          CFI FunCall _Z28do_blocking_move_to_z_nowaitRKfS0_
        BL       _Z28do_blocking_move_to_z_nowaitRKfS0_
        LDR.W    R5,??DataTable165
        LDRB     R0,[R5, #+3255]
        CMP      R0,#+1
        BNE.N    ??moveRelativeZandGetBmp_0
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP15get_sdcard_bmpsEv
        BL       _ZN7MKS_DLP15get_sdcard_bmpsEv
        B.N      ??moveRelativeZandGetBmp_1
??moveRelativeZandGetBmp_0:
        ADDW     R6,R5,#+3540
        LDR      R0,[R6, #+24]
        CMP      R0,#+2
        BLT.N    ??moveRelativeZandGetBmp_2
        MOVS     R7,#+0
??moveRelativeZandGetBmp_3:
        UXTB     R7,R7
        MOV      R0,R7
        LDR      R1,[R6, #+24]
        CMP      R0,R1
        BGE.N    ??moveRelativeZandGetBmp_1
        MOV      R2,R7
        LDRH     R1,[R4, #+476]
        LDRH     R3,[R4, #+52]
        UXTAH    R1,R3,R1
        SUBS     R1,R1,#+1
        LDR      R3,[R5, #+3540]
        MLA      R1,R3,R0,R1
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP21decode_layer_from_rleEjh
        BL       _ZN7MKS_DLP21decode_layer_from_rleEjh
        ADDS     R7,R7,#+1
        B.N      ??moveRelativeZandGetBmp_3
??moveRelativeZandGetBmp_2:
        MOVS     R2,#+0
        LDRH     R0,[R4, #+476]
        LDRH     R1,[R4, #+52]
        UXTAH    R0,R1,R0
        SUBS     R1,R0,#+1
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP21decode_layer_from_rleEjh
        BL       _ZN7MKS_DLP21decode_layer_from_rleEjh
??moveRelativeZandGetBmp_1:
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        POP      {R0,R4-R7,PC}    ;; return
          CFI EndBlock cfiBlock108

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock109 Using cfiCommon0
          CFI Function _ZN7MKS_DLP15moveFistLayer_ZEv
        THUMB
// __interwork __softfp void MKS_DLP::moveFistLayer_Z()
_ZN7MKS_DLP15moveFistLayer_ZEv:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        MOV      R5,R0
        LDR.W    R6,??DataTable157
        VLDR     S0,[R5, #+36]
        VLDR     S1,[R6, #+92]
        VSUB.F32 S0,S0,S1
        VSTR     S0,[R6, #+60]
        LDR.N    R0,??DataTable153_2
        VLDR     S0,[R0, #+16]
        VLDR.W   S1,??DataTable153  ;; 0x42f00000
        VDIV.F32 S0,S0,S1
        VSTR     S0,[SP, #+0]
        ADD      R1,SP,#+0
        ADD      R0,R6,#+60
          CFI FunCall _Z21do_blocking_move_to_zRKfS0_
        BL       _Z21do_blocking_move_to_zRKfS0_
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        ADR.W    R0,`?<Constant "Move Z offset:">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R7,??DataTable164_1
        MOVS     R1,#+2
        MOV      R4,R1
        LDR      R0,[R6, #+92]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        VMOV     D0,R0,R1
        MOV      R1,R4
        MOV      R0,R7
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
          CFI FunCall _ZN7Stepper16report_positionsEv
        BL       _ZN7Stepper16report_positionsEv
        VLDR     S0,[R5, #+36]
        VSTR     S0,[R6, #+44]
        VSTR     S0,[R6, #+60]
        ADR.W    R0,`?<Constant "Reset Z:">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR      R0,[R6, #+44]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        VMOV     D0,R0,R1
        MOV      R1,R4
        MOV      R0,R7
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
          CFI FunCall _ZN7Stepper16report_positionsEv
        BL       _ZN7Stepper16report_positionsEv
        POP      {R0,R4-R7,PC}    ;; return
          CFI EndBlock cfiBlock109

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable150:
        DC32     0x8db937

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable150_1:
        DC32     0x43cdff

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable150_2:
        DC32     0xaaaaaa

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Move Z offset:">`:
        DC8 "Move Z offset:"
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Reset Z:">`:
        DC8 "Reset Z:"
        DC8 0, 0, 0

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock110 Using cfiCommon0
          CFI Function _ZN7MKS_DLP9moveMax_ZEv
        THUMB
// __interwork __softfp void MKS_DLP::moveMax_Z()
_ZN7MKS_DLP9moveMax_ZEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.W    R0,??DataTable157
        LDR.N    R1,??DataTable153_2
        LDR      R2,[R1, #+8]
        STR      R2,[R0, #+60]
        VLDR     S0,[R1, #+16]
        VLDR.W   S1,??DataTable153  ;; 0x42f00000
        VDIV.F32 S0,S0,S1
        VMOV.F32 S1,#2.0
        VMUL.F32 S0,S0,S1
        VSTR     S0,[SP, #+0]
        ADD      R1,SP,#+0
        ADDS     R0,R0,#+60
          CFI FunCall _Z21do_blocking_move_to_zRKfS0_
        BL       _Z21do_blocking_move_to_zRKfS0_
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
        ADR.W    R0,`?<Constant "print end.\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock110

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable151:
        DC32     wifiPara

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable151_1:
        DC32     ipPara

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "print end.\\n">`:
        DC8 "print end.\012"

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock111 Using cfiCommon0
          CFI Function _ZN7MKS_DLP7getHeadEv
        THUMB
// __interwork __softfp void MKS_DLP::getHead()
_ZN7MKS_DLP7getHeadEv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+32
          CFI CFA R13+48
        MOV      R4,R0
        LDR.N    R5,??DataTable152_1
        MOVS     R2,#+3
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        MOVS     R2,#+3
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall memcpy
        BL       memcpy
        MOVS     R2,#+8
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        MOVS     R2,#+8
        ADD      R1,SP,#+0
        ADDS     R0,R4,#+3
          CFI FunCall memcpy
        BL       memcpy
        MOVS     R0,#+0
        STRB     R0,[R4, #+10]
        ADR.W    R1,`?<Constant "MKSDLP">`
        ADDS     R0,R4,#+3
          CFI FunCall _Z6strstrPcPKc
        BL       _Z6strstrPcPKc
        CMP      R0,#+0
        BNE.N    ??getHead_0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader19printingHasFinishedEv
        BL       _ZN10CardReader19printingHasFinishedEv
        B.N      ??getHead_1
??getHead_0:
        LDR.W    R1,??DataTable165_2  ;; 0x186af
        MOV      R0,R5
          CFI FunCall _ZN10CardReader8setIndexEl
        BL       _ZN10CardReader8setIndexEl
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        ADD      R6,SP,#+0
        LDRB     R0,[SP, #+0]
        LDRB     R1,[R6, #+1]
        ORR      R0,R1,R0, LSL #+8
        STRH     R0,[R4, #+12]
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R0,[SP, #+0]
        LDRB     R1,[R6, #+1]
        ORR      R0,R1,R0, LSL #+8
        STRH     R0,[R4, #+14]
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R0,[SP, #+0]
        LDRB     R1,[R6, #+1]
        ORR      R0,R1,R0, LSL #+8
        STRH     R0,[R4, #+16]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R2,[R6, #+3]
        STRB     R2,[R4, #+18]
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R1,[R4, #+18]
        ADD      R0,SP,#+0
          CFI FunCall _Z13strting2floatPhh
        BL       _Z13strting2floatPhh
        VSTR     S0,[R4, #+20]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R2,[R6, #+3]
        STRB     R2,[R4, #+24]
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R1,[R4, #+24]
        ADD      R0,SP,#+0
          CFI FunCall _Z13strting2floatPhh
        BL       _Z13strting2floatPhh
        VSTR     S0,[R4, #+28]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R2,[R6, #+3]
        STRB     R2,[R4, #+32]
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R1,[R4, #+32]
        ADD      R0,SP,#+0
          CFI FunCall _Z13strting2floatPhh
        BL       _Z13strting2floatPhh
        VSTR     S0,[R4, #+36]
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R0,[SP, #+0]
        LDRB     R1,[R6, #+1]
        ORR      R1,R1,R0, LSL #+8
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP13set_LedOnTimeEt
        BL       _ZN7MKS_DLP13set_LedOnTimeEt
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R0,[SP, #+0]
        LDRB     R1,[R6, #+1]
        ORR      R1,R1,R0, LSL #+8
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP14set_LedOffTimeEt
        BL       _ZN7MKS_DLP14set_LedOffTimeEt
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R0,[SP, #+0]
        LDRB     R1,[R6, #+1]
        ORR      R1,R1,R0, LSL #+8
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP19set_BottomLedOnTimeEt
        BL       _ZN7MKS_DLP19set_BottomLedOnTimeEt
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R0,[SP, #+0]
        LDRB     R1,[R6, #+1]
        ORR      R1,R1,R0, LSL #+8
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16set_BottomlayersEt
        BL       _ZN7MKS_DLP16set_BottomlayersEt
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP11status_initEv
        BL       _ZN7MKS_DLP11status_initEv
??getHead_1:
        ADD      SP,SP,#+32
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock111

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable152:
        DC32     BMP_PIC_X

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable152_1:
        DC32     card

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock112 Using cfiCommon0
          CFI Function _ZN7MKS_DLP8getHead1Ev
        THUMB
// __interwork __softfp void MKS_DLP::getHead1()
_ZN7MKS_DLP8getHead1Ev:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+32
          CFI CFA R13+48
        MOV      R4,R0
        LDR.W    R5,??DataTable165
        MOVS     R2,#+3
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        MOVS     R2,#+3
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall memcpy
        BL       memcpy
        MOVS     R2,#+8
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        MOVS     R2,#+8
        ADD      R1,SP,#+0
        ADDS     R0,R4,#+3
          CFI FunCall memcpy
        BL       memcpy
        MOVS     R0,#+0
        STRB     R0,[R4, #+10]
        ADR.W    R1,`?<Constant "MKSDLP">`
        ADDS     R0,R4,#+3
          CFI FunCall _Z6strstrPcPKc
        BL       _Z6strstrPcPKc
        CMP      R0,#+0
        BNE.N    ??getHead1_0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader19printingHasFinishedEv
        BL       _ZN10CardReader19printingHasFinishedEv
        B.N      ??getHead1_1
??getHead1_0:
        LDR.W    R1,??DataTable167  ;; 0x2fa37
        MOV      R0,R5
          CFI FunCall _ZN10CardReader8setIndexEl
        BL       _ZN10CardReader8setIndexEl
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        ADD      R6,SP,#+0
        LDRB     R0,[SP, #+0]
        LDRB     R1,[R6, #+1]
        ORR      R0,R1,R0, LSL #+8
        STRH     R0,[R4, #+12]
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R0,[SP, #+0]
        LDRB     R1,[R6, #+1]
        ORR      R0,R1,R0, LSL #+8
        STRH     R0,[R4, #+14]
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R0,[SP, #+0]
        LDRB     R1,[R6, #+1]
        ORR      R0,R1,R0, LSL #+8
        STRH     R0,[R4, #+16]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R2,[R6, #+3]
        STRB     R2,[R4, #+18]
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R1,[R4, #+18]
        ADD      R0,SP,#+0
          CFI FunCall _Z13strting2floatPhh
        BL       _Z13strting2floatPhh
        VSTR     S0,[R4, #+20]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R2,[R6, #+3]
        STRB     R2,[R4, #+24]
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R1,[R4, #+24]
        ADD      R0,SP,#+0
          CFI FunCall _Z13strting2floatPhh
        BL       _Z13strting2floatPhh
        VSTR     S0,[R4, #+28]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R2,[R6, #+3]
        STRB     R2,[R4, #+32]
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R1,[R4, #+32]
        ADD      R0,SP,#+0
          CFI FunCall _Z13strting2floatPhh
        BL       _Z13strting2floatPhh
        VSTR     S0,[R4, #+36]
??getHead1_1:
        ADD      SP,SP,#+32
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock112

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable153:
        DC32     0x42f00000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable153_1:
        DC32     BMP_PIC_Y

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable153_2:
        DC32     mksCfg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "MKSDLP">`:
        DC8 "MKSDLP"
        DC8 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock113 Using cfiCommon0
          CFI Function _ZN7MKS_DLP8getHead2Ev
        THUMB
// __interwork __softfp void MKS_DLP::getHead2()
_ZN7MKS_DLP8getHead2Ev:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+32
          CFI CFA R13+48
        MOV      R4,R0
        LDR.W    R5,??DataTable165
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        ADD      R6,SP,#+0
        LDRB     R0,[SP, #+0]
        LDRB     R1,[R6, #+1]
        ORR      R1,R1,R0, LSL #+8
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP13set_LedOnTimeEt
        BL       _ZN7MKS_DLP13set_LedOnTimeEt
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R0,[SP, #+0]
        LDRB     R1,[R6, #+1]
        ORR      R1,R1,R0, LSL #+8
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP14set_LedOffTimeEt
        BL       _ZN7MKS_DLP14set_LedOffTimeEt
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R0,[SP, #+0]
        LDRB     R1,[R6, #+1]
        ORR      R1,R1,R0, LSL #+8
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP19set_BottomLedOnTimeEt
        BL       _ZN7MKS_DLP19set_BottomLedOnTimeEt
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R0,[SP, #+0]
        LDRB     R1,[R6, #+1]
        ORR      R1,R1,R0, LSL #+8
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16set_BottomlayersEt
        BL       _ZN7MKS_DLP16set_BottomlayersEt
        LDR      R0,[R4, #+40]
        STR      R0,[R4, #+56]
        LDR      R0,[R4, #+48]
        STR      R0,[R4, #+60]
        ADD      SP,SP,#+32
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock113

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock114 Using cfiCommon0
          CFI Function _ZN7MKS_DLP14startFileprintEv
        THUMB
// __interwork __softfp void MKS_DLP::startFileprint()
_ZN7MKS_DLP14startFileprintEv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
        LDR.W    R0,??DataTable165
        MOVS     R1,#+0
        STR      R1,[R0, #+3564]
        ADDW     R0,R0,#+3254
          CFI FunCall _ZN7SSD28284initEv
        BL       _ZN7SSD28284initEv
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP8getHead1Ev
        BL       _ZN7MKS_DLP8getHead1Ev
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP8getHead2Ev
        BL       _ZN7MKS_DLP8getHead2Ev
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP23clean_Information_layerEv
        BL       _ZN7MKS_DLP23clean_Information_layerEv
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP11status_initEv
        BL       _ZN7MKS_DLP11status_initEv
          CFI FunCall draw_status_clear
        BL       draw_status_clear
          CFI FunCall display_print_statue
        BL       display_print_statue
          CFI FunCall GUI_Exec
        BL       GUI_Exec
        LDR.W    R0,??DataTable169
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z7mks_G28Pc
        B.W      _Z7mks_G28Pc
          CFI EndBlock cfiBlock114

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock115 Using cfiCommon0
          CFI Function _ZN7MKS_DLP14bank2disp_readEv
        THUMB
// __interwork __softfp uint8_t MKS_DLP::bank2disp_read()
_ZN7MKS_DLP14bank2disp_readEv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.W    R4,??DataTable169_1  ;; 0x4240029c
        MOVS     R0,#+0
        STR      R0,[R4, #+0]
        MOVS     R0,#+128
          CFI FunCall SPI1_ReadWriteByte
        BL       SPI1_ReadWriteByte
        MOVS     R0,#+255
          CFI FunCall SPI1_ReadWriteByte
        BL       SPI1_ReadWriteByte
        MOVS     R0,#+255
          CFI FunCall SPI1_ReadWriteByte
        BL       SPI1_ReadWriteByte
        MOVS     R1,#+1
        STR      R1,[R4, #+0]
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock115

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable156:
        DC32     pause_resum

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock116 Using cfiCommon0
          CFI Function _ZN7MKS_DLP16bank2disp_enableEhhh
        THUMB
// __interwork __softfp uint8_t MKS_DLP::bank2disp_enable(uint8_t, uint8_t, uint8_t)
_ZN7MKS_DLP16bank2disp_enableEhhh:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        MOV      R4,R0
        MOVS     R0,#+0
        STRB     R0,[R4, #+496]
        ADD      R5,R4,#+496
        STRB     R0,[R5, #+1]
        LSLS     R0,R3,#+6
        ORR      R0,R0,R2, LSL #+7
        ORR      R0,R0,R1, LSL #+4
        STRB     R0,[R5, #+2]
        MOVS     R6,#+0
        B.N      ??bank2disp_enable_0
??bank2disp_enable_1:
        ADDS     R6,R6,#+1
??bank2disp_enable_0:
        UXTB     R6,R6
        CMP      R6,#+5
        BGE.N    ??bank2disp_enable_2
        LDR.W    R7,??DataTable169_1  ;; 0x4240029c
        MOVS     R0,#+0
        STR      R0,[R7, #+0]
        LDRB     R0,[R4, #+496]
          CFI FunCall SPI1_ReadWriteByte
        BL       SPI1_ReadWriteByte
        LDRB     R0,[R5, #+1]
          CFI FunCall SPI1_ReadWriteByte
        BL       SPI1_ReadWriteByte
        LDRB     R0,[R5, #+2]
          CFI FunCall SPI1_ReadWriteByte
        BL       SPI1_ReadWriteByte
        MOVS     R0,#+1
        STR      R0,[R7, #+0]
        LDRB     R7,[R5, #+2]
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP14bank2disp_readEv
        BL       _ZN7MKS_DLP14bank2disp_readEv
        AND      R0,R0,#0xF0
        CMP      R7,R0
        BNE.N    ??bank2disp_enable_1
        MOVS     R0,#+1
        POP      {R1,R4-R7,PC}
??bank2disp_enable_2:
        MOVS     R0,#+0
        POP      {R1,R4-R7,PC}    ;; return
          CFI EndBlock cfiBlock116

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable157:
        DC32     axis_relative_modes

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable157_1:
        DC32     gArrayGpioPin

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable157_2:
        DC32     gArrayGpioPort

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock117 Using cfiCommon0
          CFI Function _ZN7MKS_DLP14reTransmissionEv
        THUMB
// __interwork __softfp uint8_t MKS_DLP::reTransmission()
_ZN7MKS_DLP14reTransmissionEv:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        MOV      R4,R0
        MOVS     R5,#+0
        LDR.W    R6,??DataTable169_1  ;; 0x4240029c
        LDR.W    R7,??DataTable169_2
        B.N      ??reTransmission_0
??reTransmission_1:
        ADDS     R5,R5,#+1
??reTransmission_0:
        UXTB     R5,R5
        CMP      R5,#+5
        BGE.N    ??reTransmission_2
        LDR      R0,[R7, #+8]
        ADDS     R0,R0,#+1
        STR      R0,[R7, #+8]
        MOVS     R0,#+0
        STR      R0,[R6, #+0]
        MOVS     R2,#+196
        ADD      R1,R4,#+276
        LDR.W    R0,??DataTable169_3
          CFI FunCall HAL_SPI_Transmit_DMA
        BL       HAL_SPI_Transmit_DMA
        LDR      R0,[R7, #+12]
        LDR      R1,[R0, #+0]
        BIC      R1,R1,#0x8
        STR      R1,[R0, #+0]
??reTransmission_3:
        LDR.W    R0,??DataTable169_4
        LDRSB    R0,[R0, #+53]
        CMP      R0,#+2
        BEQ.N    ??reTransmission_3
        MOVS     R0,#+1
        STR      R0,[R6, #+0]
        MOVS     R0,#+0
        STRB     R0,[SP, #+0]
        B.N      ??reTransmission_4
??reTransmission_5:
        LDRB     R0,[SP, #+0]
        ADDS     R0,R0,#+1
        STRB     R0,[SP, #+0]
??reTransmission_4:
        LDRB     R0,[SP, #+0]
        CMP      R0,#+10
        BLT.N    ??reTransmission_5
        LDR.W    R0,??DataTable169_5  ;; 0x42408200
        LDR      R0,[R0, #+0]
        STRB     R0,[R4, #+472]
        LDRB     R0,[R4, #+472]
        CMP      R0,#+1
        BNE.N    ??reTransmission_1
        MOVS     R0,#+1
        POP      {R1,R4-R7,PC}
??reTransmission_2:
        MOVS     R0,#+0
        POP      {R1,R4-R7,PC}    ;; return
          CFI EndBlock cfiBlock117

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock118 Using cfiCommon0
          CFI Function _ZN7MKS_DLP17line_fill_all_oneEh
        THUMB
// __interwork __softfp void MKS_DLP::line_fill_all_one(uint8_t)
_ZN7MKS_DLP17line_fill_all_oneEh:
        PUSH     {R3-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+32
        MOV      R4,R0
        MOV      R5,R1
        MOVS     R6,#+0
        ADD      R8,R4,#+80
        ADD      R9,R4,#+276
        B.N      ??line_fill_all_one_0
??line_fill_all_one_1:
        ASRS     R0,R6,#+8
        AND      R0,R0,#0xF
        ORR      R0,R0,R5, LSL #+4
        ORR      R0,R0,#0x40
        STRB     R0,[R4, #+80]
        STRB     R6,[R8, #+1]
        MOVS     R2,#+192
        MOVS     R1,#+255
        ADD      R0,R4,#+82
          CFI FunCall memset
        BL       memset
        MOVS     R1,#+194
        MOV      R0,R8
          CFI FunCall _Z12CRC16_XMODEMPhj
        BL       _Z12CRC16_XMODEMPhj
        STRH     R0,[R4, #+274]
??line_fill_all_one_2:
        LDRSB    R0,[R7, #+53]
        CMP      R0,#+2
        BEQ.N    ??line_fill_all_one_2
        LDR.W    R0,??DataTable169_5  ;; 0x42408200
        LDR      R0,[R0, #+0]
        STRB     R0,[R4, #+472]
        LDR.W    R7,??DataTable169_2
        LDRB     R0,[R4, #+472]
        CMP      R0,#+0
        BNE.N    ??line_fill_all_one_3
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP14reTransmissionEv
        BL       _ZN7MKS_DLP14reTransmissionEv
        LDR      R0,[R7, #+0]
        ADDS     R0,R0,#+1
        STR      R0,[R7, #+0]
??line_fill_all_one_3:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable169_1  ;; 0x4240029c
        STR      R0,[R1, #+0]
        MOVS     R2,#+196
        MOV      R1,R8
        MOV      R0,R9
          CFI FunCall memcpy
        BL       memcpy
        MOVS     R2,#+196
        MOV      R1,R9
        LDR.W    R0,??DataTable169_3
          CFI FunCall HAL_SPI_Transmit_DMA
        BL       HAL_SPI_Transmit_DMA
        LDR      R0,[R7, #+12]
        LDR      R1,[R0, #+0]
        BIC      R1,R1,#0x8
        STR      R1,[R0, #+0]
        ADDS     R6,R6,#+1
??line_fill_all_one_0:
        LDR.W    R7,??DataTable169_4
        CMP      R6,#+2560
        BLT.N    ??line_fill_all_one_1
??line_fill_all_one_4:
        LDRSB    R0,[R7, #+53]
        CMP      R0,#+2
        BEQ.N    ??line_fill_all_one_4
        MOVS     R0,#+1
        LDR.W    R1,??DataTable169_1  ;; 0x4240029c
        STR      R0,[R1, #+0]
        POP      {R0,R4-R9,PC}    ;; return
          CFI EndBlock cfiBlock118

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable159:
        DC32     soft_endstops_enabled

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock119 Using cfiCommon0
          CFI Function _ZN7MKS_DLP18line_fill_all_zeroEcth
        THUMB
// __interwork __softfp void MKS_DLP::line_fill_all_zero(char, uint16_t, uint8_t)
_ZN7MKS_DLP18line_fill_all_zeroEcth:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
        MOV      R4,R0
        MOV      R7,R2
        MOV      R5,R3
        CMP      R1,#+0
        BNE.N    ??line_fill_all_zero_0
        MOVS     R6,#+0
        B.N      ??line_fill_all_zero_1
??line_fill_all_zero_0:
        MOV      R6,R7
        MOV      R7,#+2560
        B.N      ??line_fill_all_zero_1
??line_fill_all_zero_2:
        ASRS     R0,R6,#+8
        AND      R0,R0,#0xF
        ORR      R0,R0,R5, LSL #+4
        ORR      R0,R0,#0x40
        STRB     R0,[R4, #+80]
        ADD      R9,R4,#+80
        STRB     R6,[R9, #+1]
        MOVS     R2,#+192
        MOVS     R1,#+0
        ADD      R0,R4,#+82
          CFI FunCall memset
        BL       memset
        MOVS     R1,#+194
        MOV      R0,R9
          CFI FunCall _Z12CRC16_XMODEMPhj
        BL       _Z12CRC16_XMODEMPhj
        STRH     R0,[R4, #+274]
??line_fill_all_zero_3:
        LDRSB    R0,[R8, #+53]
        CMP      R0,#+2
        BEQ.N    ??line_fill_all_zero_3
        LDR.W    R0,??DataTable169_5  ;; 0x42408200
        LDR      R0,[R0, #+0]
        STRB     R0,[R4, #+472]
        LDR.W    R8,??DataTable169_2
        LDRB     R0,[R4, #+472]
        CMP      R0,#+0
        BNE.N    ??line_fill_all_zero_4
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP14reTransmissionEv
        BL       _ZN7MKS_DLP14reTransmissionEv
        LDR      R0,[R8, #+0]
        ADDS     R0,R0,#+1
        STR      R0,[R8, #+0]
??line_fill_all_zero_4:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable169_1  ;; 0x4240029c
        STR      R0,[R1, #+0]
        ADD      R10,R4,#+276
        MOVS     R2,#+196
        MOV      R1,R9
        MOV      R0,R10
          CFI FunCall memcpy
        BL       memcpy
        MOVS     R2,#+196
        MOV      R1,R10
        LDR.W    R0,??DataTable169_3
          CFI FunCall HAL_SPI_Transmit_DMA
        BL       HAL_SPI_Transmit_DMA
        LDR      R0,[R8, #+12]
        LDR      R1,[R0, #+0]
        BIC      R1,R1,#0x8
        STR      R1,[R0, #+0]
        ADDS     R6,R6,#+1
        UXTH     R6,R6
??line_fill_all_zero_1:
        LDR.W    R8,??DataTable169_4
        CMP      R6,R7
        BLT.N    ??line_fill_all_zero_2
??line_fill_all_zero_5:
        LDRSB    R0,[R8, #+53]
        CMP      R0,#+2
        BEQ.N    ??line_fill_all_zero_5
        MOVS     R0,#+1
        LDR.W    R1,??DataTable169_1  ;; 0x4240029c
        STR      R0,[R1, #+0]
        POP      {R4-R10,PC}      ;; return
          CFI EndBlock cfiBlock119

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable160:
        DC32     leveling_first_time

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock120 Using cfiCommon0
          CFI Function _ZN7MKS_DLP14line_fill_zeroEth
        THUMB
// __interwork __softfp void MKS_DLP::line_fill_zero(uint16_t, uint8_t)
_ZN7MKS_DLP14line_fill_zeroEth:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R4,R0
        ASRS     R0,R1,#+8
        AND      R0,R0,#0xF
        ORR      R0,R0,R2, LSL #+4
        ORR      R0,R0,#0x40
        STRB     R0,[R4, #+80]
        ADD      R5,R4,#+80
        STRB     R1,[R5, #+1]
        MOVS     R2,#+192
        MOVS     R1,#+0
        ADD      R0,R4,#+82
          CFI FunCall memset
        BL       memset
        MOVS     R1,#+194
        MOV      R0,R5
          CFI FunCall _Z12CRC16_XMODEMPhj
        BL       _Z12CRC16_XMODEMPhj
        STRH     R0,[R4, #+274]
??line_fill_zero_0:
        LDR.W    R0,??DataTable169_4
        LDRSB    R0,[R0, #+53]
        CMP      R0,#+2
        BEQ.N    ??line_fill_zero_0
        LDR.W    R0,??DataTable169_5  ;; 0x42408200
        LDR      R0,[R0, #+0]
        STRB     R0,[R4, #+472]
        LDR.W    R6,??DataTable169_2
        LDRB     R0,[R4, #+472]
        CMP      R0,#+0
        BNE.N    ??line_fill_zero_1
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP14reTransmissionEv
        BL       _ZN7MKS_DLP14reTransmissionEv
        LDR      R0,[R6, #+0]
        ADDS     R0,R0,#+1
        STR      R0,[R6, #+0]
??line_fill_zero_1:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable169_1  ;; 0x4240029c
        STR      R0,[R1, #+0]
        ADD      R4,R4,#+276
        MOVS     R2,#+196
        MOV      R1,R5
        MOV      R0,R4
          CFI FunCall memcpy
        BL       memcpy
        MOVS     R2,#+196
        MOV      R1,R4
        LDR.W    R0,??DataTable169_3
          CFI FunCall HAL_SPI_Transmit_DMA
        BL       HAL_SPI_Transmit_DMA
        LDR      R0,[R6, #+12]
        LDR      R1,[R0, #+0]
        BIC      R1,R1,#0x8
        STR      R1,[R0, #+0]
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock120

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable161:
        DC32     card+0xCCC

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock121 Using cfiCommon0
          CFI Function _ZN7MKS_DLP13line_gen_dataEth
        THUMB
// __interwork __softfp void MKS_DLP::line_gen_data(uint16_t, uint8_t)
_ZN7MKS_DLP13line_gen_dataEth:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        MOV      R5,R0
        LSRS     R0,R1,#+8
        AND      R0,R0,#0xF
        ORR      R0,R0,R2, LSL #+4
        ORR      R0,R0,#0x40
        STRB     R0,[R5, #+80]
        ADD      R4,R5,#+80
        STRB     R1,[R4, #+1]
        MOVS     R2,#+192
        MOVS     R1,#+0
        ADD      R0,R5,#+82
          CFI FunCall memset
        BL       memset
        ADDW     R0,R5,#+82
        LDR.W    R1,??DataTable169_6
        MOVS     R2,#+0
        B.N      ??line_gen_data_0
??line_gen_data_1:
        LDRB     R3,[R0, #+0]
        LSLS     R3,R3,#+1
        STRB     R3,[R0, #+0]
        LDRB     R7,[R1], #+1
        CMP      R7,#+1
        BNE.N    ??line_gen_data_2
        ORR      R3,R3,#0x1
        STRB     R3,[R0, #+0]
??line_gen_data_2:
        ADDS     R6,R6,#+1
??line_gen_data_3:
        CMP      R6,#+8
        BLT.N    ??line_gen_data_1
        ADDS     R0,R0,#+1
        ADDS     R2,R2,#+1
??line_gen_data_0:
        CMP      R2,#+192
        BGE.N    ??line_gen_data_4
        MOVS     R6,#+0
        B.N      ??line_gen_data_3
??line_gen_data_4:
        MOVS     R1,#+194
        MOV      R0,R4
          CFI FunCall _Z12CRC16_XMODEMPhj
        BL       _Z12CRC16_XMODEMPhj
        STRH     R0,[R5, #+274]
??line_gen_data_5:
        LDR.W    R0,??DataTable169_4
        LDRSB    R0,[R0, #+53]
        CMP      R0,#+2
        BEQ.N    ??line_gen_data_5
        LDR.W    R0,??DataTable169_5  ;; 0x42408200
        LDR      R0,[R0, #+0]
        STRB     R0,[R5, #+472]
        LDR.W    R6,??DataTable169_2
        LDRB     R0,[R5, #+472]
        CMP      R0,#+0
        BNE.N    ??line_gen_data_6
        MOV      R0,R5
          CFI FunCall _ZN7MKS_DLP14reTransmissionEv
        BL       _ZN7MKS_DLP14reTransmissionEv
        LDR      R0,[R6, #+4]
        ADDS     R0,R0,#+1
        STR      R0,[R6, #+4]
??line_gen_data_6:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable169_1  ;; 0x4240029c
        STR      R0,[R1, #+0]
        ADD      R5,R5,#+276
        MOVS     R2,#+196
        MOV      R1,R4
        MOV      R0,R5
          CFI FunCall memcpy
        BL       memcpy
        MOVS     R2,#+196
        MOV      R1,R5
        LDR.W    R0,??DataTable169_3
          CFI FunCall HAL_SPI_Transmit_DMA
        BL       HAL_SPI_Transmit_DMA
        LDR      R0,[R6, #+12]
        LDR      R1,[R0, #+0]
        BIC      R1,R1,#0x8
        STR      R1,[R0, #+0]
        POP      {R0,R4-R7,PC}    ;; return
          CFI EndBlock cfiBlock121

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable162:
        DC32     curFileName

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock122 Using cfiCommon0
          CFI Function _ZN7MKS_DLP17line_gen_data_TFTEt
          CFI NoCalls
        THUMB
// __interwork __softfp void MKS_DLP::line_gen_data_TFT(uint16_t)
_ZN7MKS_DLP17line_gen_data_TFTEt:
        MOVS     R0,#+7
        TST      R1,R0
        BEQ.N    ??line_gen_data_TFT_0
        BX       LR
??line_gen_data_TFT_0:
        PUSH     {R4-R6}
          CFI R6 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        CMP      R1,#+0
        BEQ.N    ??line_gen_data_TFT_1
        ASRS     R0,R1,#+3
        SUBS     R0,R0,#+1
        UXTH     R0,R0
        MOVS     R1,#+23
        LDR.W    R2,??DataTable169_7
        MLA      R0,R1,R0,R2
        LDR.W    R1,??DataTable169_6
        MOV      R2,R1
        MOVS     R3,#+0
        B.N      ??line_gen_data_TFT_2
??line_gen_data_TFT_3:
        LDRB     R4,[R0, #+0]
        LSLS     R4,R4,#+1
        STRB     R4,[R0, #+0]
        LDRB     R6,[R2, #+0]
        CMP      R6,#+1
        BNE.N    ??line_gen_data_TFT_4
        ORR      R4,R4,#0x1
        STRB     R4,[R0, #+0]
??line_gen_data_TFT_4:
        ADDS     R2,R2,#+8
        SUBS     R4,R2,R1
        SUB      R4,R4,#+720
        CMP      R4,#+49
        BCS.N    ??line_gen_data_TFT_5
        ADDS     R2,R2,#+48
??line_gen_data_TFT_5:
        ADDS     R5,R5,#+1
??line_gen_data_TFT_6:
        CMP      R5,#+8
        BLT.N    ??line_gen_data_TFT_3
        ADDS     R0,R0,#+1
        ADDS     R3,R3,#+1
??line_gen_data_TFT_2:
        CMP      R3,#+23
        BGE.N    ??line_gen_data_TFT_1
        MOVS     R5,#+0
        B.N      ??line_gen_data_TFT_6
??line_gen_data_TFT_1:
        POP      {R4-R6}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI CFA R13+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock122

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable163:
        DC32     logo_tick2

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable163_1:
        DC32     logo_tick1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable163_2:
        DC32     gCfgItems

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable163_3:
        DC32     from_flash_pic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable163_4:
        DC32     flash_preview_begin

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable163_5:
        DC32     default_preview_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable163_6:
        DC32     continue_print_error_flg

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock123 Using cfiCommon0
          CFI Function _ZN7MKS_DLP15get_sdcard_bmpsEv
        THUMB
// __interwork __softfp void MKS_DLP::get_sdcard_bmps()
_ZN7MKS_DLP15get_sdcard_bmpsEv:
        PUSH     {R4-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+28
        SUB      SP,SP,#+36
          CFI CFA R13+64
        MOV      R4,R0
        LDR.W    R5,??DataTable165
        LDRB     R0,[R5, #+2488]
        CMP      R0,#+0
        BEQ.W    ??get_sdcard_bmps_0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader3eofEv
        BL       _ZN10CardReader3eofEv
        MOV      R0,R5
          CFI FunCall _ZN10CardReader8getsdposEv
        BL       _ZN10CardReader8getsdposEv
        STR      R0,[R5, #+3348]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        ADD      R6,SP,#+0
        LDRB     R0,[SP, #+0]
        LDRB     R1,[R6, #+1]
        LSLS     R1,R1,#+16
        ORR      R0,R1,R0, LSL #+24
        LDRB     R1,[R6, #+2]
        ORR      R0,R0,R1, LSL #+8
        LDRB     R1,[SP, #+3]
        ORRS     R0,R1,R0
        STR      R0,[R4, #+64]
        ADDW     R7,R5,#+3600
        MOV      R2,#+1536
        MOVS     R1,#+0
        MOV      R0,R7
          CFI FunCall memset
        BL       memset
        MOV      R2,#+7360
        MOVS     R1,#+0
        LDR.W    R0,??DataTable169_7
          CFI FunCall memset
        BL       memset
        MOV      R8,#+0
        ADD      R9,R4,#+64
        B.N      ??get_sdcard_bmps_1
??get_sdcard_bmps_2:
        ADD      R8,R8,#+1
??get_sdcard_bmps_1:
        LDR      R0,[R4, #+64]
        CMP      R8,R0
        BCS.W    ??get_sdcard_bmps_3
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R0,[SP, #+0]
        LDRB     R1,[R6, #+1]
        ORR      R0,R1,R0, LSL #+8
        STRH     R0,[R9, #+12]
        CMP      R0,#+1440
        BLT.N    ??get_sdcard_bmps_4
        MOVW     R0,#+1439
        STRH     R0,[R9, #+12]
??get_sdcard_bmps_4:
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R0,[SP, #+0]
        LDRB     R1,[R6, #+1]
        ORR      R0,R1,R0, LSL #+8
        STRH     R0,[R9, #+14]
        CMP      R0,#+1440
        BLT.N    ??get_sdcard_bmps_5
        MOVW     R0,#+1439
        STRH     R0,[R9, #+14]
??get_sdcard_bmps_5:
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R0,[SP, #+0]
        LDRB     R1,[R6, #+1]
        ORR      R0,R1,R0, LSL #+8
        STRH     R0,[R9, #+8]
        CMP      R0,#+2560
        BLT.N    ??get_sdcard_bmps_6
        MOVW     R0,#+2559
        STRH     R0,[R9, #+8]
??get_sdcard_bmps_6:
        CMP      R8,#+0
        BNE.N    ??get_sdcard_bmps_7
        MOVS     R3,#+0
        LDRH     R2,[R9, #+8]
        MOV      R1,R3
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP18line_fill_all_zeroEcth
        BL       _ZN7MKS_DLP18line_fill_all_zeroEcth
        LDRH     R0,[R9, #+8]
        STRH     R0,[R9, #+10]
??get_sdcard_bmps_7:
        LDRH     R1,[R9, #+10]
        LDRH     R0,[R9, #+8]
        CMP      R1,R0
        BNE.N    ??get_sdcard_bmps_8
        LDRH     R1,[R9, #+12]
        ADDS     R0,R1,R5
        ADDW     R0,R0,#+3600
        B.N      ??get_sdcard_bmps_9
??get_sdcard_bmps_10:
        MOVS     R2,#+1
        STRB     R2,[R0, #+48]
??get_sdcard_bmps_11:
        ADDS     R0,R0,#+1
        ADDS     R1,R1,#+1
??get_sdcard_bmps_9:
        LDRH     R2,[R9, #+14]
        ADDS     R2,R2,#+1
        CMP      R1,R2
        BGE.N    ??get_sdcard_bmps_2
        CMP      R1,#+720
        BGE.N    ??get_sdcard_bmps_10
        MOVS     R2,#+1
        STRB     R2,[R0, #+0]
        B.N      ??get_sdcard_bmps_11
??get_sdcard_bmps_8:
        MOVS     R2,#+0
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP13line_gen_dataEth
        BL       _ZN7MKS_DLP13line_gen_dataEth
        LDRH     R1,[R9, #+10]
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP17line_gen_data_TFTEt
        BL       _ZN7MKS_DLP17line_gen_data_TFTEt
        B.N      ??get_sdcard_bmps_12
??get_sdcard_bmps_13:
        ADDS     R1,R0,#+1
        STRH     R1,[R9, #+10]
        MOVS     R2,#+0
        UXTH     R1,R1
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP14line_fill_zeroEth
        BL       _ZN7MKS_DLP14line_fill_zeroEth
??get_sdcard_bmps_12:
        LDRH     R0,[R9, #+10]
        LDRH     R1,[R9, #+8]
        SUBS     R2,R1,R0
        CMP      R2,#+2
        BGE.N    ??get_sdcard_bmps_13
        STRH     R1,[R9, #+10]
        MOV      R2,#+1536
        MOVS     R1,#+0
        MOV      R0,R7
          CFI FunCall memset
        BL       memset
        LDRH     R1,[R9, #+12]
        ADDS     R0,R1,R5
        ADDW     R0,R0,#+3600
        B.N      ??get_sdcard_bmps_14
??get_sdcard_bmps_15:
        MOVS     R2,#+1
        STRB     R2,[R0, #+48]
??get_sdcard_bmps_16:
        ADDS     R0,R0,#+1
        ADDS     R1,R1,#+1
??get_sdcard_bmps_14:
        LDRH     R2,[R9, #+14]
        ADDS     R2,R2,#+1
        CMP      R1,R2
        BGE.W    ??get_sdcard_bmps_2
        CMP      R1,#+720
        BGE.N    ??get_sdcard_bmps_15
        MOVS     R2,#+1
        STRB     R2,[R0, #+0]
        B.N      ??get_sdcard_bmps_16
??get_sdcard_bmps_3:
        CMP      R0,#+2
        BCC.N    ??get_sdcard_bmps_17
        MOVS     R2,#+0
        LDRH     R1,[R9, #+10]
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP13line_gen_dataEth
        BL       _ZN7MKS_DLP13line_gen_dataEth
        LDRH     R1,[R9, #+10]
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP17line_gen_data_TFTEt
        BL       _ZN7MKS_DLP17line_gen_data_TFTEt
??get_sdcard_bmps_17:
        LDR.W    R0,??DataTable169_4
        LDRSB    R0,[R0, #+53]
        CMP      R0,#+2
        BEQ.N    ??get_sdcard_bmps_17
        MOVS     R0,#+1
        LDR.W    R1,??DataTable169_1  ;; 0x4240029c
        STR      R0,[R1, #+0]
        MOVS     R3,#+0
        ADD      R0,R4,#+64
        LDRH     R0,[R0, #+10]
        ADDS     R2,R0,#+1
        UXTH     R2,R2
        MOVS     R1,#+1
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP18line_fill_all_zeroEcth
        BL       _ZN7MKS_DLP18line_fill_all_zeroEcth
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R0,[SP, #+0]
        CMP      R0,#+13
        BNE.N    ??get_sdcard_bmps_18
        LDRB     R0,[R6, #+1]
        CMP      R0,#+10
        BEQ.N    ??get_sdcard_bmps_0
??get_sdcard_bmps_18:
          CFI FunCall _Z13find_next_bmpv
        BL       _Z13find_next_bmpv
??get_sdcard_bmps_0:
        ADD      SP,SP,#+36
          CFI CFA R13+28
        POP      {R4-R9,PC}       ;; return
          CFI EndBlock cfiBlock123

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable164:
        DC32     card+0xE00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable164_1:
        DC32     Serial6

        SECTION `.data`:DATA:REORDER:NOROOT(2)
axis_relative_modes:
        DATA
        DC8 0, 0, 0, 0
axis_homed:
        DC8 0, 0, 0, 0
axis_known_position:
        DC8 0, 0, 0, 0
temper_error_flg:
        DC8 0
mks_heating_busy:
        DC8 0
Running:
        DC8 1
marlin_debug_flags:
        DC8 0
commands_in_queue:
        DC8 0
        DC8 0
        DC8 0
active_extruder:
        DC8 0
        DC8 0
wait_for_heatup:
        DC8 1
target_extruder:
        DC8 0
serial_wait_tick:
        DC8 0
from_wifi_flag:
        DC8 0
// __absolute uint8_t aalay_cnt
aalay_cnt:
        DC8 0
        DC8 0, 0
        DC8 0, 0, 0, 0
feedrate_percentage:
        DC16 100
saved_feedrate_percentage:
        DC8 0, 0
current_position:
        DC32 0H
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
destination:
        DC32 0H
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
homing_feedrate_mm_s:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
home_offset:
        DC32 0H
        DC8 0, 0, 0, 0, 0, 0, 0, 0
home_bump_mm_P:
        DC32 40A00000H, 40A00000H, 40A00000H
        DC8 0, 0, 0, 0
        DC8 0, 0, 0, 0
        DC32 0
feedrate_mm_s:
        DC32 41C80000H
        DC8 0, 0, 0, 0
position_shift:
        DC32 0H
        DC8 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

        SECTION `.data`:DATA:REORDER:NOROOT(2)
soft_endstops_enabled:
        DATA
        DC8 1
        DC8 0, 0, 0
workspace_offset:
        DC32 0H
        DC8 0, 0, 0, 0, 0, 0, 0, 0
soft_endstop_min:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
soft_endstop_max:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

        SECTION `.data`:DATA:REORDER:NOROOT(2)
home_dir_P:
        DATA
        DC8 -1, -1, 0, 0
base_min_pos_P:
        DC32 0H, 0H, 0H
base_max_pos_P:
        DC32 43480000H, 43480000H, 0H
base_home_pos_P:
        DC32 0H, 0H, 0H
max_length_P:
        DC32 43480000H, 43480000H, 0H

        SECTION `.data`:DATA:REORDER:NOROOT(2)
wifi_loop_cycle:
        DATA
        DC32 500

        SECTION `.data`:DATA:REORDER:NOROOT(2)
// __absolute char *mks_pft_name
mks_pft_name:
        DATA
        DC32 `?<Constant "mks_pft.sys">`

        SECTION `.data`:DATA:REORDER:NOROOT(2)
// __absolute uint32_t volatile reTransmission_zero_cnt
reTransmission_zero_cnt:
        DATA
        DC32 0
// __absolute uint32_t volatile reTransmission_data_cnt
reTransmission_data_cnt:
        DC32 0
// __absolute uint32_t volatile reTransmission_all_cnt
reTransmission_all_cnt:
        DC32 0
// __absolute uint32_t volatile *spi1_hdmatx_CR
spi1_hdmatx_CR:
        DC32 40026488H

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock124 Using cfiCommon0
          CFI Function _ZN7MKS_DLP16bottomLayerPrintEv
        THUMB
// __interwork __softfp void MKS_DLP::bottomLayerPrint()
_ZN7MKS_DLP16bottomLayerPrintEv:
        PUSH     {R3-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+32
        MOV      R4,R0
        ADD      R5,R4,#+476
        LDRB     R0,[R5, #+2]
        CMP      R0,#+0
        BNE.N    ??bottomLayerPrint_0
        MOVS     R3,#+0
        MOV      R2,R3
        MOV      R1,R2
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        LDR.N    R7,??DataTable165
        LDRB     R0,[R7, #+3255]
        CMP      R0,#+1
        BNE.N    ??bottomLayerPrint_1
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP15get_sdcard_bmpsEv
        BL       _ZN7MKS_DLP15get_sdcard_bmpsEv
        MOVS     R0,#+1
        STRB     R0,[R5, #+3]
        MOV      R3,R0
        MOV      R2,R0
        MOVS     R1,#+0
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        B.N      ??bottomLayerPrint_2
??bottomLayerPrint_1:
        ADDW     R8,R7,#+3540
        LDR      R0,[R8, #+24]
        CMP      R0,#+2
        BLT.N    ??bottomLayerPrint_3
        LDR.W    R6,??DataTable169_8
        LDRB     R0,[R6, #+25]
        ADDS     R0,R0,#+1
        STRB     R0,[R6, #+25]
        MOV      R9,#+0
        B.N      ??bottomLayerPrint_4
??bottomLayerPrint_5:
        MOV      R2,R9
        LDRB     R1,[R5, #+2]
        LDR      R3,[R7, #+3540]
        MULS     R0,R3,R0
        ADDS     R1,R0,R1
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP21decode_layer_from_rleEjh
        BL       _ZN7MKS_DLP21decode_layer_from_rleEjh
        ADD      R9,R9,#+1
??bottomLayerPrint_4:
        UXTB     R9,R9
        MOV      R0,R9
        LDR      R1,[R8, #+24]
        CMP      R0,R1
        BLT.N    ??bottomLayerPrint_5
        MOVS     R0,#+1
        STRB     R0,[R5, #+3]
        MOV      R3,R0
        MOV      R2,R0
        MOVS     R1,#+0
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        B.N      ??bottomLayerPrint_2
??bottomLayerPrint_3:
        MOVS     R2,#+0
        LDRB     R1,[R5, #+2]
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP21decode_layer_from_rleEjh
        BL       _ZN7MKS_DLP21decode_layer_from_rleEjh
        MOVS     R0,#+1
        STRB     R0,[R5, #+3]
        MOV      R3,R0
        MOV      R2,R0
        MOVS     R1,#+0
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
??bottomLayerPrint_2:
        LDR.W    R6,??DataTable169_8
        LDR      R0,[R4, #+36]
        STR      R0,[R6, #+60]
        LDR.W    R0,??DataTable169_9
        VLDR     S0,[R0, #+16]
        VLDR.W   S1,??DataTable165_1  ;; 0x42f00000
        VDIV.F32 S0,S0,S1
        VSTR     S0,[SP, #+0]
        ADD      R1,SP,#+0
        ADD      R0,R6,#+60
          CFI FunCall _Z21do_blocking_move_to_zRKfS0_
        BL       _Z21do_blocking_move_to_zRKfS0_
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
        LDRB     R0,[R5, #+2]
        ADDS     R0,R0,#+1
        STRB     R0,[R5, #+2]
          CFI FunCall _Z22report_mksdlp_positionv
        BL       _Z22report_mksdlp_positionv
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP6led_onEv
        BL       _ZN7MKS_DLP6led_onEv
          CFI FunCall _Z10clr_ticketv
        BL       _Z10clr_ticketv
??bottomLayerPrint_0:
        LDRB     R0,[R5, #+3]
        CMP      R0,#+0
        BNE.N    ??bottomLayerPrint_6
        ADD      R1,R4,#+36
        LDR      R1,[R1, #+8]
        LDR      R2,[R4, #+728]
        CMP      R1,R2
        BCC.N    ??bottomLayerPrint_7
??bottomLayerPrint_6:
        CMP      R0,#+0
        BNE.N    ??bottomLayerPrint_8
        LDR.W    R0,??DataTable169_8
        LDRB     R0,[R0, #+25]
        CMP      R0,#+0
        BEQ.N    ??bottomLayerPrint_8
        LDR.W    R0,??DataTable169_10
        LDR      R0,[R0, #+24]
        CMP      R0,#+2
        BLT.N    ??bottomLayerPrint_8
??bottomLayerPrint_7:
        LDR.N    R7,??DataTable165
        LDRB     R0,[R7, #+3255]
        CMP      R0,#+1
        BEQ.N    ??bottomLayerPrint_9
        ADDW     R8,R7,#+3540
        LDR      R0,[R8, #+24]
        CMP      R0,#+2
        BLT.N    ??bottomLayerPrint_10
        LDR.W    R6,??DataTable169_8
        LDRB     R0,[R6, #+25]
        CMP      R0,#+0
        BNE.N    ??bottomLayerPrint_11
        MOV      R9,#+0
        B.N      ??bottomLayerPrint_12
??bottomLayerPrint_13:
        MOV      R2,R9
        LDRB     R1,[R5, #+2]
        LDR      R3,[R7, #+3540]
        MULS     R0,R3,R0
        ADDS     R1,R0,R1
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP21decode_layer_from_rleEjh
        BL       _ZN7MKS_DLP21decode_layer_from_rleEjh
        ADD      R9,R9,#+1
??bottomLayerPrint_12:
        UXTB     R9,R9
        MOV      R0,R9
        LDR      R1,[R8, #+24]
        CMP      R0,R1
        BLT.N    ??bottomLayerPrint_13
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP6led_onEv
        BL       _ZN7MKS_DLP6led_onEv
??bottomLayerPrint_11:
        MOVS     R3,#+1
        MOV      R2,R3
        LDRB     R1,[R6, #+25]
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        LDRB     R0,[R6, #+25]
        ADDS     R0,R0,#+1
        STRB     R0,[R6, #+25]
        MOVS     R0,#+1
        STRB     R0,[R5, #+3]
          CFI FunCall _Z10clr_ticketv
        BL       _Z10clr_ticketv
        B.N      ??bottomLayerPrint_8
??bottomLayerPrint_10:
        MOVS     R2,#+0
        LDRB     R1,[R5, #+2]
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP21decode_layer_from_rleEjh
        BL       _ZN7MKS_DLP21decode_layer_from_rleEjh
        MOVS     R3,#+1
        MOV      R2,R3
        MOVS     R1,#+0
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        MOVS     R0,#+1
        STRB     R0,[R5, #+3]
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP6led_onEv
        BL       _ZN7MKS_DLP6led_onEv
          CFI FunCall _Z10clr_ticketv
        BL       _Z10clr_ticketv
        B.N      ??bottomLayerPrint_8
??bottomLayerPrint_9:
        MOVS     R3,#+1
        MOV      R2,R3
        MOVS     R1,#+0
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        MOVS     R0,#+1
        STRB     R0,[R5, #+3]
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP6led_onEv
        BL       _ZN7MKS_DLP6led_onEv
          CFI FunCall _Z10clr_ticketv
        BL       _Z10clr_ticketv
??bottomLayerPrint_8:
        LDRB     R0,[R5, #+3]
        CMP      R0,#+0
        BEQ.N    ??bottomLayerPrint_14
        ADD      R0,R4,#+36
        LDR      R1,[R0, #+24]
        LDR      R2,[R4, #+728]
        CMP      R1,R2
        BCS.N    ??bottomLayerPrint_14
        LDR.W    R6,??DataTable169_8
        LDRB     R1,[R5, #+2]
        LDRH     R2,[R0, #+16]
        CMP      R1,R2
        BCS.N    ??bottomLayerPrint_15
        MOVS     R0,#+0
        STRB     R0,[R5, #+3]
          CFI FunCall _Z10clr_ticketv
        BL       _Z10clr_ticketv
        LDR.N    R7,??DataTable165
        ADDW     R8,R7,#+3540
        LDR      R0,[R8, #+24]
        CMP      R0,#+2
        BLT.N    ??bottomLayerPrint_16
        LDRB     R1,[R6, #+25]
        CMP      R1,R0
        BLT.N    ??bottomLayerPrint_17
        MOVS     R0,#+0
        STRB     R0,[R6, #+25]
        LDR.W    R1,??DataTable169_11  ;; 0x42420288
        STR      R0,[R1, #+0]
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP14CleanDataTransEv
        BL       _ZN7MKS_DLP14CleanDataTransEv
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP7led_offEv
        BL       _ZN7MKS_DLP7led_offEv
        MOVS     R1,#+166
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP23write_Information_layerE15DLP_MOVE_STATUS
        BL       _ZN7MKS_DLP23write_Information_layerE15DLP_MOVE_STATUS
        LDR.W    R0,??DataTable169_9
        VLDR     S0,[R0, #+16]
        VLDR.W   S1,??DataTable165_1  ;; 0x42f00000
        VDIV.F32 S1,S0,S1
        VLDR     S0,[R6, #+104]
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP14moveRelative_ZEff
        BL       _ZN7MKS_DLP14moveRelative_ZEff
        LDRB     R0,[R7, #+3344]
        CMP      R0,#+167
        BNE.N    ??bottomLayerPrint_18
        B.N      ??bottomLayerPrint_19
??bottomLayerPrint_16:
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP7led_offEv
        BL       _ZN7MKS_DLP7led_offEv
        MOVS     R1,#+166
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP23write_Information_layerE15DLP_MOVE_STATUS
        BL       _ZN7MKS_DLP23write_Information_layerE15DLP_MOVE_STATUS
        LDR.W    R0,??DataTable169_9
        VLDR     S0,[R0, #+16]
        VLDR.W   S1,??DataTable165_1  ;; 0x42f00000
        VDIV.F32 S1,S0,S1
        VLDR     S0,[R6, #+104]
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP14moveRelative_ZEff
        BL       _ZN7MKS_DLP14moveRelative_ZEff
        LDRB     R0,[R7, #+3344]
        CMP      R0,#+167
        BNE.N    ??bottomLayerPrint_18
??bottomLayerPrint_19:
        LDR.W    R0,??DataTable169_9
        VLDR     S0,[R0, #+16]
        VLDR.W   S1,??DataTable165_1  ;; 0x42f00000
        VDIV.F32 S1,S0,S1
        VLDR     S0,[R4, #+36]
        VLDR     S2,[R6, #+104]
        VSUB.F32 S0,S0,S2
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP14moveRelative_ZEff
        BL       _ZN7MKS_DLP14moveRelative_ZEff
??bottomLayerPrint_18:
        MOVS     R1,#+167
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP23write_Information_layerE15DLP_MOVE_STATUS
        BL       _ZN7MKS_DLP23write_Information_layerE15DLP_MOVE_STATUS
        LDRB     R0,[R5, #+2]
        ADDS     R0,R0,#+1
        STRB     R0,[R5, #+2]
??bottomLayerPrint_17:
          CFI FunCall _Z22report_mksdlp_positionv
        BL       _Z22report_mksdlp_positionv
        B.N      ??bottomLayerPrint_14
??bottomLayerPrint_15:
        MOVS     R1,#+0
        STRB     R1,[R6, #+25]
        LDR      R0,[R0, #+20]
        ADDS     R0,R0,#+1
        STR      R0,[R4, #+728]
        LDRH     R0,[R4, #+476]
        ADDS     R0,R0,#+1
        STRH     R0,[R4, #+476]
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP18GeneralLayersPrintEv
        BL       _ZN7MKS_DLP18GeneralLayersPrintEv
??bottomLayerPrint_14:
        POP      {R0,R4-R9,PC}    ;; return
          CFI EndBlock cfiBlock124

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable165:
        DC32     card

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable165_1:
        DC32     0x42f00000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable165_2:
        DC32     0x186af

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock125 Using cfiCommon0
          CFI Function _ZN7MKS_DLP18GeneralLayersPrintEv
        THUMB
// __interwork __softfp void MKS_DLP::GeneralLayersPrint()
_ZN7MKS_DLP18GeneralLayersPrintEv:
        PUSH     {R3-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+32
        MOV      R4,R0
        ADD      R5,R4,#+476
        LDRB     R0,[R5, #+3]
        CMP      R0,#+0
        BEQ.W    ??GeneralLayersPrint_0
        ADD      R6,R4,#+12
        LDR      R0,[R6, #+44]
        LDR      R1,[R4, #+728]
        CMP      R0,R1
        BCS.W    ??GeneralLayersPrint_0
        LDRH     R0,[R4, #+12]
        LDRH     R1,[R4, #+476]
        LDR.W    R7,??DataTable169_12
        CMP      R1,R0
        BCS.N    ??GeneralLayersPrint_1
        LDRB     R2,[R7, #+3255]
        CMP      R2,#+1
        BEQ.N    ??GeneralLayersPrint_2
??GeneralLayersPrint_1:
        SUBS     R1,R1,#+1
        LDRH     R2,[R6, #+40]
        SUBS     R0,R0,R2
        CMP      R1,R0
        BGE.W    ??GeneralLayersPrint_3
        LDRB     R0,[R7, #+3255]
        CMP      R0,#+1
        BEQ.W    ??GeneralLayersPrint_3
??GeneralLayersPrint_2:
        LDR.W    R8,??DataTable169_8
        LDR      R0,[R7, #+3564]
        CMP      R0,#+2
        BLT.N    ??GeneralLayersPrint_4
        MOVS     R0,#+0
        STRB     R0,[R5, #+3]
        LDRB     R0,[R8, #+25]
        CMP      R0,#+0
        BNE.N    ??GeneralLayersPrint_5
        MOVS     R0,#+0
        LDR.W    R1,??DataTable169_11  ;; 0x42420288
        STR      R0,[R1, #+0]
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP14CleanDataTransEv
        BL       _ZN7MKS_DLP14CleanDataTransEv
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP7led_offEv
        BL       _ZN7MKS_DLP7led_offEv
        LDRB     R0,[R8, #+25]
        ADDS     R0,R0,#+1
        STRB     R0,[R8, #+25]
        MOVS     R3,#+0
        MOV      R2,R3
        MOV      R1,R2
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        MOVS     R1,#+166
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP23write_Information_layerE15DLP_MOVE_STATUS
        BL       _ZN7MKS_DLP23write_Information_layerE15DLP_MOVE_STATUS
        LDR.W    R9,??DataTable169_9
        VLDR     S0,[R9, #+16]
        VLDR.W   S1,??DataTable168  ;; 0x42f00000
        VDIV.F32 S1,S0,S1
        VLDR     S0,[R8, #+104]
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP22moveRelativeZandGetBmpEff
        BL       _ZN7MKS_DLP22moveRelativeZandGetBmpEff
        LDRB     R0,[R7, #+3344]
        CMP      R0,#+167
        BNE.N    ??GeneralLayersPrint_6
        VLDR     S0,[R9, #+16]
        VLDR.W   S1,??DataTable168  ;; 0x42f00000
        VDIV.F32 S1,S0,S1
        VLDR     S0,[R6, #+24]
        VLDR     S2,[R8, #+104]
        VSUB.F32 S0,S0,S2
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP14moveRelative_ZEff
        BL       _ZN7MKS_DLP14moveRelative_ZEff
??GeneralLayersPrint_6:
        MOVS     R1,#+167
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP23write_Information_layerE15DLP_MOVE_STATUS
        BL       _ZN7MKS_DLP23write_Information_layerE15DLP_MOVE_STATUS
??GeneralLayersPrint_5:
          CFI FunCall _Z10clr_ticketv
        BL       _Z10clr_ticketv
        B.N      ??GeneralLayersPrint_7
??GeneralLayersPrint_4:
        MOVS     R0,#+0
        STRB     R0,[R5, #+3]
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP7led_offEv
        BL       _ZN7MKS_DLP7led_offEv
          CFI FunCall _Z10clr_ticketv
        BL       _Z10clr_ticketv
        MOVS     R3,#+0
        MOV      R2,R3
        MOV      R1,R2
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        MOVS     R1,#+166
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP23write_Information_layerE15DLP_MOVE_STATUS
        BL       _ZN7MKS_DLP23write_Information_layerE15DLP_MOVE_STATUS
        LDR.W    R9,??DataTable169_9
        VLDR     S0,[R9, #+16]
        VLDR.W   S1,??DataTable168  ;; 0x42f00000
        VDIV.F32 S1,S0,S1
        VLDR     S0,[R8, #+104]
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP22moveRelativeZandGetBmpEff
        BL       _ZN7MKS_DLP22moveRelativeZandGetBmpEff
        LDRB     R0,[R7, #+3344]
        CMP      R0,#+167
        BNE.N    ??GeneralLayersPrint_8
        VLDR     S0,[R9, #+16]
        VLDR.W   S1,??DataTable168  ;; 0x42f00000
        VDIV.F32 S1,S0,S1
        VLDR     S0,[R6, #+24]
        VLDR     S2,[R8, #+104]
        VSUB.F32 S0,S0,S2
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP14moveRelative_ZEff
        BL       _ZN7MKS_DLP14moveRelative_ZEff
??GeneralLayersPrint_8:
        MOVS     R1,#+167
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP23write_Information_layerE15DLP_MOVE_STATUS
        BL       _ZN7MKS_DLP23write_Information_layerE15DLP_MOVE_STATUS
??GeneralLayersPrint_7:
          CFI FunCall _Z22report_mksdlp_positionv
        BL       _Z22report_mksdlp_positionv
        B.N      ??GeneralLayersPrint_0
??GeneralLayersPrint_3:
        LDR      R0,[R7, #+3564]
        CMP      R0,#+2
        BLT.N    ??GeneralLayersPrint_9
        MOVS     R0,#+0
        LDR.N    R1,??DataTable169_11  ;; 0x42420288
        STR      R0,[R1, #+0]
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP24ExposureDataTrans_circleEv
        BL       _ZN7MKS_DLP24ExposureDataTrans_circleEv
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP14CleanDataTransEv
        BL       _ZN7MKS_DLP14CleanDataTransEv
??GeneralLayersPrint_9:
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP19printingHasFinishedEv
        BL       _ZN7MKS_DLP19printingHasFinishedEv
??GeneralLayersPrint_0:
        LDRB     R0,[R5, #+3]
        CMP      R0,#+0
        BNE.N    ??GeneralLayersPrint_10
        ADD      R1,R4,#+12
        LDR      R1,[R1, #+32]
        LDR      R2,[R4, #+728]
        CMP      R1,R2
        BCC.N    ??GeneralLayersPrint_11
??GeneralLayersPrint_10:
        CMP      R0,#+0
        BNE.N    ??GeneralLayersPrint_12
        LDR.N    R0,??DataTable169_8
        LDRB     R0,[R0, #+25]
        CMP      R0,#+0
        BEQ.N    ??GeneralLayersPrint_12
        LDR.N    R0,??DataTable169_12
        LDR      R0,[R0, #+3564]
        CMP      R0,#+2
        BLT.N    ??GeneralLayersPrint_12
??GeneralLayersPrint_11:
        LDR.N    R7,??DataTable169_12
        LDR      R0,[R7, #+3564]
        CMP      R0,#+2
        BLT.N    ??GeneralLayersPrint_13
        LDR.W    R8,??DataTable169_8
        MOVS     R3,#+1
        MOV      R2,R3
        LDRB     R0,[R8, #+25]
        SUBS     R1,R0,#+1
        UXTB     R1,R1
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        LDRB     R0,[R8, #+25]
        CMP      R0,#+1
        BNE.N    ??GeneralLayersPrint_14
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP6led_onEv
        BL       _ZN7MKS_DLP6led_onEv
??GeneralLayersPrint_14:
        LDRB     R0,[R8, #+25]
        ADDS     R0,R0,#+1
        STRB     R0,[R8, #+25]
        MOVS     R0,#+1
        STRB     R0,[R5, #+3]
          CFI FunCall _Z10clr_ticketv
        BL       _Z10clr_ticketv
        LDRB     R0,[R8, #+25]
        SUBS     R0,R0,#+1
        LDR      R1,[R7, #+3564]
        CMP      R0,R1
        BLT.N    ??GeneralLayersPrint_12
        MOVS     R0,#+0
        STRB     R0,[R8, #+25]
        LDRH     R0,[R4, #+476]
        ADDS     R0,R0,#+1
        STRH     R0,[R4, #+476]
        B.N      ??GeneralLayersPrint_12
??GeneralLayersPrint_13:
        MOVS     R3,#+1
        MOV      R2,R3
        MOVS     R1,#+0
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP6led_onEv
        BL       _ZN7MKS_DLP6led_onEv
        MOVS     R0,#+1
        STRB     R0,[R5, #+3]
          CFI FunCall _Z10clr_ticketv
        BL       _Z10clr_ticketv
        LDRH     R0,[R4, #+476]
        ADDS     R0,R0,#+1
        STRH     R0,[R4, #+476]
??GeneralLayersPrint_12:
        POP      {R0,R4-R9,PC}    ;; return
          CFI EndBlock cfiBlock125

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock126 Using cfiCommon0
          CFI Function _ZN7MKS_DLP18get_available_bmpsEv
        THUMB
// __interwork __softfp void MKS_DLP::get_available_bmps()
_ZN7MKS_DLP18get_available_bmpsEv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        LDR.N    R5,??DataTable169_12
        LDRB     R0,[R5, #+2488]
        CMP      R0,#+0
        BEQ.N    ??get_available_bmps_0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader3eofEv
        BL       _ZN10CardReader3eofEv
        LDRH     R1,[R4, #+476]
        LDRH     R2,[R4, #+12]
        CMP      R2,R1
        BCC.N    ??get_available_bmps_1
        CMP      R0,#+0
        BEQ.N    ??get_available_bmps_2
??get_available_bmps_1:
        LDRB     R0,[R5, #+3255]
        CMP      R0,#+1
        BEQ.N    ??get_available_bmps_3
??get_available_bmps_2:
        SUBS     R0,R1,#+1
        CMP      R2,R0
        BGE.N    ??get_available_bmps_4
        LDRB     R0,[R5, #+3255]
        CMP      R0,#+1
        BEQ.N    ??get_available_bmps_4
??get_available_bmps_3:
        MOV      R0,R4
        POP      {R1,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7MKS_DLP19printingHasFinishedEv
        B.W      _ZN7MKS_DLP19printingHasFinishedEv
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??get_available_bmps_4:
        CMP      R1,#+0
        MOV      R0,R4
        BNE.N    ??get_available_bmps_5
        POP      {R1,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7MKS_DLP16bottomLayerPrintEv
        B.N      _ZN7MKS_DLP16bottomLayerPrintEv
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??get_available_bmps_5:
        POP      {R1,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7MKS_DLP18GeneralLayersPrintEv
        B.N      _ZN7MKS_DLP18GeneralLayersPrintEv
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??get_available_bmps_0:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock126

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable167:
        DC32     0x2fa37

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock127 Using cfiCommon0
          CFI Function _ZN7MKS_DLP24ExposureDataTrans_circleEv
        THUMB
// __interwork __softfp void MKS_DLP::ExposureDataTrans_circle()
_ZN7MKS_DLP24ExposureDataTrans_circleEv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R4,R0
        MOVS     R3,#+0
        MOV      R2,R3
        MOVS     R1,#+1
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        MOVS     R3,#+1
        MOV      R2,#+780
        MOVS     R1,#+0
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP18line_fill_all_zeroEcth
        BL       _ZN7MKS_DLP18line_fill_all_zeroEcth
        MOV      R2,#+7360
        MOVS     R1,#+0
        LDR.N    R0,??DataTable169_7
          CFI FunCall memset
        BL       memset
        MOVS     R5,#+0
        B.N      ??ExposureDataTrans_circle_0
??ExposureDataTrans_circle_1:
        ADD      R6,R5,#+780
        MOVS     R2,#+1
        MOV      R1,R6
        UXTH     R1,R1
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP13line_gen_dataEth
        BL       _ZN7MKS_DLP13line_gen_dataEth
        MOV      R1,R6
        UXTH     R1,R1
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP17line_gen_data_TFTEt
        BL       _ZN7MKS_DLP17line_gen_data_TFTEt
        ADDS     R5,R5,#+1
??ExposureDataTrans_circle_0:
        CMP      R5,#+1000
        BGE.N    ??ExposureDataTrans_circle_2
        LDR.N    R6,??DataTable169_12
        MOV      R2,#+1536
        MOVS     R1,#+0
        ADD      R0,R6,#+3600
          CFI FunCall memset
        BL       memset
        ADD      R0,R5,R5, LSL #+1
        LSLS     R0,R0,#+1
        ADR.W    R1,exposure_bmp_data_circle
        LDRH     R2,[R0, R1]
        ADDS     R3,R2,R6
        ADDW     R3,R3,#+3600
        B.N      ??ExposureDataTrans_circle_3
??ExposureDataTrans_circle_4:
        MOVS     R6,#+1
        STRB     R6,[R3, #+48]
??ExposureDataTrans_circle_5:
        ADDS     R3,R3,#+1
        ADDS     R2,R2,#+1
??ExposureDataTrans_circle_3:
        ADDS     R6,R0,R1
        LDRH     R6,[R6, #+2]
        ADDS     R6,R6,#+1
        CMP      R2,R6
        BGE.N    ??ExposureDataTrans_circle_1
        CMP      R2,#+720
        BGE.N    ??ExposureDataTrans_circle_4
        MOVS     R6,#+1
        STRB     R6,[R3, #+0]
        B.N      ??ExposureDataTrans_circle_5
??ExposureDataTrans_circle_2:
        LDR.N    R0,??DataTable169_4
        LDRSB    R0,[R0, #+53]
        CMP      R0,#+2
        BEQ.N    ??ExposureDataTrans_circle_2
        MOVS     R0,#+1
        LDR.N    R1,??DataTable169_1  ;; 0x4240029c
        STR      R0,[R1, #+0]
        MOV      R3,R0
        MOVW     R2,#+1780
        MOV      R1,R0
        MOV      R0,R4
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7MKS_DLP18line_fill_all_zeroEcth
        B.W      _ZN7MKS_DLP18line_fill_all_zeroEcth
          CFI EndBlock cfiBlock127

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable168:
        DC32     0x42f00000

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock128 Using cfiCommon0
          CFI Function _ZN7MKS_DLP14CleanDataTransEv
        THUMB
// __interwork __softfp void MKS_DLP::CleanDataTrans()
_ZN7MKS_DLP14CleanDataTransEv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
        MOVS     R3,#+0
        MOV      R2,R3
        MOVS     R1,#+2
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        MOVS     R3,#+2
        MOV      R2,#+2560
        MOVS     R1,#+0
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7MKS_DLP18line_fill_all_zeroEcth
        B.W      _ZN7MKS_DLP18line_fill_all_zeroEcth
          CFI EndBlock cfiBlock128

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock129 Using cfiCommon0
          CFI Function _ZN7MKS_DLP23ExposureData2TFT_circleEv
        THUMB
// __interwork __softfp void MKS_DLP::ExposureData2TFT_circle()
_ZN7MKS_DLP23ExposureData2TFT_circleEv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R4,R0
        MOVS     R3,#+1
        MOV      R2,#+780
        MOVS     R1,#+0
          CFI FunCall _ZN7MKS_DLP18line_fill_all_zeroEcth
        BL       _ZN7MKS_DLP18line_fill_all_zeroEcth
        MOV      R2,#+7360
        MOVS     R1,#+0
        LDR.N    R0,??DataTable169_7
          CFI FunCall memset
        BL       memset
        MOVS     R5,#+0
        B.N      ??ExposureData2TFT_circle_0
??ExposureData2TFT_circle_1:
        ADD      R1,R5,#+780
        UXTH     R1,R1
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP17line_gen_data_TFTEt
        BL       _ZN7MKS_DLP17line_gen_data_TFTEt
??ExposureData2TFT_circle_2:
        ADDS     R5,R5,#+1
??ExposureData2TFT_circle_0:
        CMP      R5,#+1000
        BGE.N    ??ExposureData2TFT_circle_3
        ADD      R0,R5,#+780
        ASRS     R1,R0,#+2
        ADD      R1,R0,R1, LSR #+29
        ASRS     R1,R1,#+3
        SUBS     R0,R0,R1, LSL #+3
        BNE.N    ??ExposureData2TFT_circle_2
        LDR.N    R6,??DataTable169_12
        MOV      R2,#+1536
        MOVS     R1,#+0
        ADD      R0,R6,#+3600
          CFI FunCall memset
        BL       memset
        ADD      R0,R5,R5, LSL #+1
        LSLS     R0,R0,#+1
        ADR.W    R1,exposure_bmp_data_circle
        LDRH     R2,[R0, R1]
        ADDS     R3,R2,R6
        ADDW     R3,R3,#+3600
        B.N      ??ExposureData2TFT_circle_4
??ExposureData2TFT_circle_5:
        MOVS     R6,#+1
        STRB     R6,[R3, #+48]
??ExposureData2TFT_circle_6:
        ADDS     R3,R3,#+1
        ADDS     R2,R2,#+1
??ExposureData2TFT_circle_4:
        ADDS     R6,R0,R1
        LDRH     R6,[R6, #+2]
        ADDS     R6,R6,#+1
        CMP      R2,R6
        BGE.N    ??ExposureData2TFT_circle_1
        CMP      R2,#+720
        BGE.N    ??ExposureData2TFT_circle_5
        MOVS     R6,#+1
        STRB     R6,[R3, #+0]
        B.N      ??ExposureData2TFT_circle_6
??ExposureData2TFT_circle_3:
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock129

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable169:
        DC32     `?<Constant "G28 Z0">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable169_1:
        DC32     0x4240029c

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable169_2:
        DC32     reTransmission_zero_cnt

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable169_3:
        DC32     hspi1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable169_4:
        DC32     hdma_spi1_tx

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable169_5:
        DC32     0x42408200

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable169_6:
        DC32     card+0xE10

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable169_7:
        DC32     bmp_layer_buf

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable169_8:
        DC32     axis_relative_modes

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable169_9:
        DC32     mksCfg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable169_10:
        DC32     card+0xDD4

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable169_11:
        DC32     0x42420288

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable169_12:
        DC32     card

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
// static __absolute unsigned short const exposure_bmp_data_circle[1000][3]
exposure_bmp_data_circle:
        DC16 720, 720, 780, 690, 750, 781, 681, 759, 782, 673, 767, 783, 665
        DC16 775, 784, 656, 784, 785, 648, 792, 786, 639, 801, 787, 632, 808
        DC16 788, 627, 813, 789, 623, 817, 790, 619, 821, 791, 615, 825, 792
        DC16 611, 829, 793, 607, 833, 794, 603, 837, 795, 598, 842, 796, 594
        DC16 846, 797, 590, 850, 798, 586, 854, 799, 582, 858, 800, 578, 862
        DC16 801, 574, 866, 802, 571, 869, 803, 569, 871, 804, 566, 874, 805
        DC16 563, 877, 806, 560, 880, 807, 558, 882, 808, 555, 885, 809, 552
        DC16 888, 810, 550, 890, 811, 547, 893, 812, 544, 896, 813, 542, 898
        DC16 814, 539, 901, 815, 536, 904, 816, 534, 906, 817, 531, 909, 818
        DC16 528, 912, 819, 525, 915, 820, 523, 917, 821, 520, 920, 822, 518
        DC16 922, 823, 516, 924, 824, 514, 926, 825, 512, 928, 826, 510, 930
        DC16 827, 508, 932, 828, 506, 934, 829, 504, 936, 830, 502, 938, 831
        DC16 500, 940, 832, 498, 942, 833, 496, 944, 834, 494, 946, 835, 492
        DC16 948, 836, 491, 949, 837, 489, 951, 838, 487, 953, 839, 485, 955
        DC16 840, 483, 957, 841, 481, 959, 842, 479, 961, 843, 477, 963, 844
        DC16 475, 965, 845, 473, 967, 846, 471, 969, 847, 469, 971, 848, 467
        DC16 973, 849, 465, 975, 850, 464, 976, 851, 462, 978, 852, 461, 979
        DC16 853, 460, 980, 854, 458, 982, 855, 457, 983, 856, 455, 985, 857
        DC16 454, 986, 858, 452, 988, 859, 451, 989, 860, 449, 991, 861, 448
        DC16 992, 862, 446, 994, 863, 445, 995, 864, 443, 997, 865, 442, 998
        DC16 866, 440, 1000, 867, 439, 1001, 868, 437, 1003, 869, 436, 1004
        DC16 870, 434, 1006, 871, 433, 1007, 872, 431, 1009, 873, 430, 1010
        DC16 874, 428, 1012, 875, 427, 1013, 876, 425, 1015, 877, 424, 1016
        DC16 878, 422, 1018, 879, 421, 1019, 880, 419, 1021, 881, 418, 1022
        DC16 882, 417, 1023, 883, 415, 1025, 884, 414, 1026, 885, 413, 1027
        DC16 886, 412, 1028, 887, 411, 1029, 888, 410, 1030, 889, 408, 1032
        DC16 890, 407, 1033, 891, 406, 1034, 892, 405, 1035, 893, 404, 1036
        DC16 894, 403, 1037, 895, 402, 1038, 896, 400, 1040, 897, 399, 1041
        DC16 898, 398, 1042, 899, 397, 1043, 900, 396, 1044, 901, 395, 1045
        DC16 902, 393, 1047, 903, 392, 1048, 904, 391, 1049, 905, 390, 1050
        DC16 906, 389, 1051, 907, 388, 1052, 908, 386, 1054, 909, 385, 1055
        DC16 910, 384, 1056, 911, 383, 1057, 912, 382, 1058, 913, 381, 1059
        DC16 914, 379, 1061, 915, 378, 1062, 916, 377, 1063, 917, 376, 1064
        DC16 918, 375, 1065, 919, 374, 1066, 920, 372, 1067, 921, 372, 1068
        DC16 922, 371, 1069, 923, 370, 1070, 924, 369, 1071, 925, 368, 1072
        DC16 926, 367, 1073, 927, 366, 1074, 928, 365, 1075, 929, 364, 1076
        DC16 930, 363, 1077, 931, 362, 1078, 932, 361, 1079, 933, 361, 1079
        DC16 934, 360, 1080, 935, 359, 1081, 936, 358, 1082, 937, 357, 1083
        DC16 938, 356, 1084, 939, 355, 1085, 940, 354, 1086, 941, 353, 1087
        DC16 942, 352, 1088, 943, 351, 1089, 944, 350, 1090, 945, 350, 1090
        DC16 946, 349, 1091, 947, 348, 1092, 948, 347, 1093, 949, 346, 1094
        DC16 950, 345, 1095, 951, 344, 1096, 952, 343, 1097, 953, 342, 1098
        DC16 954, 341, 1099, 955, 340, 1100, 956, 339, 1100, 957, 339, 1101
        DC16 958, 338, 1102, 959, 337, 1103, 960, 336, 1104, 961, 335, 1105
        DC16 962, 334, 1106, 963, 333, 1107, 964, 332, 1108, 965, 331, 1108
        DC16 966, 331, 1109, 967, 330, 1110, 968, 329, 1111, 969, 329, 1111
        DC16 970, 328, 1112, 971, 327, 1113, 972, 326, 1114, 973, 326, 1114
        DC16 974, 325, 1115, 975, 324, 1116, 976, 324, 1116, 977, 323, 1117
        DC16 978, 322, 1118, 979, 321, 1119, 980, 321, 1119, 981, 320, 1120
        DC16 982, 319, 1121, 983, 319, 1121, 984, 318, 1122, 985, 317, 1123
        DC16 986, 316, 1124, 987, 316, 1124, 988, 315, 1125, 989, 314, 1126
        DC16 990, 314, 1126, 991, 313, 1127, 992, 312, 1128, 993, 311, 1129
        DC16 994, 311, 1129, 995, 310, 1130, 996, 309, 1131, 997, 309, 1131
        DC16 998, 308, 1132, 999, 307, 1133, 1000, 306, 1134, 1001, 306, 1134
        DC16 1002, 305, 1135, 1003, 304, 1136, 1004, 303, 1136, 1005, 303, 1137
        DC16 1006, 302, 1138, 1007, 301, 1139, 1008, 301, 1139, 1009, 300, 1140
        DC16 1010, 299, 1141, 1011, 298, 1142, 1012, 298, 1142, 1013, 297, 1143
        DC16 1014, 297, 1143, 1015, 296, 1144, 1016, 296, 1144, 1017, 295, 1145
        DC16 1018, 294, 1146, 1019, 294, 1146, 1020, 293, 1147, 1021, 293, 1147
        DC16 1022, 292, 1148, 1023, 292, 1148, 1024, 291, 1149, 1025, 291, 1149
        DC16 1026, 290, 1150, 1027, 289, 1151, 1028, 289, 1151, 1029, 288, 1152
        DC16 1030, 288, 1152, 1031, 287, 1153, 1032, 287, 1153, 1033, 286, 1154
        DC16 1034, 286, 1154, 1035, 285, 1155, 1036, 285, 1155, 1037, 284, 1156
        DC16 1038, 283, 1157, 1039, 283, 1157, 1040, 282, 1158, 1041, 282, 1158
        DC16 1042, 281, 1159, 1043, 281, 1159, 1044, 280, 1160, 1045, 280, 1160
        DC16 1046, 279, 1161, 1047, 278, 1162, 1048, 278, 1162, 1049, 277, 1163
        DC16 1050, 277, 1163, 1051, 276, 1164, 1052, 276, 1164, 1053, 275, 1165
        DC16 1054, 275, 1165, 1055, 274, 1166, 1056, 273, 1167, 1057, 273, 1167
        DC16 1058, 272, 1168, 1059, 272, 1168, 1060, 271, 1169, 1061, 271, 1169
        DC16 1062, 270, 1170, 1063, 270, 1170, 1064, 269, 1171, 1065, 269, 1171
        DC16 1066, 268, 1172, 1067, 268, 1172, 1068, 267, 1173, 1069, 267, 1173
        DC16 1070, 267, 1173, 1071, 266, 1174, 1072, 266, 1174, 1073, 265, 1175
        DC16 1074, 265, 1175, 1075, 265, 1175, 1076, 264, 1176, 1077, 264, 1176
        DC16 1078, 263, 1177, 1079, 263, 1177, 1080, 263, 1177, 1081, 262, 1178
        DC16 1082, 262, 1178, 1083, 261, 1179, 1084, 261, 1179, 1085, 261, 1179
        DC16 1086, 260, 1180, 1087, 260, 1180, 1088, 259, 1181, 1089, 259, 1181
        DC16 1090, 259, 1181, 1091, 258, 1182, 1092, 258, 1182, 1093, 257, 1183
        DC16 1094, 257, 1183, 1095, 257, 1183, 1096, 256, 1184, 1097, 256, 1184
        DC16 1098, 255, 1185, 1099, 255, 1185, 1100, 254, 1186, 1101, 254, 1186
        DC16 1102, 254, 1186, 1103, 253, 1187, 1104, 253, 1187, 1105, 252, 1188
        DC16 1106, 252, 1188, 1107, 252, 1188, 1108, 251, 1189, 1109, 251, 1189
        DC16 1110, 250, 1190, 1111, 250, 1190, 1112, 250, 1190, 1113, 249, 1191
        DC16 1114, 249, 1191, 1115, 248, 1192, 1116, 248, 1192, 1117, 248, 1192
        DC16 1118, 247, 1193, 1119, 247, 1193, 1120, 247, 1193, 1121, 246, 1194
        DC16 1122, 246, 1194, 1123, 246, 1194, 1124, 245, 1195, 1125, 245, 1195
        DC16 1126, 245, 1195, 1127, 245, 1195, 1128, 244, 1196, 1129, 244, 1196
        DC16 1130, 244, 1196, 1131, 244, 1196, 1132, 243, 1197, 1133, 243, 1197
        DC16 1134, 243, 1197, 1135, 242, 1198, 1136, 242, 1198, 1137, 242, 1198
        DC16 1138, 242, 1198, 1139, 241, 1199, 1140, 241, 1199, 1141, 241, 1199
        DC16 1142, 241, 1199, 1143, 240, 1200, 1144, 240, 1200, 1145, 240, 1200
        DC16 1146, 239, 1201, 1147, 239, 1201, 1148, 239, 1201, 1149, 239, 1201
        DC16 1150, 238, 1202, 1151, 238, 1202, 1152, 238, 1202, 1153, 238, 1202
        DC16 1154, 237, 1203, 1155, 237, 1203, 1156, 237, 1203, 1157, 236, 1204
        DC16 1158, 236, 1204, 1159, 236, 1204, 1160, 236, 1204, 1161, 235, 1205
        DC16 1162, 235, 1205, 1163, 235, 1205, 1164, 234, 1205, 1165, 234, 1206
        DC16 1166, 234, 1206, 1167, 234, 1206, 1168, 233, 1207, 1169, 233, 1207
        DC16 1170, 233, 1207, 1171, 233, 1207, 1172, 232, 1208, 1173, 232, 1208
        DC16 1174, 232, 1208, 1175, 231, 1208, 1176, 231, 1209, 1177, 231, 1209
        DC16 1178, 231, 1209, 1179, 231, 1209, 1180, 231, 1209, 1181, 230, 1210
        DC16 1182, 230, 1210, 1183, 230, 1210, 1184, 230, 1210, 1185, 230, 1210
        DC16 1186, 230, 1210, 1187, 230, 1210, 1188, 229, 1211, 1189, 229, 1211
        DC16 1190, 229, 1211, 1191, 229, 1211, 1192, 229, 1211, 1193, 229, 1211
        DC16 1194, 229, 1211, 1195, 228, 1212, 1196, 228, 1212, 1197, 228, 1212
        DC16 1198, 228, 1212, 1199, 228, 1212, 1200, 228, 1212, 1201, 227, 1213
        DC16 1202, 227, 1213, 1203, 227, 1213, 1204, 227, 1213, 1205, 227, 1213
        DC16 1206, 227, 1213, 1207, 227, 1213, 1208, 226, 1214, 1209, 226, 1214
        DC16 1210, 226, 1214, 1211, 226, 1214, 1212, 226, 1214, 1213, 226, 1214
        DC16 1214, 226, 1214, 1215, 225, 1215, 1216, 225, 1215, 1217, 225, 1215
        DC16 1218, 225, 1215, 1219, 225, 1215, 1220, 225, 1215, 1221, 224, 1215
        DC16 1222, 224, 1216, 1223, 224, 1216, 1224, 224, 1216, 1225, 224, 1216
        DC16 1226, 224, 1216, 1227, 224, 1216, 1228, 223, 1217, 1229, 223, 1217
        DC16 1230, 223, 1217, 1231, 223, 1217, 1232, 223, 1217, 1233, 223, 1217
        DC16 1234, 223, 1217, 1235, 222, 1218, 1236, 222, 1218, 1237, 222, 1218
        DC16 1238, 222, 1218, 1239, 222, 1218, 1240, 222, 1218, 1241, 222, 1218
        DC16 1242, 222, 1218, 1243, 222, 1218, 1244, 222, 1218, 1245, 222, 1218
        DC16 1246, 222, 1218, 1247, 222, 1218, 1248, 222, 1218, 1249, 222, 1218
        DC16 1250, 222, 1218, 1251, 222, 1218, 1252, 222, 1218, 1253, 222, 1218
        DC16 1254, 222, 1218, 1255, 222, 1218, 1256, 222, 1218, 1257, 222, 1218
        DC16 1258, 222, 1218, 1259, 222, 1218, 1260, 222, 1218, 1261, 222, 1218
        DC16 1262, 222, 1218, 1263, 222, 1218, 1264, 222, 1218, 1265, 222, 1218
        DC16 1266, 222, 1218, 1267, 222, 1218, 1268, 221, 1219, 1269, 221, 1219
        DC16 1270, 221, 1219, 1271, 221, 1219, 1272, 221, 1219, 1273, 221, 1219
        DC16 1274, 221, 1219, 1275, 221, 1219, 1276, 221, 1219, 1277, 221, 1219
        DC16 1278, 221, 1219, 1279, 221, 1219, 1280, 221, 1219, 1281, 221, 1219
        DC16 1282, 221, 1219, 1283, 221, 1219, 1284, 221, 1219, 1285, 221, 1219
        DC16 1286, 221, 1219, 1287, 221, 1219, 1288, 221, 1219, 1289, 221, 1219
        DC16 1290, 221, 1219, 1291, 221, 1219, 1292, 221, 1219, 1293, 221, 1219
        DC16 1294, 221, 1219, 1295, 221, 1219, 1296, 221, 1219, 1297, 221, 1219
        DC16 1298, 221, 1219, 1299, 221, 1219, 1300, 221, 1219, 1301, 221, 1219
        DC16 1302, 221, 1219, 1303, 222, 1218, 1304, 222, 1218, 1305, 222, 1218
        DC16 1306, 222, 1218, 1307, 222, 1218, 1308, 222, 1218, 1309, 222, 1218
        DC16 1310, 222, 1218, 1311, 222, 1218, 1312, 222, 1218, 1313, 222, 1218
        DC16 1314, 223, 1217, 1315, 223, 1217, 1316, 223, 1217, 1317, 223, 1217
        DC16 1318, 223, 1217, 1319, 223, 1217, 1320, 223, 1217, 1321, 223, 1217
        DC16 1322, 223, 1217, 1323, 223, 1217, 1324, 223, 1217, 1325, 223, 1216
        DC16 1326, 224, 1216, 1327, 224, 1216, 1328, 224, 1216, 1329, 224, 1216
        DC16 1330, 224, 1216, 1331, 224, 1216, 1332, 224, 1216, 1333, 224, 1216
        DC16 1334, 224, 1216, 1335, 224, 1216, 1336, 224, 1216, 1337, 225, 1215
        DC16 1338, 225, 1215, 1339, 225, 1215, 1340, 225, 1215, 1341, 225, 1215
        DC16 1342, 225, 1215, 1343, 225, 1215, 1344, 225, 1215, 1345, 225, 1215
        DC16 1346, 225, 1215, 1347, 225, 1215, 1348, 226, 1214, 1349, 226, 1214
        DC16 1350, 226, 1214, 1351, 226, 1214, 1352, 226, 1214, 1353, 226, 1214
        DC16 1354, 226, 1214, 1355, 226, 1214, 1356, 227, 1213, 1357, 227, 1213
        DC16 1358, 227, 1213, 1359, 227, 1213, 1360, 227, 1213, 1361, 228, 1212
        DC16 1362, 228, 1212, 1363, 228, 1212, 1364, 228, 1212, 1365, 229, 1211
        DC16 1366, 229, 1211, 1367, 229, 1211, 1368, 229, 1211, 1369, 229, 1211
        DC16 1370, 230, 1210, 1371, 230, 1210, 1372, 230, 1210, 1373, 230, 1210
        DC16 1374, 230, 1210, 1375, 231, 1209, 1376, 231, 1209, 1377, 231, 1209
        DC16 1378, 231, 1209, 1379, 231, 1209, 1380, 232, 1208, 1381, 232, 1208
        DC16 1382, 232, 1208, 1383, 232, 1208, 1384, 233, 1207, 1385, 233, 1207
        DC16 1386, 233, 1207, 1387, 233, 1207, 1388, 233, 1207, 1389, 234, 1206
        DC16 1390, 234, 1206, 1391, 234, 1206, 1392, 234, 1206, 1393, 234, 1206
        DC16 1394, 235, 1205, 1395, 235, 1205, 1396, 235, 1205, 1397, 235, 1205
        DC16 1398, 235, 1205, 1399, 236, 1204, 1400, 236, 1204, 1401, 236, 1204
        DC16 1402, 236, 1204, 1403, 237, 1203, 1404, 237, 1203, 1405, 237, 1203
        DC16 1406, 237, 1203, 1407, 237, 1203, 1408, 238, 1202, 1409, 238, 1202
        DC16 1410, 238, 1202, 1411, 238, 1202, 1412, 239, 1201, 1413, 239, 1201
        DC16 1414, 239, 1201, 1415, 240, 1200, 1416, 240, 1200, 1417, 240, 1200
        DC16 1418, 241, 1199, 1419, 241, 1199, 1420, 241, 1199, 1421, 242, 1198
        DC16 1422, 242, 1198, 1423, 242, 1198, 1424, 243, 1197, 1425, 243, 1197
        DC16 1426, 243, 1197, 1427, 244, 1196, 1428, 244, 1196, 1429, 244, 1196
        DC16 1430, 245, 1195, 1431, 245, 1195, 1432, 245, 1195, 1433, 246, 1194
        DC16 1434, 246, 1194, 1435, 246, 1194, 1436, 247, 1193, 1437, 247, 1193
        DC16 1438, 247, 1193, 1439, 248, 1192, 1440, 248, 1192, 1441, 248, 1192
        DC16 1442, 249, 1191, 1443, 249, 1191, 1444, 249, 1191, 1445, 250, 1190
        DC16 1446, 250, 1190, 1447, 250, 1190, 1448, 251, 1189, 1449, 251, 1189
        DC16 1450, 251, 1189, 1451, 252, 1188, 1452, 252, 1188, 1453, 252, 1188
        DC16 1454, 253, 1187, 1455, 253, 1187, 1456, 253, 1187, 1457, 254, 1186
        DC16 1458, 254, 1186, 1459, 254, 1186, 1460, 255, 1185, 1461, 255, 1185
        DC16 1462, 255, 1185, 1463, 256, 1184, 1464, 256, 1184, 1465, 256, 1183
        DC16 1466, 257, 1183, 1467, 257, 1183, 1468, 258, 1182, 1469, 258, 1182
        DC16 1470, 259, 1181, 1471, 259, 1181, 1472, 260, 1180, 1473, 260, 1180
        DC16 1474, 261, 1179, 1475, 261, 1179, 1476, 261, 1179, 1477, 262, 1178
        DC16 1478, 262, 1178, 1479, 263, 1177, 1480, 263, 1177, 1481, 264, 1176
        DC16 1482, 264, 1176, 1483, 265, 1175, 1484, 265, 1175, 1485, 266, 1174
        DC16 1486, 266, 1174, 1487, 267, 1173, 1488, 267, 1173, 1489, 268, 1172
        DC16 1490, 268, 1172, 1491, 269, 1171, 1492, 269, 1171, 1493, 270, 1170
        DC16 1494, 270, 1170, 1495, 271, 1169, 1496, 271, 1169, 1497, 271, 1169
        DC16 1498, 272, 1168, 1499, 272, 1168, 1500, 273, 1167, 1501, 273, 1167
        DC16 1502, 274, 1166, 1503, 274, 1166, 1504, 275, 1165, 1505, 275, 1165
        DC16 1506, 276, 1164, 1507, 276, 1164, 1508, 277, 1163, 1509, 277, 1163
        DC16 1510, 278, 1162, 1511, 278, 1162, 1512, 279, 1161, 1513, 279, 1161
        DC16 1514, 280, 1160, 1515, 280, 1160, 1516, 281, 1159, 1517, 281, 1159
        DC16 1518, 281, 1158, 1519, 282, 1158, 1520, 282, 1158, 1521, 283, 1157
        DC16 1522, 284, 1156, 1523, 284, 1156, 1524, 285, 1155, 1525, 286, 1154
        DC16 1526, 286, 1154, 1527, 287, 1153, 1528, 287, 1153, 1529, 288, 1152
        DC16 1530, 289, 1151, 1531, 289, 1151, 1532, 290, 1150, 1533, 291, 1149
        DC16 1534, 291, 1149, 1535, 292, 1148, 1536, 292, 1148, 1537, 293, 1147
        DC16 1538, 294, 1146, 1539, 294, 1146, 1540, 295, 1145, 1541, 296, 1144
        DC16 1542, 296, 1144, 1543, 297, 1143, 1544, 298, 1142, 1545, 298, 1142
        DC16 1546, 299, 1141, 1547, 299, 1141, 1548, 300, 1140, 1549, 301, 1139
        DC16 1550, 301, 1139, 1551, 302, 1138, 1552, 303, 1137, 1553, 303, 1137
        DC16 1554, 304, 1136, 1555, 304, 1136, 1556, 305, 1135, 1557, 306, 1134
        DC16 1558, 306, 1134, 1559, 307, 1133, 1560, 308, 1132, 1561, 308, 1132
        DC16 1562, 309, 1131, 1563, 310, 1130, 1564, 310, 1130, 1565, 311, 1129
        DC16 1566, 311, 1129, 1567, 312, 1128, 1568, 313, 1127, 1569, 313, 1127
        DC16 1570, 314, 1126, 1571, 315, 1125, 1572, 315, 1125, 1573, 316, 1124
        DC16 1574, 317, 1123, 1575, 318, 1122, 1576, 319, 1121, 1577, 320, 1120
        DC16 1578, 320, 1120, 1579, 321, 1119, 1580, 322, 1118, 1581, 323, 1117
        DC16 1582, 324, 1116, 1583, 324, 1116, 1584, 325, 1115, 1585, 326, 1114
        DC16 1586, 327, 1113, 1587, 328, 1112, 1588, 328, 1112, 1589, 329, 1111
        DC16 1590, 330, 1110, 1591, 331, 1109, 1592, 332, 1108, 1593, 333, 1107
        DC16 1594, 333, 1107, 1595, 334, 1106, 1596, 335, 1105, 1597, 336, 1104
        DC16 1598, 337, 1103, 1599, 337, 1103, 1600, 338, 1102, 1601, 339, 1101
        DC16 1602, 340, 1100, 1603, 341, 1099, 1604, 341, 1099, 1605, 342, 1098
        DC16 1606, 343, 1097, 1607, 344, 1096, 1608, 345, 1095, 1609, 346, 1094
        DC16 1610, 346, 1094, 1611, 347, 1093, 1612, 348, 1092, 1613, 349, 1091
        DC16 1614, 350, 1090, 1615, 350, 1090, 1616, 351, 1089, 1617, 352, 1088
        DC16 1618, 353, 1087, 1619, 354, 1086, 1620, 355, 1085, 1621, 356, 1084
        DC16 1622, 357, 1083, 1623, 358, 1082, 1624, 359, 1081, 1625, 360, 1080
        DC16 1626, 361, 1079, 1627, 362, 1078, 1628, 363, 1077, 1629, 364, 1076
        DC16 1630, 365, 1074, 1631, 367, 1073, 1632, 368, 1072, 1633, 369, 1071
        DC16 1634, 370, 1070, 1635, 371, 1069, 1636, 372, 1068, 1637, 373, 1067
        DC16 1638, 374, 1066, 1639, 375, 1065, 1640, 376, 1064, 1641, 377, 1063
        DC16 1642, 378, 1062, 1643, 379, 1061, 1644, 380, 1060, 1645, 381, 1059
        DC16 1646, 382, 1058, 1647, 383, 1057, 1648, 384, 1056, 1649, 385, 1055
        DC16 1650, 386, 1054, 1651, 387, 1053, 1652, 388, 1052, 1653, 389, 1051
        DC16 1654, 390, 1050, 1655, 391, 1049, 1656, 392, 1048, 1657, 393, 1047
        DC16 1658, 394, 1046, 1659, 396, 1044, 1660, 397, 1043, 1661, 398, 1042
        DC16 1662, 400, 1040, 1663, 401, 1039, 1664, 402, 1038, 1665, 404, 1036
        DC16 1666, 405, 1035, 1667, 406, 1034, 1668, 408, 1032, 1669, 409, 1031
        DC16 1670, 410, 1030, 1671, 411, 1029, 1672, 413, 1027, 1673, 414, 1026
        DC16 1674, 415, 1025, 1675, 417, 1023, 1676, 418, 1022, 1677, 419, 1021
        DC16 1678, 421, 1019, 1679, 422, 1018, 1680, 423, 1017, 1681, 425, 1015
        DC16 1682, 426, 1014, 1683, 427, 1013, 1684, 428, 1012, 1685, 430, 1010
        DC16 1686, 431, 1009, 1687, 432, 1008, 1688, 434, 1006, 1689, 435, 1005
        DC16 1690, 436, 1004, 1691, 438, 1002, 1692, 439, 1001, 1693, 440, 1000
        DC16 1694, 442, 998, 1695, 443, 997, 1696, 445, 995, 1697, 447, 993
        DC16 1698, 448, 992, 1699, 450, 990, 1700, 452, 988, 1701, 454, 986
        DC16 1702, 455, 985, 1703, 457, 983, 1704, 459, 981, 1705, 460, 980
        DC16 1706, 462, 978, 1707, 464, 976, 1708, 465, 975, 1709, 467, 973
        DC16 1710, 469, 971, 1711, 470, 970, 1712, 472, 968, 1713, 474, 966
        DC16 1714, 476, 964, 1715, 477, 963, 1716, 479, 961, 1717, 481, 959
        DC16 1718, 482, 958, 1719, 484, 956, 1720, 486, 954, 1721, 487, 953
        DC16 1722, 489, 951, 1723, 491, 949, 1724, 493, 947, 1725, 495, 945
        DC16 1726, 497, 943, 1727, 499, 941, 1728, 502, 938, 1729, 504, 936
        DC16 1730, 506, 934, 1731, 508, 932, 1732, 511, 929, 1733, 513, 927
        DC16 1734, 515, 925, 1735, 518, 922, 1736, 520, 920, 1737, 522, 918
        DC16 1738, 524, 916, 1739, 527, 913, 1740, 529, 911, 1741, 531, 909
        DC16 1742, 533, 907, 1743, 536, 904, 1744, 538, 902, 1745, 540, 900
        DC16 1746, 543, 897, 1747, 545, 895, 1748, 547, 893, 1749, 551, 889
        DC16 1750, 554, 886, 1751, 557, 883, 1752, 560, 880, 1753, 564, 876
        DC16 1754, 567, 873, 1755, 570, 870, 1756, 574, 866, 1757, 577, 863
        DC16 1758, 580, 860, 1759, 583, 857, 1760, 587, 853, 1761, 590, 850
        DC16 1762, 593, 847, 1763, 596, 843, 1764, 600, 840, 1765, 603, 837
        DC16 1766, 609, 831, 1767, 614, 826, 1768, 620, 820, 1769, 625, 815
        DC16 1770, 631, 809, 1771, 636, 804, 1772, 642, 798, 1773, 648, 792
        DC16 1774, 653, 787, 1775, 659, 781, 1776, 670, 770, 1777, 687, 753
        DC16 1778, 704, 736, 1779

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock130 Using cfiCommon0
          CFI Function _ZN7MKS_DLP24ExposureDataTrans_squareEv
        THUMB
// __interwork __softfp void MKS_DLP::ExposureDataTrans_square()
_ZN7MKS_DLP24ExposureDataTrans_squareEv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R4,R0
        MOVS     R3,#+0
        MOV      R2,R3
        MOVS     R1,#+1
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        MOVS     R3,#+1
        MOV      R2,#+880
        MOVS     R1,#+0
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP18line_fill_all_zeroEcth
        BL       _ZN7MKS_DLP18line_fill_all_zeroEcth
        MOV      R2,#+7360
        MOVS     R1,#+0
        LDR.N    R0,??DataTable170
          CFI FunCall memset
        BL       memset
        MOVS     R5,#+0
        B.N      ??ExposureDataTrans_square_0
??ExposureDataTrans_square_1:
        MOVS     R2,#+1
        ADD      R1,R5,#+880
        UXTH     R1,R1
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP13line_gen_dataEth
        BL       _ZN7MKS_DLP13line_gen_dataEth
        ADD      R1,R5,#+780
        UXTH     R1,R1
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP17line_gen_data_TFTEt
        BL       _ZN7MKS_DLP17line_gen_data_TFTEt
        ADDS     R5,R5,#+1
??ExposureDataTrans_square_0:
        CMP      R5,#+800
        BGE.N    ??ExposureDataTrans_square_2
        LDR.N    R6,??DataTable170_1
        MOV      R2,#+1536
        MOVS     R1,#+0
        ADD      R0,R6,#+3600
          CFI FunCall memset
        BL       memset
        ADD      R0,R5,R5, LSL #+1
        LSLS     R0,R0,#+1
        ADR.W    R1,exposure_bmp_data_square
        LDRH     R2,[R0, R1]
        ADDS     R3,R2,R6
        ADDW     R3,R3,#+3600
        B.N      ??ExposureDataTrans_square_3
??ExposureDataTrans_square_4:
        MOVS     R6,#+1
        STRB     R6,[R3, #+48]
??ExposureDataTrans_square_5:
        ADDS     R3,R3,#+1
        ADDS     R2,R2,#+1
??ExposureDataTrans_square_3:
        ADDS     R6,R0,R1
        LDRH     R6,[R6, #+2]
        ADDS     R6,R6,#+1
        CMP      R2,R6
        BGE.N    ??ExposureDataTrans_square_1
        CMP      R2,#+720
        BGE.N    ??ExposureDataTrans_square_4
        MOVS     R6,#+1
        STRB     R6,[R3, #+0]
        B.N      ??ExposureDataTrans_square_5
??ExposureDataTrans_square_2:
        LDR.N    R0,??DataTable170_2
        LDRSB    R0,[R0, #+53]
        CMP      R0,#+2
        BEQ.N    ??ExposureDataTrans_square_2
        MOVS     R0,#+1
        LDR.N    R1,??DataTable170_3  ;; 0x4240029c
        STR      R0,[R1, #+0]
        MOV      R3,R0
        MOV      R2,#+1680
        MOV      R1,R0
        MOV      R0,R4
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7MKS_DLP18line_fill_all_zeroEcth
        B.W      _ZN7MKS_DLP18line_fill_all_zeroEcth
          CFI EndBlock cfiBlock130

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable170:
        DC32     bmp_layer_buf

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable170_1:
        DC32     card

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable170_2:
        DC32     hdma_spi1_tx

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable170_3:
        DC32     0x4240029c

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
// static __absolute unsigned short const exposure_bmp_data_square[800][3]
exposure_bmp_data_square:
        DC16 320, 1119, 880, 320, 1119, 881, 320, 1119, 882, 320, 1119, 883
        DC16 320, 1119, 884, 320, 1119, 885, 320, 1119, 886, 320, 1119, 887
        DC16 320, 1119, 888, 320, 1119, 889, 320, 1119, 890, 320, 1119, 891
        DC16 320, 1119, 892, 320, 1119, 893, 320, 1119, 894, 320, 1119, 895
        DC16 320, 1119, 896, 320, 1119, 897, 320, 1119, 898, 320, 1119, 899
        DC16 320, 1119, 900, 320, 1119, 901, 320, 1119, 902, 320, 1119, 903
        DC16 320, 1119, 904, 320, 1119, 905, 320, 1119, 906, 320, 1119, 907
        DC16 320, 1119, 908, 320, 1119, 909, 320, 1119, 910, 320, 1119, 911
        DC16 320, 1119, 912, 320, 1119, 913, 320, 1119, 914, 320, 1119, 915
        DC16 320, 1119, 916, 320, 1119, 917, 320, 1119, 918, 320, 1119, 919
        DC16 320, 1119, 920, 320, 1119, 921, 320, 1119, 922, 320, 1119, 923
        DC16 320, 1119, 924, 320, 1119, 925, 320, 1119, 926, 320, 1119, 927
        DC16 320, 1119, 928, 320, 1119, 929, 320, 1119, 930, 320, 1119, 931
        DC16 320, 1119, 932, 320, 1119, 933, 320, 1119, 934, 320, 1119, 935
        DC16 320, 1119, 936, 320, 1119, 937, 320, 1119, 938, 320, 1119, 939
        DC16 320, 1119, 940, 320, 1119, 941, 320, 1119, 942, 320, 1119, 943
        DC16 320, 1119, 944, 320, 1119, 945, 320, 1119, 946, 320, 1119, 947
        DC16 320, 1119, 948, 320, 1119, 949, 320, 1119, 950, 320, 1119, 951
        DC16 320, 1119, 952, 320, 1119, 953, 320, 1119, 954, 320, 1119, 955
        DC16 320, 1119, 956, 320, 1119, 957, 320, 1119, 958, 320, 1119, 959
        DC16 320, 1119, 960, 320, 1119, 961, 320, 1119, 962, 320, 1119, 963
        DC16 320, 1119, 964, 320, 1119, 965, 320, 1119, 966, 320, 1119, 967
        DC16 320, 1119, 968, 320, 1119, 969, 320, 1119, 970, 320, 1119, 971
        DC16 320, 1119, 972, 320, 1119, 973, 320, 1119, 974, 320, 1119, 975
        DC16 320, 1119, 976, 320, 1119, 977, 320, 1119, 978, 320, 1119, 979
        DC16 320, 1119, 980, 320, 1119, 981, 320, 1119, 982, 320, 1119, 983
        DC16 320, 1119, 984, 320, 1119, 985, 320, 1119, 986, 320, 1119, 987
        DC16 320, 1119, 988, 320, 1119, 989, 320, 1119, 990, 320, 1119, 991
        DC16 320, 1119, 992, 320, 1119, 993, 320, 1119, 994, 320, 1119, 995
        DC16 320, 1119, 996, 320, 1119, 997, 320, 1119, 998, 320, 1119, 999
        DC16 320, 1119, 1000, 320, 1119, 1001, 320, 1119, 1002, 320, 1119, 1003
        DC16 320, 1119, 1004, 320, 1119, 1005, 320, 1119, 1006, 320, 1119, 1007
        DC16 320, 1119, 1008, 320, 1119, 1009, 320, 1119, 1010, 320, 1119, 1011
        DC16 320, 1119, 1012, 320, 1119, 1013, 320, 1119, 1014, 320, 1119, 1015
        DC16 320, 1119, 1016, 320, 1119, 1017, 320, 1119, 1018, 320, 1119, 1019
        DC16 320, 1119, 1020, 320, 1119, 1021, 320, 1119, 1022, 320, 1119, 1023
        DC16 320, 1119, 1024, 320, 1119, 1025, 320, 1119, 1026, 320, 1119, 1027
        DC16 320, 1119, 1028, 320, 1119, 1029, 320, 1119, 1030, 320, 1119, 1031
        DC16 320, 1119, 1032, 320, 1119, 1033, 320, 1119, 1034, 320, 1119, 1035
        DC16 320, 1119, 1036, 320, 1119, 1037, 320, 1119, 1038, 320, 1119, 1039
        DC16 320, 1119, 1040, 320, 1119, 1041, 320, 1119, 1042, 320, 1119, 1043
        DC16 320, 1119, 1044, 320, 1119, 1045, 320, 1119, 1046, 320, 1119, 1047
        DC16 320, 1119, 1048, 320, 1119, 1049, 320, 1119, 1050, 320, 1119, 1051
        DC16 320, 1119, 1052, 320, 1119, 1053, 320, 1119, 1054, 320, 1119, 1055
        DC16 320, 1119, 1056, 320, 1119, 1057, 320, 1119, 1058, 320, 1119, 1059
        DC16 320, 1119, 1060, 320, 1119, 1061, 320, 1119, 1062, 320, 1119, 1063
        DC16 320, 1119, 1064, 320, 1119, 1065, 320, 1119, 1066, 320, 1119, 1067
        DC16 320, 1119, 1068, 320, 1119, 1069, 320, 1119, 1070, 320, 1119, 1071
        DC16 320, 1119, 1072, 320, 1119, 1073, 320, 1119, 1074, 320, 1119, 1075
        DC16 320, 1119, 1076, 320, 1119, 1077, 320, 1119, 1078, 320, 1119, 1079
        DC16 320, 1119, 1080, 320, 1119, 1081, 320, 1119, 1082, 320, 1119, 1083
        DC16 320, 1119, 1084, 320, 1119, 1085, 320, 1119, 1086, 320, 1119, 1087
        DC16 320, 1119, 1088, 320, 1119, 1089, 320, 1119, 1090, 320, 1119, 1091
        DC16 320, 1119, 1092, 320, 1119, 1093, 320, 1119, 1094, 320, 1119, 1095
        DC16 320, 1119, 1096, 320, 1119, 1097, 320, 1119, 1098, 320, 1119, 1099
        DC16 320, 1119, 1100, 320, 1119, 1101, 320, 1119, 1102, 320, 1119, 1103
        DC16 320, 1119, 1104, 320, 1119, 1105, 320, 1119, 1106, 320, 1119, 1107
        DC16 320, 1119, 1108, 320, 1119, 1109, 320, 1119, 1110, 320, 1119, 1111
        DC16 320, 1119, 1112, 320, 1119, 1113, 320, 1119, 1114, 320, 1119, 1115
        DC16 320, 1119, 1116, 320, 1119, 1117, 320, 1119, 1118, 320, 1119, 1119
        DC16 320, 1119, 1120, 320, 1119, 1121, 320, 1119, 1122, 320, 1119, 1123
        DC16 320, 1119, 1124, 320, 1119, 1125, 320, 1119, 1126, 320, 1119, 1127
        DC16 320, 1119, 1128, 320, 1119, 1129, 320, 1119, 1130, 320, 1119, 1131
        DC16 320, 1119, 1132, 320, 1119, 1133, 320, 1119, 1134, 320, 1119, 1135
        DC16 320, 1119, 1136, 320, 1119, 1137, 320, 1119, 1138, 320, 1119, 1139
        DC16 320, 1119, 1140, 320, 1119, 1141, 320, 1119, 1142, 320, 1119, 1143
        DC16 320, 1119, 1144, 320, 1119, 1145, 320, 1119, 1146, 320, 1120, 1147
        DC16 320, 1119, 1148, 320, 1119, 1149, 320, 1119, 1150, 320, 1119, 1151
        DC16 320, 1119, 1152, 320, 1119, 1153, 320, 1119, 1154, 320, 1119, 1155
        DC16 320, 1119, 1156, 320, 1119, 1157, 320, 1119, 1158, 320, 1119, 1159
        DC16 320, 1119, 1160, 320, 1119, 1161, 320, 1119, 1162, 320, 1119, 1163
        DC16 320, 1119, 1164, 320, 1119, 1165, 320, 1119, 1166, 320, 1119, 1167
        DC16 320, 1119, 1168, 320, 1119, 1169, 320, 1119, 1170, 320, 1119, 1171
        DC16 320, 1119, 1172, 320, 1119, 1173, 320, 1119, 1174, 320, 1119, 1175
        DC16 320, 1119, 1176, 320, 1119, 1177, 320, 1119, 1178, 320, 1119, 1179
        DC16 320, 1119, 1180, 320, 1119, 1181, 320, 1119, 1182, 320, 1119, 1183
        DC16 320, 1119, 1184, 320, 1119, 1185, 320, 1119, 1186, 320, 1119, 1187
        DC16 320, 1119, 1188, 320, 1119, 1189, 320, 1119, 1190, 320, 1119, 1191
        DC16 320, 1119, 1192, 320, 1119, 1193, 320, 1119, 1194, 320, 1119, 1195
        DC16 320, 1119, 1196, 320, 1119, 1197, 320, 1119, 1198, 320, 1119, 1199
        DC16 320, 1119, 1200, 320, 1119, 1201, 320, 1119, 1202, 320, 1119, 1203
        DC16 320, 1119, 1204, 320, 1119, 1205, 320, 1119, 1206, 320, 1119, 1207
        DC16 320, 1119, 1208, 320, 1119, 1209, 320, 1119, 1210, 320, 1119, 1211
        DC16 320, 1119, 1212, 320, 1119, 1213, 320, 1119, 1214, 320, 1119, 1215
        DC16 320, 1119, 1216, 320, 1119, 1217, 320, 1119, 1218, 320, 1119, 1219
        DC16 320, 1119, 1220, 320, 1119, 1221, 320, 1119, 1222, 320, 1119, 1223
        DC16 320, 1119, 1224, 320, 1119, 1225, 320, 1119, 1226, 320, 1119, 1227
        DC16 320, 1119, 1228, 320, 1119, 1229, 320, 1119, 1230, 320, 1119, 1231
        DC16 320, 1119, 1232, 320, 1119, 1233, 320, 1119, 1234, 320, 1119, 1235
        DC16 320, 1119, 1236, 320, 1119, 1237, 320, 1119, 1238, 320, 1119, 1239
        DC16 320, 1119, 1240, 320, 1119, 1241, 320, 1119, 1242, 320, 1119, 1243
        DC16 320, 1119, 1244, 320, 1119, 1245, 320, 1119, 1246, 320, 1119, 1247
        DC16 320, 1119, 1248, 320, 1119, 1249, 320, 1119, 1250, 320, 1119, 1251
        DC16 320, 1119, 1252, 320, 1119, 1253, 320, 1119, 1254, 320, 1119, 1255
        DC16 320, 1119, 1256, 320, 1119, 1257, 320, 1119, 1258, 320, 1119, 1259
        DC16 320, 1119, 1260, 320, 1119, 1261, 320, 1119, 1262, 320, 1119, 1263
        DC16 320, 1119, 1264, 320, 1119, 1265, 320, 1119, 1266, 320, 1119, 1267
        DC16 320, 1119, 1268, 320, 1119, 1269, 320, 1119, 1270, 320, 1119, 1271
        DC16 320, 1119, 1272, 320, 1119, 1273, 320, 1119, 1274, 320, 1119, 1275
        DC16 320, 1119, 1276, 320, 1119, 1277, 320, 1119, 1278, 320, 1119, 1279
        DC16 320, 1119, 1280, 320, 1119, 1281, 320, 1119, 1282, 320, 1119, 1283
        DC16 320, 1119, 1284, 320, 1119, 1285, 320, 1119, 1286, 320, 1119, 1287
        DC16 320, 1119, 1288, 320, 1119, 1289, 320, 1119, 1290, 320, 1119, 1291
        DC16 320, 1119, 1292, 320, 1119, 1293, 320, 1119, 1294, 320, 1119, 1295
        DC16 320, 1119, 1296, 320, 1119, 1297, 320, 1119, 1298, 320, 1119, 1299
        DC16 320, 1119, 1300, 320, 1119, 1301, 320, 1119, 1302, 320, 1119, 1303
        DC16 320, 1119, 1304, 320, 1119, 1305, 320, 1119, 1306, 320, 1119, 1307
        DC16 320, 1119, 1308, 320, 1119, 1309, 320, 1119, 1310, 320, 1119, 1311
        DC16 320, 1119, 1312, 320, 1119, 1313, 320, 1119, 1314, 320, 1119, 1315
        DC16 320, 1119, 1316, 320, 1119, 1317, 320, 1119, 1318, 320, 1119, 1319
        DC16 320, 1119, 1320, 320, 1119, 1321, 320, 1119, 1322, 320, 1119, 1323
        DC16 320, 1119, 1324, 320, 1119, 1325, 320, 1119, 1326, 320, 1119, 1327
        DC16 320, 1119, 1328, 320, 1119, 1329, 320, 1119, 1330, 320, 1119, 1331
        DC16 320, 1119, 1332, 320, 1119, 1333, 320, 1119, 1334, 320, 1119, 1335
        DC16 320, 1119, 1336, 320, 1119, 1337, 320, 1119, 1338, 320, 1119, 1339
        DC16 320, 1119, 1340, 320, 1119, 1341, 320, 1119, 1342, 320, 1119, 1343
        DC16 320, 1119, 1344, 320, 1119, 1345, 320, 1119, 1346, 320, 1119, 1347
        DC16 320, 1119, 1348, 320, 1119, 1349, 320, 1119, 1350, 320, 1119, 1351
        DC16 320, 1119, 1352, 320, 1119, 1353, 320, 1119, 1354, 320, 1119, 1355
        DC16 320, 1119, 1356, 320, 1119, 1357, 320, 1119, 1358, 320, 1119, 1359
        DC16 320, 1119, 1360, 320, 1119, 1361, 320, 1119, 1362, 320, 1119, 1363
        DC16 320, 1119, 1364, 320, 1119, 1365, 320, 1119, 1366, 320, 1119, 1367
        DC16 320, 1119, 1368, 320, 1119, 1369, 320, 1119, 1370, 320, 1119, 1371
        DC16 320, 1119, 1372, 320, 1119, 1373, 320, 1119, 1374, 320, 1119, 1375
        DC16 320, 1119, 1376, 320, 1119, 1377, 320, 1119, 1378, 320, 1119, 1379
        DC16 320, 1119, 1380, 320, 1119, 1381, 320, 1119, 1382, 320, 1119, 1383
        DC16 320, 1119, 1384, 320, 1119, 1385, 320, 1119, 1386, 320, 1119, 1387
        DC16 320, 1119, 1388, 320, 1119, 1389, 320, 1119, 1390, 320, 1119, 1391
        DC16 320, 1119, 1392, 320, 1119, 1393, 320, 1119, 1394, 320, 1119, 1395
        DC16 320, 1119, 1396, 320, 1119, 1397, 320, 1119, 1398, 320, 1119, 1399
        DC16 320, 1119, 1400, 320, 1119, 1401, 320, 1119, 1402, 320, 1119, 1403
        DC16 320, 1119, 1404, 320, 1119, 1405, 320, 1119, 1406, 320, 1119, 1407
        DC16 320, 1119, 1408, 320, 1119, 1409, 320, 1119, 1410, 320, 1119, 1411
        DC16 320, 1119, 1412, 320, 1120, 1413, 320, 1119, 1414, 320, 1119, 1415
        DC16 320, 1119, 1416, 320, 1119, 1417, 320, 1119, 1418, 320, 1119, 1419
        DC16 320, 1119, 1420, 320, 1119, 1421, 320, 1119, 1422, 320, 1119, 1423
        DC16 320, 1119, 1424, 320, 1119, 1425, 320, 1119, 1426, 320, 1119, 1427
        DC16 320, 1119, 1428, 320, 1119, 1429, 320, 1119, 1430, 320, 1119, 1431
        DC16 320, 1119, 1432, 320, 1119, 1433, 320, 1119, 1434, 320, 1119, 1435
        DC16 320, 1119, 1436, 320, 1119, 1437, 320, 1119, 1438, 320, 1119, 1439
        DC16 320, 1119, 1440, 320, 1119, 1441, 320, 1119, 1442, 320, 1119, 1443
        DC16 320, 1119, 1444, 320, 1119, 1445, 320, 1119, 1446, 320, 1119, 1447
        DC16 320, 1119, 1448, 320, 1119, 1449, 320, 1119, 1450, 320, 1119, 1451
        DC16 320, 1119, 1452, 320, 1119, 1453, 320, 1119, 1454, 320, 1119, 1455
        DC16 320, 1119, 1456, 320, 1119, 1457, 320, 1119, 1458, 320, 1119, 1459
        DC16 320, 1119, 1460, 320, 1119, 1461, 320, 1119, 1462, 320, 1119, 1463
        DC16 320, 1119, 1464, 320, 1119, 1465, 320, 1119, 1466, 320, 1119, 1467
        DC16 320, 1119, 1468, 320, 1119, 1469, 320, 1119, 1470, 320, 1119, 1471
        DC16 320, 1119, 1472, 320, 1119, 1473, 320, 1119, 1474, 320, 1119, 1475
        DC16 320, 1119, 1476, 320, 1119, 1477, 320, 1119, 1478, 320, 1119, 1479
        DC16 320, 1119, 1480, 320, 1119, 1481, 320, 1119, 1482, 320, 1119, 1483
        DC16 320, 1119, 1484, 320, 1119, 1485, 320, 1119, 1486, 320, 1119, 1487
        DC16 320, 1119, 1488, 320, 1119, 1489, 320, 1119, 1490, 320, 1119, 1491
        DC16 320, 1119, 1492, 320, 1119, 1493, 320, 1119, 1494, 320, 1119, 1495
        DC16 320, 1119, 1496, 320, 1119, 1497, 320, 1119, 1498, 320, 1119, 1499
        DC16 320, 1119, 1500, 320, 1119, 1501, 320, 1119, 1502, 320, 1119, 1503
        DC16 320, 1119, 1504, 320, 1119, 1505, 320, 1119, 1506, 320, 1119, 1507
        DC16 320, 1119, 1508, 320, 1119, 1509, 320, 1119, 1510, 320, 1119, 1511
        DC16 320, 1119, 1512, 320, 1119, 1513, 320, 1119, 1514, 320, 1119, 1515
        DC16 320, 1119, 1516, 320, 1119, 1517, 320, 1119, 1518, 320, 1119, 1519
        DC16 320, 1119, 1520, 320, 1119, 1521, 320, 1119, 1522, 320, 1119, 1523
        DC16 320, 1119, 1524, 320, 1119, 1525, 320, 1119, 1526, 320, 1119, 1527
        DC16 320, 1119, 1528, 320, 1119, 1529, 320, 1119, 1530, 320, 1119, 1531
        DC16 320, 1119, 1532, 320, 1119, 1533, 320, 1119, 1534, 320, 1119, 1535
        DC16 320, 1119, 1536, 320, 1119, 1537, 320, 1119, 1538, 320, 1119, 1539
        DC16 320, 1119, 1540, 320, 1119, 1541, 320, 1119, 1542, 320, 1119, 1543
        DC16 320, 1119, 1544, 320, 1119, 1545, 320, 1119, 1546, 320, 1119, 1547
        DC16 320, 1119, 1548, 320, 1119, 1549, 320, 1119, 1550, 320, 1119, 1551
        DC16 320, 1119, 1552, 320, 1119, 1553, 320, 1119, 1554, 320, 1119, 1555
        DC16 320, 1119, 1556, 320, 1119, 1557, 320, 1119, 1558, 320, 1119, 1559
        DC16 320, 1119, 1560, 320, 1119, 1561, 320, 1119, 1562, 320, 1119, 1563
        DC16 320, 1119, 1564, 320, 1119, 1565, 320, 1119, 1566, 320, 1119, 1567
        DC16 320, 1119, 1568, 320, 1119, 1569, 320, 1119, 1570, 320, 1119, 1571
        DC16 320, 1119, 1572, 320, 1119, 1573, 320, 1119, 1574, 320, 1119, 1575
        DC16 320, 1119, 1576, 320, 1119, 1577, 320, 1119, 1578, 320, 1119, 1579
        DC16 320, 1119, 1580, 320, 1119, 1581, 320, 1119, 1582, 320, 1119, 1583
        DC16 320, 1119, 1584, 320, 1119, 1585, 320, 1119, 1586, 320, 1119, 1587
        DC16 320, 1119, 1588, 320, 1119, 1589, 320, 1119, 1590, 320, 1119, 1591
        DC16 320, 1119, 1592, 320, 1119, 1593, 320, 1119, 1594, 320, 1119, 1595
        DC16 320, 1119, 1596, 320, 1119, 1597, 320, 1119, 1598, 320, 1119, 1599
        DC16 320, 1119, 1600, 320, 1119, 1601, 320, 1119, 1602, 320, 1119, 1603
        DC16 320, 1119, 1604, 320, 1119, 1605, 320, 1119, 1606, 320, 1119, 1607
        DC16 320, 1119, 1608, 320, 1119, 1609, 320, 1119, 1610, 320, 1119, 1611
        DC16 320, 1119, 1612, 320, 1119, 1613, 320, 1119, 1614, 320, 1119, 1615
        DC16 320, 1119, 1616, 320, 1119, 1617, 320, 1119, 1618, 320, 1119, 1619
        DC16 320, 1119, 1620, 320, 1119, 1621, 320, 1119, 1622, 320, 1119, 1623
        DC16 320, 1119, 1624, 320, 1119, 1625, 320, 1119, 1626, 320, 1119, 1627
        DC16 320, 1119, 1628, 320, 1119, 1629, 320, 1119, 1630, 320, 1119, 1631
        DC16 320, 1119, 1632, 320, 1119, 1633, 320, 1119, 1634, 320, 1119, 1635
        DC16 320, 1119, 1636, 320, 1119, 1637, 320, 1119, 1638, 320, 1119, 1639
        DC16 320, 1119, 1640, 320, 1119, 1641, 320, 1119, 1642, 320, 1119, 1643
        DC16 320, 1119, 1644, 320, 1119, 1645, 320, 1119, 1646, 320, 1119, 1647
        DC16 320, 1119, 1648, 320, 1119, 1649, 320, 1119, 1650, 320, 1119, 1651
        DC16 320, 1119, 1652, 320, 1119, 1653, 320, 1119, 1654, 320, 1119, 1655
        DC16 320, 1119, 1656, 320, 1119, 1657, 320, 1119, 1658, 320, 1119, 1659
        DC16 320, 1119, 1660, 320, 1119, 1661, 320, 1119, 1662, 320, 1119, 1663
        DC16 320, 1119, 1664, 320, 1119, 1665, 320, 1119, 1666, 320, 1119, 1667
        DC16 320, 1119, 1668, 320, 1119, 1669, 320, 1119, 1670, 320, 1119, 1671
        DC16 320, 1119, 1672, 320, 1119, 1673, 320, 1119, 1674, 320, 1119, 1675
        DC16 320, 1119, 1676, 320, 1119, 1677, 320, 1119, 1678, 320, 1119, 1679

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock131 Using cfiCommon0
          CFI Function _ZN7MKS_DLP12ExposureTestEv
        THUMB
// __interwork __softfp void MKS_DLP::ExposureTest()
_ZN7MKS_DLP12ExposureTestEv:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        MOV      R4,R0
        MOVS     R0,#+2
          CFI FunCall exposure_msg_display
        BL       exposure_msg_display
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP23ExposureData2TFT_circleEv
        BL       _ZN7MKS_DLP23ExposureData2TFT_circleEv
        MOVS     R0,#+180
        STR      R0,[SP, #+0]
        MOV      R3,#+320
        MOVS     R2,#+20
        MOVS     R1,#+80
        LDR.W    R0,??DataTable194_1
          CFI FunCall layer_pic_display
        BL       layer_pic_display
        MOVS     R3,#+1
        MOV      R2,R3
        MOV      R1,R2
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        ADDW     R5,R4,#+754
        MOV      R0,R5
          CFI FunCall _ZN7SSD28289sleep_outEv
        BL       _ZN7SSD28289sleep_outEv
        LDR.W    R6,??DataTable194_2  ;; 0x42420288
        MOVS     R0,#+1
        STR      R0,[R6, #+0]
        ADD      R7,R4,#+484
        STRB     R0,[R7, #+4]
        MOVS     R0,#+0
        LDR.W    R1,??DataTable194_3
        STR      R0,[R1, #+0]
          CFI FunCall _Z10clr_ticketv
        BL       _Z10clr_ticketv
        B.N      ??ExposureTest_0
??ExposureTest_1:
          CFI FunCall _Z4idlev
        BL       _Z4idlev
??ExposureTest_0:
        LDR      R0,[R4, #+728]
        LDR      R1,[R4, #+484]
        CMP      R0,R1
        BCC.N    ??ExposureTest_1
        MOVS     R0,#+0
        STR      R0,[R6, #+0]
        STRB     R0,[R7, #+4]
        MOVS     R3,#+1
        MOV      R2,R3
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        MOV      R0,R5
          CFI FunCall _ZN7SSD28288sleep_inEv
        BL       _ZN7SSD28288sleep_inEv
        MOVS     R0,#+20
          CFI FunCall HAL_Delay
        BL       HAL_Delay
        MOVS     R3,#+0
        MOV      R2,R3
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        LDR.W    R0,??DataTable195
        LDRSB    R0,[R0, #+0]
        CMP      R0,#+35
        BNE.N    ??ExposureTest_2
        MOVS     R0,#+0
        STR      R0,[SP, #+0]
        MOVS     R3,#+180
        MOV      R2,#+320
        MOVS     R1,#+20
        MOVS     R0,#+80
          CFI FunCall layer_pic_clean
        BL       layer_pic_clean
        MOVS     R0,#+3
        POP      {R1,R4-R7,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall exposure_msg_display
        B.W      exposure_msg_display
          CFI R4 Frame(CFA, -20)
          CFI R5 Frame(CFA, -16)
          CFI R6 Frame(CFA, -12)
          CFI R7 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+24
??ExposureTest_2:
        POP      {R0,R4-R7,PC}    ;; return
          CFI EndBlock cfiBlock131

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock132 Using cfiCommon0
          CFI Function _ZN7MKS_DLP14ExposureAll_onEv
        THUMB
// __interwork __softfp void MKS_DLP::ExposureAll_on()
_ZN7MKS_DLP14ExposureAll_onEv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
        MOVS     R1,#+1
          CFI FunCall _ZN7MKS_DLP17line_fill_all_oneEh
        BL       _ZN7MKS_DLP17line_fill_all_oneEh
        MOVS     R3,#+1
        MOV      R2,R3
        MOV      R1,R2
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        ADDW     R0,R4,#+754
          CFI FunCall _ZN7SSD28289sleep_outEv
        BL       _ZN7SSD28289sleep_outEv
        MOVS     R0,#+1
        LDR.W    R1,??DataTable194_2  ;; 0x42420288
        STR      R0,[R1, #+0]
        STRB     R0,[R4, #+488]
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock132

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock133 Using cfiCommon0
          CFI Function _ZN7MKS_DLP15ExposureAll_offEv
        THUMB
// __interwork __softfp void MKS_DLP::ExposureAll_off()
_ZN7MKS_DLP15ExposureAll_offEv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
        MOVS     R0,#+0
        LDR.W    R1,??DataTable194_2  ;; 0x42420288
        STR      R0,[R1, #+0]
        STRB     R0,[R4, #+488]
        MOVS     R3,#+1
        MOV      R2,R3
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        ADDW     R0,R4,#+754
          CFI FunCall _ZN7SSD28288sleep_inEv
        BL       _ZN7SSD28288sleep_inEv
        MOVS     R0,#+20
          CFI FunCall HAL_Delay
        BL       HAL_Delay
        MOVS     R3,#+0
        MOV      R2,R3
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP24ExposureDataTrans_circleEv
        BL       _ZN7MKS_DLP24ExposureDataTrans_circleEv
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7MKS_DLP14CleanDataTransEv
        B.W      _ZN7MKS_DLP14CleanDataTransEv
          CFI EndBlock cfiBlock133

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock134 Using cfiCommon0
          CFI Function _ZN7MKS_DLP6led_onEv
        THUMB
// __interwork __softfp void MKS_DLP::led_on()
_ZN7MKS_DLP6led_onEv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        SUB      SP,SP,#+8
          CFI CFA R13+16
        MOV      R4,R0
        ADDW     R0,R4,#+754
          CFI FunCall _ZN7SSD28289sleep_outEv
        BL       _ZN7SSD28289sleep_outEv
        MOVS     R0,#+1
        LDR.W    R1,??DataTable194_2  ;; 0x42420288
        STR      R0,[R1, #+0]
        STRB     R0,[R4, #+488]
        ADR.W    R0,`?<Constant "led on:">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R0,??DataTable195_1
          CFI FunCall _ZN7MKS_DLP16get_currentLayerEv
        BL       _ZN7MKS_DLP16get_currentLayerEv
        MOVS     R2,#+10
        MOV      R1,R0
        LDR.W    R0,??DataTable195_2
          CFI FunCall _ZN5Print5printEii
        BL       _ZN5Print5printEii
        LDR.W    R0,??DataTable195
        LDRSB    R0,[R0, #+0]
        CMP      R0,#+3
        BNE.N    ??led_on_0
        MOVS     R0,#+180
        STR      R0,[SP, #+0]
        MOV      R3,#+320
        MOVS     R2,#+15
        MOVS     R1,#+30
        LDR.W    R0,??DataTable194_1
          CFI FunCall layer_pic_display
        BL       layer_pic_display
          CFI FunCall draw_status_clear
        BL       draw_status_clear
          CFI FunCall display_print_statue
        BL       display_print_statue
          CFI FunCall setProBarRate
        BL       setProBarRate
        POP      {R0,R1,R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall GUI_Exec
        B.W      GUI_Exec
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??led_on_0:
        POP      {R0,R1,R4,PC}    ;; return
          CFI EndBlock cfiBlock134

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "led on:">`:
        DC8 "led on:"

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock135 Using cfiCommon0
          CFI Function _ZN7MKS_DLP7led_offEv
        THUMB
// __interwork __softfp void MKS_DLP::led_off()
_ZN7MKS_DLP7led_offEv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        SUB      SP,SP,#+8
          CFI CFA R13+16
        MOV      R4,R0
        MOVS     R0,#+0
        LDR.W    R1,??DataTable194_2  ;; 0x42420288
        STR      R0,[R1, #+0]
        STRB     R0,[R4, #+488]
        MOVS     R3,#+1
        MOV      R2,R3
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        ADDW     R0,R4,#+754
          CFI FunCall _ZN7SSD28288sleep_inEv
        BL       _ZN7SSD28288sleep_inEv
        MOVS     R0,#+10
          CFI FunCall HAL_Delay
        BL       HAL_Delay
        MOVS     R3,#+0
        MOV      R2,R3
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        LDR.W    R0,??DataTable195
        LDRSB    R0,[R0, #+0]
        CMP      R0,#+3
        BNE.N    ??led_off_0
        MOVS     R0,#+0
        STR      R0,[SP, #+0]
        MOVS     R3,#+180
        MOV      R2,#+320
        MOVS     R1,#+15
        MOVS     R0,#+30
          CFI FunCall layer_pic_clean
        BL       layer_pic_clean
??led_off_0:
        POP      {R0,R1,R4,PC}    ;; return
          CFI EndBlock cfiBlock135

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock136 Using cfiCommon0
          CFI Function _ZN7MKS_DLP8power_onEv
        THUMB
// __interwork __softfp void MKS_DLP::power_on()
_ZN7MKS_DLP8power_onEv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.W    R4,??DataTable196  ;; 0x42408284
        MOVS     R0,#+0
        STR      R0,[R4, #+0]
        MOVS     R0,#+200
          CFI FunCall HAL_Delay
        BL       HAL_Delay
        LDR.W    R5,??DataTable197  ;; 0x42400290
        MOVS     R0,#+1
        STR      R0,[R5, #+0]
        MOVS     R0,#+200
          CFI FunCall HAL_Delay
        BL       HAL_Delay
        MOVS     R0,#+1
        STR      R0,[R5, #+4]
        MOVS     R0,#+50
          CFI FunCall HAL_Delay
        BL       HAL_Delay
        MOVS     R0,#+1
        STR      R0,[R4, #+0]
        MOVS     R0,#+100
        POP      {R1,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall HAL_Delay
        B.W      HAL_Delay
          CFI EndBlock cfiBlock136

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock137 Using cfiCommon0
          CFI Function _ZN7MKS_DLP9power_offEv
        THUMB
// __interwork __softfp void MKS_DLP::power_off()
_ZN7MKS_DLP9power_offEv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R0,#+0
        LDR.W    R1,??DataTable196  ;; 0x42408284
        STR      R0,[R1, #+0]
        MOVS     R0,#+5
          CFI FunCall HAL_Delay
        BL       HAL_Delay
        LDR.W    R4,??DataTable197  ;; 0x42400290
        MOVS     R0,#+0
        STR      R0,[R4, #+4]
        MOVS     R0,#+200
          CFI FunCall HAL_Delay
        BL       HAL_Delay
        MOVS     R0,#+0
        STR      R0,[R4, #+0]
        MOVS     R0,#+100
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall HAL_Delay
        B.W      HAL_Delay
          CFI EndBlock cfiBlock137

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock138 Using cfiCommon0
          CFI Function _ZN7MKS_DLP21bank2disp_enable_grayEhhhh
        THUMB
// __interwork __softfp uint8_t MKS_DLP::bank2disp_enable_gray(uint8_t, uint8_t, uint8_t, uint8_t)
_ZN7MKS_DLP21bank2disp_enable_grayEhhhh:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        MOV      R4,R0
        MOVS     R0,#+0
        STRB     R0,[R4, #+496]
        ADD      R5,R4,#+496
        LDR      R0,[SP, #+24]
        STRB     R0,[R5, #+1]
        LSLS     R0,R3,#+6
        ORR      R0,R0,R2, LSL #+7
        ORR      R0,R0,R1, LSL #+4
        STRB     R0,[R5, #+2]
        MOVS     R6,#+0
        B.N      ??bank2disp_enable_gray_0
??bank2disp_enable_gray_1:
        ADDS     R6,R6,#+1
??bank2disp_enable_gray_0:
        UXTB     R6,R6
        CMP      R6,#+5
        BGE.N    ??bank2disp_enable_gray_2
        LDR.W    R7,??DataTable198  ;; 0x4240029c
        MOVS     R0,#+0
        STR      R0,[R7, #+0]
        LDRB     R0,[R4, #+496]
          CFI FunCall SPI1_ReadWriteByte
        BL       SPI1_ReadWriteByte
        LDRB     R0,[R5, #+1]
          CFI FunCall SPI1_ReadWriteByte
        BL       SPI1_ReadWriteByte
        LDRB     R0,[R5, #+2]
          CFI FunCall SPI1_ReadWriteByte
        BL       SPI1_ReadWriteByte
        MOVS     R0,#+1
        STR      R0,[R7, #+0]
        LDRB     R7,[R5, #+2]
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP14bank2disp_readEv
        BL       _ZN7MKS_DLP14bank2disp_readEv
        AND      R0,R0,#0xF0
        CMP      R7,R0
        BNE.N    ??bank2disp_enable_gray_1
        MOVS     R0,#+1
        POP      {R1,R4-R7,PC}
??bank2disp_enable_gray_2:
        MOVS     R0,#+0
        POP      {R1,R4-R7,PC}    ;; return
          CFI EndBlock cfiBlock138

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock139 Using cfiCommon0
          CFI Function _ZN7MKS_DLP9grag_testEv
        THUMB
// __interwork __softfp void MKS_DLP::grag_test()
_ZN7MKS_DLP9grag_testEv:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        SUB      SP,SP,#+8
          CFI CFA R13+32
        MOV      R4,R0
        MOVS     R5,#+0
        ADD      R6,R4,#+484
        ADDW     R7,R4,#+754
        LDR.W    R8,??DataTable194_2  ;; 0x42420288
        B.N      ??grag_test_0
??grag_test_1:
          CFI FunCall _Z4idlev
        BL       _Z4idlev
??grag_test_2:
        LDR      R0,[R4, #+728]
        LDR      R1,[R4, #+484]
        CMP      R0,R1
        BCC.N    ??grag_test_1
        MOV      R0,#+2000
          CFI FunCall HAL_Delay
        BL       HAL_Delay
        MOVS     R0,#+0
        STR      R0,[R8, #+0]
        STRB     R0,[R6, #+4]
        MOVS     R3,#+1
        MOV      R2,R3
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        MOV      R0,R7
          CFI FunCall _ZN7SSD28288sleep_inEv
        BL       _ZN7SSD28288sleep_inEv
        MOVS     R0,#+20
          CFI FunCall HAL_Delay
        BL       HAL_Delay
        MOVS     R3,#+0
        MOV      R2,R3
        MOVS     R1,#+2
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        LDR.W    R0,??DataTable195
        LDRSB    R0,[R0, #+0]
        CMP      R0,#+35
        BNE.N    ??grag_test_3
        MOVS     R0,#+0
        STR      R0,[SP, #+0]
        MOVS     R3,#+180
        MOV      R2,#+320
        MOVS     R1,#+20
        MOVS     R0,#+80
          CFI FunCall layer_pic_clean
        BL       layer_pic_clean
        MOVS     R0,#+3
          CFI FunCall exposure_msg_display
        BL       exposure_msg_display
??grag_test_3:
        MOV      R0,#+2000
          CFI FunCall HAL_Delay
        BL       HAL_Delay
        ADDS     R0,R5,#+1
        ASRS     R1,R0,#+2
        ADD      R1,R0,R1, LSR #+29
        ASRS     R1,R1,#+3
        SUB      R5,R0,R1, LSL #+3
??grag_test_0:
        MOVS     R0,#+2
          CFI FunCall exposure_msg_display
        BL       exposure_msg_display
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP23ExposureData2TFT_circleEv
        BL       _ZN7MKS_DLP23ExposureData2TFT_circleEv
        MOVS     R0,#+180
        STR      R0,[SP, #+0]
        MOV      R3,#+320
        MOVS     R2,#+20
        MOVS     R1,#+80
        LDR.W    R0,??DataTable194_1
          CFI FunCall layer_pic_display
        BL       layer_pic_display
        UXTB     R5,R5
        STR      R5,[SP, #+0]
        MOVS     R3,#+1
        MOV      R2,R3
        MOV      R1,R2
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP21bank2disp_enable_grayEhhhh
        BL       _ZN7MKS_DLP21bank2disp_enable_grayEhhhh
        MOV      R0,R7
          CFI FunCall _ZN7SSD28289sleep_outEv
        BL       _ZN7SSD28289sleep_outEv
        MOVS     R0,#+1
        STR      R0,[R8, #+0]
        STRB     R0,[R6, #+4]
        MOVS     R0,#+0
        LDR.W    R1,??DataTable194_3
        STR      R0,[R1, #+0]
          CFI FunCall _Z10clr_ticketv
        BL       _Z10clr_ticketv
        B.N      ??grag_test_2
          CFI EndBlock cfiBlock139

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock140 Using cfiCommon0
          CFI Function _ZN7MKS_DLP9dlp_startEv
        THUMB
// __interwork __softfp void MKS_DLP::dlp_start()
_ZN7MKS_DLP9dlp_startEv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
        ADDW     R0,R4,#+754
          CFI FunCall _ZN7SSD28284initEv
        BL       _ZN7SSD28284initEv
        CMP      R0,#+0
        BNE.N    ??dlp_start_0
        ADR.W    R0,`?<Constant "ssd dev is error!\\r\\n\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??dlp_start_0:
        ADR.W    R0,`?<Constant "CPLD VER:">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP12get_cpld_verEv
        BL       _ZN7MKS_DLP12get_cpld_verEv
        MOVS     R2,#+10
        MOV      R1,R0
        LDR.W    R0,??DataTable195_2
          CFI FunCall _ZN5Print5printEhi
        BL       _ZN5Print5printEhi
        MOVS     R2,#+1
        ADD      R1,R4,#+752
        MOVW     R0,#+1594
          CFI FunCall AT24CXX_Read
        BL       AT24CXX_Read
        LDRB     R0,[R4, #+752]
        LDR.W    R1,??DataTable201
        STRB     R0,[R1, #+632]
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP24ExposureDataTrans_circleEv
        BL       _ZN7MKS_DLP24ExposureDataTrans_circleEv
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP14CleanDataTransEv
        BL       _ZN7MKS_DLP14CleanDataTransEv
        LDR.W    R0,??DataTable201_1  ;; 0x4242028c
        MOVS     R1,#+1
        STR      R1,[R0, #+4]
        STR      R1,[R0, #+0]
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock140

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "ssd dev is error!\\r\\n\\n">`:
        DC8 "ssd dev is error!\015\012\012"
        DC8 0, 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "CPLD VER:">`:
        DC8 "CPLD VER:"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock141 Using cfiCommon0
          CFI Function _ZN7MKS_DLP13set_LedOnTimeEt
        THUMB
// __interwork __softfp void MKS_DLP::set_LedOnTime(uint16_t)
_ZN7MKS_DLP13set_LedOnTimeEt:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        MOV      R6,R0
        MOV      R0,#+1000
        MULS     R0,R0,R1
        STR      R0,[R6, #+40]
        MOVW     R4,#+1031
        MOVS     R2,#+4
        ADD      R1,R6,#+40
        MOV      R0,R4
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R0,#+0
        STR      R0,[R6, #+40]
        MOVS     R2,#+4
        ADD      R1,R6,#+40
        MOV      R0,R4
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDR      R0,[R6, #+40]
        LDR.W    R1,??DataTable201_2
        LDR      R7,[R1, #+3564]
        CMP      R7,#+2
        BLT.N    ??set_LedOnTime_0
          CFI FunCall __aeabi_ui2d
        BL       __aeabi_ui2d
        MOV      R4,R0
        MOV      R5,R1
        MOV      R0,R7
          CFI FunCall __aeabi_i2d
        BL       __aeabi_i2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
        MOV      R1,R5
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOVS     R2,#+0
        LDR.W    R3,??DataTable201_3  ;; 0x3fe00000
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall __aeabi_d2uiz
        BL       __aeabi_d2uiz
        STR      R0,[R6, #+56]
        POP      {R0,R4-R7,PC}
??set_LedOnTime_0:
        STR      R0,[R6, #+56]
        POP      {R0,R4-R7,PC}    ;; return
          CFI EndBlock cfiBlock141

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock142 Using cfiCommon0
          CFI Function _ZN7MKS_DLP14set_LedOffTimeEt
        THUMB
// __interwork __softfp void MKS_DLP::set_LedOffTime(uint16_t)
_ZN7MKS_DLP14set_LedOffTimeEt:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        MOV      R0,#+1000
        MULS     R0,R0,R1
        STR      R0,[R4, #+44]
        MOVW     R5,#+1035
        MOVS     R2,#+4
        ADD      R1,R4,#+44
        MOV      R0,R5
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R0,#+0
        STR      R0,[R4, #+44]
        MOVS     R2,#+4
        ADD      R1,R4,#+44
        MOV      R0,R5
        POP      {R3-R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall epr_read_data
        B.W      epr_read_data
          CFI EndBlock cfiBlock142

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock143 Using cfiCommon0
          CFI Function _ZN7MKS_DLP16set_BottomlayersEt
        THUMB
// __interwork __softfp void MKS_DLP::set_Bottomlayers(uint16_t)
_ZN7MKS_DLP16set_BottomlayersEt:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        LDRH     R0,[R4, #+476]
        CMP      R0,#+0
        BNE.N    ??set_Bottomlayers_0
        STRH     R1,[R4, #+52]
        MOVW     R5,#+1043
        MOVS     R2,#+2
        ADD      R1,R4,#+52
        MOV      R0,R5
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R0,#+0
        STRH     R0,[R4, #+52]
        MOVS     R2,#+2
        ADD      R1,R4,#+52
        MOV      R0,R5
        POP      {R3-R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall epr_read_data
        B.W      epr_read_data
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??set_Bottomlayers_0:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock143

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock144 Using cfiCommon0
          CFI Function _ZN7MKS_DLP19set_BottomLedOnTimeEt
        THUMB
// __interwork __softfp void MKS_DLP::set_BottomLedOnTime(uint16_t)
_ZN7MKS_DLP19set_BottomLedOnTimeEt:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        MOV      R6,R0
        MOV      R0,#+1000
        MULS     R0,R0,R1
        STR      R0,[R6, #+48]
        MOVW     R4,#+1039
        MOVS     R2,#+4
        ADD      R1,R6,#+48
        MOV      R0,R4
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R0,#+0
        STR      R0,[R6, #+48]
        MOVS     R2,#+4
        ADD      R1,R6,#+48
        MOV      R0,R4
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDR      R0,[R6, #+48]
        LDR.W    R1,??DataTable201_2
        LDR      R7,[R1, #+3564]
        CMP      R7,#+2
        BLT.N    ??set_BottomLedOnTime_0
          CFI FunCall __aeabi_ui2d
        BL       __aeabi_ui2d
        MOV      R4,R0
        MOV      R5,R1
        MOV      R0,R7
          CFI FunCall __aeabi_i2d
        BL       __aeabi_i2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
        MOV      R1,R5
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOVS     R2,#+0
        LDR.W    R3,??DataTable201_3  ;; 0x3fe00000
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall __aeabi_d2uiz
        BL       __aeabi_d2uiz
        STR      R0,[R6, #+60]
        POP      {R0,R4-R7,PC}
??set_BottomLedOnTime_0:
        STR      R0,[R6, #+60]
        POP      {R0,R4-R7,PC}    ;; return
          CFI EndBlock cfiBlock144

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock145 Using cfiCommon0
          CFI Function _ZN7MKS_DLP13get_LedOnTimeEv
          CFI NoCalls
        THUMB
// __interwork __softfp uint16_t MKS_DLP::get_LedOnTime()
_ZN7MKS_DLP13get_LedOnTimeEv:
        LDR      R0,[R0, #+40]
        MOV      R1,#+1000
        UDIV     R0,R0,R1
        UXTH     R0,R0
        BX       LR               ;; return
          CFI EndBlock cfiBlock145

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock146 Using cfiCommon0
          CFI Function _ZN7MKS_DLP14get_LedOffTimeEv
          CFI NoCalls
        THUMB
// __interwork __softfp uint16_t MKS_DLP::get_LedOffTime()
_ZN7MKS_DLP14get_LedOffTimeEv:
        LDR      R0,[R0, #+44]
        MOV      R1,#+1000
        UDIV     R0,R0,R1
        UXTH     R0,R0
        BX       LR               ;; return
          CFI EndBlock cfiBlock146

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock147 Using cfiCommon0
          CFI Function _ZN7MKS_DLP16get_BottomlayersEv
          CFI NoCalls
        THUMB
// __interwork __softfp uint16_t MKS_DLP::get_Bottomlayers()
_ZN7MKS_DLP16get_BottomlayersEv:
        LDRH     R0,[R0, #+52]
        BX       LR               ;; return
          CFI EndBlock cfiBlock147

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock148 Using cfiCommon0
          CFI Function _ZN7MKS_DLP19get_BottomLedOnTimeEv
          CFI NoCalls
        THUMB
// __interwork __softfp uint32_t MKS_DLP::get_BottomLedOnTime()
_ZN7MKS_DLP19get_BottomLedOnTimeEv:
        LDR      R0,[R0, #+48]
        MOV      R1,#+1000
        UDIV     R0,R0,R1
        BX       LR               ;; return
          CFI EndBlock cfiBlock148

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock149 Using cfiCommon0
          CFI Function _ZN7MKS_DLP22set_test_exposure_timeEt
          CFI NoCalls
        THUMB
// __interwork __softfp void MKS_DLP::set_test_exposure_time(uint16_t)
_ZN7MKS_DLP22set_test_exposure_timeEt:
        MOV      R2,#+1000
        MULS     R1,R2,R1
        STR      R1,[R0, #+484]
        BX       LR               ;; return
          CFI EndBlock cfiBlock149

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock150 Using cfiCommon0
          CFI Function _ZN7MKS_DLP11set_ZoffsetEv
        THUMB
// __interwork __softfp void MKS_DLP::set_Zoffset()
_ZN7MKS_DLP11set_ZoffsetEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+1
          CFI FunCall _Z18axis_unhomed_errorb
        BL       _Z18axis_unhomed_errorb
        CMP      R0,#+0
        BNE.N    ??set_Zoffset_0
          CFI FunCall _Z10gcode_M428v
        BL       _Z10gcode_M428v
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z10gcode_M500v
        B.W      _Z10gcode_M500v
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??set_Zoffset_0:
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock150

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock151 Using cfiCommon0
          CFI Function _ZN7MKS_DLP15get_totalLayersEv
          CFI NoCalls
        THUMB
// __interwork __softfp uint16_t MKS_DLP::get_totalLayers()
_ZN7MKS_DLP15get_totalLayersEv:
        LDRH     R1,[R0, #+12]
        LDR.W    R2,??DataTable201_2
        LDRB     R2,[R2, #+3255]
        CMP      R2,#+1
        BNE.N    ??get_totalLayers_0
        LDRH     R0,[R0, #+52]
        ADDS     R0,R0,R1
        SUBS     R0,R0,#+1
        UXTH     R0,R0
        BX       LR
??get_totalLayers_0:
        MOV      R0,R1
        BX       LR               ;; return
          CFI EndBlock cfiBlock151

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock152 Using cfiCommon0
          CFI Function _ZN7MKS_DLP16get_currentLayerEv
        THUMB
// __interwork __softfp uint16_t MKS_DLP::get_currentLayer()
_ZN7MKS_DLP16get_currentLayerEv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
          CFI FunCall _ZN7MKS_DLP15get_totalLayersEv
        BL       _ZN7MKS_DLP15get_totalLayersEv
        LDRB     R1,[R4, #+478]
        LDRH     R2,[R4, #+476]
        ADDS     R1,R2,R1
        UXTH     R1,R1
        CMP      R0,R1
        BLS.N    ??get_currentLayer_0
        MOV      R0,R1
??get_currentLayer_0:
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock152

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock153 Using cfiCommon0
          CFI Function _ZN7MKS_DLP18get_totalPrintTimeEv
        THUMB
// __interwork __softfp uint32_t MKS_DLP::get_totalPrintTime()
_ZN7MKS_DLP18get_totalPrintTimeEv:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        MOV      R7,R0
        LDR.W    R0,??DataTable201_5
        LDRH     R1,[R0, #+2]
        MOV      R2,#+3600
        LDRB     R3,[R0, #+4]
        RSB      R4,R3,R3, LSL #+4
        LSLS     R3,R4,#+2
        MLA      R1,R2,R1,R3
        LDRSB    R0,[R0, #+5]
        SXTAB    R4,R1,R0
        MOV      R0,R7
          CFI FunCall _ZN7MKS_DLP15get_totalLayersEv
        BL       _ZN7MKS_DLP15get_totalLayersEv
        MOV      R5,R0
        MOV      R0,R7
          CFI FunCall _ZN7MKS_DLP16get_currentLayerEv
        BL       _ZN7MKS_DLP16get_currentLayerEv
        SUBS     R0,R5,R0
        UXTH     R0,R0
        ADD      R1,R7,#+36
        LDR      R2,[R1, #+4]
        LDRH     R3,[R1, #+16]
        LDRB     R5,[R7, #+478]
        MOV      R6,R5
        CMP      R6,R3
        BCS.N    ??get_totalPrintTime_0
        LDR      R6,[R1, #+12]
        CMP      R2,R6
        BCS.N    ??get_totalPrintTime_0
        MUL      R12,R2,R0
        MOV      LR,#+1000
        UDIV     R12,R12,LR
        SUBS     R3,R3,R5
        SUBS     R2,R6,R2
        MULS     R2,R2,R3
        MOV      R3,LR
        UDIV     R2,R2,R3
        ADD      R5,R2,R12
        B.N      ??get_totalPrintTime_1
??get_totalPrintTime_0:
        MULS     R2,R2,R0
        MOV      R3,#+1000
        UDIV     R5,R2,R3
??get_totalPrintTime_1:
        LDR      R1,[R1, #+8]
        MULS     R1,R1,R0
        MOV      R2,R3
        UDIV     R6,R1,R2
        MOV      R1,R0
        VMOV     S0,R1
        VCVT.F32.U32 S0,S0
        LDR.W    R1,??DataTable201_6
        VLDR     S1,[R1, #+104]
        VMOV.F32 S2,#2.0
        VMUL.F32 S1,S1,S2
        VLDR     S2,[R7, #+36]
        VSUB.F32 S1,S1,S2
        VMUL.F32 S0,S0,S1
        LDR.W    R1,??DataTable201_7
        VLDR     S1,[R1, #+16]
        VLDR.W   S2,??DataTable189  ;; 0x42f00000
        VDIV.F32 S1,S1,S2
        VDIV.F32 S0,S0,S1
        VCVT.U32.F32 S0,S0
        VMOV     R7,S0
          CFI FunCall __aeabi_ui2d
        BL       __aeabi_ui2d
        MOVS     R2,#+0
        LDR.W    R3,??DataTable201_3  ;; 0x3fe00000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2uiz
        BL       __aeabi_d2uiz
        CMP      R7,R6
        BCS.N    ??get_totalPrintTime_2
        MOV      R7,R6
??get_totalPrintTime_2:
        ADDS     R0,R0,R5
        ADDS     R0,R7,R0
        ADDS     R0,R0,R4
        POP      {R1,R4-R7,PC}    ;; return
          CFI EndBlock cfiBlock153

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock154 Using cfiCommon0
          CFI Function _ZN7MKS_DLP20get_currentPrintTimeEv
        THUMB
// __interwork __softfp uint32_t MKS_DLP::get_currentPrintTime()
_ZN7MKS_DLP20get_currentPrintTimeEv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R4,R0
        ADD      R5,R4,#+36
        LDRB     R0,[R4, #+478]
        LDR      R1,[R5, #+12]
        MULS     R0,R1,R0
        MOV      R1,#+1000
        UDIV     R0,R0,R1
        LDRH     R1,[R4, #+476]
        LDR      R2,[R5, #+4]
        MULS     R1,R2,R1
        MOV      R2,#+1000
        UDIV     R1,R1,R2
        ADDS     R6,R1,R0
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16get_currentLayerEv
        BL       _ZN7MKS_DLP16get_currentLayerEv
        LDR      R1,[R5, #+8]
        MULS     R0,R1,R0
        MOV      R1,#+1000
        UDIV     R5,R0,R1
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16get_currentLayerEv
        BL       _ZN7MKS_DLP16get_currentLayerEv
        VMOV     S0,R0
        VCVT.F32.U32 S0,S0
        LDR.W    R0,??DataTable201_6
        VLDR     S1,[R0, #+104]
        VMOV.F32 S2,#2.0
        VMUL.F32 S1,S1,S2
        VLDR     S2,[R4, #+36]
        VSUB.F32 S1,S1,S2
        VMUL.F32 S0,S0,S1
        LDR.W    R0,??DataTable201_7
        VLDR     S1,[R0, #+16]
        VLDR.W   S2,??DataTable189  ;; 0x42f00000
        VDIV.F32 S1,S1,S2
        VDIV.F32 S0,S0,S1
        VCVT.U32.F32 S0,S0
        VMOV     R0,S0
        CMP      R0,R5
        BCS.N    ??get_currentPrintTime_0
        MOV      R0,R5
??get_currentPrintTime_0:
        ADDS     R0,R0,R6
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock154

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock155 Using cfiCommon0
          CFI Function _ZN7MKS_DLP10get_HeightEv
          CFI NoCalls
        THUMB
// __interwork __vfp float MKS_DLP::get_Height()
_ZN7MKS_DLP10get_HeightEv:
        LDRB     R1,[R0, #+478]
        LDRH     R2,[R0, #+476]
        ADDS     R1,R2,R1
        VMOV     S0,R1
        VCVT.F32.S32 S0,S0
        VLDR     S1,[R0, #+36]
        VMUL.F32 S0,S0,S1
        BX       LR               ;; return
          CFI EndBlock cfiBlock155

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock156 Using cfiCommon0
          CFI Function _ZN7MKS_DLP17get_ttfStatus_OFFEv
          CFI NoCalls
        THUMB
// __interwork __softfp char MKS_DLP::get_ttfStatus_OFF()
_ZN7MKS_DLP17get_ttfStatus_OFFEv:
        LDRSB    R1,[R0, #+500]
        CMP      R1,#+0
        BEQ.N    ??get_ttfStatus_OFF_0
        MOVS     R1,#+0
        STRB     R1,[R0, #+500]
        MOVS     R0,#+1
        BX       LR
??get_ttfStatus_OFF_0:
        MOVS     R0,#+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock156

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock157 Using cfiCommon0
          CFI Function _ZN7MKS_DLP16get_ttfStatus_ONEv
          CFI NoCalls
        THUMB
// __interwork __softfp char MKS_DLP::get_ttfStatus_ON()
_ZN7MKS_DLP16get_ttfStatus_ONEv:
        LDRSB    R1,[R0, #+499]
        CMP      R1,#+0
        BEQ.N    ??get_ttfStatus_ON_0
        MOVS     R1,#+0
        STRB     R1,[R0, #+499]
        MOVS     R0,#+1
        BX       LR
??get_ttfStatus_ON_0:
        MOVS     R0,#+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock157

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock158 Using cfiCommon0
          CFI Function _ZN7MKS_DLP12get_cpld_verEv
        THUMB
// __interwork __softfp uint8_t MKS_DLP::get_cpld_ver()
_ZN7MKS_DLP12get_cpld_verEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN7MKS_DLP14bank2disp_readEv
        BL       _ZN7MKS_DLP14bank2disp_readEv
        AND      R0,R0,#0xF
        MOVS     R1,#+10
        SDIV     R1,R0,R1
        ADD      R2,R1,R1, LSL #+2
        SUB      R0,R0,R2, LSL #+1
        UXTB     R0,R0
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock158

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock159 Using cfiCommon0
          CFI Function _ZN7MKS_DLP13buzzer_enableEh
        THUMB
// __interwork __softfp void MKS_DLP::buzzer_enable(uint8_t)
_ZN7MKS_DLP13buzzer_enableEh:
        PUSH     {R1,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        STRB     R1,[R0, #+752]
        MOVS     R2,#+1
        ADD      R1,SP,#+0
        MOVW     R0,#+1594
          CFI FunCall AT24CXX_Write
        BL       AT24CXX_Write
        LDR.W    R0,??DataTable201_2
        LDRB     R0,[R0, #+3252]
        LDR.W    R1,??DataTable201
        STRB     R0,[R1, #+632]
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock159

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock160 Using cfiCommon0
          CFI Function _ZN7MKS_DLP11buzzer_toneEtth
          CFI NoCalls
        THUMB
// __interwork __softfp void MKS_DLP::buzzer_tone(uint16_t, uint16_t, uint8_t)
_ZN7MKS_DLP11buzzer_toneEtth:
        PUSH     {R4,R5}
          CFI R5 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDRB     R4,[R0, #+752]
        CMP      R4,#+0
        BEQ.N    ??buzzer_tone_0
        CMP      R3,#+6
        BLT.N    ??buzzer_tone_1
        MOVS     R3,#+5
??buzzer_tone_1:
        cpsid i
        MOVS     R4,#+0
        B.N      ??buzzer_tone_2
??buzzer_tone_3:
        ADD      R5,R0,R4, LSL #+2
        STRH     R1,[R5, #+732]
        STRH     R2,[R5, #+734]
        ADDS     R4,R4,#+1
??buzzer_tone_2:
        CMP      R4,R3
        BLT.N    ??buzzer_tone_3
        cpsie i
??buzzer_tone_0:
        POP      {R4,R5}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI CFA R13+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock160

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock161 Using cfiCommon0
          CFI Function _ZN7MKS_DLP14buzzer_pollingEv
          CFI NoCalls
        THUMB
// __interwork __softfp void MKS_DLP::buzzer_polling()
_ZN7MKS_DLP14buzzer_pollingEv:
        LDRB     R1,[R0, #+752]
        CMP      R1,#+0
        BEQ.N    ??buzzer_polling_0
        MOVS     R1,#+0
        B.N      ??buzzer_polling_1
??buzzer_polling_2:
        ADDS     R1,R1,#+1
??buzzer_polling_1:
        CMP      R1,#+5
        BGE.N    ??buzzer_polling_0
        ADD      R2,R0,R1, LSL #+2
        LDRH     R3,[R2, #+732]
        CMP      R3,#+0
        BEQ.N    ??buzzer_polling_3
        SUBS     R0,R3,#+1
        STRH     R0,[R2, #+732]
        UXTH     R0,R0
        AND      R0,R0,#0x1
        LDR.W    R1,??DataTable204_4  ;; 0x424082b4
        STR      R0,[R1, #+0]
        BX       LR
??buzzer_polling_3:
        ADD      R2,R2,#+732
        LDRH     R3,[R2, #+2]
        CMP      R3,#+0
        BEQ.N    ??buzzer_polling_2
        SUBS     R0,R3,#+1
        STRH     R0,[R2, #+2]
??buzzer_polling_0:
        BX       LR               ;; return
          CFI EndBlock cfiBlock161

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock162 Using cfiCommon0
          CFI Function _ZN7MKS_DLP17get_buzzer_statusEv
          CFI NoCalls
        THUMB
// __interwork __softfp uint8_t MKS_DLP::get_buzzer_status()
_ZN7MKS_DLP17get_buzzer_statusEv:
        LDRB     R0,[R0, #+752]
        BX       LR               ;; return
          CFI EndBlock cfiBlock162

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock163 Using cfiCommon0
          CFI Function _ZN7MKS_DLP19printingHasFinishedEv
        THUMB
// __interwork __softfp void MKS_DLP::printingHasFinished()
_ZN7MKS_DLP19printingHasFinishedEv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        SUB      SP,SP,#+8
          CFI CFA R13+16
        MOV      R4,R0
        MOVS     R3,#+0
        MOV      R2,R3
        MOVS     R1,#+2
          CFI FunCall _ZN7MKS_DLP16bank2disp_enableEhhh
        BL       _ZN7MKS_DLP16bank2disp_enableEhhh
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP7led_offEv
        BL       _ZN7MKS_DLP7led_offEv
        LDR.W    R0,??DataTable201_2
          CFI FunCall _ZN10CardReader19printingHasFinishedEv
        BL       _ZN10CardReader19printingHasFinishedEv
        MOVS     R0,#+166
        STRB     R0,[SP, #+0]
        MOVS     R2,#+1
        ADD      R1,SP,#+0
        MOV      R0,#+1000
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP9moveMax_ZEv
        BL       _ZN7MKS_DLP9moveMax_ZEv
        MOVS     R2,#+1
        LDR.W    R0,??DataTable204
        LDRH     R1,[R0, #+4]
        LDR.W    R0,??DataTable204_1
        LDR      R0,[R0, #+8]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        LDR.W    R1,??DataTable201_6
        STRB     R0,[R1, #+10]
        MOVS     R3,#+5
        MOV      R2,#+2000
        MOV      R1,#+1000
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP11buzzer_toneEtth
        BL       _ZN7MKS_DLP11buzzer_toneEtth
          CFI FunCall _Z10clr_ticketv
        BL       _Z10clr_ticketv
        POP      {R0,R1,R4,PC}    ;; return
          CFI EndBlock cfiBlock163

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock164 Using cfiCommon0
          CFI Function _ZN7MKS_DLP17PrintStatePollingEv
        THUMB
// __interwork __softfp void MKS_DLP::PrintStatePolling()
_ZN7MKS_DLP17PrintStatePollingEv:
        LDR.W    R1,??DataTable201_2
        LDRB     R2,[R1, #+2488]
        CMP      R2,#+0
        BEQ.N    ??PrintStatePolling_0
        BX       LR
??PrintStatePolling_0:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDRB     R2,[R0, #+490]
        CMP      R2,#+0
        BNE.N    ??PrintStatePolling_1
        LDRB     R1,[R1, #+3344]
        CMP      R1,#+168
        BEQ.N    ??PrintStatePolling_2
        CMP      R1,#+172
        BNE.N    ??PrintStatePolling_1
??PrintStatePolling_2:
        MOVS     R1,#+1
        STRB     R1,[R0, #+490]
          CFI FunCall _ZN7Planner13blocks_queuedEv
        BL       _ZN7Planner13blocks_queuedEv
        CMP      R0,#+0
        BNE.N    ??PrintStatePolling_3
        LDR.W    R0,??DataTable205
        LDRSH    R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??PrintStatePolling_1
??PrintStatePolling_3:
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z17quickstop_stepperv
        B.W      _Z17quickstop_stepperv
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??PrintStatePolling_1:
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock164

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable189:
        DC32     0x42f00000

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock165 Using cfiCommon0
          CFI Function _ZN7MKS_DLP10pausePrintEv
        THUMB
// __interwork __softfp bool MKS_DLP::pausePrint()
_ZN7MKS_DLP10pausePrintEv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        ADD      R4,R0,#+476
        LDRH     R1,[R0, #+476]
        CMP      R1,#+0
        BEQ.N    ??pausePrint_0
        LDRB     R1,[R4, #+12]
        CMP      R1,#+0
        BEQ.N    ??pausePrint_0
        MOVS     R1,#+1
        STRB     R1,[R4, #+13]
??pausePrint_0:
        MOVS     R1,#+0
        STRB     R1,[R4, #+3]
          CFI FunCall _ZN7MKS_DLP7led_offEv
        BL       _ZN7MKS_DLP7led_offEv
        LDRB     R0,[R4, #+12]
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock165

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock166 Using cfiCommon0
          CFI Function _ZN7MKS_DLP11resumePrintEv
        THUMB
// __interwork __softfp void MKS_DLP::resumePrint()
_ZN7MKS_DLP11resumePrintEv:
        PUSH     {R2-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+24
        MOV      R4,R0
        ADD      R5,R4,#+36
        ADD      R0,R4,#+476
        LDRB     R1,[R0, #+13]
        CMP      R1,#+0
        BEQ.N    ??resumePrint_0
        MOVS     R1,#+0
        STRB     R1,[R0, #+13]
        LDRB     R1,[R0, #+2]
        MOV      R2,R1
        LDRH     R3,[R5, #+16]
        CMP      R2,R3
        BCS.N    ??resumePrint_1
        SUBS     R1,R1,#+1
        STRB     R1,[R0, #+2]
        UXTB     R1,R1
        CMP      R1,#+2
        BGE.N    ??resumePrint_0
        MOVS     R1,#+1
        STRB     R1,[R0, #+2]
        B.N      ??resumePrint_0
??resumePrint_1:
        LDRH     R0,[R4, #+476]
        SUBS     R0,R0,#+1
        STRH     R0,[R4, #+476]
??resumePrint_0:
        MOVS     R0,#+166
        STRB     R0,[SP, #+0]
        MOVW     R6,#+1059
        MOVS     R2,#+1
        ADD      R1,SP,#+0
        MOV      R0,R6
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP16get_currentLayerEv
        BL       _ZN7MKS_DLP16get_currentLayerEv
        LDR.W    R2,??DataTable201_6
        VMOV     S0,R0
        VCVT.F32.U32 S0,S0
        VLDR     S1,[R4, #+36]
        VMUL.F32 S0,S0,S1
        VSTR     S0,[R2, #+60]
        LDR.W    R0,??DataTable201_7
        VLDR     S0,[R0, #+16]
        VLDR.W   S1,??DataTable194  ;; 0x42f00000
        VDIV.F32 S0,S0,S1
        VSTR     S0,[SP, #+4]
        ADD      R1,SP,#+4
        ADD      R0,R2,#+60
          CFI FunCall _Z21do_blocking_move_to_zRKfS0_
        BL       _Z21do_blocking_move_to_zRKfS0_
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        MOVS     R0,#+167
        STRB     R0,[SP, #+0]
        MOVS     R2,#+1
        ADD      R1,SP,#+0
        MOV      R0,R6
          CFI FunCall epr_write_data
        BL       epr_write_data
        ADR.W    R0,`?<Constant "resume:">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
        LDR      R0,[R5, #+8]
        ADDS     R0,R0,#+1
        STR      R0,[R4, #+728]
        POP      {R0,R1,R4-R6,PC}  ;; return
          CFI EndBlock cfiBlock166

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "resume:">`:
        DC8 "resume:"

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock167 Using cfiCommon0
          CFI Function _ZN7MKS_DLP9stopPrintEv
        THUMB
// __interwork __softfp void MKS_DLP::stopPrint()
_ZN7MKS_DLP9stopPrintEv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
        LDR.W    R0,??DataTable201_2
        LDR      R0,[R0, #+3564]
        CMP      R0,#+2
        BLT.N    ??stopPrint_0
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP24ExposureDataTrans_circleEv
        BL       _ZN7MKS_DLP24ExposureDataTrans_circleEv
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP14CleanDataTransEv
        BL       _ZN7MKS_DLP14CleanDataTransEv
??stopPrint_0:
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP7led_offEv
        BL       _ZN7MKS_DLP7led_offEv
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z17quickstop_stepperv
        B.W      _Z17quickstop_stepperv
          CFI EndBlock cfiBlock167

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock168 Using cfiCommon0
          CFI Function _ZN7MKS_DLP24write_Information_pausedEv
        THUMB
// __interwork __softfp void MKS_DLP::write_Information_paused()
_ZN7MKS_DLP24write_Information_pausedEv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        SUB      SP,SP,#+8
          CFI CFA R13+16
        ADD      R1,R0,#+476
        LDRB     R2,[R1, #+13]
        CMP      R2,#+0
        BEQ.N    ??write_Information_paused_0
        MOVS     R2,#+0
        STRB     R2,[R1, #+13]
        LDRB     R2,[R1, #+2]
        MOV      R3,R2
        LDRH     R4,[R0, #+52]
        CMP      R3,R4
        BCS.N    ??write_Information_paused_1
        SUBS     R2,R2,#+1
        STRB     R2,[R1, #+2]
        UXTB     R2,R2
        CMP      R2,#+2
        BGE.N    ??write_Information_paused_0
        MOVS     R2,#+1
        STRB     R2,[R1, #+2]
        B.N      ??write_Information_paused_0
??write_Information_paused_1:
        LDRH     R1,[R0, #+476]
        SUBS     R1,R1,#+1
        STRH     R1,[R0, #+476]
??write_Information_paused_0:
          CFI FunCall _ZN7MKS_DLP16get_currentLayerEv
        BL       _ZN7MKS_DLP16get_currentLayerEv
        STRH     R0,[SP, #+0]
        LDR.W    R4,??DataTable201_2
        MOVS     R2,#+4
        ADDW     R1,R4,#+3348
        MOVW     R0,#+1053
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOVW     R0,#+1057
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADDW     R1,R4,#+3320
        MOVW     R0,#+1045
          CFI FunCall epr_write_data
        BL       epr_write_data
        LDR.W    R4,??DataTable201_5
        MOVS     R2,#+2
        ADDS     R1,R4,#+2
        MOVW     R0,#+1049
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDS     R1,R4,#+4
        MOVW     R0,#+1051
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDS     R1,R4,#+5
        MOVW     R0,#+1052
          CFI FunCall epr_write_data
        BL       epr_write_data
        POP      {R0,R1,R4,PC}    ;; return
          CFI EndBlock cfiBlock168

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock169 Using cfiCommon0
          CFI Function _ZN7MKS_DLP23read_Information_pausedEv
        THUMB
// __interwork __softfp void MKS_DLP::read_Information_paused()
_ZN7MKS_DLP23read_Information_pausedEv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+8
          CFI CFA R13+24
        MOV      R4,R0
        LDR.W    R5,??DataTable201_2
        MOVS     R2,#+30
        ADDW     R1,R5,#+3276
        MOVW     R0,#+1001
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADDW     R1,R5,#+3348
        MOVW     R0,#+1053
          CFI FunCall epr_read_data
        BL       epr_read_data
        ADD      R6,R4,#+40
        MOVS     R2,#+4
        MOV      R1,R6
        MOVW     R0,#+1031
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+44
        MOVW     R0,#+1035
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+52
        MOVW     R0,#+1043
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+48
        MOVW     R0,#+1039
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDR      R0,[R4, #+40]
        STR      R0,[R6, #+16]
        LDR      R0,[R6, #+8]
        STR      R0,[R6, #+20]
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        MOVW     R0,#+1057
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDRH     R0,[R6, #+12]
        ADD      R1,R4,#+476
        LDRH     R2,[SP, #+0]
        CMP      R0,R2
        BCC.N    ??read_Information_paused_0
        MOV      R0,R2
        STRB     R0,[R1, #+2]
        MOVS     R0,#+0
        STRH     R0,[R4, #+476]
        B.N      ??read_Information_paused_1
??read_Information_paused_0:
        STRB     R0,[R1, #+2]
        LDRH     R0,[SP, #+0]
        LDRH     R1,[R6, #+12]
        SUBS     R0,R0,R1
        STRH     R0,[R4, #+476]
??read_Information_paused_1:
        MOVS     R2,#+4
        ADDW     R1,R5,#+3320
        MOVW     R0,#+1045
          CFI FunCall epr_read_data
        BL       epr_read_data
          CFI FunCall mks_setPositionZ
        BL       mks_setPositionZ
        LDR.W    R4,??DataTable201_5
        MOVS     R2,#+2
        ADDS     R1,R4,#+2
        MOVW     R0,#+1049
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDS     R1,R4,#+4
        MOVW     R0,#+1051
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDS     R1,R4,#+5
        MOVW     R0,#+1052
          CFI FunCall epr_read_data
        BL       epr_read_data
        POP      {R0,R1,R4-R6,PC}  ;; return
          CFI EndBlock cfiBlock169

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock170 Using cfiCommon0
          CFI Function _ZN7MKS_DLP19contiuePrint_pausedEv
        THUMB
// __interwork __softfp void MKS_DLP::contiuePrint_paused()
_ZN7MKS_DLP19contiuePrint_pausedEv:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        MOV      R4,R0
        LDR.W    R5,??DataTable201_2
        MOVS     R0,#+1
        STRB     R0,[R5, #+2488]
        LDRB     R0,[R5, #+3255]
        CMP      R0,#+1
        BNE.N    ??contiuePrint_paused_0
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP8getHead1Ev
        BL       _ZN7MKS_DLP8getHead1Ev
        LDR      R1,[R5, #+3348]
        MOV      R0,R5
          CFI FunCall _ZN10CardReader8setIndexEl
        BL       _ZN10CardReader8setIndexEl
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP15get_sdcard_bmpsEv
        BL       _ZN7MKS_DLP15get_sdcard_bmpsEv
        B.N      ??contiuePrint_paused_1
??contiuePrint_paused_0:
        LDRH     R1,[R4, #+476]
        CMP      R1,#+0
        BEQ.N    ??contiuePrint_paused_1
        ADDW     R6,R5,#+3540
        LDR      R0,[R6, #+24]
        CMP      R0,#+2
        BLT.N    ??contiuePrint_paused_2
        LDR.W    R7,??DataTable201_6
        LDRB     R0,[R7, #+25]
        ADDS     R0,R0,#+1
        STRB     R0,[R7, #+25]
        MOVS     R7,#+0
??contiuePrint_paused_3:
        UXTB     R7,R7
        MOV      R0,R7
        LDR      R1,[R6, #+24]
        CMP      R0,R1
        BGE.N    ??contiuePrint_paused_1
        MOV      R2,R7
        LDRH     R1,[R4, #+476]
        LDR      R3,[R5, #+3540]
        MULS     R0,R3,R0
        UXTAH    R1,R0,R1
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP21decode_layer_from_rleEjh
        BL       _ZN7MKS_DLP21decode_layer_from_rleEjh
        ADDS     R7,R7,#+1
        B.N      ??contiuePrint_paused_3
??contiuePrint_paused_2:
        MOVS     R2,#+0
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP21decode_layer_from_rleEjh
        BL       _ZN7MKS_DLP21decode_layer_from_rleEjh
??contiuePrint_paused_1:
        MOVS     R0,#+0
        STRB     R0,[R4, #+479]
        LDR      R0,[R4, #+44]
        ADDS     R0,R0,#+1
        STR      R0,[R4, #+728]
        LDR.W    R7,??DataTable201_6
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP10get_HeightEv
        BL       _ZN7MKS_DLP10get_HeightEv
        VSTR     S0,[R7, #+60]
        LDR.W    R0,??DataTable201_7
        VLDR     S0,[R0, #+16]
        VLDR.W   S1,??DataTable194  ;; 0x42f00000
        VDIV.F32 S0,S0,S1
        VSTR     S0,[SP, #+0]
        ADD      R1,SP,#+0
        ADD      R0,R7,#+60
          CFI FunCall _Z21do_blocking_move_to_zRKfS0_
        BL       _Z21do_blocking_move_to_zRKfS0_
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
        MOVS     R0,#+167
        STRB     R0,[R5, #+3344]
          CFI FunCall _Z9gcode_M24v
        BL       _Z9gcode_M24v
        POP      {R0,R4-R7,PC}    ;; return
          CFI EndBlock cfiBlock170

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable194:
        DC32     0x42f00000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable194_1:
        DC32     bmp_layer_buf

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable194_2:
        DC32     0x42420288

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable194_3:
        DC32     mipi_te_cnt

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock171 Using cfiCommon0
          CFI Function _ZN7MKS_DLP18Is_Paused_FinishedEv
        THUMB
// __interwork __softfp bool MKS_DLP::Is_Paused_Finished()
_ZN7MKS_DLP18Is_Paused_FinishedEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R2,#+1
        ADD      R1,SP,#+0
        MOVW     R0,#+1059
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDRB     R0,[SP, #+0]
        CMP      R0,#+166
        BNE.N    ??Is_Paused_Finished_0
        MOVS     R0,#+0
        POP      {R1,PC}
??Is_Paused_Finished_0:
        CMP      R0,#+167
        BNE.N    ??Is_Paused_Finished_1
        MOVS     R0,#+1
        POP      {R1,PC}
??Is_Paused_Finished_1:
        MOVS     R0,#+0
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock171

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock172 Using cfiCommon0
          CFI Function _ZN7MKS_DLP23clean_Information_layerEv
        THUMB
// __interwork __softfp void MKS_DLP::clean_Information_layer()
_ZN7MKS_DLP23clean_Information_layerEv:
        PUSH     {R2-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+24
        MOV      R4,R0
        MOVS     R0,#+0
        STR      R0,[SP, #+4]
        STRH     R0,[SP, #+2]
        STRB     R0,[SP, #+0]
        MOV      R5,R0
        B.N      ??clean_Information_layer_0
??clean_Information_layer_1:
        MOVS     R0,#+20
        SDIV     R0,R5,R0
        ADD      R1,R0,R0, LSL #+2
        SUB      R0,R5,R1, LSL #+2
        MOVS     R1,#+11
        SMULBB   R0,R0,R1
        ADDW     R6,R0,#+1067
        UXTH     R6,R6
        MOVS     R2,#+4
        ADD      R1,SP,#+4
        MOV      R0,R6
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,SP,#+2
        ADDS     R0,R6,#+4
        UXTH     R0,R0
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,SP,#+0
        ADDS     R0,R6,#+6
        UXTH     R0,R0
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        ADDS     R0,R6,#+7
        UXTH     R0,R0
          CFI FunCall epr_write_data
        BL       epr_write_data
        ADDS     R5,R5,#+1
??clean_Information_layer_0:
        CMP      R5,#+20
        BLT.N    ??clean_Information_layer_1
        MOVS     R0,#+0
        B.N      ??clean_Information_layer_2
??clean_Information_layer_3:
        ADD      R1,R4,R0, LSL #+2
        MOVS     R2,#+0
        STR      R2,[R1, #+504]
        ADD      R3,R4,R0, LSL #+1
        STRH     R2,[R3, #+584]
        MOVS     R2,#+166
        ADDS     R3,R0,R4
        STRB     R2,[R3, #+624]
        MOVS     R2,#+0
        STR      R2,[R1, #+644]
        ADDS     R0,R0,#+1
??clean_Information_layer_2:
        CMP      R0,#+20
        BLT.N    ??clean_Information_layer_3
        POP      {R0,R1,R4-R6,PC}  ;; return
          CFI EndBlock cfiBlock172

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock173 Using cfiCommon0
          CFI Function _ZN7MKS_DLP23write_Information_layerE15DLP_MOVE_STATUS
        THUMB
// __interwork __softfp void MKS_DLP::write_Information_layer(DLP_MOVE_STATUS)
_ZN7MKS_DLP23write_Information_layerE15DLP_MOVE_STATUS:
        PUSH     {R1,R4-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        SUB      SP,SP,#+8
          CFI CFA R13+32
        MOV      R4,R0
          CFI FunCall _ZN7MKS_DLP16get_currentLayerEv
        BL       _ZN7MKS_DLP16get_currentLayerEv
        STRH     R0,[SP, #+0]
        MOVS     R5,#+20
        MOV      R1,R5
        SDIV     R1,R0,R1
        MLS      R0,R5,R1,R0
        MOVS     R1,#+11
        MULS     R0,R1,R0
        ADDW     R0,R0,#+1067
        STRH     R0,[R4, #+724]
        LDR.W    R6,??DataTable201_2
        LDRB     R0,[SP, #+8]
        CMP      R0,#+167
        BNE.N    ??write_Information_layer_0
        MOVS     R2,#+4
        ADDW     R1,R6,#+3348
        LDRH     R0,[R4, #+724]
          CFI FunCall epr_write_data
        BL       epr_write_data
        LDR.W    R0,??DataTable201_5
        LDRH     R1,[R0, #+2]
        MOV      R2,#+3600
        LDRB     R3,[R0, #+4]
        RSB      R7,R3,R3, LSL #+4
        LSLS     R3,R7,#+2
        MLA      R1,R2,R1,R3
        LDRSB    R0,[R0, #+5]
        SXTAB    R0,R1,R0
        STR      R0,[SP, #+4]
        MOVS     R2,#+4
        ADD      R1,SP,#+4
        LDRH     R0,[R4, #+724]
        ADDS     R0,R0,#+7
        UXTH     R0,R0
          CFI FunCall epr_write_data
        BL       epr_write_data
??write_Information_layer_0:
        MOVS     R2,#+2
        ADD      R1,SP,#+0
        LDRH     R0,[R4, #+724]
        ADDS     R0,R0,#+4
        UXTH     R0,R0
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,SP,#+8
        LDRH     R0,[R4, #+724]
        ADDS     R0,R0,#+6
        UXTH     R0,R0
          CFI FunCall epr_write_data
        BL       epr_write_data
        LDRH     R0,[SP, #+0]
        MOV      R1,R5
        SDIV     R1,R0,R1
        MLS      R0,R5,R1,R0
        ADD      R0,R4,R0, LSL #+2
        LDR      R1,[R6, #+3348]
        STR      R1,[R0, #+504]
        LDRH     R0,[SP, #+0]
        MOV      R1,R5
        SDIV     R1,R0,R1
        MLS      R0,R5,R1,R0
        ADD      R0,R4,R0, LSL #+1
        LDRH     R1,[SP, #+0]
        STRH     R1,[R0, #+584]
        LDRH     R0,[SP, #+0]
        MOV      R1,R5
        SDIV     R1,R0,R1
        MLS      R0,R5,R1,R0
        ADDS     R0,R0,R4
        LDRB     R1,[SP, #+8]
        STRB     R1,[R0, #+624]
        LDRH     R0,[SP, #+0]
        MOV      R1,R5
        SDIV     R1,R0,R1
        MLS      R0,R5,R1,R0
        ADD      R0,R4,R0, LSL #+2
        LDR      R1,[SP, #+4]
        STR      R1,[R0, #+644]
        POP      {R0-R2,R4-R7,PC}  ;; return
          CFI EndBlock cfiBlock173

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable195:
        DC32     disp_state

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable195_1:
        DC32     card+0x9C4

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable195_2:
        DC32     Serial6

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock174 Using cfiCommon0
          CFI Function _ZN7MKS_DLP16Can_Resume_PrintEv
        THUMB
// __interwork __softfp uint16_t MKS_DLP::Can_Resume_Print()
_ZN7MKS_DLP16Can_Resume_PrintEv:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
        MOV      R5,R0
        MOVS     R4,#+0
        MOV      R7,R4
        B.N      ??Can_Resume_Print_0
??Can_Resume_Print_1:
        MOVS     R0,#+20
        SDIV     R0,R7,R0
        ADD      R1,R0,R0, LSL #+2
        SUB      R0,R7,R1, LSL #+2
        MOVS     R1,#+11
        SMULBB   R0,R0,R1
        ADDW     R8,R0,#+1067
        UXTH     R8,R8
        ADD      R9,R5,R7, LSL #+2
        MOVS     R2,#+4
        ADD      R1,R9,#+504
        MOV      R0,R8
          CFI FunCall epr_read_data
        BL       epr_read_data
        ADD      R10,R5,R7, LSL #+1
        MOVS     R2,#+2
        ADD      R1,R10,#+584
        ADD      R0,R8,#+4
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDS     R0,R7,R5
        ADD      R1,R0,#+624
        ADD      R0,R8,#+6
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R9,#+644
        ADD      R0,R8,#+7
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDRH     R0,[R10, #+584]
        CMP      R4,R0
        BCS.N    ??Can_Resume_Print_2
        MOV      R4,R0
        MOV      R6,R7
??Can_Resume_Print_2:
        ADDS     R7,R7,#+1
??Can_Resume_Print_0:
        CMP      R7,#+20
        BLT.N    ??Can_Resume_Print_1
        UXTB     R6,R6
        ADDS     R0,R6,R5
        LDRB     R0,[R0, #+624]
        CMP      R0,#+167
        BNE.N    ??Can_Resume_Print_3
        ADD      R0,R5,R6, LSL #+2
        LDR      R1,[R0, #+504]
        LDR.N    R2,??DataTable201_2
        STR      R1,[R2, #+3348]
        LDR.N    R1,??DataTable201_5
        LDR      R2,[R0, #+644]
        MOV      R3,#+3600
        UDIV     R2,R2,R3
        STRH     R2,[R1, #+2]
        LDR      R2,[R0, #+644]
        MOV      R5,R3
        UDIV     R5,R2,R5
        MLS      R2,R3,R5,R2
        MOVS     R5,#+60
        UDIV     R2,R2,R5
        STRB     R2,[R1, #+4]
        LDR      R0,[R0, #+644]
        MOV      R2,R3
        UDIV     R2,R0,R2
        MLS      R0,R3,R2,R0
        MOV      R2,R5
        UDIV     R2,R0,R2
        RSB      R3,R2,R2, LSL #+4
        SUB      R0,R0,R3, LSL #+2
        STRB     R0,[R1, #+5]
        ADDS     R0,R4,#+1
        UXTH     R0,R0
        B.N      ??Can_Resume_Print_4
??Can_Resume_Print_3:
        MOVS     R0,#+0
??Can_Resume_Print_4:
        POP      {R4-R10,PC}      ;; return
          CFI EndBlock cfiBlock174

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable196:
        DC32     0x42408284

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock175 Using cfiCommon0
          CFI Function _ZN7MKS_DLP22read_Information_layerEv
        THUMB
// __interwork __softfp bool MKS_DLP::read_Information_layer()
_ZN7MKS_DLP22read_Information_layerEv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R4,R0
          CFI FunCall _ZN7MKS_DLP16Can_Resume_PrintEv
        BL       _ZN7MKS_DLP16Can_Resume_PrintEv
        MOVS     R5,R0
        BNE.N    ??read_Information_layer_0
        MOVS     R0,#+0
        POP      {R4-R6,PC}
??read_Information_layer_0:
        MOVS     R2,#+30
        LDR.W    R1,??DataTable210
        MOVW     R0,#+1001
          CFI FunCall epr_read_data
        BL       epr_read_data
        ADD      R6,R4,#+40
        MOVS     R2,#+4
        MOV      R1,R6
        MOVW     R0,#+1031
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+44
        MOVW     R0,#+1035
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+52
        MOVW     R0,#+1043
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+48
        MOVW     R0,#+1039
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDR      R0,[R4, #+40]
        STR      R0,[R6, #+16]
        LDR      R0,[R6, #+8]
        STR      R0,[R6, #+20]
        LDRH     R0,[R6, #+12]
        ADD      R1,R4,#+476
        CMP      R0,R5
        BLT.N    ??read_Information_layer_1
        STRB     R5,[R1, #+2]
        MOVS     R0,#+0
        STRH     R0,[R4, #+476]
        B.N      ??read_Information_layer_2
??read_Information_layer_1:
        STRB     R0,[R1, #+2]
        LDRH     R0,[R6, #+12]
        SUBS     R0,R5,R0
        STRH     R0,[R4, #+476]
        UXTH     R0,R0
        CMP      R0,#+0
        BEQ.N    ??read_Information_layer_2
        SUBS     R0,R0,#+1
        STRH     R0,[R4, #+476]
??read_Information_layer_2:
        MOVS     R0,#+1
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock175

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable197:
        DC32     0x42400290

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock176 Using cfiCommon0
          CFI Function _ZN7MKS_DLP18contiuePrint_PwdwnEv
        THUMB
// __interwork __softfp void MKS_DLP::contiuePrint_Pwdwn()
_ZN7MKS_DLP18contiuePrint_PwdwnEv:
        PUSH     {R4-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+20
        SUB      SP,SP,#+12
          CFI CFA R13+32
        MOV      R5,R0
        LDR.N    R4,??DataTable201_2
        MOVS     R0,#+1
        STRB     R0,[R4, #+2488]
        LDRB     R0,[R4, #+3255]
        CMP      R0,#+1
        BNE.N    ??contiuePrint_Pwdwn_0
        MOV      R0,R5
          CFI FunCall _ZN7MKS_DLP8getHead1Ev
        BL       _ZN7MKS_DLP8getHead1Ev
        ADDW     R0,R4,#+3320
        LDR      R1,[R0, #+28]
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8setIndexEl
        BL       _ZN10CardReader8setIndexEl
        MOV      R0,R5
          CFI FunCall _ZN7MKS_DLP15get_sdcard_bmpsEv
        BL       _ZN7MKS_DLP15get_sdcard_bmpsEv
        B.N      ??contiuePrint_Pwdwn_1
??contiuePrint_Pwdwn_0:
        LDRH     R1,[R5, #+476]
        CMP      R1,#+0
        BEQ.N    ??contiuePrint_Pwdwn_1
        ADDW     R6,R4,#+3540
        LDR      R0,[R6, #+24]
        CMP      R0,#+2
        BLT.N    ??contiuePrint_Pwdwn_2
        LDR.N    R7,??DataTable201_6
        LDRB     R0,[R7, #+25]
        ADDS     R0,R0,#+1
        STRB     R0,[R7, #+25]
        MOVS     R7,#+0
??contiuePrint_Pwdwn_3:
        UXTB     R7,R7
        MOV      R0,R7
        LDR      R1,[R6, #+24]
        CMP      R0,R1
        BGE.N    ??contiuePrint_Pwdwn_1
        MOV      R2,R7
        LDRH     R1,[R5, #+476]
        LDR      R3,[R4, #+3540]
        MULS     R0,R3,R0
        UXTAH    R1,R0,R1
        MOV      R0,R5
          CFI FunCall _ZN7MKS_DLP21decode_layer_from_rleEjh
        BL       _ZN7MKS_DLP21decode_layer_from_rleEjh
        ADDS     R7,R7,#+1
        B.N      ??contiuePrint_Pwdwn_3
??contiuePrint_Pwdwn_2:
        MOVS     R2,#+0
        MOV      R0,R5
          CFI FunCall _ZN7MKS_DLP21decode_layer_from_rleEjh
        BL       _ZN7MKS_DLP21decode_layer_from_rleEjh
??contiuePrint_Pwdwn_1:
        MOVS     R0,#+0
        STRB     R0,[R5, #+479]
        LDR      R0,[R5, #+44]
        ADDS     R0,R0,#+1
        STR      R0,[R5, #+728]
        MOV      R0,R5
          CFI FunCall _ZN7MKS_DLP10get_HeightEv
        BL       _ZN7MKS_DLP10get_HeightEv
        ADDW     R0,R4,#+3320
        VSTR     S0,[R0, #0]
          CFI FunCall mks_setPositionZ
        BL       mks_setPositionZ
        LDR.N    R7,??DataTable201_6
        VLDR     S0,[R7, #+44]
        VLDR     S1,[R7, #+104]
        VADD.F32 S0,S0,S1
        VSTR     S0,[R7, #+60]
        LDR.N    R5,??DataTable201_7
        VLDR     S0,[R5, #+16]
        VLDR.W   S1,??DataTable201_4  ;; 0x42f00000
        VDIV.F32 S0,S0,S1
        VSTR     S0,[SP, #+4]
        ADD      R1,SP,#+4
        ADD      R0,R7,#+60
          CFI FunCall _Z21do_blocking_move_to_zRKfS0_
        BL       _Z21do_blocking_move_to_zRKfS0_
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
        VLDR     S0,[R7, #+44]
        VLDR     S1,[R7, #+104]
        VSUB.F32 S0,S0,S1
        VSTR     S0,[R7, #+60]
        VLDR     S0,[R5, #+16]
        VLDR.W   S1,??DataTable201_4  ;; 0x42f00000
        VDIV.F32 S0,S0,S1
        VSTR     S0,[SP, #+0]
        ADD      R1,SP,#+0
        ADD      R0,R7,#+60
          CFI FunCall _Z21do_blocking_move_to_zRKfS0_
        BL       _Z21do_blocking_move_to_zRKfS0_
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
        MOVS     R0,#+167
        ADDW     R1,R4,#+3320
        STRB     R0,[R1, #+24]
          CFI FunCall _Z9gcode_M24v
        BL       _Z9gcode_M24v
        POP      {R0-R2,R4-R7,PC}  ;; return
          CFI EndBlock cfiBlock176

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable198:
        DC32     0x4240029c

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock177 Using cfiCommon0
          CFI Function _ZN7MKS_DLP10quick_stopEv
        THUMB
// __interwork __softfp void MKS_DLP::quick_stop()
_ZN7MKS_DLP10quick_stopEv:
        MOVS     R1,#+1
        STRB     R1,[R0, #+753]
          CFI FunCall _Z17quickstop_stepperv
        B.W      _Z17quickstop_stepperv
          CFI EndBlock cfiBlock177

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock178 Using cfiCommon0
          CFI Function _ZN7MKS_DLP16TFT_display_testEv
        THUMB
// __interwork __softfp void MKS_DLP::TFT_display_test()
_ZN7MKS_DLP16TFT_display_testEv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        SUB      SP,SP,#+8
          CFI CFA R13+16
        LDR.W    R4,??DataTable210_1
        MOV      R2,#+8192
        MOVS     R1,#+85
        MOV      R0,R4
          CFI FunCall memset
        BL       memset
        MOVS     R0,#+180
        STR      R0,[SP, #+0]
        MOV      R3,#+320
        MOVS     R2,#+20
        MOVS     R1,#+80
        MOV      R0,R4
          CFI FunCall layer_pic_display
        BL       layer_pic_display
        MOVS     R0,#+2
          CFI FunCall exposure_msg_display
        BL       exposure_msg_display
??TFT_display_test_0:
          CFI FunCall _Z4idlev
        BL       _Z4idlev
        B.N      ??TFT_display_test_0
          CFI EndBlock cfiBlock178

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock179 Using cfiCommon0
          CFI Function _ZN7MKS_DLP23draw_return_printing_uiEv
        THUMB
// __interwork __softfp void MKS_DLP::draw_return_printing_ui()
_ZN7MKS_DLP23draw_return_printing_uiEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall display_print_statue
        BL       display_print_statue
          CFI FunCall setProBarRate
        BL       setProBarRate
          CFI FunCall GUI_Exec
        BL       GUI_Exec
        LDR.N    R0,??DataTable201_2
        LDRB     R0,[R0, #+2988]
        CMP      R0,#+0
        BEQ.N    ??draw_return_printing_ui_0
        MOVS     R0,#+180
        STR      R0,[SP, #+0]
        MOV      R3,#+320
        MOVS     R2,#+15
        MOVS     R1,#+30
        LDR.W    R0,??DataTable210_1
          CFI FunCall layer_pic_display
        BL       layer_pic_display
??draw_return_printing_ui_0:
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock179

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock180 Using cfiCommon0
          CFI Function _ZN7MKS_DLP13draw_printingEv
        THUMB
// __interwork __softfp void MKS_DLP::draw_printing()
_ZN7MKS_DLP13draw_printingEv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.W    R4,??DataTable210_2
        LDRB     R1,[R4, #+3255]
        CMP      R1,#+1
        BNE.N    ??draw_printing_0
          CFI FunCall _ZN7MKS_DLP8getHead1Ev
        BL       _ZN7MKS_DLP8getHead1Ev
        B.N      ??draw_printing_1
??draw_printing_0:
          CFI FunCall _ZN7MKS_DLP22get_cbddlp_file_headerEv
        BL       _ZN7MKS_DLP22get_cbddlp_file_headerEv
??draw_printing_1:
          CFI FunCall draw_status_clear
        BL       draw_status_clear
          CFI FunCall display_print_statue
        BL       display_print_statue
          CFI FunCall setProBarRate
        BL       setProBarRate
          CFI FunCall GUI_Exec
        BL       GUI_Exec
        MOVS     R1,#+0
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10CardReader8setIndexEl
        B.W      _ZN10CardReader8setIndexEl
          CFI EndBlock cfiBlock180

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable201:
        DC32     gCfgItems

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable201_1:
        DC32     0x4242028c

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable201_2:
        DC32     card

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable201_3:
        DC32     0x3fe00000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable201_4:
        DC32     0x42f00000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable201_5:
        DC32     print_time

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable201_6:
        DC32     axis_relative_modes

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable201_7:
        DC32     mksCfg

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
card:
        DS8 2500
// __absolute MKS_DLP mksdlp
mksdlp:
        DS8 756
// __absolute DATA_REPRINT_ITMES mksReprint
mksReprint:
        DS8 216
// __absolute cbddlp_file_head_t cbddlp_file_header
cbddlp_file_header:
        DS8 112
print_job_timer:
        DS8 16
// __absolute uint8_t Line_Pixel[1536]
Line_Pixel:
        DS8 1536

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
injected_commands_P:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
fanSpeeds:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
serial_count:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
wifi_read_count:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
previous_cmd_ms:
        DS8 4
        DS8 4
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
cartes:
        DS8 12

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvE18serial_line_buffer
_ZZ19get_serial_commandsvE18serial_line_buffer:
        DS8 96

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
        SECTION_GROUP _ZZ19get_serial_commandsvE19serial_comment_mode
_ZZ19get_serial_commandsvE19serial_comment_mode:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvE14last_wait_time
_ZZ19get_serial_commandsvE14last_wait_time:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ17get_wifi_commandsvE16wifi_line_buffer
_ZZ17get_wifi_commandsvE16wifi_line_buffer:
        DS8 96

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
        SECTION_GROUP _ZZ17get_wifi_commandsvE17wifi_comment_mode
_ZZ17get_wifi_commandsvE17wifi_comment_mode:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
wifi_init_state:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
// __absolute uint8_t continue_print_error_flg
continue_print_error_flg:
        DS8 1
// __absolute MKS_PRINTER_STATE volatile ctemp
ctemp:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
// __absolute uint32_t t1
t1:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
// __absolute uint32_t t2
t2:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
// __absolute char t12[10]
t12:
        DS8 12

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
// __absolute uint8_t Line_Pixel_TFT[180]
Line_Pixel_TFT:
        DS8 180

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
// __absolute print_parameters print_para
print_para:
        DS8 60

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
// __absolute layer_definition layer_def
layer_def:
        DS8 36

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
// __absolute preview_pic_def preview_pic1
preview_pic1:
        DS8 16
// __absolute preview_pic_def preview_pic2
preview_pic2:
        DS8 16

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock181 Using cfiCommon0
          CFI Function _ZN7MKS_DLP22get_cbddlp_file_headerEv
        THUMB
// __interwork __softfp void MKS_DLP::get_cbddlp_file_header()
_ZN7MKS_DLP22get_cbddlp_file_headerEv:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        VPUSH    {D8-D9}
          CFI D9 Frame(CFA, -32)
          CFI D8 Frame(CFA, -40)
          CFI CFA R13+40
        SUB      SP,SP,#+16
          CFI CFA R13+56
        MOV      R6,R0
        LDR.W    R4,??DataTable210_2
        MOVS     R2,#+4
        ADD      R1,SP,#+4
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        MOVS     R2,#+4
        ADD      R1,SP,#+4
        ADD      R0,R4,#+3472
          CFI FunCall memcpy
        BL       memcpy
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+0]
        STR      R0,[R4, #+3476]
        MOVS     R2,#+4
        ADD      R1,SP,#+8
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        ADDW     R7,R4,#+3476
        LDR      R0,[SP, #+8]
        STR      R0,[R7, #+4]
        MOVS     R2,#+4
        ADD      R1,SP,#+8
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+8]
        STR      R0,[R7, #+8]
        MOVS     R2,#+4
        ADD      R1,SP,#+8
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+8]
        STR      R0,[R7, #+12]
        MOVS     R2,#+4
        ADD      R1,SP,#+4
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        MOVS     R2,#+4
        ADD      R1,SP,#+4
        ADDW     R0,R4,#+3492
          CFI FunCall memcpy
        BL       memcpy
        MOVS     R2,#+4
        ADD      R1,SP,#+4
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        MOVS     R2,#+4
        ADD      R1,SP,#+4
        ADDW     R0,R4,#+3496
          CFI FunCall memcpy
        BL       memcpy
        MOVS     R2,#+4
        ADD      R1,SP,#+4
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        MOVS     R2,#+4
        ADD      R1,SP,#+4
        ADDW     R0,R4,#+3500
          CFI FunCall memcpy
        BL       memcpy
        MOVS     R2,#+4
        ADD      R1,SP,#+8
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+8]
        STR      R0,[R7, #+28]
        MOVS     R2,#+4
        ADD      R1,SP,#+8
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+8]
        STR      R0,[R7, #+32]
        MOVS     R2,#+4
        ADD      R1,SP,#+8
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+8]
        STR      R0,[R7, #+36]
        MOVS     R2,#+4
        ADD      R1,SP,#+8
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+8]
        STR      R0,[R7, #+40]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+0]
        STR      R0,[R7, #+44]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+0]
        STR      R0,[R7, #+48]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+0]
        STR      R0,[R7, #+52]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+0]
        STR      R0,[R7, #+56]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+0]
        STR      R0,[R7, #+60]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+0]
        STR      R0,[R7, #+64]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+0]
        STR      R0,[R7, #+68]
        LDR      R0,[R4, #+3476]
        CMP      R0,#+2
        BLT.N    ??get_cbddlp_file_header_0
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+0]
        STR      R0,[R7, #+72]
??get_cbddlp_file_header_0:
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+0]
        STR      R0,[R7, #+76]
        LDR      R0,[R4, #+3476]
        CMP      R0,#+2
        BLT.N    ??get_cbddlp_file_header_1
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+0]
        STR      R0,[R7, #+80]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+0]
        STR      R0,[R7, #+84]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+0]
        STR      R0,[R7, #+88]
        MOVS     R2,#+2
        ADD      R1,SP,#+4
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        ADD      R5,SP,#+4
        LDRB     R0,[R5, #+1]
        LDRB     R1,[SP, #+4]
        ORR      R0,R1,R0, LSL #+8
        STRH     R0,[R4, #+3568]
        MOVS     R2,#+2
        ADD      R1,SP,#+4
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R0,[R5, #+1]
        LDRB     R1,[SP, #+4]
        ORR      R0,R1,R0, LSL #+8
        STRH     R0,[R4, #+3570]
??get_cbddlp_file_header_1:
        MOVS     R2,#+4
        ADD      R1,SP,#+4
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        MOVS     R2,#+4
        ADD      R1,SP,#+4
        ADDW     R0,R4,#+3572
          CFI FunCall memcpy
        BL       memcpy
        MOVS     R2,#+4
        ADD      R1,SP,#+4
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        MOVS     R2,#+4
        ADD      R1,SP,#+4
        ADDW     R0,R4,#+3576
          CFI FunCall memcpy
        BL       memcpy
        MOVS     R2,#+4
        ADD      R1,SP,#+4
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        MOVS     R2,#+4
        ADD      R1,SP,#+4
        ADDW     R0,R4,#+3580
          CFI FunCall memcpy
        BL       memcpy
        LDR      R0,[R7, #+44]
        STRH     R0,[R6, #+52]
        LDR      R0,[R7, #+64]
        STRH     R0,[R6, #+12]
        LDR      R0,[R7, #+28]
        STR      R0,[R6, #+36]
        VLDR.W   S0,??DataTable204_2  ;; 0x447a0000
        VLDR     S1,[R7, #+32]
        VMUL.F32 S1,S1,S0
        VCVT.U32.F32 S1,S1
        VSTR     S1,[R6, #+40]
        VLDR     S1,[R7, #+40]
        VMUL.F32 S1,S1,S0
        VCVT.U32.F32 S1,S1
        VSTR     S1,[R6, #+44]
        VLDR     S1,[R7, #+36]
        VMUL.F32 S0,S1,S0
        VCVT.U32.F32 S0,S0
        VSTR     S0,[R6, #+48]
        LDR      R0,[R7, #+88]
        CMP      R0,#+5
        BLT.N    ??get_cbddlp_file_header_2
        MOVS     R0,#+4
        STR      R0,[R7, #+88]
??get_cbddlp_file_header_2:
        LDR      R8,[R7, #+88]
        CMP      R8,#+2
        BLT.N    ??get_cbddlp_file_header_3
        VLDR.W   D8,??DataTable204_3
        VLDR.W   D9,??DataTable204_5
        LDR      R0,[R7, #+32]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        VMOV     R2,R3,D9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R4,R0
        MOV      R5,R1
        MOV      R0,R8
          CFI FunCall __aeabi_i2d
        BL       __aeabi_i2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
        MOV      R1,R5
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        VMOV     R2,R3,D8
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall __aeabi_d2uiz
        BL       __aeabi_d2uiz
        STR      R0,[R6, #+56]
        LDR      R0,[R7, #+36]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        VMOV     R2,R3,D9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R4,R0
        MOV      R5,R1
        LDR      R0,[R7, #+88]
          CFI FunCall __aeabi_i2d
        BL       __aeabi_i2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
        MOV      R1,R5
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        VMOV     R2,R3,D8
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall __aeabi_d2uiz
        BL       __aeabi_d2uiz
        STR      R0,[R6, #+60]
        B.N      ??get_cbddlp_file_header_4
??get_cbddlp_file_header_3:
        LDR      R0,[R6, #+40]
        STR      R0,[R6, #+56]
        LDR      R0,[R6, #+48]
        STR      R0,[R6, #+60]
??get_cbddlp_file_header_4:
        ADD      SP,SP,#+16
          CFI CFA R13+40
        VPOP     {D8-D9}
          CFI D8 SameValue
          CFI D9 SameValue
          CFI CFA R13+24
        POP      {R4-R8,PC}       ;; return
          CFI EndBlock cfiBlock181

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock182 Using cfiCommon0
          CFI Function _ZN7MKS_DLP24get_cbddlp_preview1_infoEv
        THUMB
// __interwork __softfp void MKS_DLP::get_cbddlp_preview1_info()
_ZN7MKS_DLP24get_cbddlp_preview1_infoEv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.W    R4,??DataTable210_2
        LDR      R1,[R4, #+3532]
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8setIndexEl
        BL       _ZN10CardReader8setIndexEl
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR.W    R5,??DataTable210_3
        LDR      R0,[SP, #+0]
        STR      R0,[R5, #+0]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+0]
        STR      R0,[R5, #+4]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+0]
        STR      R0,[R5, #+8]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+0]
        STR      R0,[R5, #+12]
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock182

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock183 Using cfiCommon0
          CFI Function _ZN7MKS_DLP24get_cbddlp_preview2_infoEv
        THUMB
// __interwork __softfp void MKS_DLP::get_cbddlp_preview2_info()
_ZN7MKS_DLP24get_cbddlp_preview2_infoEv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.W    R4,??DataTable210_2
        LDR      R1,[R4, #+3544]
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8setIndexEl
        BL       _ZN10CardReader8setIndexEl
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR.W    R5,??DataTable210_3
        LDR      R0,[SP, #+0]
        STR      R0,[R5, #+16]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+0]
        STR      R0,[R5, #+20]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+0]
        STR      R0,[R5, #+24]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+0]
        STR      R0,[R5, #+28]
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock183

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable204:
        DC32     gArrayGpioPin

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable204_1:
        DC32     gArrayGpioPort

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable204_2:
        DC32     0x447a0000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable204_3:
        DC32     0x0,0x3FE00000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable204_4:
        DC32     0x424082b4

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable204_5:
        DC32     0x0,0x408F4000

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock184 Using cfiCommon0
          CFI Function get_pic_display
        THUMB
// __interwork __softfp void get_pic_display(uint8_t)
get_pic_display:
        PUSH     {R0,R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        SUB      SP,SP,#+4032
          CFI CFA R13+4072
        MOVS     R4,#+0
        MOV      R5,R4
        MOV      R6,R4
        MOV      R7,R4
        MOV      R8,R4
        LDR.W    R10,??DataTable210_3
        CMP      R0,#+1
        BNE.N    ??get_pic_display_0
        MOV      R9,#+290
        VLDR     S0,[R10, #0]
        VCVT.F32.S32 S1,S0
        VLDR.W   S2,??DataTable207  ;; 0x43910000
        VDIV.F32 S1,S1,S2
        VSTR     S1,[SP, #+12]
        VLDR     S1,[R10, #+4]
        VCVT.F32.S32 S1,S1
        VDIV.F32 S1,S1,S2
        VSTR     S1,[SP, #+8]
        VSTR     S0,[SP, #+0]
        LDR      R1,[R10, #+8]
        LDR      R0,[R10, #+12]
        STR      R0,[SP, #+20]
        LDR      R0,[SP, #+0]
        CMP      R0,#+500
        BLT.N    ??get_pic_display_1
        VLDR     S0,[R10, #+16]
        VCVT.F32.S32 S1,S0
        VDIV.F32 S1,S1,S2
        VSTR     S1,[SP, #+12]
        VLDR     S1,[R10, #+20]
        VCVT.F32.S32 S1,S1
        VDIV.F32 S1,S1,S2
        VSTR     S1,[SP, #+8]
        VSTR     S0,[SP, #+0]
        LDR      R1,[R10, #+24]
        LDR      R0,[R10, #+28]
        STR      R0,[SP, #+20]
??get_pic_display_1:
        LDR      R0,[SP, #+0]
        CMP      R0,#+500
        BLT.N    ??get_pic_display_2
        MOV      R0,#+500
        STR      R0,[SP, #+0]
        B.N      ??get_pic_display_2
??get_pic_display_0:
        MOV      R2,#+32768
        MOV      R1,R4
        LDR.W    R0,??DataTable210_4
          CFI FunCall memset
        BL       memset
        MOV      R9,#+116
        VLDR     S0,[R10, #+16]
        VCVT.F32.S32 S1,S0
        VLDR.W   S2,??DataTable207_1  ;; 0x42e80000
        VDIV.F32 S1,S1,S2
        VSTR     S1,[SP, #+12]
        VLDR     S1,[R10, #+20]
        VCVT.F32.S32 S1,S1
        VDIV.F32 S1,S1,S2
        VSTR     S1,[SP, #+8]
        VSTR     S0,[SP, #+0]
        LDR      R1,[R10, #+24]
        LDR      R0,[R10, #+28]
        STR      R0,[SP, #+20]
        LDR      R0,[SP, #+0]
        CMP      R0,#+500
        BLT.N    ??get_pic_display_2
        MOV      R0,#+500
        STR      R0,[SP, #+0]
??get_pic_display_2:
        LDR.W    R0,??DataTable210_2
          CFI FunCall _ZN10CardReader8setIndexEl
        BL       _ZN10CardReader8setIndexEl
        MOV      R10,R4
        B.N      ??get_pic_display_3
??get_pic_display_4:
        LDR      R0,[SP, #+16]
        ADD      R10,R0,#+1
??get_pic_display_3:
        LDR      R0,[SP, #+20]
        CMP      R10,R0
        BGE.W    ??get_pic_display_5
        MOVS     R2,#+2
        ADD      R1,SP,#+4
        LDR.W    R0,??DataTable210_2
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        ADD      R0,R10,#+1
        STR      R0,[SP, #+16]
        ADD      R11,SP,#+4
        LDRB     R0,[SP, #+4]
        LDRB     R1,[R11, #+1]
        ORR      R0,R0,R1, LSL #+8
        STR      R0,[SP, #+24]
        MOV      R10,#+1
        LSLS     R0,R0,#+26
        BPL.N    ??get_pic_display_6
        MOVS     R2,#+2
        ADD      R1,SP,#+4
        LDR.W    R0,??DataTable210_2
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R0,[SP, #+4]
        LDRB     R1,[R11, #+1]
        AND      R1,R1,#0xF
        ORR      R0,R0,R1, LSL #+8
        ADD      R10,R0,#+1
        LDR      R0,[SP, #+16]
        ADDS     R0,R0,#+2
        STR      R0,[SP, #+16]
        B.N      ??get_pic_display_6
??get_pic_display_7:
        VMOV     S0,R1
        VCVT.F32.S32 S0,S0
        VLDR     S1,[SP, #+12]
        VMUL.F32 S0,S0,S1
        VCVT.S32.F32 S0,S0
        VMOV     R0,S0
        LDR      R0,[R11, R0, LSL #+2]
        ADD      R2,SP,#+28
        STR      R0,[R2, R1, LSL #+2]
        LDR.W    R2,??DataTable210_4
        STRB     R0,[R8, R2]
        ADD      R3,R8,#+1
        ASRS     R0,R0,#+8
        STRB     R0,[R3, R2]
        ADD      R8,R3,#+1
        ADDS     R1,R1,#+1
??get_pic_display_8:
        CMP      R1,R9
        BLT.N    ??get_pic_display_7
        ADDS     R7,R7,#+1
        VMOV     S0,R7
        VCVT.F32.S32 S0,S0
        VLDR     S1,[SP, #+8]
        VMUL.F32 S0,S0,S1
        VCVT.S32.F32 S0,S0
        VMOV     R6,S0
??get_pic_display_9:
        CMP      R6,R5
        BEQ.N    ??get_pic_display_10
??get_pic_display_11:
        ADDS     R5,R5,#+1
??get_pic_display_12:
        SUB      R10,R10,#+1
??get_pic_display_6:
        CMP      R10,#+1
        BLT.N    ??get_pic_display_4
        MOVW     R11,#+2028
        ADD      R11,R11,SP
        LDR      R0,[SP, #+24]
        STR      R0,[R11, R4, LSL #+2]
        ADDS     R4,R4,#+1
        LDR      R0,[SP, #+0]
        CMP      R4,R0
        BNE.N    ??get_pic_display_12
        MOVS     R4,#+0
        CMP      R6,R5
        BNE.N    ??get_pic_display_11
??get_pic_display_10:
        LDRB     R0,[SP, #+4032]
        CMP      R0,#+1
        BNE.N    ??get_pic_display_13
        MOV      R0,R4
        ADD      R2,SP,#+28
        B.N      ??get_pic_display_14
??get_pic_display_15:
        VMOV     S0,R0
        VCVT.F32.S32 S0,S0
        VLDR     S1,[SP, #+12]
        VMUL.F32 S0,S0,S1
        VCVT.S32.F32 S0,S0
        VMOV     R1,S0
        LDR      R1,[R11, R1, LSL #+2]
        STR      R1,[R2, R0, LSL #+2]
        ADDS     R0,R0,#+1
??get_pic_display_14:
        CMP      R0,R9
        BLT.N    ??get_pic_display_15
        MOVS     R3,#+1
        MOV      R2,R9
        ADD      R1,R7,#+15
        UXTH     R1,R1
        MOVS     R0,#+40
          CFI FunCall LCD_setWindowArea
        BL       LCD_setWindowArea
          CFI FunCall LCD_WriteRAM_Prepare
        BL       LCD_WriteRAM_Prepare
        MOV      R6,R4
        B.N      ??get_pic_display_16
??get_pic_display_17:
        ADD      R0,SP,#+28
        LDR      R0,[R0, R6, LSL #+2]
        UXTH     R0,R0
          CFI FunCall LCD_WriteRAM
        BL       LCD_WriteRAM
        ADDS     R6,R6,#+1
??get_pic_display_16:
        CMP      R6,R9
        BLT.N    ??get_pic_display_17
        ADDS     R7,R7,#+1
        VMOV     S0,R7
        VCVT.F32.S32 S0,S0
        VLDR     S1,[SP, #+8]
        VMUL.F32 S0,S0,S1
        VCVT.S32.F32 S0,S0
        VMOV     R6,S0
        B.N      ??get_pic_display_9
??get_pic_display_13:
        MOV      R1,R4
        B.N      ??get_pic_display_8
??get_pic_display_5:
        LDR.N    R0,??DataTable210_2
          CFI FunCall _ZN10CardReader14close_CBD_FileEv
        BL       _ZN10CardReader14close_CBD_FileEv
        ADDW     SP,SP,#+4036
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
          CFI EndBlock cfiBlock184

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable205:
        DC32     _ZN7Stepper23cleaning_buffer_counterE

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock185 Using cfiCommon0
          CFI Function get_pic_info
        THUMB
// __interwork __softfp void get_pic_info(char *)
get_pic_info:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R4,??DataTable210_2
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader13open_CBD_FileEPc
        BL       _ZN10CardReader13open_CBD_FileEPc
        CMP      R0,#+0
        BEQ.N    ??get_pic_info_0
        ADDW     R4,R4,#+2500
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP22get_cbddlp_file_headerEv
        BL       _ZN7MKS_DLP22get_cbddlp_file_headerEv
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP24get_cbddlp_preview1_infoEv
        BL       _ZN7MKS_DLP24get_cbddlp_preview1_infoEv
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7MKS_DLP24get_cbddlp_preview2_infoEv
        B.N      _ZN7MKS_DLP24get_cbddlp_preview2_infoEv
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??get_pic_info_0:
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock185

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock186 Using cfiCommon0
          CFI Function _ZN7MKS_DLP26get_cbddlp_print_para_infoEv
        THUMB
// __interwork __softfp void MKS_DLP::get_cbddlp_print_para_info()
_ZN7MKS_DLP26get_cbddlp_print_para_infoEv:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        SUB      SP,SP,#+12
          CFI CFA R13+24
        LDR.N    R4,??DataTable210_2
        LDR      R1,[R4, #+3556]
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8setIndexEl
        BL       _ZN10CardReader8setIndexEl
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR.N    R5,??DataTable210_5
        LDR      R0,[SP, #+0]
        STR      R0,[R5, #+0]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+0]
        STR      R0,[R5, #+4]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+0]
        STR      R0,[R5, #+8]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+0]
        STR      R0,[R5, #+12]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+0]
        STR      R0,[R5, #+16]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+0]
        STR      R0,[R5, #+20]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+0]
        STR      R0,[R5, #+24]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+0]
        STR      R0,[R5, #+28]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+0]
        STR      R0,[R5, #+32]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+0]
        STR      R0,[R5, #+36]
        MOVS     R2,#+4
        ADD      R1,SP,#+4
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+4]
        STR      R0,[R5, #+40]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+0]
        STR      R0,[R5, #+44]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+0]
        STR      R0,[R5, #+48]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+0]
        STR      R0,[R5, #+52]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+0]
        STR      R0,[R5, #+56]
        POP      {R0-R2,R4,R5,PC}  ;; return
          CFI EndBlock cfiBlock186

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable207:
        DC32     0x43910000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable207_1:
        DC32     0x42e80000

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock187 Using cfiCommon0
          CFI Function _ZN7MKS_DLP24get_cbddlp_cur_layer_defEj
        THUMB
// __interwork __softfp void MKS_DLP::get_cbddlp_cur_layer_def(uint32_t)
_ZN7MKS_DLP24get_cbddlp_cur_layer_defEj:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        SUB      SP,SP,#+44
          CFI CFA R13+56
        LDR.N    R4,??DataTable210_2
        LDR      R0,[R4, #+3536]
        ADD      R2,R1,R1, LSL #+3
        ADD      R1,R0,R2, LSL #+2
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8setIndexEl
        BL       _ZN10CardReader8setIndexEl
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR.N    R5,??DataTable210_6
        LDR      R0,[SP, #+0]
        STR      R0,[R5, #+0]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+0]
        STR      R0,[R5, #+4]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+0]
        STR      R0,[R5, #+8]
        MOVS     R2,#+4
        ADD      R1,SP,#+4
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+4]
        STR      R0,[R5, #+12]
        MOVS     R2,#+4
        ADD      R1,SP,#+4
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDR      R0,[SP, #+4]
        STR      R0,[R5, #+16]
        MOVS     R2,#+4
        ADD      R1,SP,#+8
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        MOVS     R2,#+4
        ADD      R1,SP,#+8
        ADD      R0,R5,#+20
          CFI FunCall memcpy
        BL       memcpy
        MOVS     R2,#+4
        ADD      R1,SP,#+8
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        MOVS     R2,#+4
        ADD      R1,SP,#+8
        ADD      R0,R5,#+24
          CFI FunCall memcpy
        BL       memcpy
        MOVS     R2,#+4
        ADD      R1,SP,#+8
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        MOVS     R2,#+4
        ADD      R1,SP,#+8
        ADD      R0,R5,#+28
          CFI FunCall memcpy
        BL       memcpy
        MOVS     R2,#+4
        ADD      R1,SP,#+8
        MOV      R0,R4
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        MOVS     R2,#+4
        ADD      R1,SP,#+8
        ADD      R0,R5,#+32
          CFI FunCall memcpy
        BL       memcpy
        ADD      SP,SP,#+44
          CFI CFA R13+12
        POP      {R4,R5,PC}       ;; return
          CFI EndBlock cfiBlock187

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock188 Using cfiCommon0
          CFI Function _ZN7MKS_DLP18startFileprint_cbdEv
        THUMB
// __interwork __softfp void MKS_DLP::startFileprint_cbd()
_ZN7MKS_DLP18startFileprint_cbdEv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
        LDR.N    R0,??DataTable210_7
          CFI FunCall _ZN7SSD28284initEv
        BL       _ZN7SSD28284initEv
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP22get_cbddlp_file_headerEv
        BL       _ZN7MKS_DLP22get_cbddlp_file_headerEv
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP24get_cbddlp_preview1_infoEv
        BL       _ZN7MKS_DLP24get_cbddlp_preview1_infoEv
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP24get_cbddlp_preview2_infoEv
        BL       _ZN7MKS_DLP24get_cbddlp_preview2_infoEv
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP26get_cbddlp_print_para_infoEv
        BL       _ZN7MKS_DLP26get_cbddlp_print_para_infoEv
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP23clean_Information_layerEv
        BL       _ZN7MKS_DLP23clean_Information_layerEv
        MOV      R0,R4
          CFI FunCall _ZN7MKS_DLP11status_initEv
        BL       _ZN7MKS_DLP11status_initEv
          CFI FunCall draw_status_clear
        BL       draw_status_clear
          CFI FunCall display_print_statue
        BL       display_print_statue
          CFI FunCall GUI_Exec
        BL       GUI_Exec
        ADR.W    R0,`?<Constant "G28 Z0">`
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z7mks_G28Pc
        B.W      _Z7mks_G28Pc
          CFI EndBlock cfiBlock188

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock189 Using cfiCommon0
          CFI Function _ZN7MKS_DLP21decode_layer_from_rleEjh
        THUMB
// __interwork __softfp void MKS_DLP::decode_layer_from_rle(uint32_t, uint8_t)
_ZN7MKS_DLP21decode_layer_from_rleEjh:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
        SUB      SP,SP,#+12
          CFI CFA R13+48
        MOV      R4,R2
          CFI FunCall _ZN7MKS_DLP24get_cbddlp_cur_layer_defEj
        BL       _ZN7MKS_DLP24get_cbddlp_cur_layer_defEj
        LDR.N    R5,??DataTable210_2
        LDR.N    R0,??DataTable210_6
        LDR      R1,[R0, #+12]
        MOV      R0,R5
          CFI FunCall _ZN10CardReader8setIndexEl
        BL       _ZN10CardReader8setIndexEl
        ADDW     R0,R5,#+3600
        STR      R0,[SP, #+0]
        MOV      R2,#+1536
        MOVS     R1,#+0
          CFI FunCall memset
        BL       memset
        CMP      R4,#+0
        BEQ.N    ??decode_layer_from_rle_0
        BNE.N    ??decode_layer_from_rle_1
??decode_layer_from_rle_0:
        MOV      R2,#+7360
        MOVS     R1,#+0
        LDR.N    R0,??DataTable210_1
          CFI FunCall memset
        BL       memset
??decode_layer_from_rle_1:
        MOVS     R0,#+0
        STRH     R0,[R5, #+2574]
        LDR      R6,[SP, #+0]
        MOV      R7,R0
        MOV      R8,R0
        B.N      ??decode_layer_from_rle_2
??decode_layer_from_rle_3:
        STRB     R9,[R6], #+1
        ADDS     R7,R7,#+1
        ADDS     R0,R0,#+1
??decode_layer_from_rle_4:
        CMP      R0,R1
        BLT.N    ??decode_layer_from_rle_3
??decode_layer_from_rle_5:
        ADD      R8,R8,#+1
??decode_layer_from_rle_2:
        LDR.N    R0,??DataTable210_6
        LDR      R0,[R0, #+16]
        CMP      R8,R0
        BGE.N    ??decode_layer_from_rle_6
        MOVS     R2,#+1
        ADD      R1,SP,#+4
        MOV      R0,R5
          CFI FunCall _ZN10CardReader4getsEPhj
        BL       _ZN10CardReader4getsEPhj
        LDRB     R0,[SP, #+4]
        LSR      R9,R0,#+7
        AND      R10,R0,#0x7F
        MOV      R11,#+0
        B.N      ??decode_layer_from_rle_7
??decode_layer_from_rle_8:
        ADD      R11,R11,#+1
??decode_layer_from_rle_7:
        CMP      R11,R10
        BGE.N    ??decode_layer_from_rle_5
        UXTH     R7,R7
        CMP      R7,#+720
        BGE.N    ??decode_layer_from_rle_9
        STRB     R9,[R6, #+0]
        B.N      ??decode_layer_from_rle_10
??decode_layer_from_rle_9:
        STRB     R9,[R6, #+48]
??decode_layer_from_rle_10:
        ADDS     R6,R6,#+1
        ADDS     R7,R7,#+1
        LDR      R0,[R5, #+3524]
        UXTH     R7,R7
        CMP      R0,R7
        BGE.N    ??decode_layer_from_rle_8
        ADDW     R6,R5,#+2500
        MOV      R2,R4
        LDRH     R1,[R5, #+2574]
        MOV      R0,R6
          CFI FunCall _ZN7MKS_DLP13line_gen_dataEth
        BL       _ZN7MKS_DLP13line_gen_dataEth
        CMP      R4,#+0
        BEQ.N    ??decode_layer_from_rle_11
        BNE.N    ??decode_layer_from_rle_12
??decode_layer_from_rle_11:
        LDRH     R1,[R5, #+2574]
        MOV      R0,R6
          CFI FunCall _ZN7MKS_DLP17line_gen_data_TFTEt
        BL       _ZN7MKS_DLP17line_gen_data_TFTEt
??decode_layer_from_rle_12:
        LDRH     R0,[R5, #+2574]
        ADDS     R0,R0,#+1
        STRH     R0,[R5, #+2574]
        MOVS     R7,#+0
        MOV      R2,#+1536
        MOV      R1,R7
        LDR      R0,[SP, #+0]
          CFI FunCall memset
        BL       memset
        LDR      R6,[SP, #+0]
        SUB      R1,R10,R11
        UXTB     R1,R1
        MOV      R0,R7
        B.N      ??decode_layer_from_rle_4
??decode_layer_from_rle_6:
        POP      {R0-R2,R4-R11,PC}  ;; return
          CFI EndBlock cfiBlock189

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210:
        DC32     card+0xCCC

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210_1:
        DC32     bmp_layer_buf

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210_2:
        DC32     card

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210_3:
        DC32     preview_pic1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210_4:
        DC32     bmp_public_buf

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210_5:
        DC32     print_para

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210_6:
        DC32     layer_def

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210_7:
        DC32     card+0xCB6

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "G28 Z0">`:
        DC8 "G28 Z0"
        DC8 0

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z6strchrPci
          CFI Block cfiBlock190 Using cfiCommon0
          CFI Function _Z6strchrPci
          CFI FunCall __iar_Strchr
        THUMB
// __intrinsic __nounwind __interwork __softfp char *strchr(char *, int)
_Z6strchrPci:
        B.W      __iar_Strchr
          CFI EndBlock cfiBlock190

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z7strrchrPci
          CFI Block cfiBlock191 Using cfiCommon0
          CFI Function _Z7strrchrPci
          CFI FunCall __iar_Strrchr
        THUMB
// __intrinsic __nounwind __interwork __softfp char *strrchr(char *, int)
_Z7strrchrPci:
        B.W      __iar_Strrchr
          CFI EndBlock cfiBlock191

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z6strstrPcPKc
          CFI Block cfiBlock192 Using cfiCommon0
          CFI Function _Z6strstrPcPKc
          CFI FunCall __iar_Strstr
        THUMB
// __intrinsic __nounwind __interwork __softfp char *strstr(char *, char const *)
_Z6strstrPcPKc:
        B.W      __iar_Strstr
          CFI EndBlock cfiBlock192

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z14serialprintPGMPKc
          CFI Block cfiBlock193 Using cfiCommon0
          CFI Function _Z14serialprintPGMPKc
        THUMB
// __interwork __softfp void serialprintPGM(char const *)
_Z14serialprintPGMPKc:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
        B.N      ??serialprintPGM_0
??serialprintPGM_1:
        UXTB     R1,R1
        LDR.N    R0,??serialprintPGM_2
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??serialprintPGM_0:
        LDRSB    R1,[R4], #+1
        MOVS     R0,R1
        BNE.N    ??serialprintPGM_1
        POP      {R4,PC}          ;; return
        DATA
??serialprintPGM_2:
        DC32     Serial6
          CFI EndBlock cfiBlock193

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9IsRunningv
          CFI Block cfiBlock194 Using cfiCommon0
          CFI Function _Z9IsRunningv
          CFI NoCalls
        THUMB
// __interwork __softfp bool IsRunning()
_Z9IsRunningv:
        LDR.N    R0,??IsRunning_0
        LDRB     R0,[R0, #+14]
        BX       LR               ;; return
        Nop      
        DATA
??IsRunning_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock194

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9IsStoppedv
          CFI Block cfiBlock195 Using cfiCommon0
          CFI Function _Z9IsStoppedv
          CFI NoCalls
        THUMB
// __interwork __softfp bool IsStopped()
_Z9IsStoppedv:
        LDR.N    R0,??IsStopped_0
        LDRB     R0,[R0, #+14]
        EOR      R0,R0,#0x1
        BX       LR               ;; return
        Nop      
        DATA
??IsStopped_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock195

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z19refresh_cmd_timeoutv
          CFI Block cfiBlock196 Using cfiCommon0
          CFI Function _Z19refresh_cmd_timeoutv
        THUMB
// __interwork __softfp void refresh_cmd_timeout()
_Z19refresh_cmd_timeoutv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        LDR.N    R1,??refresh_cmd_timeout_0
        STR      R0,[R1, #+0]
        POP      {R0,PC}          ;; return
        DATA
??refresh_cmd_timeout_0:
        DC32     previous_cmd_ms
          CFI EndBlock cfiBlock196

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z28set_current_from_destinationv
          CFI Block cfiBlock197 Using cfiCommon0
          CFI Function _Z28set_current_from_destinationv
        THUMB
// __interwork __softfp void set_current_from_destination()
_Z28set_current_from_destinationv:
        LDR.N    R0,??set_current_from_destination_0
        MOVS     R2,#+16
        ADD      R1,R0,#+52
        ADDS     R0,R0,#+36
          CFI FunCall memcpy
        B.W      memcpy
        Nop      
        DATA
??set_current_from_destination_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock197

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z28set_destination_from_currentv
          CFI Block cfiBlock198 Using cfiCommon0
          CFI Function _Z28set_destination_from_currentv
        THUMB
// __interwork __softfp void set_destination_from_current()
_Z28set_destination_from_currentv:
        LDR.N    R0,??set_destination_from_current_0
        MOVS     R2,#+16
        ADD      R1,R0,#+36
        ADDS     R0,R0,#+52
          CFI FunCall memcpy
        B.W      memcpy
        Nop      
        DATA
??set_destination_from_current_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock198

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z8lcd_initv
          CFI Block cfiBlock199 Using cfiCommon0
          CFI Function _Z8lcd_initv
          CFI NoCalls
        THUMB
// __interwork __softfp void lcd_init()
_Z8lcd_initv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock199

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z13lcd_hasstatusv
          CFI Block cfiBlock200 Using cfiCommon0
          CFI Function _Z13lcd_hasstatusv
          CFI NoCalls
        THUMB
// __interwork __softfp bool lcd_hasstatus()
_Z13lcd_hasstatusv:
        MOVS     R0,#+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock200

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z13lcd_setstatusPKcb
          CFI Block cfiBlock201 Using cfiCommon0
          CFI Function _Z13lcd_setstatusPKcb
          CFI NoCalls
        THUMB
// __interwork __softfp void lcd_setstatus(char const *, bool)
_Z13lcd_setstatusPKcb:
        BX       LR               ;; return
          CFI EndBlock cfiBlock201

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z16lcd_setstatusPGMPKca
          CFI Block cfiBlock202 Using cfiCommon0
          CFI Function _Z16lcd_setstatusPGMPKca
          CFI NoCalls
        THUMB
// __interwork __softfp void lcd_setstatusPGM(char const *, int8_t)
_Z16lcd_setstatusPGMPKca:
        BX       LR               ;; return
          CFI EndBlock cfiBlock202

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z21lcd_setalertstatusPGMPKc
          CFI Block cfiBlock203 Using cfiCommon0
          CFI Function _Z21lcd_setalertstatusPGMPKc
          CFI NoCalls
        THUMB
// __interwork __softfp void lcd_setalertstatusPGM(char const *)
_Z21lcd_setalertstatusPGMPKc:
        BX       LR               ;; return
          CFI EndBlock cfiBlock203

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z21lcd_reset_alert_levelv
          CFI Block cfiBlock204 Using cfiCommon0
          CFI Function _Z21lcd_reset_alert_levelv
          CFI NoCalls
        THUMB
// __interwork __softfp void lcd_reset_alert_level()
_Z21lcd_reset_alert_levelv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock204

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z11lcd_refreshv
          CFI Block cfiBlock205 Using cfiCommon0
          CFI Function _Z11lcd_refreshv
          CFI NoCalls
        THUMB
// __interwork __softfp void lcd_refresh()
_Z11lcd_refreshv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock205

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN7Planner16refresh_e_factorEh
          CFI Block cfiBlock206 Using cfiCommon0
          CFI Function _ZN7Planner16refresh_e_factorEh
        THUMB
// __interwork __softfp void Planner::refresh_e_factor(uint8_t)
_ZN7Planner16refresh_e_factorEh:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R6,R0
        LDR.N    R0,??refresh_e_factor_0
        LDRSH    R0,[R0, R6, LSL #+1]
          CFI FunCall __aeabi_i2d
        BL       __aeabi_i2d
        LDR.N    R2,??refresh_e_factor_0+0x4  ;; 0x47ae147b
        LDR.N    R3,??refresh_e_factor_0+0x8  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R4,R0
        MOV      R5,R1
        LDR.N    R0,??refresh_e_factor_0+0xC
        LDR      R0,[R0, R6, LSL #+2]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        LDR.N    R1,??refresh_e_factor_0+0x10
        STR      R0,[R1, R6, LSL #+2]
        POP      {R4-R6,PC}       ;; return
        DATA
??refresh_e_factor_0:
        DC32     _ZN7Planner15flow_percentageE
        DC32     0x47ae147b
        DC32     0x3f847ae1
        DC32     _ZN7Planner21volumetric_multiplierE
        DC32     _ZN7Planner8e_factorE
          CFI EndBlock cfiBlock206

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN7Planner17set_filament_sizeEhRKf
          CFI Block cfiBlock207 Using cfiCommon0
          CFI Function _ZN7Planner17set_filament_sizeEhRKf
          CFI NoCalls
        THUMB
// __interwork __softfp void Planner::set_filament_size(uint8_t, float const &)
_ZN7Planner17set_filament_sizeEhRKf:
        LDR.N    R2,??set_filament_size_0
        LDR      R1,[R1, #+0]
        STR      R1,[R2, R0, LSL #+2]
        MOVS     R0,#+0
        B.N      ??set_filament_size_1
??set_filament_size_2:
        VLDR     S0,[R2, #0]
        VCMP.F32 S0,#0.0
        FMSTAT   
        BNE.N    ??set_filament_size_3
        LDR.N    R0,??set_filament_size_0+0x4  ;; 0x40400000
        STR      R0,[R2, #+0]
??set_filament_size_3:
        MOVS     R0,#+1
??set_filament_size_1:
        CMP      R0,#+0
        BEQ.N    ??set_filament_size_2
        BX       LR               ;; return
        Nop      
        DATA
??set_filament_size_0:
        DC32     _ZN7Planner13filament_sizeE
        DC32     0x40400000
          CFI EndBlock cfiBlock207

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN7Planner11buffer_lineEfffRKfS1_h
          CFI Block cfiBlock208 Using cfiCommon0
          CFI Function _ZN7Planner11buffer_lineEfffRKfS1_h
        THUMB
// __interwork __vfp void Planner::buffer_line(float, float, float, float const &, float const &, uint8_t)
_ZN7Planner11buffer_lineEfffRKfS1_h:
        PUSH     {LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+4
        VPUSH    {S0-S2}
          CFI CFA R13+16
        SUB      SP,SP,#+8
          CFI CFA R13+24
        UXTB     R2,R2
        STR      R2,[SP, #+4]
        STR      R1,[SP, #+0]
        MOV      R3,R0
        ADD      R2,SP,#+16
        ADD      R1,SP,#+12
        ADD      R0,SP,#+8
          CFI FunCall _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
        BL       _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
        ADD      SP,SP,#+20
          CFI CFA R13+4
        POP      {PC}             ;; return
          CFI EndBlock cfiBlock208

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
          CFI Block cfiBlock209 Using cfiCommon0
          CFI Function _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
        THUMB
// __interwork __softfp void Planner::buffer_line_kinematic(float const (&)[4], float const &, uint8_t)
_ZN7Planner21buffer_line_kinematicERA4_KfRS0_h:
        PUSH     {LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+4
        SUB      SP,SP,#+12
          CFI CFA R13+16
        STR      R2,[SP, #+4]
        STR      R1,[SP, #+0]
        ADD      R3,R0,#+12
        ADD      R2,R0,#+8
        ADDS     R1,R0,#+4
          CFI FunCall _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
        BL       _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
        POP      {R0-R2,PC}       ;; return
          CFI EndBlock cfiBlock209

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN7Planner15set_position_mmEfffRKf
          CFI Block cfiBlock210 Using cfiCommon0
          CFI Function _ZN7Planner15set_position_mmEfffRKf
        THUMB
// __interwork __vfp void Planner::set_position_mm(float, float, float, float const &)
_ZN7Planner15set_position_mmEfffRKf:
        PUSH     {LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+4
        VPUSH    {S0-S2}
          CFI CFA R13+16
        MOV      R3,R0
        ADD      R2,SP,#+8
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
          CFI FunCall _ZN7Planner16_set_position_mmERKfS1_S1_S1_
        BL       _ZN7Planner16_set_position_mmERKfS1_S1_S1_
        POP      {R0-R2,PC}       ;; return
          CFI EndBlock cfiBlock210

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN7Planner17set_e_position_mmERKf
          CFI Block cfiBlock211 Using cfiCommon0
          CFI Function _ZN7Planner17set_e_position_mmERKf
        THUMB
// __interwork __softfp void Planner::set_e_position_mm(float const &)
_ZN7Planner17set_e_position_mmERKf:
        MOV      R1,R0
        MOVS     R0,#+3
          CFI FunCall _ZN7Planner15set_position_mmE8AxisEnumRKf
        B.W      _ZN7Planner15set_position_mmE8AxisEnumRKf
          CFI EndBlock cfiBlock211

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN7Planner13blocks_queuedEv
          CFI Block cfiBlock212 Using cfiCommon0
          CFI Function _ZN7Planner13blocks_queuedEv
          CFI NoCalls
        THUMB
// __interwork __softfp bool Planner::blocks_queued()
_ZN7Planner13blocks_queuedEv:
        LDR.N    R0,??blocks_queued_0
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??blocks_queued_0+0x4
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BEQ.N    ??blocks_queued_1
        MOVS     R0,#+1
        BX       LR
??blocks_queued_1:
        MOVS     R0,#+0
        BX       LR               ;; return
        DATA
??blocks_queued_0:
        DC32     _ZN7Planner17block_buffer_headE
        DC32     _ZN7Planner17block_buffer_tailE
          CFI EndBlock cfiBlock212

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN8Endstops15enable_globallyEb
          CFI Block cfiBlock213 Using cfiCommon0
          CFI Function _ZN8Endstops15enable_globallyEb
          CFI NoCalls
        THUMB
// __interwork __softfp void Endstops::enable_globally(bool)
_ZN8Endstops15enable_globallyEb:
        LDR.N    R1,??enable_globally_0
        STRB     R0,[R1, #+0]
        LDR.N    R1,??enable_globally_0+0x4
        STRB     R0,[R1, #+0]
        BX       LR               ;; return
        Nop      
        DATA
??enable_globally_0:
        DC32     _ZN8Endstops7enabledE
        DC32     _ZN8Endstops16enabled_globallyE
          CFI EndBlock cfiBlock213

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN8Endstops6enableEb
          CFI Block cfiBlock214 Using cfiCommon0
          CFI Function _ZN8Endstops6enableEb
          CFI NoCalls
        THUMB
// __interwork __softfp void Endstops::enable(bool)
_ZN8Endstops6enableEb:
        LDR.N    R1,??enable_0
        STRB     R0,[R1, #+0]
        BX       LR               ;; return
        Nop      
        DATA
??enable_0:
        DC32     _ZN8Endstops7enabledE
          CFI EndBlock cfiBlock214

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN8Endstops10not_homingEv
          CFI Block cfiBlock215 Using cfiCommon0
          CFI Function _ZN8Endstops10not_homingEv
          CFI NoCalls
        THUMB
// __interwork __softfp void Endstops::not_homing()
_ZN8Endstops10not_homingEv:
        LDR.N    R0,??not_homing_0
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??not_homing_0+0x4
        STRB     R0,[R1, #+0]
        BX       LR               ;; return
        Nop      
        DATA
??not_homing_0:
        DC32     _ZN8Endstops16enabled_globallyE
        DC32     _ZN8Endstops7enabledE
          CFI EndBlock cfiBlock215

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN8Endstops14hit_on_purposeEv
          CFI Block cfiBlock216 Using cfiCommon0
          CFI Function _ZN8Endstops14hit_on_purposeEv
          CFI NoCalls
        THUMB
// __interwork __softfp void Endstops::hit_on_purpose()
_ZN8Endstops14hit_on_purposeEv:
        MOVS     R0,#+0
        LDR.N    R1,??hit_on_purpose_0
        STRB     R0,[R1, #+0]
        BX       LR               ;; return
        DATA
??hit_on_purpose_0:
        DC32     _ZN8Endstops16endstop_hit_bitsE
          CFI EndBlock cfiBlock216

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature9degHotendEh
          CFI Block cfiBlock217 Using cfiCommon0
          CFI Function _ZN11Temperature9degHotendEh
          CFI NoCalls
        THUMB
// __interwork __vfp float Temperature::degHotend(uint8_t)
_ZN11Temperature9degHotendEh:
        LDR.N    R0,??degHotend_0
        VLDR     S0,[R0, #0]
        BX       LR               ;; return
        DATA
??degHotend_0:
        DC32     _ZN11Temperature19current_temperatureE
          CFI EndBlock cfiBlock217

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature15degTargetHotendEh
          CFI Block cfiBlock218 Using cfiCommon0
          CFI Function _ZN11Temperature15degTargetHotendEh
          CFI NoCalls
        THUMB
// __interwork __vfp float Temperature::degTargetHotend(uint8_t)
_ZN11Temperature15degTargetHotendEh:
        LDR.N    R0,??degTargetHotend_0
        VLDR     S0,[R0, #0]
        VCVT.F32.S32 S0,S0
        BX       LR               ;; return
        DATA
??degTargetHotend_0:
        DC32     _ZN11Temperature18target_temperatureE
          CFI EndBlock cfiBlock218

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature15setTargetHotendEfh
          CFI Block cfiBlock219 Using cfiCommon0
          CFI Function _ZN11Temperature15setTargetHotendEfh
        THUMB
// __interwork __vfp void Temperature::setTargetHotend(float, uint8_t)
_ZN11Temperature15setTargetHotendEfh:
        VCVT.S32.F32 S0,S0
        LDR.N    R0,??setTargetHotend_0
        VSTR     S0,[R0, #0]
        MOVS     R0,#+0
          CFI FunCall _ZN11Temperature21start_watching_heaterEh
        B.W      _ZN11Temperature21start_watching_heaterEh
        DATA
??setTargetHotend_0:
        DC32     _ZN11Temperature18target_temperatureE
          CFI EndBlock cfiBlock219

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11Temperature12setTargetBedEf
          CFI Block cfiBlock220 Using cfiCommon0
          CFI Function _ZN11Temperature12setTargetBedEf
          CFI NoCalls
        THUMB
// __interwork __vfp void Temperature::setTargetBed(float)
_ZN11Temperature12setTargetBedEf:
        BX       LR               ;; return
          CFI EndBlock cfiBlock220

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature15isCoolingHotendEh
          CFI Block cfiBlock221 Using cfiCommon0
          CFI Function _ZN11Temperature15isCoolingHotendEh
          CFI NoCalls
        THUMB
// __interwork __softfp bool Temperature::isCoolingHotend(uint8_t)
_ZN11Temperature15isCoolingHotendEh:
        LDR.N    R0,??isCoolingHotend_0
        VLDR     S0,[R0, #0]
        VCVT.F32.S32 S0,S0
        LDR.N    R0,??isCoolingHotend_0+0x4
        VLDR     S1,[R0, #0]
        VCMP.F32 S0,S1
        FMSTAT   
        BPL.N    ??isCoolingHotend_1
        MOVS     R0,#+1
        BX       LR
??isCoolingHotend_1:
        MOVS     R0,#+0
        BX       LR               ;; return
        Nop      
        DATA
??isCoolingHotend_0:
        DC32     _ZN11Temperature18target_temperatureE
        DC32     _ZN11Temperature19current_temperatureE
          CFI EndBlock cfiBlock221

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11Temperature9updatePIDEv
          CFI Block cfiBlock222 Using cfiCommon0
          CFI Function _ZN11Temperature9updatePIDEv
          CFI NoCalls
        THUMB
// __interwork __softfp void Temperature::updatePID()
_ZN11Temperature9updatePIDEv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock222

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN10CardReader10isFileOpenEv
          CFI Block cfiBlock223 Using cfiCommon0
          CFI Function _ZN10CardReader10isFileOpenEv
          CFI NoCalls
        THUMB
// __interwork __softfp bool CardReader::isFileOpen()
_ZN10CardReader10isFileOpenEv:
        LDR      R0,[R0, #+512]
        CMP      R0,#+0
        BEQ.N    ??isFileOpen_0
        MOVS     R0,#+1
        BX       LR
??isFileOpen_0:
        MOVS     R0,#+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock223

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN10CardReader3eofEv
          CFI Block cfiBlock224 Using cfiCommon0
          CFI Function _ZN10CardReader3eofEv
          CFI NoCalls
        THUMB
// __interwork __softfp bool CardReader::eof()
_ZN10CardReader3eofEv:
        LDR      R1,[R0, #+1120]
        LDR      R0,[R0, #+1116]
        CMP      R1,R0
        SBCS     R0,R0,R0
        MVNS     R0,R0
        LSRS     R0,R0,#+31
        BX       LR               ;; return
          CFI EndBlock cfiBlock224

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN10CardReader4getsEPhj
          CFI Block cfiBlock225 Using cfiCommon0
          CFI Function _ZN10CardReader4getsEPhj
        THUMB
// __interwork __softfp UINT CardReader::gets(BYTE *, UINT)
_ZN10CardReader4getsEPhj:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        MOV      R5,R1
        ADD      R3,SP,#+0
          CFI FunCall f_read
        BL       f_read
        CMP      R0,#+0
        BEQ.N    ??gets_0
        MOVS     R0,#+255
        STRB     R0,[R5, #+0]
        MOV      R0,#-1
        STR      R0,[SP, #+0]
        B.N      ??gets_1
??gets_0:
        LDR      R0,[R4, #+1120]
        LDR      R1,[SP, #+0]
        ADDS     R0,R1,R0
        STR      R0,[R4, #+1120]
??gets_1:
        LDR      R0,[SP, #+0]
        POP      {R1,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock225

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN10CardReader8setIndexEl
          CFI Block cfiBlock226 Using cfiCommon0
          CFI Function _ZN10CardReader8setIndexEl
        THUMB
// __interwork __softfp void CardReader::setIndex(long)
_ZN10CardReader8setIndexEl:
        STR      R1,[R0, #+1120]
          CFI FunCall f_lseek
        B.W      f_lseek
          CFI EndBlock cfiBlock226

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN10duration_tC1ERKj
          CFI Block cfiBlock227 Using cfiCommon0
          CFI Function _ZN10duration_tC1ERKj
          CFI NoCalls
        THUMB
// __code __interwork __softfp duration_t::duration_t(uint32_t const &)
_ZN10duration_tC1ERKj:
        LDR      R1,[R1, #+0]
        STR      R1,[R0, #+0]
        BX       LR               ;; return
          CFI EndBlock cfiBlock227

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZNK10duration_t4yearEv
          CFI Block cfiBlock228 Using cfiCommon0
          CFI Function _ZNK10duration_t4yearEv
        THUMB
// __interwork __softfp uint8_t duration_t::year() const
_ZNK10duration_t4yearEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZNK10duration_t3dayEv
        BL       _ZNK10duration_t3dayEv
        MOVW     R1,#+365
        SDIV     R0,R0,R1
        UXTB     R0,R0
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock228

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZNK10duration_t3dayEv
          CFI Block cfiBlock229 Using cfiCommon0
          CFI Function _ZNK10duration_t3dayEv
        THUMB
// __interwork __softfp uint16_t duration_t::day() const
_ZNK10duration_t3dayEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZNK10duration_t4hourEv
        BL       _ZNK10duration_t4hourEv
        MOVS     R1,#+24
        UDIV     R0,R0,R1
        UXTH     R0,R0
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock229

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZNK10duration_t4hourEv
          CFI Block cfiBlock230 Using cfiCommon0
          CFI Function _ZNK10duration_t4hourEv
        THUMB
// __interwork __softfp uint32_t duration_t::hour() const
_ZNK10duration_t4hourEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZNK10duration_t6minuteEv
        BL       _ZNK10duration_t6minuteEv
        MOVS     R1,#+60
        UDIV     R0,R0,R1
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock230

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZNK10duration_t6minuteEv
          CFI Block cfiBlock231 Using cfiCommon0
          CFI Function _ZNK10duration_t6minuteEv
        THUMB
// __interwork __softfp uint32_t duration_t::minute() const
_ZNK10duration_t6minuteEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZNK10duration_t6secondEv
        BL       _ZNK10duration_t6secondEv
        MOVS     R1,#+60
        UDIV     R0,R0,R1
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock231

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZNK10duration_t6secondEv
          CFI Block cfiBlock232 Using cfiCommon0
          CFI Function _ZNK10duration_t6secondEv
          CFI NoCalls
        THUMB
// __interwork __softfp uint32_t duration_t::second() const
_ZNK10duration_t6secondEv:
        LDR      R0,[R0, #+0]
        BX       LR               ;; return
          CFI EndBlock cfiBlock232

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZNK10duration_t8toStringEPc
          CFI Block cfiBlock233 Using cfiCommon0
          CFI Function _ZNK10duration_t8toStringEPc
        THUMB
// __interwork __softfp void duration_t::toString(char *) const
_ZNK10duration_t8toStringEPc:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
        SUB      SP,SP,#+16
          CFI CFA R13+48
        MOV      R7,R0
        MOV      R4,R1
          CFI FunCall _ZNK10duration_t4yearEv
        BL       _ZNK10duration_t4yearEv
        MOV      R5,R0
        MOV      R0,R7
          CFI FunCall _ZNK10duration_t3dayEv
        BL       _ZNK10duration_t3dayEv
        MOVW     R1,#+365
        SDIV     R1,R0,R1
        MOVW     R2,#+365
        MLS      R6,R2,R1,R0
        MOV      R0,R7
          CFI FunCall _ZNK10duration_t4hourEv
        BL       _ZNK10duration_t4hourEv
        MOVS     R1,#+24
        UDIV     R1,R0,R1
        ADD      R2,R1,R1, LSL #+1
        SUB      R8,R0,R2, LSL #+3
        MOV      R0,R7
          CFI FunCall _ZNK10duration_t6minuteEv
        BL       _ZNK10duration_t6minuteEv
        MOV      R9,#+60
        MOV      R1,R9
        UDIV     R1,R0,R1
        MLS      R10,R9,R1,R0
        MOV      R0,R7
          CFI FunCall _ZNK10duration_t6secondEv
        BL       _ZNK10duration_t6secondEv
        MOV      R1,R9
        UDIV     R1,R0,R1
        MLS      R2,R9,R1,R0
        CMP      R5,#+0
        BEQ.N    ??toString_0
        STR      R2,[SP, #+8]
        STR      R10,[SP, #+4]
        STR      R8,[SP, #+0]
        MOV      R3,R6
        MOV      R2,R5
        LDR.N    R1,??toString_1
        MOV      R0,R4
          CFI FunCall sprintf
        BL       sprintf
        B.N      ??toString_2
??toString_0:
        CMP      R6,#+0
        BEQ.N    ??toString_3
        STR      R2,[SP, #+4]
        STR      R10,[SP, #+0]
        MOV      R3,R8
        MOV      R2,R6
        LDR.N    R1,??toString_1+0x4
        MOV      R0,R4
          CFI FunCall sprintf
        BL       sprintf
        B.N      ??toString_2
??toString_3:
        CMP      R8,#+0
        BEQ.N    ??toString_4
        STR      R2,[SP, #+0]
        MOV      R3,R10
        MOV      R2,R8
        LDR.N    R1,??toString_1+0x8
        MOV      R0,R4
          CFI FunCall sprintf
        BL       sprintf
        B.N      ??toString_2
??toString_4:
        CMP      R10,#+0
        BEQ.N    ??toString_5
        MOV      R3,R2
        MOV      R2,R10
        LDR.N    R1,??toString_1+0xC
        MOV      R0,R4
        ADD      SP,SP,#+16
          CFI CFA R13+32
        POP      {R4-R10,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall sprintf
        B.W      sprintf
          CFI R4 Frame(CFA, -32)
          CFI R5 Frame(CFA, -28)
          CFI R6 Frame(CFA, -24)
          CFI R7 Frame(CFA, -20)
          CFI R8 Frame(CFA, -16)
          CFI R9 Frame(CFA, -12)
          CFI R10 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+48
??toString_5:
        LDR.N    R1,??toString_1+0x10
        MOV      R0,R4
        ADD      SP,SP,#+16
          CFI CFA R13+32
        POP      {R4-R10,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall sprintf
        B.W      sprintf
          CFI R4 Frame(CFA, -32)
          CFI R5 Frame(CFA, -28)
          CFI R6 Frame(CFA, -24)
          CFI R7 Frame(CFA, -20)
          CFI R8 Frame(CFA, -16)
          CFI R9 Frame(CFA, -12)
          CFI R10 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+48
??toString_2:
        POP      {R0-R10,PC}      ;; return
        Nop      
        DATA
??toString_1:
        DC32     _ZZNK10duration_t8toStringEPcEs
        DC32     _ZZNK10duration_t8toStringEPcEs_0
        DC32     _ZZNK10duration_t8toStringEPcEs_1
        DC32     _ZZNK10duration_t8toStringEPcEs_2
        DC32     _ZZNK10duration_t8toStringEPcEs_3
          CFI EndBlock cfiBlock233

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11GCodeParser4seenEc
          CFI Block cfiBlock234 Using cfiCommon0
          CFI Function _ZN11GCodeParser4seenEc
          CFI NoCalls
        THUMB
// __interwork __softfp bool GCodeParser::seen(char)
_ZN11GCodeParser4seenEc:
        SUB      R1,R0,#+65
        UXTB     R1,R1
        CMP      R1,#+26
        BCC.N    ??seen_0
        MOVS     R0,#+0
        BX       LR
??seen_0:
        ASRS     R0,R1,#+3
        LDR.N    R2,??seen_1
        LDRB     R0,[R0, R2]
        AND      R2,R1,#0x7
        LSRS     R0,R0,R2
        ANDS     R0,R0,#0x1
        BEQ.N    ??seen_2
        LDR.N    R2,??seen_1+0x4
        LDRB     R1,[R1, R2]
        LDR.N    R2,??seen_1+0x8
        CMP      R1,#+0
        BEQ.N    ??seen_3
        LDR.N    R3,??seen_1+0xC
        LDR      R3,[R3, #+0]
        ADDS     R1,R1,R3
        STR      R1,[R2, #+0]
        BX       LR
??seen_3:
        MOVS     R1,#+0
        STR      R1,[R2, #+0]
??seen_2:
        BX       LR               ;; return
        Nop      
        DATA
??seen_1:
        DC32     _ZN11GCodeParser8codebitsE
        DC32     _ZN11GCodeParser5paramE
        DC32     _ZN11GCodeParser9value_ptrE
        DC32     _ZN11GCodeParser11command_ptrE
          CFI EndBlock cfiBlock234

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11GCodeParser9has_valueEv
          CFI Block cfiBlock235 Using cfiCommon0
          CFI Function _ZN11GCodeParser9has_valueEv
          CFI NoCalls
        THUMB
// __interwork __softfp bool GCodeParser::has_value()
_ZN11GCodeParser9has_valueEv:
        LDR.N    R0,??has_value_0
        LDR      R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??has_value_1
        MOVS     R0,#+1
        BX       LR
??has_value_1:
        MOVS     R0,#+0
        BX       LR               ;; return
        DATA
??has_value_0:
        DC32     _ZN11GCodeParser9value_ptrE
          CFI EndBlock cfiBlock235

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser7seenvalEc
          CFI Block cfiBlock236 Using cfiCommon0
          CFI Function _ZN11GCodeParser7seenvalEc
        THUMB
// __interwork __softfp bool GCodeParser::seenval(char)
_ZN11GCodeParser7seenvalEc:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??seenval_0
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN11GCodeParser9has_valueEv
        B.W      _ZN11GCodeParser9has_valueEv
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??seenval_0:
        MOVS     R0,#+0
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock236

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11GCodeParser11value_floatEv
          CFI Block cfiBlock237 Using cfiCommon0
          CFI Function _ZN11GCodeParser11value_floatEv
        THUMB
// __interwork __vfp float GCodeParser::value_float()
_ZN11GCodeParser11value_floatEv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.N    R2,??value_float_0+0x4
        LDR      R0,[R2, #+0]
        CMP      R0,#+0
        BEQ.N    ??value_float_1
        MOV      R4,R0
        B.N      ??value_float_2
??value_float_3:
        ADDS     R4,R4,#+1
??value_float_2:
        LDRSB    R5,[R4, #+0]
        CMP      R5,#+0
        BEQ.N    ??value_float_4
        CMP      R5,#+32
        BNE.N    ??value_float_5
??value_float_4:
        MOVS     R1,#+0
          CFI FunCall strtod
        BL       strtod
        VMOV     R0,R1,D0
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        VMOV     S0,R0
        POP      {R0,R4,R5,PC}
??value_float_5:
        CMP      R5,#+69
        BEQ.N    ??value_float_6
        CMP      R5,#+101
        BNE.N    ??value_float_3
??value_float_6:
        MOVS     R0,#+0
        STRB     R0,[R4, #+0]
        MOV      R1,R0
        LDR      R0,[R2, #+0]
          CFI FunCall strtod
        BL       strtod
        VMOV     R0,R1,D0
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        VMOV     S0,R0
        STRB     R5,[R4, #+0]
        POP      {R0,R4,R5,PC}
??value_float_1:
        VLDR.W   S0,??value_float_0  ;; 0x0
        POP      {R0,R4,R5,PC}    ;; return
        Nop      
        DATA
??value_float_0:
        DC32     0x0
        DC32     _ZN11GCodeParser9value_ptrE
          CFI EndBlock cfiBlock237

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11GCodeParser10value_longEv
          CFI Block cfiBlock238 Using cfiCommon0
          CFI Function _ZN11GCodeParser10value_longEv
        THUMB
// __interwork __softfp int32_t GCodeParser::value_long()
_ZN11GCodeParser10value_longEv:
        LDR.N    R0,??value_long_0
        LDR      R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??value_long_1
        MOVS     R2,#+10
        MOVS     R1,#+0
          CFI FunCall strtol
        B.W      strtol
??value_long_1:
        MOVS     R0,#+0
        BX       LR               ;; return
        DATA
??value_long_0:
        DC32     _ZN11GCodeParser9value_ptrE
          CFI EndBlock cfiBlock238

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11GCodeParser11value_ulongEv
          CFI Block cfiBlock239 Using cfiCommon0
          CFI Function _ZN11GCodeParser11value_ulongEv
        THUMB
// __interwork __softfp uint32_t GCodeParser::value_ulong()
_ZN11GCodeParser11value_ulongEv:
        LDR.N    R0,??value_ulong_0
        LDR      R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??value_ulong_1
        MOVS     R2,#+10
        MOVS     R1,#+0
          CFI FunCall strtoul
        B.W      strtoul
??value_ulong_1:
        MOVS     R0,#+0
        BX       LR               ;; return
        DATA
??value_ulong_0:
        DC32     _ZN11GCodeParser9value_ptrE
          CFI EndBlock cfiBlock239

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser12value_millisEv
          CFI Block cfiBlock240 Using cfiCommon0
          CFI Function _ZN11GCodeParser12value_millisEv
          CFI FunCall _ZN11GCodeParser11value_ulongEv
        THUMB
// __interwork __softfp millis_t GCodeParser::value_millis()
_ZN11GCodeParser12value_millisEv:
        B.W      _ZN11GCodeParser11value_ulongEv
          CFI EndBlock cfiBlock240

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11GCodeParser25value_millis_from_secondsEv
          CFI Block cfiBlock241 Using cfiCommon0
          CFI Function _ZN11GCodeParser25value_millis_from_secondsEv
        THUMB
// __interwork __softfp millis_t GCodeParser::value_millis_from_seconds()
_ZN11GCodeParser25value_millis_from_secondsEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        VLDR.W   S1,??value_millis_from_seconds_0  ;; 0x447a0000
        VMUL.F32 S0,S0,S1
        VCVT.U32.F32 S0,S0
        VMOV     R0,S0
        POP      {R1,PC}          ;; return
        DATA
??value_millis_from_seconds_0:
        DC32     0x447a0000
          CFI EndBlock cfiBlock241

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser9value_intEv
          CFI Block cfiBlock242 Using cfiCommon0
          CFI Function _ZN11GCodeParser9value_intEv
        THUMB
// __interwork __softfp int16_t GCodeParser::value_int()
_ZN11GCodeParser9value_intEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN11GCodeParser10value_longEv
        BL       _ZN11GCodeParser10value_longEv
        SXTH     R0,R0
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock242

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser12value_ushortEv
          CFI Block cfiBlock243 Using cfiCommon0
          CFI Function _ZN11GCodeParser12value_ushortEv
        THUMB
// __interwork __softfp uint16_t GCodeParser::value_ushort()
_ZN11GCodeParser12value_ushortEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN11GCodeParser10value_longEv
        BL       _ZN11GCodeParser10value_longEv
        UXTH     R0,R0
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock243

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser10value_byteEv
          CFI Block cfiBlock244 Using cfiCommon0
          CFI Function _ZN11GCodeParser10value_byteEv
        THUMB
// __interwork __softfp uint8_t GCodeParser::value_byte()
_ZN11GCodeParser10value_byteEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN11GCodeParser10value_longEv
        BL       _ZN11GCodeParser10value_longEv
        CMP      R0,#+0
        BPL.N    ??value_byte_0
        MOVS     R0,#+0
        B.N      ??value_byte_1
??value_byte_0:
          CFI FunCall _ZN11GCodeParser10value_longEv
        BL       _ZN11GCodeParser10value_longEv
        CMP      R0,#+255
        BLE.N    ??value_byte_2
        MOVS     R0,#+255
        B.N      ??value_byte_1
??value_byte_2:
          CFI FunCall _ZN11GCodeParser10value_longEv
        BL       _ZN11GCodeParser10value_longEv
??value_byte_1:
        UXTB     R0,R0
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock244

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser10value_boolEv
          CFI Block cfiBlock245 Using cfiCommon0
          CFI Function _ZN11GCodeParser10value_boolEv
        THUMB
// __interwork __softfp bool GCodeParser::value_bool()
_ZN11GCodeParser10value_boolEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN11GCodeParser9has_valueEv
        BL       _ZN11GCodeParser9has_valueEv
        CMP      R0,#+0
        BEQ.N    ??value_bool_0
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        MVNS     R0,R0
        LSRS     R0,R0,#+31
        POP      {R1,PC}
??value_bool_0:
        MOVS     R0,#+1
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock245

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser18value_linear_unitsEv
          CFI Block cfiBlock246 Using cfiCommon0
          CFI Function _ZN11GCodeParser18value_linear_unitsEv
          CFI FunCall _ZN11GCodeParser11value_floatEv
        THUMB
// __interwork __vfp float GCodeParser::value_linear_units()
_ZN11GCodeParser18value_linear_unitsEv:
        B.W      _ZN11GCodeParser11value_floatEv
          CFI EndBlock cfiBlock246

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser16value_axis_unitsE8AxisEnum
          CFI Block cfiBlock247 Using cfiCommon0
          CFI Function _ZN11GCodeParser16value_axis_unitsE8AxisEnum
          CFI FunCall _ZN11GCodeParser11value_floatEv
        THUMB
// __interwork __vfp float GCodeParser::value_axis_units(AxisEnum)
_ZN11GCodeParser16value_axis_unitsE8AxisEnum:
        B.W      _ZN11GCodeParser11value_floatEv
          CFI EndBlock cfiBlock247

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser19value_per_axis_unitE8AxisEnum
          CFI Block cfiBlock248 Using cfiCommon0
          CFI Function _ZN11GCodeParser19value_per_axis_unitE8AxisEnum
          CFI FunCall _ZN11GCodeParser11value_floatEv
        THUMB
// __interwork __vfp float GCodeParser::value_per_axis_unit(AxisEnum)
_ZN11GCodeParser19value_per_axis_unitE8AxisEnum:
        B.W      _ZN11GCodeParser11value_floatEv
          CFI EndBlock cfiBlock248

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser13value_celsiusEv
          CFI Block cfiBlock249 Using cfiCommon0
          CFI Function _ZN11GCodeParser13value_celsiusEv
          CFI FunCall _ZN11GCodeParser11value_floatEv
        THUMB
// __interwork __vfp float GCodeParser::value_celsius()
_ZN11GCodeParser13value_celsiusEv:
        B.W      _ZN11GCodeParser11value_floatEv
          CFI EndBlock cfiBlock249

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser14value_feedrateEv
          CFI Block cfiBlock250 Using cfiCommon0
          CFI Function _ZN11GCodeParser14value_feedrateEv
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        THUMB
// __interwork __vfp float GCodeParser::value_feedrate()
_ZN11GCodeParser14value_feedrateEv:
        B.W      _ZN11GCodeParser18value_linear_unitsEv
          CFI EndBlock cfiBlock250

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser7boolvalEc
          CFI Block cfiBlock251 Using cfiCommon0
          CFI Function _ZN11GCodeParser7boolvalEc
        THUMB
// __interwork __softfp bool GCodeParser::boolval(char)
_ZN11GCodeParser7boolvalEc:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??boolval_0
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN11GCodeParser10value_boolEv
        B.W      _ZN11GCodeParser10value_boolEv
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??boolval_0:
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN11GCodeParser4seenEc
        B.W      _ZN11GCodeParser4seenEc
          CFI EndBlock cfiBlock251

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser7bytevalEch
          CFI Block cfiBlock252 Using cfiCommon0
          CFI Function _ZN11GCodeParser7bytevalEch
        THUMB
// __interwork __softfp uint8_t GCodeParser::byteval(char, uint8_t)
_ZN11GCodeParser7bytevalEch:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R1
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??byteval_0
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        MOV      R4,R0
??byteval_0:
        MOV      R0,R4
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock252

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser6intvalEcs
          CFI Block cfiBlock253 Using cfiCommon0
          CFI Function _ZN11GCodeParser6intvalEcs
        THUMB
// __interwork __softfp int16_t GCodeParser::intval(char, int16_t)
_ZN11GCodeParser6intvalEcs:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R1
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??intval_0
          CFI FunCall _ZN11GCodeParser9value_intEv
        BL       _ZN11GCodeParser9value_intEv
        MOV      R4,R0
??intval_0:
        MOV      R0,R4
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock253

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser9ushortvalEct
          CFI Block cfiBlock254 Using cfiCommon0
          CFI Function _ZN11GCodeParser9ushortvalEct
        THUMB
// __interwork __softfp uint16_t GCodeParser::ushortval(char, uint16_t)
_ZN11GCodeParser9ushortvalEct:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R1
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??ushortval_0
          CFI FunCall _ZN11GCodeParser12value_ushortEv
        BL       _ZN11GCodeParser12value_ushortEv
        MOV      R4,R0
??ushortval_0:
        MOV      R0,R4
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock254

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser9linearvalEcf
          CFI Block cfiBlock255 Using cfiCommon0
          CFI Function _ZN11GCodeParser9linearvalEcf
        THUMB
// __interwork __vfp float GCodeParser::linearval(char, float)
_ZN11GCodeParser9linearvalEcf:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        VPUSH    {D8}
          CFI D8 Frame(CFA, -16)
          CFI CFA R13+16
        VMOV.F32 S16,S0
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??linearval_0
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        VMOV.F32 S16,S0
??linearval_0:
        VMOV.F32 S0,S16
        VPOP     {D8}
          CFI D8 SameValue
          CFI CFA R13+8
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock255

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser10celsiusvalEcf
          CFI Block cfiBlock256 Using cfiCommon0
          CFI Function _ZN11GCodeParser10celsiusvalEcf
        THUMB
// __interwork __vfp float GCodeParser::celsiusval(char, float)
_ZN11GCodeParser10celsiusvalEcf:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        VPUSH    {D8}
          CFI D8 Frame(CFA, -16)
          CFI CFA R13+16
        VMOV.F32 S16,S0
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??celsiusval_0
          CFI FunCall _ZN11GCodeParser13value_celsiusEv
        BL       _ZN11GCodeParser13value_celsiusEv
        VMOV.F32 S16,S0
??celsiusval_0:
        VMOV.F32 S0,S16
        VPOP     {D8}
          CFI D8 SameValue
          CFI CFA R13+8
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock256

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z20sync_plan_position_ev
          CFI Block cfiBlock257 Using cfiCommon0
          CFI Function _Z20sync_plan_position_ev
        THUMB
_Z20sync_plan_position_ev:
        LDR.N    R0,??sync_plan_position_e_0
          CFI FunCall _ZN7Planner17set_e_position_mmERKf
        B.W      _ZN7Planner17set_e_position_mmERKf
        Nop      
        DATA
??sync_plan_position_e_0:
        DC32     axis_relative_modes+0x30
          CFI EndBlock cfiBlock257

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z15_commit_commandb
          CFI Block cfiBlock258 Using cfiCommon0
          CFI Function _Z15_commit_commandb
          CFI NoCalls
        THUMB
_Z15_commit_commandb:
        LDR.N    R1,??_commit_command_0
        LDRB     R2,[R1, #+18]
        ADDS     R3,R2,R1
        STRB     R0,[R3, #+28]
        ADDS     R0,R2,#+1
        STRB     R0,[R1, #+18]
        UXTB     R0,R0
        CMP      R0,#+4
        BLT.N    ??_commit_command_1
        MOVS     R0,#+0
        STRB     R0,[R1, #+18]
??_commit_command_1:
        LDRB     R0,[R1, #+16]
        ADDS     R0,R0,#+1
        STRB     R0,[R1, #+16]
        BX       LR               ;; return
        Nop      
        DATA
??_commit_command_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock258

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z15_enqueuecommandPKcb
          CFI Block cfiBlock259 Using cfiCommon0
          CFI Function _Z15_enqueuecommandPKcb
        THUMB
_Z15_enqueuecommandPKcb:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R1
        LDRSB    R1,[R0, #+0]
        CMP      R1,#+59
        BEQ.N    ??_enqueuecommand_0
        LDR.N    R2,??_enqueuecommand_1
        LDRB     R1,[R2, #+16]
        CMP      R1,#+4
        BLT.N    ??_enqueuecommand_2
??_enqueuecommand_0:
        MOVS     R0,#+0
        POP      {R4,PC}
??_enqueuecommand_2:
        MOV      R1,R0
        LDRB     R0,[R2, #+18]
        ADD      R3,R0,R0, LSL #+1
        ADD      R0,R2,R3, LSL #+5
        ADDS     R0,R0,#+140
          CFI FunCall strcpy
        BL       strcpy
        MOV      R0,R4
          CFI FunCall _Z15_commit_commandb
        BL       _Z15_commit_commandb
        MOVS     R0,#+1
        POP      {R4,PC}          ;; return
        DATA
??_enqueuecommand_1:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock259

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z19get_serial_commandsv
          CFI Block cfiBlock260 Using cfiCommon0
          CFI Function _Z19get_serial_commandsv
        THUMB
_Z19get_serial_commandsv:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        MOV      R5,R0
        LDR.N    R4,??get_serial_commands_0
        LDRB     R0,[R4, #+16]
        CMP      R0,#+0
        BNE.W    ??get_serial_commands_1
        LDR.N    R0,??get_serial_commands_0+0x4
          CFI FunCall _ZN10USARTClass9availableEv
        BL       _ZN10USARTClass9availableEv
        CMP      R0,#+0
        BNE.W    ??get_serial_commands_1
        LDR.N    R0,??get_serial_commands_0+0x8
        LDR      R1,[R0, #+0]
        SUBS     R1,R5,R1
        SUBS     R1,R1,#+1000
        BMI.W    ??get_serial_commands_1
        LDRB     R1,[R4, #+23]
        CMP      R1,#+6
        BGE.N    ??get_serial_commands_2
        ADDS     R1,R1,#+1
        STRB     R1,[R4, #+23]
??get_serial_commands_2:
        STR      R5,[R0, #+0]
        B.N      ??get_serial_commands_1
??get_serial_commands_3:
        ADDS     R6,R6,#+1
??get_serial_commands_4:
        LDRSB    R0,[R6, #+0]
        CMP      R0,#+32
        BEQ.N    ??get_serial_commands_3
        CMP      R0,#+78
        BNE.N    ??get_serial_commands_5
        MOV      R8,R6
        B.N      ??get_serial_commands_6
??get_serial_commands_5:
        MOV      R8,#+0
??get_serial_commands_6:
        CMP      R8,#+0
        BEQ.N    ??get_serial_commands_7
        LDR.N    R1,??get_serial_commands_0+0xC
        MOV      R0,R6
          CFI FunCall _Z6strstrPcPKc
        BL       _Z6strstrPcPKc
        CMP      R0,#+0
        BEQ.N    ??get_serial_commands_8
        MOVS     R7,#+1
        B.N      ??get_serial_commands_9
??get_serial_commands_8:
        MOVS     R7,#+0
??get_serial_commands_9:
        CMP      R7,#+0
        BEQ.N    ??get_serial_commands_10
        MOVS     R1,#+78
        ADDS     R0,R6,#+4
          CFI FunCall _Z6strchrPci
        BL       _Z6strchrPci
        CMP      R0,#+0
        BEQ.N    ??get_serial_commands_10
        MOV      R8,R0
??get_serial_commands_10:
        MOVS     R2,#+10
        MOVS     R1,#+0
        ADD      R0,R8,#+1
          CFI FunCall strtol
        BL       strtol
        STR      R0,[R4, #+108]
        LDR      R1,[R4, #+112]
        ADDS     R1,R1,#+1
        CMP      R0,R1
        BEQ.N    ??get_serial_commands_11
        CMP      R7,#+0
        BNE.N    ??get_serial_commands_11
        MOVS     R1,#+1
        LDR.N    R0,??get_serial_commands_0+0x10
        POP      {R4-R8,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z16gcode_line_errorPKcb
        B.W      _Z16gcode_line_errorPKcb
          CFI R4 Frame(CFA, -24)
          CFI R5 Frame(CFA, -20)
          CFI R6 Frame(CFA, -16)
          CFI R7 Frame(CFA, -12)
          CFI R8 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+24
??get_serial_commands_11:
        MOVS     R1,#+42
        MOV      R0,R6
          CFI FunCall _Z7strrchrPci
        BL       _Z7strrchrPci
        CMP      R0,#+0
        BEQ.N    ??get_serial_commands_12
        MOVS     R7,#+0
        SUBS     R1,R0,R6
        B.N      ??get_serial_commands_13
??get_serial_commands_14:
        SUBS     R1,R1,#+1
        UXTB     R1,R1
        LDRSB    R2,[R1, R6]
        EORS     R7,R2,R7
??get_serial_commands_13:
        UXTB     R1,R1
        CMP      R1,#+0
        BNE.N    ??get_serial_commands_14
        MOVS     R2,#+10
        MOVS     R1,#+0
        ADDS     R0,R0,#+1
          CFI FunCall strtol
        BL       strtol
        UXTB     R7,R7
        CMP      R0,R7
        BEQ.N    ??get_serial_commands_15
        MOVS     R1,#+1
        LDR.N    R0,??get_serial_commands_0+0x14
        POP      {R4-R8,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z16gcode_line_errorPKcb
        B.W      _Z16gcode_line_errorPKcb
          CFI R4 Frame(CFA, -24)
          CFI R5 Frame(CFA, -20)
          CFI R6 Frame(CFA, -16)
          CFI R7 Frame(CFA, -12)
          CFI R8 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+24
??get_serial_commands_15:
        LDR      R0,[R4, #+108]
        STR      R0,[R4, #+112]
??get_serial_commands_7:
          CFI FunCall _Z9IsStoppedv
        BL       _Z9IsStoppedv
        CMP      R0,#+0
        BEQ.N    ??get_serial_commands_16
        MOVS     R1,#+71
        MOV      R0,R6
          CFI FunCall _Z6strchrPci
        BL       _Z6strchrPci
        CMP      R0,#+0
        BEQ.N    ??get_serial_commands_16
        MOVS     R2,#+10
        MOVS     R1,#+0
        ADDS     R0,R0,#+1
          CFI FunCall strtol
        BL       strtol
        CMP      R0,#+3
        BHI.N    ??get_serial_commands_16
        LDR.N    R0,??get_serial_commands_0+0x18
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R1,#+0
        LDR.N    R0,??get_serial_commands_0+0x1C
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
??get_serial_commands_16:
        LDR.N    R1,??get_serial_commands_0+0x20
        MOV      R0,R6
          CFI FunCall strcmp
        BL       strcmp
        CMP      R0,#+0
        BNE.N    ??get_serial_commands_17
        MOVS     R0,#+0
        STRB     R0,[R4, #+21]
??get_serial_commands_17:
        LDR.N    R1,??get_serial_commands_0+0x24
        MOV      R0,R6
          CFI FunCall strcmp
        BL       strcmp
        CMP      R0,#+0
        BNE.N    ??get_serial_commands_18
        LDR.N    R0,??get_serial_commands_0+0x28
          CFI FunCall _Z4killPKc
        BL       _Z4killPKc
??get_serial_commands_18:
        LDR.N    R1,??get_serial_commands_0+0x2C
        MOV      R0,R6
          CFI FunCall strcmp
        BL       strcmp
        CMP      R0,#+0
        BNE.N    ??get_serial_commands_19
          CFI FunCall _Z17quickstop_stepperv
        BL       _Z17quickstop_stepperv
??get_serial_commands_19:
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall _Z15_enqueuecommandPKcb
        BL       _Z15_enqueuecommandPKcb
??get_serial_commands_1:
        LDRB     R0,[R4, #+16]
        CMP      R0,#+4
        BGE.N    ??get_serial_commands_20
        LDR.N    R5,??get_serial_commands_0+0x4
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass4readEv
        BL       _ZN10USARTClass4readEv
        CMP      R0,#+0
        BMI.N    ??get_serial_commands_20
        SXTB     R0,R0
        MOVS     R1,#+0
        STRB     R1,[R4, #+23]
        STRB     R1,[R4, #+24]
        CMP      R0,#+10
        BEQ.N    ??get_serial_commands_21
        CMP      R0,#+13
        BNE.N    ??get_serial_commands_22
??get_serial_commands_21:
        MOV      R0,R1
        LDR.N    R1,??get_serial_commands_0+0x30
        STRB     R0,[R1, #+0]
        LDR.N    R6,??get_serial_commands_0+0x34
        LDR      R1,[R6, #+0]
        CMP      R1,#+0
        BEQ.N    ??get_serial_commands_1
        LDR.N    R5,??get_serial_commands_0+0x38
        STRB     R0,[R1, R5]
        STR      R0,[R6, #+0]
        MOV      R6,R5
        B.N      ??get_serial_commands_4
??get_serial_commands_12:
        MOVS     R1,#+1
        LDR.N    R0,??get_serial_commands_0+0x3C
        POP      {R4-R8,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z16gcode_line_errorPKcb
        B.W      _Z16gcode_line_errorPKcb
          CFI R4 Frame(CFA, -24)
          CFI R5 Frame(CFA, -20)
          CFI R6 Frame(CFA, -16)
          CFI R7 Frame(CFA, -12)
          CFI R8 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+24
??get_serial_commands_22:
        LDR.N    R6,??get_serial_commands_0+0x34
        LDR      R1,[R6, #+0]
        CMP      R1,#+95
        BGE.N    ??get_serial_commands_1
        CMP      R0,#+92
        BNE.N    ??get_serial_commands_23
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass4readEv
        BL       _ZN10USARTClass4readEv
        CMP      R0,#+0
        BMI.N    ??get_serial_commands_1
        LDR.N    R1,??get_serial_commands_0+0x30
        LDRB     R1,[R1, #+0]
        CMP      R1,#+0
        BNE.N    ??get_serial_commands_1
        LDR      R1,[R6, #+0]
        LDR.N    R2,??get_serial_commands_0+0x38
        STRB     R0,[R1, R2]
        ADDS     R0,R1,#+1
        STR      R0,[R6, #+0]
        B.N      ??get_serial_commands_1
??get_serial_commands_23:
        LDR.N    R2,??get_serial_commands_0+0x30
        CMP      R0,#+59
        BNE.N    ??get_serial_commands_24
        MOVS     R3,#+1
        STRB     R3,[R2, #+0]
??get_serial_commands_24:
        LDRB     R2,[R2, #+0]
        CMP      R2,#+0
        BNE.N    ??get_serial_commands_1
        LDR.N    R2,??get_serial_commands_0+0x38
        STRB     R0,[R1, R2]
        ADDS     R0,R1,#+1
        STR      R0,[R6, #+0]
        B.N      ??get_serial_commands_1
??get_serial_commands_20:
        POP      {R4-R8,PC}       ;; return
        Nop      
        DATA
??get_serial_commands_0:
        DC32     axis_relative_modes
        DC32     Serial6
        DC32     _ZZ19get_serial_commandsvE14last_wait_time
        DC32     _ZZ19get_serial_commandsvEs
        DC32     _ZZ19get_serial_commandsvEs_0
        DC32     _ZZ19get_serial_commandsvEs_1
        DC32     _ZZ19get_serial_commandsvEs_3
        DC32     _ZZ19get_serial_commandsvEs_4
        DC32     _ZZ19get_serial_commandsvEs_5
        DC32     _ZZ19get_serial_commandsvEs_6
        DC32     _ZZ19get_serial_commandsvEs_7
        DC32     _ZZ19get_serial_commandsvEs_8
        DC32     _ZZ19get_serial_commandsvE19serial_comment_mode
        DC32     serial_count
        DC32     _ZZ19get_serial_commandsvE18serial_line_buffer
        DC32     _ZZ19get_serial_commandsvEs_2
          CFI EndBlock cfiBlock260

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z17get_wifi_commandsv
          CFI Block cfiBlock261 Using cfiCommon0
          CFI Function _Z17get_wifi_commandsv
        THUMB
_Z17get_wifi_commandsv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        LDR.N    R4,??get_wifi_commands_0
        LDRB     R0,[R4, #+23]
        CMP      R0,#+6
        BLT.N    ??get_wifi_commands_1
        MOVS     R0,#+1
        STRB     R0,[R4, #+24]
        B.N      ??get_wifi_commands_2
??get_wifi_commands_3:
        ADDS     R6,R6,#+1
??get_wifi_commands_4:
        LDRSB    R0,[R6, #+0]
        CMP      R0,#+32
        BEQ.N    ??get_wifi_commands_3
          CFI FunCall _Z9IsStoppedv
        BL       _Z9IsStoppedv
        CMP      R0,#+0
        BEQ.N    ??get_wifi_commands_5
        MOVS     R1,#+71
        MOV      R0,R6
          CFI FunCall _Z6strchrPci
        BL       _Z6strchrPci
        CMP      R0,#+0
        BEQ.N    ??get_wifi_commands_5
        MOVS     R2,#+10
        MOVS     R1,#+0
        ADDS     R0,R0,#+1
          CFI FunCall strtol
        BL       strtol
        CMP      R0,#+3
        BHI.N    ??get_wifi_commands_5
        LDR.N    R0,??get_wifi_commands_0+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R1,#+0
        LDR.N    R0,??get_wifi_commands_0+0x8
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
??get_wifi_commands_5:
        LDR.N    R1,??get_wifi_commands_0+0xC
        MOV      R0,R6
          CFI FunCall strcmp
        BL       strcmp
        CMP      R0,#+0
        BNE.N    ??get_wifi_commands_6
        MOVS     R0,#+0
        STRB     R0,[R4, #+21]
??get_wifi_commands_6:
        LDR.N    R1,??get_wifi_commands_0+0x10
        MOV      R0,R6
          CFI FunCall strcmp
        BL       strcmp
        CMP      R0,#+0
        BNE.N    ??get_wifi_commands_7
        LDR.N    R0,??get_wifi_commands_0+0x14
          CFI FunCall _Z4killPKc
        BL       _Z4killPKc
??get_wifi_commands_7:
        LDR.N    R1,??get_wifi_commands_0+0x18
        MOV      R0,R6
          CFI FunCall strcmp
        BL       strcmp
        CMP      R0,#+0
        BNE.N    ??get_wifi_commands_8
          CFI FunCall _Z17quickstop_stepperv
        BL       _Z17quickstop_stepperv
??get_wifi_commands_8:
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall _Z15_enqueuecommandPKcb
        BL       _Z15_enqueuecommandPKcb
??get_wifi_commands_2:
        LDRB     R0,[R4, #+16]
        CMP      R0,#+4
        BGE.N    ??get_wifi_commands_9
        LDR.N    R1,??get_wifi_commands_0+0x1C
        LDR      R2,[R1, #+96]
        LDR      R0,[R1, #+100]
        CMP      R2,R0
        BEQ.N    ??get_wifi_commands_9
        LDRSB    R0,[R2, R1]
        ADDS     R2,R2,#+1
        MOVS     R3,#+96
        UDIV     R3,R2,R3
        ADD      R5,R3,R3, LSL #+1
        SUB      R2,R2,R5, LSL #+5
        STR      R2,[R1, #+96]
        CMP      R0,#+10
        BEQ.N    ??get_wifi_commands_10
        CMP      R0,#+13
        BNE.N    ??get_wifi_commands_11
??get_wifi_commands_10:
        MOVS     R0,#+0
        LDR.N    R1,??get_wifi_commands_0+0x20
        STRB     R0,[R1, #+0]
        LDR.N    R1,??get_wifi_commands_0+0x24
        LDR      R2,[R1, #+0]
        CMP      R2,#+0
        BEQ.N    ??get_wifi_commands_2
        LDR.N    R5,??get_wifi_commands_0+0x28
        STRB     R0,[R2, R5]
        STR      R0,[R1, #+0]
        MOV      R6,R5
        B.N      ??get_wifi_commands_4
??get_wifi_commands_11:
        LDR.N    R1,??get_wifi_commands_0+0x24
        LDR      R2,[R1, #+0]
        CMP      R2,#+95
        BGE.N    ??get_wifi_commands_2
        LDR.N    R3,??get_wifi_commands_0+0x20
        CMP      R0,#+59
        BNE.N    ??get_wifi_commands_12
        MOVS     R5,#+1
        STRB     R5,[R3, #+0]
??get_wifi_commands_12:
        LDRB     R3,[R3, #+0]
        CMP      R3,#+0
        BNE.N    ??get_wifi_commands_2
        LDR.N    R3,??get_wifi_commands_0+0x28
        STRB     R0,[R2, R3]
        ADDS     R0,R2,#+1
        STR      R0,[R1, #+0]
        B.N      ??get_wifi_commands_2
??get_wifi_commands_1:
        MOVS     R0,#+0
        STRB     R0,[R4, #+24]
??get_wifi_commands_9:
        POP      {R4-R6,PC}       ;; return
        DATA
??get_wifi_commands_0:
        DC32     axis_relative_modes
        DC32     _ZZ17get_wifi_commandsvEs
        DC32     _ZZ17get_wifi_commandsvEs_0
        DC32     _ZZ17get_wifi_commandsvEs_1
        DC32     _ZZ17get_wifi_commandsvEs_2
        DC32     _ZZ17get_wifi_commandsvEs_3
        DC32     _ZZ17get_wifi_commandsvEs_4
        DC32     espGcodeFifo
        DC32     _ZZ17get_wifi_commandsvE17wifi_comment_mode
        DC32     wifi_read_count
        DC32     _ZZ17get_wifi_commandsvE16wifi_line_buffer
          CFI EndBlock cfiBlock261

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z24get_homing_bump_feedrate8AxisEnum
          CFI Block cfiBlock262 Using cfiCommon0
          CFI Function _Z24get_homing_bump_feedrate8AxisEnum
        THUMB
_Z24get_homing_bump_feedrate8AxisEnum:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        SUB      SP,SP,#+20
          CFI CFA R13+32
        MOV      R4,R0
        MOVS     R0,#+2
        STR      R0,[SP, #+0]
        ADD      R0,SP,#+0
        MOVS     R1,#+2
        STR      R1,[R0, #+4]
        MOVS     R1,#+4
        STR      R1,[SP, #+8]
        LDRB     R5,[R0, R4, LSL #+2]
        CMP      R5,#+0
        BNE.N    ??get_homing_bump_feedrate_0
        MOVS     R5,#+10
        LDR.N    R0,??get_homing_bump_feedrate_1
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??get_homing_bump_feedrate_1+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??get_homing_bump_feedrate_0:
        VMOV     S0,R5
        VCVT.F32.U32 S0,S0
        LDR.N    R0,??get_homing_bump_feedrate_1+0x8
        ADD      R0,R0,R4, LSL #+2
        VLDR     S1,[R0, #+68]
        VDIV.F32 S0,S1,S0
        ADD      SP,SP,#+20
          CFI CFA R13+12
        POP      {R4,R5,PC}       ;; return
        DATA
??get_homing_bump_feedrate_1:
        DC32     echomagic
        DC32     _ZZ24get_homing_bump_feedrate8AxisEnumEs
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock262

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z31buffer_line_to_current_positionv
          CFI Block cfiBlock263 Using cfiCommon0
          CFI Function _Z31buffer_line_to_current_positionv
        THUMB
_Z31buffer_line_to_current_positionv:
        LDR.N    R3,??buffer_line_to_current_position_0
        LDRB     R2,[R3, #+19]
        ADD      R1,R3,#+120
        ADD      R0,R3,#+48
        VLDR     S2,[R3, #+44]
        VLDR     S1,[R3, #+40]
        VLDR     S0,[R3, #+36]
          CFI FunCall _ZN7Planner11buffer_lineEfffRKfS1_h
        B.W      _ZN7Planner11buffer_lineEfffRKfS1_h
        DATA
??buffer_line_to_current_position_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock263

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z26buffer_line_to_destinationf
          CFI Block cfiBlock264 Using cfiCommon0
          CFI Function _Z26buffer_line_to_destinationf
        THUMB
_Z26buffer_line_to_destinationf:
        PUSH     {LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+4
        VPUSH    {S0}
          CFI CFA R13+8
        LDR.N    R3,??buffer_line_to_destination_0
        LDRB     R2,[R3, #+19]
        ADD      R1,SP,#+0
        ADD      R0,R3,#+64
        VLDR     S2,[R3, #+60]
        VLDR     S1,[R3, #+56]
        VLDR     S0,[R3, #+52]
          CFI FunCall _ZN7Planner11buffer_lineEfffRKfS1_h
        BL       _ZN7Planner11buffer_lineEfffRKfS1_h
        POP      {R0,PC}          ;; return
        Nop      
        DATA
??buffer_line_to_destination_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock264

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z11gcode_G0_G1v
          CFI Block cfiBlock265 Using cfiCommon0
          CFI Function _Z11gcode_G0_G1v
        THUMB
_Z11gcode_G0_G1v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _Z9IsRunningv
        BL       _Z9IsRunningv
        CMP      R0,#+0
        BEQ.N    ??gcode_G0_G1_0
          CFI FunCall _Z21gcode_get_destinationv
        BL       _Z21gcode_get_destinationv
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z27prepare_move_to_destinationv
        B.W      _Z27prepare_move_to_destinationv
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_G0_G1_0:
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock265

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z11gcode_G2_G3b
          CFI Block cfiBlock266 Using cfiCommon0
          CFI Function _Z11gcode_G2_G3b
        THUMB
_Z11gcode_G2_G3b:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        VPUSH    {D8-D14}
          CFI D14 Frame(CFA, -24)
          CFI D13 Frame(CFA, -32)
          CFI D12 Frame(CFA, -40)
          CFI D11 Frame(CFA, -48)
          CFI D10 Frame(CFA, -56)
          CFI D9 Frame(CFA, -64)
          CFI D8 Frame(CFA, -72)
          CFI CFA R13+72
        SUB      SP,SP,#+8
          CFI CFA R13+80
        MOV      R4,R0
          CFI FunCall _Z9IsRunningv
        BL       _Z9IsRunningv
        CMP      R0,#+0
        BEQ.W    ??gcode_G2_G3_0
          CFI FunCall _Z21gcode_get_destinationv
        BL       _Z21gcode_get_destinationv
        ADD      R0,SP,#+0
        MOVS     R1,#+0
        MOV      R2,R1
        STM      R0!,{R1,R2}
        MOVS     R0,#+82
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.W    ??gcode_G2_G3_1
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        VMOV.F32 S16,S0
        LDR.N    R0,??gcode_G2_G3_2+0x4
        VLDR     S20,[R0, #+36]
        VLDR     S21,[R0, #+40]
        VLDR     S22,[R0, #+52]
        VLDR     S23,[R0, #+56]
        VCMP.F32 S16,#0.0
        FMSTAT   
        BEQ.W    ??gcode_G2_G3_3
        VCMP.F32 S22,S20
        FMSTAT   
        BNE.N    ??gcode_G2_G3_4
        VCMP.F32 S23,S21
        FMSTAT   
        BEQ.W    ??gcode_G2_G3_3
??gcode_G2_G3_4:
        VCMP.F32 S16,#0.0
        FMSTAT   
        BPL.N    ??gcode_G2_G3_5
        MOVS     R0,#+1
        B.N      ??gcode_G2_G3_6
??gcode_G2_G3_5:
        MOVS     R0,#+0
??gcode_G2_G3_6:
        VMOV.F32 S27,#1.0
        TEQ      R0,R4
        BEQ.N    ??gcode_G2_G3_7
        VMOV.F32 S24,#-1.0
        B.N      ??gcode_G2_G3_8
??gcode_G2_G3_7:
        VMOV.F32 S24,S27
??gcode_G2_G3_8:
        VSUB.F32 S25,S22,S20
        VSUB.F32 S26,S23,S21
        VMOV.F32 S0,S25
        MOVS     R0,#+2
        VMOV.F32 S1,S27
        B.N      ??gcode_G2_G3_9
??gcode_G2_G3_10:
        VMUL.F32 S0,S0,S0
??gcode_G2_G3_9:
        LSLS     R1,R0,#+31
        BPL.N    ??gcode_G2_G3_11
        VMUL.F32 S1,S1,S0
??gcode_G2_G3_11:
        LSRS     R0,R0,#+1
        BNE.N    ??gcode_G2_G3_10
        VMOV.F32 S0,S26
        MOVS     R0,#+2
        VMOV.F32 S2,S27
        B.N      ??gcode_G2_G3_12
??gcode_G2_G3_13:
        VMUL.F32 S0,S0,S0
??gcode_G2_G3_12:
        LSLS     R1,R0,#+31
        BPL.N    ??gcode_G2_G3_14
        VMUL.F32 S2,S2,S0
??gcode_G2_G3_14:
        LSRS     R0,R0,#+1
        BNE.N    ??gcode_G2_G3_13
        VADD.F32 S0,S1,S2
          CFI FunCall sqrtf
        BL       sqrtf
        VMOV.F32 S28,S0
        MOVS     R0,#+2
        B.N      ??gcode_G2_G3_15
??gcode_G2_G3_16:
        VMUL.F32 S16,S16,S16
??gcode_G2_G3_15:
        LSLS     R1,R0,#+31
        BPL.N    ??gcode_G2_G3_17
        VMUL.F32 S27,S27,S16
??gcode_G2_G3_17:
        LSRS     R0,R0,#+1
        BNE.N    ??gcode_G2_G3_16
        VMOV     R0,S28
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        LDR.N    R3,??gcode_G2_G3_2+0x8  ;; 0x3fe00000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        VMOV     D8,R0,R1
        MOVS     R5,#+2
        VLDR.W   D9,??gcode_G2_G3_2+0xC
        B.N      ??gcode_G2_G3_18
??gcode_G2_G3_19:
        VMOV     R0,R1,D8
        VMOV     R2,R3,D8
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        VMOV     D8,R0,R1
??gcode_G2_G3_18:
        LSLS     R0,R5,#+31
        BPL.N    ??gcode_G2_G3_20
        VMOV     R0,R1,D9
        VMOV     R2,R3,D8
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        VMOV     D9,R0,R1
??gcode_G2_G3_20:
        LSRS     R5,R5,#+1
        BNE.N    ??gcode_G2_G3_19
        VMOV     R0,S27
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        VMOV     R2,R3,D9
          CFI FunCall __aeabi_dsub
        BL       __aeabi_dsub
        VMOV     D0,R0,R1
          CFI FunCall sqrt
        BL       sqrt
        VMOV     R0,R1,D0
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        VMOV     S0,R0
        VMUL.F32 S0,S24,S0
        VMOV.F32 S1,#0.5
        VADD.F32 S2,S20,S22
        VMUL.F32 S2,S2,S1
        VDIV.F32 S3,S26,S28
        VMLS.F32 S2,S0,S3
        VSUB.F32 S2,S2,S20
        VSTR     S2,[SP, #+0]
        VADD.F32 S2,S21,S23
        VMUL.F32 S1,S2,S1
        VDIV.F32 S2,S25,S28
        VMLA.F32 S1,S0,S2
        VSUB.F32 S0,S1,S21
        VSTR     S0,[SP, #+4]
        B.N      ??gcode_G2_G3_3
??gcode_G2_G3_1:
        MOVS     R0,#+73
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G2_G3_21
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        VSTR     S0,[SP, #+0]
??gcode_G2_G3_21:
        MOVS     R0,#+74
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G2_G3_3
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        VSTR     S0,[SP, #+4]
??gcode_G2_G3_3:
        VLDR     S0,[SP, #+0]
        VCMP.F32 S0,#0.0
        FMSTAT   
        BNE.N    ??gcode_G2_G3_22
        VLDR     S0,[SP, #+4]
        VCMP.F32 S0,#0.0
        FMSTAT   
        BEQ.N    ??gcode_G2_G3_23
??gcode_G2_G3_22:
        MOV      R2,R4
        ADD      R1,SP,#+0
        LDR.N    R0,??gcode_G2_G3_2+0x14
          CFI FunCall _Z8plan_arcRA4_KfRA2_S_b
        BL       _Z8plan_arcRA4_KfRA2_S_b
          CFI FunCall _Z19refresh_cmd_timeoutv
        BL       _Z19refresh_cmd_timeoutv
        B.N      ??gcode_G2_G3_0
??gcode_G2_G3_23:
        LDR.N    R0,??gcode_G2_G3_2+0x18
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_G2_G3_2
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_G2_G3_0:
        ADD      SP,SP,#+8
          CFI CFA R13+72
        VPOP     {D8-D14}
          CFI D8 SameValue
          CFI D9 SameValue
          CFI D10 SameValue
          CFI D11 SameValue
          CFI D12 SameValue
          CFI D13 SameValue
          CFI D14 SameValue
          CFI CFA R13+16
        POP      {R0,R4,R5,PC}    ;; return
        Nop      
        DATA
??gcode_G2_G3_2:
        DC32     _ZZ11gcode_G2_G3bEs
        DC32     axis_relative_modes
        DC32     0x3fe00000
        DC32     0x0,0x3FF00000
        DC32     axis_relative_modes+0x34
        DC32     errormagic
          CFI EndBlock cfiBlock266

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z8gcode_G4v
          CFI Block cfiBlock267 Using cfiCommon0
          CFI Function _Z8gcode_G4v
        THUMB
_Z8gcode_G4v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R4,#+0
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G4_0
          CFI FunCall _ZN11GCodeParser12value_millisEv
        BL       _ZN11GCodeParser12value_millisEv
        MOV      R4,R0
??gcode_G4_0:
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G4_1
          CFI FunCall _ZN11GCodeParser25value_millis_from_secondsEv
        BL       _ZN11GCodeParser25value_millis_from_secondsEv
        MOV      R4,R0
??gcode_G4_1:
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
          CFI FunCall _Z13lcd_hasstatusv
        BL       _Z13lcd_hasstatusv
        CMP      R0,#+0
        BNE.N    ??gcode_G4_2
        MOVS     R1,#+0
        LDR.N    R0,??gcode_G4_3
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
??gcode_G4_2:
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z5dwellm
        B.W      _Z5dwellm
        Nop      
        DATA
??gcode_G4_3:
        DC32     _ZZ8gcode_G4vEs
          CFI EndBlock cfiBlock267

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_G28b
          CFI Block cfiBlock268 Using cfiCommon0
          CFI Function _Z9gcode_G28b
        THUMB
_Z9gcode_G28b:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        SUB      SP,SP,#+8
          CFI CFA R13+32
        MOV      R5,R0
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
          CFI FunCall _Z31setup_for_endstop_or_probe_movev
        BL       _Z31setup_for_endstop_or_probe_movev
        MOVS     R0,#+1
          CFI FunCall _ZN8Endstops6enableEb
        BL       _ZN8Endstops6enableEb
        CMP      R5,#+0
        BNE.N    ??gcode_G28_0
        MOVS     R0,#+88
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOV      R6,R0
        B.N      ??gcode_G28_1
??gcode_G28_0:
        MOVS     R6,#+1
??gcode_G28_1:
        CMP      R5,#+0
        BNE.N    ??gcode_G28_2
        MOVS     R0,#+89
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOV      R4,R0
        B.N      ??gcode_G28_3
??gcode_G28_2:
        MOVS     R4,#+1
??gcode_G28_3:
        CMP      R5,#+0
        BNE.N    ??gcode_G28_4
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOV      R5,R0
        B.N      ??gcode_G28_5
??gcode_G28_4:
        MOVS     R5,#+1
??gcode_G28_5:
        ORR      R0,R4,R6
        ORRS     R0,R5,R0
        EOR      R0,R0,#0x1
        AND      R1,R4,R6
        ANDS     R1,R5,R1
        ORR      R7,R1,R0
          CFI FunCall _Z28set_destination_from_currentv
        BL       _Z28set_destination_from_currentv
        LDR.W    R8,??gcode_G28_6
        LDRSB    R0,[R8, #+1]
        CMP      R0,#+1
        BLT.N    ??gcode_G28_7
        ORRS     R0,R5,R7
        BEQ.N    ??gcode_G28_7
        MOVS     R0,#+2
          CFI FunCall _Z8homeaxis8AxisEnum
        BL       _Z8homeaxis8AxisEnum
??gcode_G28_7:
        ORRS     R6,R6,R7
        ORRS     R0,R4,R6
        BEQ.N    ??gcode_G28_8
        LDR.N    R0,??gcode_G28_6+0x4
        MOVS     R1,#+0
        STR      R1,[R0, #+60]
        VLDR     S0,[R0, #+44]
        VCMP.F32 S0,#0.0
        FMSTAT   
        BPL.N    ??gcode_G28_8
        STR      R1,[SP, #+0]
        ADD      R1,SP,#+0
        ADDS     R0,R0,#+60
          CFI FunCall _Z21do_blocking_move_to_zRKfS0_
        BL       _Z21do_blocking_move_to_zRKfS0_
??gcode_G28_8:
        CMP      R6,#+0
        BEQ.N    ??gcode_G28_9
        MOVS     R0,#+0
          CFI FunCall _Z8homeaxis8AxisEnum
        BL       _Z8homeaxis8AxisEnum
??gcode_G28_9:
        ORRS     R0,R4,R7
        BEQ.N    ??gcode_G28_10
        MOVS     R0,#+1
          CFI FunCall _Z8homeaxis8AxisEnum
        BL       _Z8homeaxis8AxisEnum
??gcode_G28_10:
        LDRSB    R0,[R8, #+1]
        CMP      R0,#+0
        BPL.N    ??gcode_G28_11
        ORRS     R0,R5,R7
        BEQ.N    ??gcode_G28_11
        MOVS     R0,#+2
          CFI FunCall _Z8homeaxis8AxisEnum
        BL       _Z8homeaxis8AxisEnum
??gcode_G28_11:
          CFI FunCall _Z18sync_plan_positionv
        BL       _Z18sync_plan_positionv
          CFI FunCall _ZN8Endstops10not_homingEv
        BL       _ZN8Endstops10not_homingEv
          CFI FunCall _Z36clean_up_after_endstop_or_probe_movev
        BL       _Z36clean_up_after_endstop_or_probe_movev
          CFI FunCall _Z11lcd_refreshv
        BL       _Z11lcd_refreshv
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
        POP      {R0,R1,R4-R8,PC}  ;; return
        Nop      
        DATA
??gcode_G28_6:
        DC32     mksCfg
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock268

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_G92v
          CFI Block cfiBlock269 Using cfiCommon0
          CFI Function _Z9gcode_G92v
        THUMB
_Z9gcode_G92v:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        MOVS     R4,#+0
        MOV      R5,R4
        MOV      R6,R4
        B.N      ??gcode_G92_0
??gcode_G92_1:
        MOVS     R5,#+1
??gcode_G92_2:
        VSTR     S0,[R0, #+36]
??gcode_G92_3:
        ADDS     R6,R6,#+1
??gcode_G92_0:
        CMP      R6,#+4
        BGE.N    ??gcode_G92_4
        LDR.N    R0,??gcode_G92_5+0x8
        LDRSB    R0,[R6, R0]
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G92_3
        MOV      R0,R6
        SXTB     R0,R0
          CFI FunCall _ZN11GCodeParser16value_axis_unitsE8AxisEnum
        BL       _ZN11GCodeParser16value_axis_unitsE8AxisEnum
        CMP      R6,#+3
        BEQ.N    ??gcode_G92_6
        LDR.N    R0,??gcode_G92_5+0xC
        ADD      R0,R0,R6, LSL #+2
        VLDR     S1,[R0, #+4]
        VSUB.F32 S0,S0,S1
??gcode_G92_6:
        LDR.N    R0,??gcode_G92_5+0x10
        ADD      R0,R0,R6, LSL #+2
        VLDR     S1,[R0, #+36]
        VSUB.F32 S1,S0,S1
        VLDR.W   S2,??gcode_G92_5  ;; 0xb58637bd
        VCMP.F32 S1,S2
        FMSTAT   
        BLT.N    ??gcode_G92_7
        VLDR.W   S2,??gcode_G92_5+0x4  ;; 0x358637be
        VCMP.F32 S1,S2
        FMSTAT   
        BMI.N    ??gcode_G92_3
??gcode_G92_7:
        CMP      R6,#+3
        BNE.N    ??gcode_G92_1
        MOVS     R4,#+1
        B.N      ??gcode_G92_2
??gcode_G92_4:
        CMP      R5,#+0
        BEQ.N    ??gcode_G92_8
          CFI FunCall _Z18sync_plan_positionv
        BL       _Z18sync_plan_positionv
        B.N      ??gcode_G92_9
??gcode_G92_8:
        CMP      R4,#+0
        BEQ.N    ??gcode_G92_9
          CFI FunCall _Z20sync_plan_position_ev
        BL       _Z20sync_plan_position_ev
??gcode_G92_9:
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z23report_current_positionv
        B.W      _Z23report_current_positionv
        DATA
??gcode_G92_5:
        DC32     0xb58637bd
        DC32     0x358637be
        DC32     axis_codes
        DC32     soft_endstops_enabled
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock269

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M17v
          CFI Block cfiBlock270 Using cfiCommon0
          CFI Function _Z9gcode_M17v
        THUMB
_Z9gcode_M17v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M17_0
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z19enable_all_steppersv
        B.W      _Z19enable_all_steppersv
        Nop      
        DATA
??gcode_M17_0:
        DC32     _ZZ9gcode_M17vEs
          CFI EndBlock cfiBlock270

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M20v
          CFI Block cfiBlock271 Using cfiCommon0
          CFI Function _Z9gcode_M20v
        THUMB
_Z9gcode_M20v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??gcode_M20_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M20_0+0x4
          CFI FunCall _ZN10CardReader2lsEv
        BL       _ZN10CardReader2lsEv
        LDR.N    R0,??gcode_M20_0+0x8
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
        DATA
??gcode_M20_0:
        DC32     _ZZ9gcode_M20vEs
        DC32     card
        DC32     _ZZ9gcode_M20vEs_0
          CFI EndBlock cfiBlock271

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M22v
          CFI Block cfiBlock272 Using cfiCommon0
          CFI Function _Z9gcode_M22v
        THUMB
_Z9gcode_M22v:
        LDR.N    R0,??gcode_M22_0
          CFI FunCall _ZN10CardReader7releaseEv
        B.W      _ZN10CardReader7releaseEv
        Nop      
        DATA
??gcode_M22_0:
        DC32     card
          CFI EndBlock cfiBlock272

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M23v
          CFI Block cfiBlock273 Using cfiCommon0
          CFI Function _Z9gcode_M23v
        THUMB
_Z9gcode_M23v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R0,??gcode_M23_0
        LDR      R1,[R0, #+0]
        B.N      ??gcode_M23_1
??gcode_M23_2:
        CMP      R2,#+32
        BNE.N    ??gcode_M23_3
        MOVS     R2,#+0
        STRB     R2,[R1, #+0]
??gcode_M23_3:
        ADDS     R1,R1,#+1
??gcode_M23_1:
        LDRSB    R2,[R1, #+0]
        CMP      R2,#+0
        BNE.N    ??gcode_M23_2
        LDR.N    R4,??gcode_M23_0+0x4
        MOVS     R3,#+1
        MOV      R2,R3
        LDR      R1,[R0, #+0]
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8openFileEPcbb
        BL       _ZN10CardReader8openFileEPcbb
        ADDW     R1,R4,#+3276
        LDR.N    R0,??gcode_M23_0+0x8
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall strcpy
        B.W      strcpy
        Nop      
        DATA
??gcode_M23_0:
        DC32     _ZN11GCodeParser10string_argE
        DC32     card
        DC32     curFileName
          CFI EndBlock cfiBlock273

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M24v
          CFI Block cfiBlock274 Using cfiCommon0
          CFI Function _Z9gcode_M24v
        THUMB
_Z9gcode_M24v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
          CFI FunCall mks_resumePrint
        BL       mks_resumePrint
        LDR.N    R4,??gcode_M24_0
        LDRB     R0,[R4, #+3344]
        CMP      R0,#+170
        BEQ.N    ??gcode_M24_1
        CMP      R0,#+171
        BEQ.N    ??gcode_M24_1
        MOV      R0,R4
          CFI FunCall _ZN10CardReader14startFileprintEv
        BL       _ZN10CardReader14startFileprintEv
        ADD      R0,R4,#+3584
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN9Stopwatch5startEv
        B.W      _ZN9Stopwatch5startEv
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M24_1:
        POP      {R4,PC}          ;; return
        DATA
??gcode_M24_0:
        DC32     card
          CFI EndBlock cfiBlock274

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M25v
          CFI Block cfiBlock275 Using cfiCommon0
          CFI Function _Z9gcode_M25v
        THUMB
_Z9gcode_M25v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R4,??gcode_M25_0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader12pauseSDPrintEv
        BL       _ZN10CardReader12pauseSDPrintEv
        ADD      R0,R4,#+3584
          CFI FunCall _ZN9Stopwatch5pauseEv
        BL       _ZN9Stopwatch5pauseEv
        MOVS     R0,#+168
        STRB     R0,[R4, #+3344]
        POP      {R4,PC}          ;; return
        Nop      
        DATA
??gcode_M25_0:
        DC32     card
          CFI EndBlock cfiBlock275

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M998v
          CFI Block cfiBlock276 Using cfiCommon0
          CFI Function _Z10gcode_M998v
        THUMB
_Z10gcode_M998v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R4,??gcode_M998_0
        LDRB     R0,[R4, #+3344]
        CMP      R0,#+171
        BEQ.N    ??gcode_M998_1
        MOVS     R0,#+166
        STRB     R0,[R4, #+3344]
        LDR.N    R0,??gcode_M998_0+0x4
        LDRB     R0,[R0, #+379]
        CMP      R0,#+1
        BEQ.N    ??gcode_M998_2
        MOVS     R2,#+1
        ADD      R1,R4,#+3344
        MOV      R0,#+1000
          CFI FunCall epr_write_data
        BL       epr_write_data
??gcode_M998_2:
        MOV      R0,R4
          CFI FunCall _ZN10CardReader11stopSDPrintEv
        BL       _ZN10CardReader11stopSDPrintEv
          CFI FunCall _Z19clear_command_queuev
        BL       _Z19clear_command_queuev
          CFI FunCall _Z17quickstop_stepperv
        BL       _Z17quickstop_stepperv
        ADD      R0,R4,#+3584
          CFI FunCall _ZN9Stopwatch4stopEv
        BL       _ZN9Stopwatch4stopEv
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
        MOVS     R0,#+0
        B.N      ??gcode_M998_3
??gcode_M998_4:
        MOVS     R0,#+0
        LDR.N    R1,??gcode_M998_0+0x8
        STR      R0,[R1, #+0]
        LDR.N    R1,??gcode_M998_0+0xC  ;; 0x42408288
        STR      R0,[R1, #+0]
        MOVS     R0,#+1
??gcode_M998_3:
        CMP      R0,#+0
        BEQ.N    ??gcode_M998_4
        MOVS     R0,#+0
        LDR.N    R1,??gcode_M998_0+0x10
        STRB     R0,[R1, #+21]
??gcode_M998_1:
        POP      {R4,PC}          ;; return
        DATA
??gcode_M998_0:
        DC32     card
        DC32     gCfgItems
        DC32     fanSpeeds
        DC32     0x42408288
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock276

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M26v
          CFI Block cfiBlock277 Using cfiCommon0
          CFI Function _Z9gcode_M26v
        THUMB
_Z9gcode_M26v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R4,??gcode_M26_0
        LDRB     R0,[R4, #+2491]
        CMP      R0,#+0
        BEQ.N    ??gcode_M26_1
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M26_1
          CFI FunCall _ZN11GCodeParser10value_longEv
        BL       _ZN11GCodeParser10value_longEv
        MOV      R1,R0
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10CardReader8setIndexEl
        B.W      _ZN10CardReader8setIndexEl
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M26_1:
        POP      {R4,PC}          ;; return
        DATA
??gcode_M26_0:
        DC32     card
          CFI EndBlock cfiBlock277

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M27v
          CFI Block cfiBlock278 Using cfiCommon0
          CFI Function _Z9gcode_M27v
        THUMB
_Z9gcode_M27v:
        LDR.N    R0,??gcode_M27_0
          CFI FunCall _ZN10CardReader9getStatusEv
        B.W      _ZN10CardReader9getStatusEv
        Nop      
        DATA
??gcode_M27_0:
        DC32     card
          CFI EndBlock cfiBlock278

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M28v
          CFI Block cfiBlock279 Using cfiCommon0
          CFI Function _Z9gcode_M28v
        THUMB
_Z9gcode_M28v:
        MOVS     R3,#+1
        MOVS     R2,#+0
        LDR.N    R0,??gcode_M28_0
        LDR      R1,[R0, #+0]
        LDR.N    R0,??gcode_M28_0+0x4
          CFI FunCall _ZN10CardReader8openFileEPcbb
        B.W      _ZN10CardReader8openFileEPcbb
        Nop      
        DATA
??gcode_M28_0:
        DC32     _ZN11GCodeParser10string_argE
        DC32     card
          CFI EndBlock cfiBlock279

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z9gcode_M29v
          CFI Block cfiBlock280 Using cfiCommon0
          CFI Function _Z9gcode_M29v
          CFI NoCalls
        THUMB
_Z9gcode_M29v:
        BX       LR               ;; return
          CFI EndBlock cfiBlock280

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M30v
          CFI Block cfiBlock281 Using cfiCommon0
          CFI Function _Z9gcode_M30v
        THUMB
_Z9gcode_M30v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R4,??gcode_M30_0
        LDRB     R0,[R4, #+2491]
        CMP      R0,#+0
        BEQ.N    ??gcode_M30_1
        MOVS     R1,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader9closefileEb
        BL       _ZN10CardReader9closefileEb
        LDR.N    R0,??gcode_M30_0+0x4
        LDR      R1,[R0, #+0]
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10CardReader10removeFileEPc
        B.W      _ZN10CardReader10removeFileEPc
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M30_1:
        POP      {R4,PC}          ;; return
        DATA
??gcode_M30_0:
        DC32     card
        DC32     _ZN11GCodeParser10string_argE
          CFI EndBlock cfiBlock281

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M31v
          CFI Block cfiBlock282 Using cfiCommon0
          CFI Function _Z9gcode_M31v
        THUMB
_Z9gcode_M31v:
        PUSH     {LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+4
        SUB      SP,SP,#+36
          CFI CFA R13+40
        LDR.N    R0,??gcode_M31_0
          CFI FunCall _ZN9Stopwatch8durationEv
        BL       _ZN9Stopwatch8durationEv
        STR      R0,[SP, #+0]
        ADD      R1,SP,#+0
        ADD      R0,SP,#+4
          CFI FunCall _ZN10duration_tC1ERKj
        BL       _ZN10duration_tC1ERKj
        ADD      R1,SP,#+8
          CFI FunCall _ZNK10duration_t8toStringEPc
        BL       _ZNK10duration_t8toStringEPc
        MOVS     R1,#+0
        ADD      R0,SP,#+8
          CFI FunCall _Z13lcd_setstatusPKcb
        BL       _Z13lcd_setstatusPKcb
        LDR.N    R0,??gcode_M31_0+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        ADD      R1,SP,#+8
        LDR.N    R0,??gcode_M31_0+0x8
          CFI FunCall _Z17serial_echopair_PPKcS0_
        BL       _Z17serial_echopair_PPKcS0_
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M31_0+0xC
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        ADD      SP,SP,#+36
          CFI CFA R13+4
        POP      {PC}             ;; return
        DATA
??gcode_M31_0:
        DC32     card+0xE00
        DC32     echomagic
        DC32     _ZZ9gcode_M31vEs
        DC32     Serial6
          CFI EndBlock cfiBlock282

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M32v
          CFI Block cfiBlock283 Using cfiCommon0
          CFI Function _Z9gcode_M32v
        THUMB
_Z9gcode_M32v:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.N    R4,??gcode_M32_0
        LDRB     R0,[R4, #+2488]
        CMP      R0,#+0
        BEQ.N    ??gcode_M32_1
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
??gcode_M32_1:
        ADDW     R0,R4,#+2488
        LDRB     R1,[R0, #+3]
        LDRB     R0,[R0, #+4]
        ORRS     R0,R0,R1
        BEQ.N    ??gcode_M32_2
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser7boolvalEc
        BL       _ZN11GCodeParser7boolvalEc
        MOV      R5,R0
        MOV      R3,R5
        MOVS     R2,#+1
        LDR.N    R0,??gcode_M32_0+0x4
        LDR      R1,[R0, #+0]
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8openFileEPcbb
        BL       _ZN10CardReader8openFileEPcbb
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M32_3
          CFI FunCall _ZN11GCodeParser10value_longEv
        BL       _ZN11GCodeParser10value_longEv
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8setIndexEl
        BL       _ZN10CardReader8setIndexEl
??gcode_M32_3:
        MOV      R0,R4
          CFI FunCall _ZN10CardReader14startFileprintEv
        BL       _ZN10CardReader14startFileprintEv
        CMP      R5,#+0
        BNE.N    ??gcode_M32_2
        ADD      R0,R4,#+3584
        POP      {R1,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN9Stopwatch5startEv
        B.W      _ZN9Stopwatch5startEv
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??gcode_M32_2:
        POP      {R0,R4,R5,PC}    ;; return
        DATA
??gcode_M32_0:
        DC32     card
        DC32     _ZN11GCodeParser10string_argE
          CFI EndBlock cfiBlock283

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M928v
          CFI Block cfiBlock284 Using cfiCommon0
          CFI Function _Z10gcode_M928v
        THUMB
_Z10gcode_M928v:
        LDR.N    R0,??gcode_M928_0
        LDR      R1,[R0, #+0]
        LDR.N    R0,??gcode_M928_0+0x4
          CFI FunCall _ZN10CardReader11openLogFileEPc
        B.W      _ZN10CardReader11openLogFileEPc
        Nop      
        DATA
??gcode_M928_0:
        DC32     _ZN11GCodeParser10string_argE
        DC32     card
          CFI EndBlock cfiBlock284

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M42v
          CFI Block cfiBlock285 Using cfiCommon0
          CFI Function _Z9gcode_M42v
        THUMB
_Z9gcode_M42v:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M42_0
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        MOV      R4,R0
        MOV      R1,#-1
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser6intvalEcs
        BL       _ZN11GCodeParser6intvalEcs
        MOVS     R5,R0
        BMI.N    ??gcode_M42_0
        SXTB     R0,R0
          CFI FunCall _Z16pin_is_protecteda
        BL       _Z16pin_is_protecteda
        CMP      R0,#+0
        BEQ.N    ??gcode_M42_1
        LDR.N    R0,??gcode_M42_2
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M42_2+0x4
        POP      {R1,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??gcode_M42_1:
        CMP      R5,#+0
        MOV      R2,R4
        SXTB     R2,R2
        BMI.N    ??gcode_M42_3
        LDR.N    R0,??gcode_M42_2+0x8
        LDRH     R1,[R0, R5, LSL #+1]
        LDR.N    R0,??gcode_M42_2+0xC
        LDR      R0,[R0, R5, LSL #+2]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        B.N      ??gcode_M42_4
??gcode_M42_3:
        MOVS     R1,#+0
        MOV      R0,R1
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
??gcode_M42_4:
        CMP      R5,#+8
        BNE.N    ??gcode_M42_0
        LDR.N    R0,??gcode_M42_2+0x10
        STR      R4,[R0, #+0]
??gcode_M42_0:
        POP      {R0,R4,R5,PC}    ;; return
        Nop      
        DATA
??gcode_M42_2:
        DC32     errormagic
        DC32     _ZZ9gcode_M42vEs
        DC32     gArrayGpioPin
        DC32     gArrayGpioPort
        DC32     fanSpeeds
          CFI EndBlock cfiBlock285

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M75v
          CFI Block cfiBlock286 Using cfiCommon0
          CFI Function _Z9gcode_M75v
        THUMB
_Z9gcode_M75v:
        LDR.N    R0,??gcode_M75_0
          CFI FunCall _ZN9Stopwatch5startEv
        B.W      _ZN9Stopwatch5startEv
        Nop      
        DATA
??gcode_M75_0:
        DC32     card+0xE00
          CFI EndBlock cfiBlock286

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M76v
          CFI Block cfiBlock287 Using cfiCommon0
          CFI Function _Z9gcode_M76v
        THUMB
_Z9gcode_M76v:
        LDR.N    R0,??gcode_M76_0
          CFI FunCall _ZN9Stopwatch5pauseEv
        B.W      _ZN9Stopwatch5pauseEv
        Nop      
        DATA
??gcode_M76_0:
        DC32     card+0xE00
          CFI EndBlock cfiBlock287

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M77v
          CFI Block cfiBlock288 Using cfiCommon0
          CFI Function _Z9gcode_M77v
        THUMB
_Z9gcode_M77v:
        LDR.N    R0,??gcode_M77_0
          CFI FunCall _ZN9Stopwatch4stopEv
        B.W      _ZN9Stopwatch4stopEv
        Nop      
        DATA
??gcode_M77_0:
        DC32     card+0xE00
          CFI EndBlock cfiBlock288

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M104v
          CFI Block cfiBlock289 Using cfiCommon0
          CFI Function _Z10gcode_M104v
        THUMB
_Z10gcode_M104v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        VPUSH    {D8}
          CFI D8 Frame(CFA, -16)
          CFI CFA R13+16
        MOVS     R0,#+104
          CFI FunCall _Z32get_target_extruder_from_commandt
        BL       _Z32get_target_extruder_from_commandt
        CMP      R0,#+0
        BNE.N    ??gcode_M104_1
        LDR.N    R4,??gcode_M104_2+0x4
        LDRB     R0,[R4, #+15]
        LSLS     R0,R0,#+28
        BMI.N    ??gcode_M104_1
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M104_3
          CFI FunCall _ZN11GCodeParser13value_celsiusEv
        BL       _ZN11GCodeParser13value_celsiusEv
        VCVT.S32.F32 S0,S0
        VMOV     R1,S0
        LDRB     R0,[R4, #+22]
        SXTH     R1,R1
        VMOV     S0,R1
        VCVT.F32.S32 S0,S0
          CFI FunCall _ZN11Temperature15setTargetHotendEfh
        BL       _ZN11Temperature15setTargetHotendEfh
          CFI FunCall _ZN11GCodeParser13value_celsiusEv
        BL       _ZN11GCodeParser13value_celsiusEv
        VLDR.W   S1,??gcode_M104_2  ;; 0x42aa0001
        VCMP.F32 S0,S1
        FMSTAT   
        BPL.N    ??gcode_M104_4
        LDR.N    R0,??gcode_M104_2+0x8
          CFI FunCall _ZN9Stopwatch4stopEv
        BL       _ZN9Stopwatch4stopEv
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M104_2+0xC
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
??gcode_M104_4:
        LDRB     R0,[R4, #+22]
          CFI FunCall _ZN11Temperature9degHotendEh
        BL       _ZN11Temperature9degHotendEh
        VMOV.F32 S16,S0
          CFI FunCall _ZN11GCodeParser13value_celsiusEv
        BL       _ZN11GCodeParser13value_celsiusEv
        VCMP.F32 S16,S0
        FMSTAT   
        BPL.N    ??gcode_M104_3
        LDRB     R0,[R4, #+22]
        CMP      R0,#+4
        BHI.N    ??gcode_M104_3
        TBB      [PC, R0]
        DATA
??gcode_M104_0:
        DC8      0x3,0x8,0xD,0x12
        DC8      0x17,0x0
        THUMB
??gcode_M104_5:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M104_2+0x10
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        B.N      ??gcode_M104_3
??gcode_M104_6:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M104_2+0x14
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        B.N      ??gcode_M104_3
??gcode_M104_7:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M104_2+0x18
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        B.N      ??gcode_M104_3
??gcode_M104_8:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M104_2+0x1C
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        B.N      ??gcode_M104_3
??gcode_M104_9:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M104_2+0x20
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
??gcode_M104_3:
        VPOP     {D8}
          CFI D8 SameValue
          CFI CFA R13+8
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Planner18autotemp_M104_M109Ev
        B.W      _ZN7Planner18autotemp_M104_M109Ev
          CFI D8 Frame(CFA, -16)
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??gcode_M104_1:
        VPOP     {D8}
          CFI D8 SameValue
          CFI CFA R13+8
        POP      {R4,PC}          ;; return
        DATA
??gcode_M104_2:
        DC32     0x42aa0001
        DC32     axis_relative_modes
        DC32     card+0xE00
        DC32     _ZZ10gcode_M104vEs
        DC32     _ZZ10gcode_M104vEs_0
        DC32     _ZZ10gcode_M104vEs_1
        DC32     _ZZ10gcode_M104vEs_2
        DC32     _ZZ10gcode_M104vEs_3
        DC32     _ZZ10gcode_M104vEs_4
          CFI EndBlock cfiBlock289

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M105v
          CFI Block cfiBlock290 Using cfiCommon0
          CFI Function _Z10gcode_M105v
        THUMB
_Z10gcode_M105v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+105
          CFI FunCall _Z32get_target_extruder_from_commandt
        BL       _Z32get_target_extruder_from_commandt
        CMP      R0,#+0
        BNE.N    ??gcode_M105_0
        LDR.N    R0,??gcode_M105_1
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M105_1+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M105_1+0x8
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M105_0:
        POP      {R0,PC}          ;; return
        Nop      
        DATA
??gcode_M105_1:
        DC32     errormagic
        DC32     _ZZ10gcode_M105vEs
        DC32     Serial6
          CFI EndBlock cfiBlock290

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M106v
          CFI Block cfiBlock291 Using cfiCommon0
          CFI Function _Z10gcode_M106v
        THUMB
_Z10gcode_M106v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R1,#+0
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser7bytevalEch
        BL       _ZN11GCodeParser7bytevalEch
        CMP      R0,#+0
        BNE.N    ??gcode_M106_0
        MOVS     R1,#+255
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser9ushortvalEct
        BL       _ZN11GCodeParser9ushortvalEct
        MOVS     R1,#+255
        CMP      R0,#+255
        BGT.N    ??gcode_M106_1
        MOV      R1,R0
??gcode_M106_1:
        LDR.N    R2,??gcode_M106_2
        STR      R1,[R2, #+0]
        MOVW     R1,#+10000
        MULS     R0,R1,R0
        MOVS     R1,#+255
        SDIV     R0,R0,R1
        LDR.N    R1,??gcode_M106_2+0x4  ;; 0x42408288
        STR      R0,[R1, #+0]
??gcode_M106_0:
        POP      {R0,PC}          ;; return
        DATA
??gcode_M106_2:
        DC32     fanSpeeds
        DC32     0x42408288
          CFI EndBlock cfiBlock291

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M107v
          CFI Block cfiBlock292 Using cfiCommon0
          CFI Function _Z10gcode_M107v
        THUMB
_Z10gcode_M107v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R1,#+0
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser9ushortvalEct
        BL       _ZN11GCodeParser9ushortvalEct
        CMP      R0,#+0
        BNE.N    ??gcode_M107_0
        MOVS     R0,#+0
        LDR.N    R1,??gcode_M107_1
        STR      R0,[R1, #+0]
        LDR.N    R1,??gcode_M107_1+0x4  ;; 0x42408288
        STR      R0,[R1, #+0]
??gcode_M107_0:
        POP      {R0,PC}          ;; return
        Nop      
        DATA
??gcode_M107_1:
        DC32     fanSpeeds
        DC32     0x42408288
          CFI EndBlock cfiBlock292

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M108v
          CFI Block cfiBlock293 Using cfiCommon0
          CFI Function _Z10gcode_M108v
          CFI NoCalls
        THUMB
_Z10gcode_M108v:
        MOVS     R0,#+0
        LDR.N    R1,??gcode_M108_0
        STRB     R0,[R1, #+21]
        BX       LR               ;; return
        DATA
??gcode_M108_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock293

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M112v
          CFI Block cfiBlock294 Using cfiCommon0
          CFI Function _Z10gcode_M112v
        THUMB
_Z10gcode_M112v:
        LDR.N    R0,??gcode_M112_0
          CFI FunCall _Z4killPKc
        B.W      _Z4killPKc
        Nop      
        DATA
??gcode_M112_0:
        DC32     _ZZ10gcode_M112vEs
          CFI EndBlock cfiBlock294

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M410v
          CFI Block cfiBlock295 Using cfiCommon0
          CFI Function _Z10gcode_M410v
          CFI FunCall _Z17quickstop_stepperv
        THUMB
_Z10gcode_M410v:
        B.W      _Z17quickstop_stepperv
          CFI EndBlock cfiBlock295

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M109v
          CFI Block cfiBlock296 Using cfiCommon0
          CFI Function _Z10gcode_M109v
        THUMB
_Z10gcode_M109v:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        VPUSH    {D8}
          CFI D8 Frame(CFA, -48)
          CFI CFA R13+48
        MOVS     R0,#+109
          CFI FunCall _Z32get_target_extruder_from_commandt
        BL       _Z32get_target_extruder_from_commandt
        CMP      R0,#+0
        BNE.W    ??gcode_M109_1
        LDR.N    R4,??gcode_M109_2+0xC
        LDRB     R0,[R4, #+15]
        LSLS     R0,R0,#+28
        BMI.W    ??gcode_M109_1
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        MOVS     R5,R0
        BNE.N    ??gcode_M109_3
        MOVS     R0,#+82
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.W    ??gcode_M109_1
??gcode_M109_3:
          CFI FunCall _ZN11GCodeParser13value_celsiusEv
        BL       _ZN11GCodeParser13value_celsiusEv
        VCVT.S32.F32 S0,S0
        VMOV     R1,S0
        LDRB     R0,[R4, #+22]
        SXTH     R1,R1
        VMOV     S0,R1
        VCVT.F32.S32 S0,S0
          CFI FunCall _ZN11Temperature15setTargetHotendEfh
        BL       _ZN11Temperature15setTargetHotendEfh
        LDR.N    R6,??gcode_M109_2+0x10
          CFI FunCall _ZN11GCodeParser13value_celsiusEv
        BL       _ZN11GCodeParser13value_celsiusEv
        VLDR.W   S1,??gcode_M109_2  ;; 0x42aa0001
        VCMP.F32 S0,S1
        FMSTAT   
        MOV      R0,R6
        BPL.N    ??gcode_M109_4
          CFI FunCall _ZN9Stopwatch4stopEv
        BL       _ZN9Stopwatch4stopEv
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M109_2+0x14
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        B.N      ??gcode_M109_5
??gcode_M109_4:
          CFI FunCall _ZN9Stopwatch5startEv
        BL       _ZN9Stopwatch5startEv
??gcode_M109_5:
        LDRB     R0,[R4, #+22]
          CFI FunCall _ZN11Temperature9degHotendEh
        BL       _ZN11Temperature9degHotendEh
        VMOV.F32 S16,S0
          CFI FunCall _ZN11GCodeParser13value_celsiusEv
        BL       _ZN11GCodeParser13value_celsiusEv
        VCMP.F32 S16,S0
        FMSTAT   
        BPL.N    ??gcode_M109_6
        LDRB     R0,[R4, #+22]
        CMP      R0,#+4
        BHI.N    ??gcode_M109_6
        TBB      [PC, R0]
        DATA
??gcode_M109_0:
        DC8      0x3,0x8,0xD,0x12
        DC8      0x17,0x0
        THUMB
??gcode_M109_7:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M109_2+0x18
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        B.N      ??gcode_M109_6
??gcode_M109_8:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M109_2+0x1C
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        B.N      ??gcode_M109_6
??gcode_M109_9:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M109_2+0x20
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        B.N      ??gcode_M109_6
??gcode_M109_10:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M109_2+0x24
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        B.N      ??gcode_M109_6
??gcode_M109_11:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M109_2+0x28
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
??gcode_M109_6:
          CFI FunCall _ZN7Planner18autotemp_M104_M109Ev
        BL       _ZN7Planner18autotemp_M104_M109Ev
        MOVS     R6,#+0
        VMOV.F32 S16,#-1.0
        VLDR.W   S17,??gcode_M109_2+0x4  ;; 0x461c3c00
        MOV      R7,R6
        MOVS     R0,#+1
        STRB     R0,[R4, #+21]
        MOV      R8,R6
        MOV      R9,R6
        STRB     R0,[R4, #+13]
        LDR.W    R11,??gcode_M109_2+0x2C
??gcode_M109_12:
        LDRB     R10,[R4, #+22]
        MOV      R0,R10
          CFI FunCall _ZN11Temperature15degTargetHotendEh
        BL       _ZN11Temperature15degTargetHotendEh
        VCMP.F32 S16,S0
        FMSTAT   
        BEQ.N    ??gcode_M109_13
        MOV      R0,R10
          CFI FunCall _ZN11Temperature15isCoolingHotendEh
        BL       _ZN11Temperature15isCoolingHotendEh
        MOV      R7,R0
        MOV      R0,R10
          CFI FunCall _ZN11Temperature15degTargetHotendEh
        BL       _ZN11Temperature15degTargetHotendEh
        VMOV.F32 S16,S0
        MOV      R0,R5
        MOV      R1,R7
        TST      R0,R1
        BNE.N    ??gcode_M109_14
??gcode_M109_13:
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        MOV      R10,R0
        SUBS     R0,R10,R8
        BMI.N    ??gcode_M109_15
        ADD      R8,R10,#+1000
        LDR.N    R0,??gcode_M109_2+0x30
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        CMP      R6,#+0
        BEQ.N    ??gcode_M109_16
        MOVS     R2,#+10
        MOVW     R0,#+10000
        SUB      R0,R0,R10
        ADDS     R0,R6,R0
        MOV      R1,#+1000
        UDIV     R1,R0,R1
        MOV      R0,R11
          CFI FunCall _ZN5Print5printEli
        BL       _ZN5Print5printEli
        B.N      ??gcode_M109_17
??gcode_M109_16:
        MOVS     R1,#+63
        MOV      R0,R11
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M109_17:
        MOVS     R1,#+10
        MOV      R0,R11
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M109_15:
          CFI FunCall _Z4idlev
        BL       _Z4idlev
          CFI FunCall _Z19refresh_cmd_timeoutv
        BL       _Z19refresh_cmd_timeoutv
        LDRB     R0,[R4, #+22]
          CFI FunCall _ZN11Temperature9degHotendEh
        BL       _ZN11Temperature9degHotendEh
        VSUB.F32 S1,S16,S0
        VABS.F32 S1,S1
        CMP      R6,#+0
        BNE.N    ??gcode_M109_18
        VMOV.F32 S2,#1.0
        VCMP.F32 S1,S2
        FMSTAT   
        BPL.N    ??gcode_M109_19
        MOV      R6,R10
        B.N      ??gcode_M109_19
??gcode_M109_18:
        VLDR.W   S2,??gcode_M109_2+0x8  ;; 0x40400001
        VCMP.F32 S1,S2
        FMSTAT   
        BLT.N    ??gcode_M109_19
        MOV      R6,R10
??gcode_M109_19:
        CMP      R7,#+0
        BEQ.N    ??gcode_M109_20
        CMP      R9,#+0
        BEQ.N    ??gcode_M109_21
        SUBS     R0,R10,R9
        BMI.N    ??gcode_M109_20
??gcode_M109_21:
        VSUB.F32 S1,S17,S0
        VMOV.F32 S2,#1.5
        VCMP.F32 S1,S2
        FMSTAT   
        BMI.N    ??gcode_M109_14
        ADD      R9,R10,#+59904
        ADD      R9,R9,#+96
        VMOV.F32 S17,S0
??gcode_M109_20:
        LDRB     R0,[R4, #+21]
        CMP      R0,#+0
        BEQ.N    ??gcode_M109_14
        CMP      R6,#+0
        BEQ.N    ??gcode_M109_12
        SUB      R0,R10,R6
        LDR.N    R1,??gcode_M109_2+0x34  ;; 0xffffd8f0
        ADDS     R0,R1,R0
        BMI.N    ??gcode_M109_12
??gcode_M109_14:
        MOVS     R0,#+0
        STRB     R0,[R4, #+13]
        LDRB     R0,[R4, #+21]
        CMP      R0,#+0
        BEQ.N    ??gcode_M109_1
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M109_2+0x38
        VPOP     {D8}
          CFI D8 SameValue
          CFI CFA R13+40
        POP      {R2,R4-R11,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z16lcd_setstatusPGMPKca
        B.W      _Z16lcd_setstatusPGMPKca
          CFI D8 Frame(CFA, -48)
          CFI R4 Frame(CFA, -36)
          CFI R5 Frame(CFA, -32)
          CFI R6 Frame(CFA, -28)
          CFI R7 Frame(CFA, -24)
          CFI R8 Frame(CFA, -20)
          CFI R9 Frame(CFA, -16)
          CFI R10 Frame(CFA, -12)
          CFI R11 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+48
??gcode_M109_1:
        VPOP     {D8}
          CFI D8 SameValue
          CFI CFA R13+40
        POP      {R0,R4-R11,PC}   ;; return
        Nop      
        DATA
??gcode_M109_2:
        DC32     0x42aa0001
        DC32     0x461c3c00
        DC32     0x40400001
        DC32     axis_relative_modes
        DC32     card+0xE00
        DC32     _ZZ10gcode_M109vEs
        DC32     _ZZ10gcode_M109vEs_0
        DC32     _ZZ10gcode_M109vEs_1
        DC32     _ZZ10gcode_M109vEs_2
        DC32     _ZZ10gcode_M109vEs_3
        DC32     _ZZ10gcode_M109vEs_4
        DC32     Serial6
        DC32     _ZZ10gcode_M109vEs_5
        DC32     0xffffd8f0
        DC32     _ZZ10gcode_M109vEs_6
          CFI EndBlock cfiBlock296

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M110v
          CFI Block cfiBlock297 Using cfiCommon0
          CFI Function _Z10gcode_M110v
        THUMB
_Z10gcode_M110v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+78
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M110_0
          CFI FunCall _ZN11GCodeParser10value_longEv
        BL       _ZN11GCodeParser10value_longEv
        LDR.N    R1,??gcode_M110_1
        STR      R0,[R1, #+112]
??gcode_M110_0:
        POP      {R0,PC}          ;; return
        Nop      
        DATA
??gcode_M110_1:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock297

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M111v
          CFI Block cfiBlock298 Using cfiCommon0
          CFI Function _Z10gcode_M111v
        THUMB
_Z10gcode_M111v:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        LDR.N    R4,??gcode_M111_0
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M111_1
        MOVS     R1,#+0
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7bytevalEch
        BL       _ZN11GCodeParser7bytevalEch
        STRB     R0,[R4, #+15]
??gcode_M111_1:
        LDR.N    R0,??gcode_M111_0+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M111_0+0x8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDRB     R0,[R4, #+15]
        CMP      R0,#+0
        BEQ.N    ??gcode_M111_2
        MOVS     R6,#+0
        MOV      R5,R6
??gcode_M111_3:
        CMP      R5,#+5
        BCS.N    ??gcode_M111_4
        LDRB     R0,[R4, #+15]
        MOVS     R1,#+1
        LSLS     R1,R1,R5
        TST      R0,R1
        BEQ.N    ??gcode_M111_5
        MOV      R0,R6
        ADDS     R6,R0,#+1
        UXTB     R0,R0
        CMP      R0,#+0
        BEQ.N    ??gcode_M111_6
        MOVS     R1,#+44
        LDR.N    R0,??gcode_M111_0+0xC
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M111_6:
        LDR.N    R0,??gcode_M111_0+0x10
        ADD      R0,R0,R5, LSL #+2
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_M111_5:
        ADDS     R5,R5,#+1
        B.N      ??gcode_M111_3
??gcode_M111_2:
        LDR.N    R0,??gcode_M111_0+0x14
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_M111_4:
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M111_0+0xC
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
        Nop      
        DATA
??gcode_M111_0:
        DC32     axis_relative_modes
        DC32     echomagic
        DC32     _ZZ10gcode_M111vEs_4
        DC32     Serial6
        DC32     _ZZ10gcode_M111vE13debug_strings
        DC32     _ZZ10gcode_M111vEs_5
          CFI EndBlock cfiBlock298

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M140v
          CFI Block cfiBlock299 Using cfiCommon0
          CFI Function _Z10gcode_M140v
        THUMB
_Z10gcode_M140v:
        LDR.N    R0,??gcode_M140_0
        LDRB     R0,[R0, #+15]
        LSLS     R0,R0,#+28
        BPL.N    ??gcode_M140_1
        BX       LR
??gcode_M140_1:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M140_2
          CFI FunCall _ZN11GCodeParser13value_celsiusEv
        BL       _ZN11GCodeParser13value_celsiusEv
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN11Temperature12setTargetBedEf
        B.W      _ZN11Temperature12setTargetBedEf
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M140_2:
        POP      {R0,PC}          ;; return
        DATA
??gcode_M140_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock299

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M81v
          CFI Block cfiBlock300 Using cfiCommon0
          CFI Function _Z9gcode_M81v
        THUMB
_Z9gcode_M81v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
          CFI FunCall _ZN7Stepper18finish_and_disableEv
        BL       _ZN7Stepper18finish_and_disableEv
        MOVS     R0,#+0
        LDR.N    R1,??gcode_M81_0
        B.N      ??gcode_M81_1
??gcode_M81_2:
        MOVS     R0,#+0
        STR      R0,[R1, #+0]
        MOVS     R0,#+1
??gcode_M81_1:
        CMP      R0,#+0
        BEQ.N    ??gcode_M81_2
        MOV      R0,#+1000
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z10safe_delaym
        B.W      _Z10safe_delaym
        Nop      
        DATA
??gcode_M81_0:
        DC32     fanSpeeds
          CFI EndBlock cfiBlock300

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M82v
          CFI Block cfiBlock301 Using cfiCommon0
          CFI Function _Z9gcode_M82v
          CFI NoCalls
        THUMB
_Z9gcode_M82v:
        MOVS     R0,#+0
        LDR.N    R1,??gcode_M82_0
        STRB     R0,[R1, #+3]
        BX       LR               ;; return
        DATA
??gcode_M82_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock301

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M83v
          CFI Block cfiBlock302 Using cfiCommon0
          CFI Function _Z9gcode_M83v
          CFI NoCalls
        THUMB
_Z9gcode_M83v:
        MOVS     R0,#+1
        LDR.N    R1,??gcode_M83_0
        STRB     R0,[R1, #+3]
        BX       LR               ;; return
        DATA
??gcode_M83_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock302

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z13gcode_M18_M84v
          CFI Block cfiBlock303 Using cfiCommon0
          CFI Function _Z13gcode_M18_M84v
        THUMB
_Z13gcode_M18_M84v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M18_M84_0
          CFI FunCall _ZN11GCodeParser25value_millis_from_secondsEv
        BL       _ZN11GCodeParser25value_millis_from_secondsEv
        LDR.N    R1,??gcode_M18_M84_1
        STR      R0,[R1, #+8]
        POP      {R0,PC}
??gcode_M18_M84_0:
        MOVS     R0,#+88
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BNE.N    ??gcode_M18_M84_2
        MOVS     R0,#+89
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BNE.N    ??gcode_M18_M84_2
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BNE.N    ??gcode_M18_M84_2
        MOVS     R0,#+69
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        AND      R0,R0,#0x1
        EOR      R0,R0,#0x1
        B.N      ??gcode_M18_M84_3
??gcode_M18_M84_2:
        MOVS     R0,#+0
??gcode_M18_M84_3:
        CMP      R0,#+0
        BEQ.N    ??gcode_M18_M84_4
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Stepper18finish_and_disableEv
        B.W      _ZN7Stepper18finish_and_disableEv
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M18_M84_4:
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        MOVS     R0,#+88
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOVS     R0,#+89
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M18_M84_5
        MOVS     R2,#+1
        LDR.N    R0,??gcode_M18_M84_1+0x4
        LDRH     R1,[R0, #+4]
        LDR.N    R0,??gcode_M18_M84_1+0x8
        LDR      R0,[R0, #+8]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        LDR.N    R1,??gcode_M18_M84_1+0xC
        STRB     R0,[R1, #+10]
??gcode_M18_M84_5:
        POP      {R0,PC}          ;; return
        Nop      
        DATA
??gcode_M18_M84_1:
        DC32     previous_cmd_ms
        DC32     gArrayGpioPin
        DC32     gArrayGpioPort
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock303

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M85v
          CFI Block cfiBlock304 Using cfiCommon0
          CFI Function _Z9gcode_M85v
        THUMB
_Z9gcode_M85v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M85_0
          CFI FunCall _ZN11GCodeParser25value_millis_from_secondsEv
        BL       _ZN11GCodeParser25value_millis_from_secondsEv
        LDR.N    R1,??gcode_M85_1
        STR      R0,[R1, #+4]
??gcode_M85_0:
        POP      {R0,PC}          ;; return
        Nop      
        DATA
??gcode_M85_1:
        DC32     previous_cmd_ms
          CFI EndBlock cfiBlock304

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M92v
          CFI Block cfiBlock305 Using cfiCommon0
          CFI Function _Z9gcode_M92v
        THUMB
_Z9gcode_M92v:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R4,#+0
        LDR.N    R5,??gcode_M92_0
        B.N      ??gcode_M92_1
??gcode_M92_2:
        MOV      R0,R4
        SXTB     R0,R0
          CFI FunCall _ZN11GCodeParser19value_per_axis_unitE8AxisEnum
        BL       _ZN11GCodeParser19value_per_axis_unitE8AxisEnum
        ADD      R0,R5,R4, LSL #+2
        VSTR     S0,[R0, #0]
??gcode_M92_3:
        ADDS     R4,R4,#+1
??gcode_M92_1:
        CMP      R4,#+4
        BGE.N    ??gcode_M92_4
        LDR.N    R0,??gcode_M92_0+0x4
        LDRSB    R0,[R4, R0]
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M92_3
        CMP      R4,#+3
        BNE.N    ??gcode_M92_2
        MOVS     R0,#+3
          CFI FunCall _ZN11GCodeParser19value_per_axis_unitE8AxisEnum
        BL       _ZN11GCodeParser19value_per_axis_unitE8AxisEnum
        VMOV.F32 S1,#20.0
        VCMP.F32 S0,S1
        FMSTAT   
        BPL.N    ??gcode_M92_5
        VLDR     S1,[R5, #+12]
        VDIV.F32 S1,S1,S0
        LDR.N    R0,??gcode_M92_0+0x8
        VLDR     S2,[R0, #+12]
        VMUL.F32 S2,S2,S1
        VSTR     S2,[R0, #+12]
        LDR.N    R0,??gcode_M92_0+0xC
        VLDR     S2,[R0, #+12]
        VMUL.F32 S2,S2,S1
        VSTR     S2,[R0, #+12]
        LDR.N    R0,??gcode_M92_0+0x10
        VLDR     S2,[R0, #+12]
        VCVT.F32.U32 S2,S2
        VMUL.F32 S1,S2,S1
        VCVT.U32.F32 S1,S1
        VSTR     S1,[R0, #+12]
??gcode_M92_5:
        VSTR     S0,[R5, #+12]
        B.N      ??gcode_M92_3
??gcode_M92_4:
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Planner19refresh_positioningEv
        B.W      _ZN7Planner19refresh_positioningEv
        Nop      
        DATA
??gcode_M92_0:
        DC32     _ZN7Planner17axis_steps_per_mmE
        DC32     axis_codes
        DC32     _ZN7Planner8max_jerkE
        DC32     _ZN7Planner17max_feedrate_mm_sE
        DC32     _ZN7Planner29max_acceleration_steps_per_s2E
          CFI EndBlock cfiBlock305

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M114v
          CFI Block cfiBlock306 Using cfiCommon0
          CFI Function _Z10gcode_M114v
        THUMB
_Z10gcode_M114v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z23report_current_positionv
        B.W      _Z23report_current_positionv
          CFI EndBlock cfiBlock306

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M115v
          CFI Block cfiBlock307 Using cfiCommon0
          CFI Function _Z10gcode_M115v
        THUMB
_Z10gcode_M115v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??gcode_M115_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M115_0+0x4
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+1
        LDR.N    R0,??gcode_M115_0+0x8
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+1
        LDR.N    R0,??gcode_M115_0+0xC
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+1
        LDR.N    R0,??gcode_M115_0+0x10
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M115_0+0x14
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+1
        LDR.N    R0,??gcode_M115_0+0x18
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M115_0+0x1C
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M115_0+0x20
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M115_0+0x24
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M115_0+0x28
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M115_0+0x2C
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M115_0+0x30
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M115_0+0x34
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M115_0+0x38
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z8cap_linePKcb
        B.W      _Z8cap_linePKcb
        DATA
??gcode_M115_0:
        DC32     _ZZ10gcode_M115vEs
        DC32     _ZZ10gcode_M115vEs_0
        DC32     _ZZ10gcode_M115vEs_1
        DC32     _ZZ10gcode_M115vEs_2
        DC32     _ZZ10gcode_M115vEs_3
        DC32     _ZZ10gcode_M115vEs_4
        DC32     _ZZ10gcode_M115vEs_5
        DC32     _ZZ10gcode_M115vEs_6
        DC32     _ZZ10gcode_M115vEs_7
        DC32     _ZZ10gcode_M115vEs_8
        DC32     _ZZ10gcode_M115vEs_9
        DC32     _ZZ10gcode_M115vEs__10_
        DC32     _ZZ10gcode_M115vEs__11_
        DC32     _ZZ10gcode_M115vEs__12_
        DC32     _ZZ10gcode_M115vEs__13_
          CFI EndBlock cfiBlock307

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M117v
          CFI Block cfiBlock308 Using cfiCommon0
          CFI Function _Z10gcode_M117v
        THUMB
_Z10gcode_M117v:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M117_0
        LDR      R0,[R0, #+0]
          CFI FunCall _Z13lcd_setstatusPKcb
        B.W      _Z13lcd_setstatusPKcb
        Nop      
        DATA
??gcode_M117_0:
        DC32     _ZN11GCodeParser10string_argE
          CFI EndBlock cfiBlock308

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M118v
          CFI Block cfiBlock309 Using cfiCommon0
          CFI Function _Z10gcode_M118v
        THUMB
_Z10gcode_M118v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R0,#+69
          CFI FunCall _ZN11GCodeParser7boolvalEc
        BL       _ZN11GCodeParser7boolvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M118_0
        LDR.N    R0,??gcode_M118_1
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_M118_0:
        MOVS     R0,#+65
          CFI FunCall _ZN11GCodeParser7boolvalEc
        BL       _ZN11GCodeParser7boolvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M118_2
        LDR.N    R0,??gcode_M118_1+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_M118_2:
        LDR.N    R4,??gcode_M118_1+0x8
        LDR.N    R0,??gcode_M118_1+0xC
        LDR      R1,[R0, #+0]
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEPKc
        BL       _ZN5Print5printEPKc
        MOVS     R1,#+10
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
        Nop      
        DATA
??gcode_M118_1:
        DC32     echomagic
        DC32     _ZZ10gcode_M118vEs
        DC32     Serial6
        DC32     _ZN11GCodeParser10string_argE
          CFI EndBlock cfiBlock309

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M119v
          CFI Block cfiBlock310 Using cfiCommon0
          CFI Function _Z10gcode_M119v
          CFI FunCall _ZN8Endstops4M119Ev
        THUMB
_Z10gcode_M119v:
        B.W      _ZN8Endstops4M119Ev
          CFI EndBlock cfiBlock310

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M120v
          CFI Block cfiBlock311 Using cfiCommon0
          CFI Function _Z10gcode_M120v
        THUMB
_Z10gcode_M120v:
        MOVS     R0,#+1
          CFI FunCall _ZN8Endstops15enable_globallyEb
        B.W      _ZN8Endstops15enable_globallyEb
          CFI EndBlock cfiBlock311

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M121v
          CFI Block cfiBlock312 Using cfiCommon0
          CFI Function _Z10gcode_M121v
        THUMB
_Z10gcode_M121v:
        MOVS     R0,#+0
          CFI FunCall _ZN8Endstops15enable_globallyEb
        B.W      _ZN8Endstops15enable_globallyEb
          CFI EndBlock cfiBlock312

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M200v
          CFI Block cfiBlock313 Using cfiCommon0
          CFI Function _Z10gcode_M200v
        THUMB
_Z10gcode_M200v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        SUB      SP,SP,#+8
          CFI CFA R13+16
        MOVS     R0,#+200
          CFI FunCall _Z32get_target_extruder_from_commandt
        BL       _Z32get_target_extruder_from_commandt
        CMP      R0,#+0
        BNE.N    ??gcode_M200_0
        MOVS     R0,#+68
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M200_1
        LDR.N    R4,??gcode_M200_2
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        VCMP.F32 S0,#0.0
        FMSTAT   
        BEQ.N    ??gcode_M200_3
        MOVS     R0,#+1
        STRB     R0,[R4, #+0]
        B.N      ??gcode_M200_4
??gcode_M200_3:
        MOVS     R0,#+0
        STRB     R0,[R4, #+0]
??gcode_M200_4:
        LDRB     R0,[R4, #+0]
        CMP      R0,#+0
        BEQ.N    ??gcode_M200_1
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        VSTR     S0,[SP, #+0]
        ADD      R1,SP,#+0
        LDR.N    R0,??gcode_M200_2+0x4
        LDRB     R0,[R0, #+22]
          CFI FunCall _ZN7Planner17set_filament_sizeEhRKf
        BL       _ZN7Planner17set_filament_sizeEhRKf
??gcode_M200_1:
          CFI FunCall _ZN7Planner32calculate_volumetric_multipliersEv
        BL       _ZN7Planner32calculate_volumetric_multipliersEv
??gcode_M200_0:
        POP      {R0,R1,R4,PC}    ;; return
        DATA
??gcode_M200_2:
        DC32     _ZN11GCodeParser18volumetric_enabledE
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock313

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M201v
          CFI Block cfiBlock314 Using cfiCommon0
          CFI Function _Z10gcode_M201v
        THUMB
_Z10gcode_M201v:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R4,#+0
        B.N      ??gcode_M201_0
??gcode_M201_1:
        LDR.N    R0,??gcode_M201_2
        LDRSB    R0,[R4, R0]
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M201_3
        MOV      R5,R4
        MOV      R0,R5
        SXTB     R0,R0
          CFI FunCall _ZN11GCodeParser16value_axis_unitsE8AxisEnum
        BL       _ZN11GCodeParser16value_axis_unitsE8AxisEnum
        VCVT.U32.F32 S0,S0
        LDR.N    R0,??gcode_M201_2+0x4
        ADD      R0,R0,R5, LSL #+2
        VSTR     S0,[R0, #0]
??gcode_M201_3:
        ADDS     R4,R4,#+1
??gcode_M201_0:
        CMP      R4,#+4
        BLT.N    ??gcode_M201_1
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Planner24reset_acceleration_ratesEv
        B.W      _ZN7Planner24reset_acceleration_ratesEv
        DATA
??gcode_M201_2:
        DC32     axis_codes
        DC32     _ZN7Planner26max_acceleration_mm_per_s2E
          CFI EndBlock cfiBlock314

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M203v
          CFI Block cfiBlock315 Using cfiCommon0
          CFI Function _Z10gcode_M203v
        THUMB
_Z10gcode_M203v:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R4,#+0
        B.N      ??gcode_M203_0
??gcode_M203_1:
        LDR.N    R0,??gcode_M203_2
        LDRSB    R0,[R4, R0]
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M203_3
        MOV      R5,R4
        MOV      R0,R5
        SXTB     R0,R0
          CFI FunCall _ZN11GCodeParser16value_axis_unitsE8AxisEnum
        BL       _ZN11GCodeParser16value_axis_unitsE8AxisEnum
        LDR.N    R0,??gcode_M203_2+0x4
        ADD      R0,R0,R5, LSL #+2
        VSTR     S0,[R0, #0]
??gcode_M203_3:
        ADDS     R4,R4,#+1
??gcode_M203_0:
        CMP      R4,#+4
        BLT.N    ??gcode_M203_1
        POP      {R0,R4,R5,PC}    ;; return
        Nop      
        DATA
??gcode_M203_2:
        DC32     axis_codes
        DC32     _ZN7Planner17max_feedrate_mm_sE
          CFI EndBlock cfiBlock315

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M204v
          CFI Block cfiBlock316 Using cfiCommon0
          CFI Function _Z10gcode_M204v
        THUMB
_Z10gcode_M204v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M204_0
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R0,??gcode_M204_1
        VSTR     S0,[R0, #0]
        LDR.N    R0,??gcode_M204_1+0x4
        VSTR     S0,[R0, #0]
        LDR.N    R0,??gcode_M204_1+0x8
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M204_1+0xC
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M204_0:
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M204_2
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R0,??gcode_M204_1
        VSTR     S0,[R0, #0]
        LDR.N    R0,??gcode_M204_1+0x10
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M204_1+0xC
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M204_2:
        MOVS     R0,#+82
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M204_3
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R0,??gcode_M204_1+0x14
        VSTR     S0,[R0, #0]
        LDR.N    R0,??gcode_M204_1+0x18
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M204_1+0xC
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M204_3:
        MOVS     R0,#+84
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M204_4
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R0,??gcode_M204_1+0x4
        VSTR     S0,[R0, #0]
        LDR.N    R0,??gcode_M204_1+0x1C
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M204_1+0xC
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M204_4:
        POP      {R0,PC}          ;; return
        Nop      
        DATA
??gcode_M204_1:
        DC32     _ZN7Planner12accelerationE
        DC32     _ZN7Planner19travel_accelerationE
        DC32     _ZZ10gcode_M204vEs
        DC32     Serial6
        DC32     _ZZ10gcode_M204vEs_0
        DC32     _ZN7Planner20retract_accelerationE
        DC32     _ZZ10gcode_M204vEs_1
        DC32     _ZZ10gcode_M204vEs_2
          CFI EndBlock cfiBlock316

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M205v
          CFI Block cfiBlock317 Using cfiCommon0
          CFI Function _Z10gcode_M205v
        THUMB
_Z10gcode_M205v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M205_0
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R0,??gcode_M205_1
        VSTR     S0,[R0, #0]
??gcode_M205_0:
        MOVS     R0,#+84
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M205_2
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R0,??gcode_M205_1+0x4
        VSTR     S0,[R0, #0]
??gcode_M205_2:
        MOVS     R0,#+66
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M205_3
          CFI FunCall _ZN11GCodeParser11value_ulongEv
        BL       _ZN11GCodeParser11value_ulongEv
        LDR.N    R1,??gcode_M205_1+0x8
        STR      R0,[R1, #+0]
??gcode_M205_3:
        MOVS     R0,#+88
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M205_4
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R0,??gcode_M205_1+0xC
        VSTR     S0,[R0, #0]
??gcode_M205_4:
        MOVS     R0,#+89
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M205_5
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R0,??gcode_M205_1+0xC
        VSTR     S0,[R0, #+4]
??gcode_M205_5:
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M205_6
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R0,??gcode_M205_1+0xC
        VSTR     S0,[R0, #+8]
??gcode_M205_6:
        MOVS     R0,#+69
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M205_7
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R0,??gcode_M205_1+0xC
        VSTR     S0,[R0, #+12]
??gcode_M205_7:
        POP      {R0,PC}          ;; return
        Nop      
        DATA
??gcode_M205_1:
        DC32     _ZN7Planner17min_feedrate_mm_sE
        DC32     _ZN7Planner24min_travel_feedrate_mm_sE
        DC32     _ZN7Planner19min_segment_time_usE
        DC32     _ZN7Planner8max_jerkE
          CFI EndBlock cfiBlock317

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M206v
          CFI Block cfiBlock318 Using cfiCommon0
          CFI Function _Z10gcode_M206v
        THUMB
_Z10gcode_M206v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R4,#+0
        B.N      ??gcode_M206_0
??gcode_M206_1:
        LDR.N    R0,??gcode_M206_2
        LDRSB    R0,[R4, R0]
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M206_3
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        MOV      R0,R4
        SXTB     R0,R0
          CFI FunCall _Z15set_home_offset8AxisEnumf
        BL       _Z15set_home_offset8AxisEnumf
??gcode_M206_3:
        ADDS     R4,R4,#+1
??gcode_M206_0:
        CMP      R4,#+3
        BLT.N    ??gcode_M206_1
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z23report_current_positionv
        B.W      _Z23report_current_positionv
        DATA
??gcode_M206_2:
        DC32     axis_codes
          CFI EndBlock cfiBlock318

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M211v
          CFI Block cfiBlock319 Using cfiCommon0
          CFI Function _Z10gcode_M211v
        THUMB
_Z10gcode_M211v:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        LDR.N    R0,??gcode_M211_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R4,??gcode_M211_0+0x4
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M211_1
          CFI FunCall _ZN11GCodeParser10value_boolEv
        BL       _ZN11GCodeParser10value_boolEv
        STRB     R0,[R4, #+0]
??gcode_M211_1:
        LDR.N    R0,??gcode_M211_0+0x8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDRB     R0,[R4, #+0]
        CMP      R0,#+0
        BEQ.N    ??gcode_M211_2
        LDR.N    R0,??gcode_M211_0+0xC
        B.N      ??gcode_M211_3
??gcode_M211_2:
        LDR.N    R0,??gcode_M211_0+0x10
??gcode_M211_3:
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M211_0+0x14
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R5,??gcode_M211_0+0x18
        VLDR     S0,[R4, #+16]
        VLDR     S1,[R4, #+4]
        VADD.F32 S0,S0,S1
        MOV      R0,R5
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR.N    R6,??gcode_M211_0+0x1C
        VLDR     S0,[R4, #+20]
        VLDR     S1,[R4, #+8]
        VADD.F32 S0,S0,S1
        MOV      R0,R6
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR.N    R7,??gcode_M211_0+0x20
        VLDR     S0,[R4, #+24]
        VLDR     S1,[R4, #+12]
        VADD.F32 S0,S0,S1
        MOV      R0,R7
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR.N    R0,??gcode_M211_0+0x24
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        VLDR     S0,[R4, #+28]
        VLDR     S1,[R4, #+4]
        VADD.F32 S0,S0,S1
        MOV      R0,R5
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        VLDR     S0,[R4, #+32]
        VLDR     S1,[R4, #+8]
        VADD.F32 S0,S0,S1
        MOV      R0,R6
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        VLDR     S0,[R4, #+36]
        VLDR     S1,[R4, #+12]
        VADD.F32 S0,S0,S1
        MOV      R0,R7
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M211_0+0x28
        POP      {R2,R4-R7,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
        Nop      
        DATA
??gcode_M211_0:
        DC32     echomagic
        DC32     soft_endstops_enabled
        DC32     _ZZ10gcode_M211vEs
        DC32     _ZZ10gcode_M211vEs_0
        DC32     _ZZ10gcode_M211vEs_1
        DC32     _ZZ10gcode_M211vEs_2
        DC32     _ZZ10gcode_M211vEs_3
        DC32     _ZZ10gcode_M211vEs_4
        DC32     _ZZ10gcode_M211vEs_5
        DC32     _ZZ10gcode_M211vEs_6
        DC32     Serial6
          CFI EndBlock cfiBlock319

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M220v
          CFI Block cfiBlock320 Using cfiCommon0
          CFI Function _Z10gcode_M220v
        THUMB
_Z10gcode_M220v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M220_0
          CFI FunCall _ZN11GCodeParser9value_intEv
        BL       _ZN11GCodeParser9value_intEv
        LDR.N    R1,??gcode_M220_1
        STRH     R0,[R1, #+32]
??gcode_M220_0:
        POP      {R0,PC}          ;; return
        Nop      
        DATA
??gcode_M220_1:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock320

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M221v
          CFI Block cfiBlock321 Using cfiCommon0
          CFI Function _Z10gcode_M221v
        THUMB
_Z10gcode_M221v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+221
          CFI FunCall _Z32get_target_extruder_from_commandt
        BL       _Z32get_target_extruder_from_commandt
        CMP      R0,#+0
        BNE.N    ??gcode_M221_0
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M221_0
          CFI FunCall _ZN11GCodeParser9value_intEv
        BL       _ZN11GCodeParser9value_intEv
        LDR.N    R1,??gcode_M221_1
        LDRB     R1,[R1, #+22]
        LDR.N    R2,??gcode_M221_1+0x4
        STRH     R0,[R2, R1, LSL #+1]
        MOV      R0,R1
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Planner16refresh_e_factorEh
        B.W      _ZN7Planner16refresh_e_factorEh
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M221_0:
        POP      {R0,PC}          ;; return
        DATA
??gcode_M221_1:
        DC32     axis_relative_modes
        DC32     _ZN7Planner15flow_percentageE
          CFI EndBlock cfiBlock321

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M226v
          CFI Block cfiBlock322 Using cfiCommon0
          CFI Function _Z10gcode_M226v
        THUMB
_Z10gcode_M226v:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M226_0
          CFI FunCall _ZN11GCodeParser9value_intEv
        BL       _ZN11GCodeParser9value_intEv
        MOV      R4,R0
        MOV      R1,#-1
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser6intvalEcs
        BL       _ZN11GCodeParser6intvalEcs
        MOV      R5,R0
        ADDS     R0,R5,#+1
        CMP      R0,#+3
        BCS.N    ??gcode_M226_0
        CMP      R4,#+0
        BMI.N    ??gcode_M226_0
        MOV      R0,R4
        SXTB     R0,R0
          CFI FunCall _Z16pin_is_protecteda
        BL       _Z16pin_is_protecteda
        CMP      R0,#+0
        BNE.N    ??gcode_M226_0
        MOVS     R6,#+0
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        CMP      R5,#+1
        BEQ.N    ??gcode_M226_1
        CMP      R5,#-1
        BEQ.N    ??gcode_M226_2
        B.N      ??gcode_M226_3
??gcode_M226_1:
        MOVS     R6,#+1
        B.N      ??gcode_M226_3
??gcode_M226_2:
        CMP      R4,#+0
        BPL.N    ??gcode_M226_3
        LDR.N    R0,??gcode_M226_4
        LDRH     R1,[R0, R4, LSL #+1]
        LDR.N    R0,??gcode_M226_4+0x4
        LDR      R0,[R0, R4, LSL #+2]
          CFI FunCall HAL_GPIO_ReadPin
        BL       HAL_GPIO_ReadPin
        MOV      R6,R0
        B.N      ??gcode_M226_3
??gcode_M226_5:
          CFI FunCall _Z4idlev
        BL       _Z4idlev
??gcode_M226_3:
        CMP      R4,#+0
        BMI.N    ??gcode_M226_6
        LDR.N    R0,??gcode_M226_4
        LDRH     R1,[R0, R4, LSL #+1]
        LDR.N    R0,??gcode_M226_4+0x4
        LDR      R0,[R0, R4, LSL #+2]
          CFI FunCall HAL_GPIO_ReadPin
        BL       HAL_GPIO_ReadPin
        B.N      ??gcode_M226_7
??gcode_M226_6:
        MOV      R0,R6
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        MVNS     R0,R0
        LSRS     R0,R0,#+31
??gcode_M226_7:
        CMP      R0,#+0
        BNE.N    ??gcode_M226_5
??gcode_M226_0:
        POP      {R4-R6,PC}       ;; return
        DATA
??gcode_M226_4:
        DC32     gArrayGpioPin
        DC32     gArrayGpioPort
          CFI EndBlock cfiBlock322

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M301v
          CFI Block cfiBlock323 Using cfiCommon0
          CFI Function _Z10gcode_M301v
        THUMB
_Z10gcode_M301v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R1,#+0
        MOVS     R0,#+69
          CFI FunCall _ZN11GCodeParser7bytevalEch
        BL       _ZN11GCodeParser7bytevalEch
        CMP      R0,#+0
        BNE.N    ??gcode_M301_0
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M301_1
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDR.N    R0,??gcode_M301_2
        VSTR     S0,[R0, #0]
??gcode_M301_1:
        MOVS     R0,#+73
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M301_3
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        VMOV     R0,S0
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??gcode_M301_2+0x4  ;; 0x88e368f1
        LDR.N    R3,??gcode_M301_2+0x8  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        LDR.N    R1,??gcode_M301_2+0xC
        STR      R0,[R1, #+0]
??gcode_M301_3:
        LDR.N    R4,??gcode_M301_2+0x10
        MOVS     R0,#+68
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M301_4
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        VMOV     R0,S0
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??gcode_M301_2+0x4  ;; 0x88e368f1
        LDR.N    R3,??gcode_M301_2+0x8  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R4, #+0]
??gcode_M301_4:
          CFI FunCall _ZN11Temperature9updatePIDEv
        BL       _ZN11Temperature9updatePIDEv
        LDR.N    R0,??gcode_M301_2+0x14
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M301_2
        VLDR     S0,[R0, #0]
        LDR.N    R0,??gcode_M301_2+0x18
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR.N    R0,??gcode_M301_2+0xC
        LDR      R0,[R0, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??gcode_M301_2+0x4  ;; 0x88e368f1
        LDR.N    R3,??gcode_M301_2+0x8  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        VMOV     D0,R0,R1
        LDR.N    R0,??gcode_M301_2+0x1C
          CFI FunCall _Z17serial_echopair_PPKcd
        BL       _Z17serial_echopair_PPKcd
        LDR      R0,[R4, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??gcode_M301_2+0x4  ;; 0x88e368f1
        LDR.N    R3,??gcode_M301_2+0x8  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        VMOV     D0,R0,R1
        LDR.N    R0,??gcode_M301_2+0x20
          CFI FunCall _Z17serial_echopair_PPKcd
        BL       _Z17serial_echopair_PPKcd
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M301_2+0x24
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M301_0:
        LDR.N    R0,??gcode_M301_2+0x28
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R4,??gcode_M301_2+0x24
        LDR.N    R1,??gcode_M301_2+0x2C
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEPKc
        BL       _ZN5Print5printEPKc
        MOVS     R1,#+10
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
        Nop      
        DATA
??gcode_M301_2:
        DC32     _ZN11Temperature2KpE
        DC32     0x88e368f1
        DC32     0x3fc4f8b5
        DC32     _ZN11Temperature2KiE
        DC32     _ZN11Temperature2KdE
        DC32     echomagic
        DC32     _ZZ10gcode_M301vEs
        DC32     _ZZ10gcode_M301vEs_0
        DC32     _ZZ10gcode_M301vEs_1
        DC32     Serial6
        DC32     errormagic
        DC32     _ZZ10gcode_M301vEs_2
          CFI EndBlock cfiBlock323

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M303v
          CFI Block cfiBlock324 Using cfiCommon0
          CFI Function _Z10gcode_M303v
        THUMB
_Z10gcode_M303v:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOVS     R1,#+0
        MOVS     R0,#+69
          CFI FunCall _ZN11GCodeParser6intvalEcs
        BL       _ZN11GCodeParser6intvalEcs
        MOV      R4,R0
        MOVS     R1,#+5
        MOVS     R0,#+67
          CFI FunCall _ZN11GCodeParser6intvalEcs
        BL       _ZN11GCodeParser6intvalEcs
        MOV      R5,R0
        MOVS     R0,#+85
          CFI FunCall _ZN11GCodeParser7boolvalEc
        BL       _ZN11GCodeParser7boolvalEc
        MOV      R6,R0
        CMP      R4,#+0
        BPL.N    ??gcode_M303_0
        VLDR.W   S0,??gcode_M303_1  ;; 0x46
        B.N      ??gcode_M303_2
??gcode_M303_0:
        VLDR.W   S0,??gcode_M303_1+0x4  ;; 0x96
??gcode_M303_2:
        VCVT.F32.S32 S0,S0
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser10celsiusvalEcf
        BL       _ZN11GCodeParser10celsiusvalEcf
        VCVT.S32.F32 S0,S0
        VMOV     R3,S0
        CMP      R4,#+0
        BNE.N    ??gcode_M303_3
        MOVS     R0,#+0
        LDR.N    R1,??gcode_M303_1+0x8
        STRB     R0,[R1, #+22]
??gcode_M303_3:
        MOV      R2,R6
        MOV      R1,R5
        SXTB     R1,R1
        MOV      R0,R4
        SXTB     R0,R0
        SXTH     R3,R3
        VMOV     S0,R3
        VCVT.F32.S32 S0,S0
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN11Temperature12PID_autotuneEfaab
        B.W      _ZN11Temperature12PID_autotuneEfaab
        DATA
??gcode_M303_1:
        DC32     0x46
        DC32     0x96
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock324

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M400v
          CFI Block cfiBlock325 Using cfiCommon0
          CFI Function _Z10gcode_M400v
          CFI FunCall _ZN7Stepper11synchronizeEv
        THUMB
_Z10gcode_M400v:
        B.W      _ZN7Stepper11synchronizeEv
          CFI EndBlock cfiBlock325

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M428v
          CFI Block cfiBlock326 Using cfiCommon0
          CFI Function _Z10gcode_M428v
        THUMB
_Z10gcode_M428v:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        VPUSH    {D8}
          CFI D8 Frame(CFA, -24)
          CFI CFA R13+24
        SUB      SP,SP,#+16
          CFI CFA R13+40
        MOVS     R0,#+1
          CFI FunCall _Z18axis_unhomed_errorb
        BL       _Z18axis_unhomed_errorb
        CMP      R0,#+0
        BNE.N    ??gcode_M428_0
        MOVS     R4,#+0
        LDR.N    R5,??gcode_M428_1+0x8
        ADD      R6,SP,#+0
        B.N      ??gcode_M428_2
??gcode_M428_3:
        ADDS     R4,R4,#+1
        UXTB     R4,R4
??gcode_M428_2:
        CMP      R4,#+3
        BGE.N    ??gcode_M428_4
        ADD      R0,R5,R4, LSL #+2
        VLDR     S16,[R0, #+36]
        MOV      R0,R4
        SXTB     R0,R0
          CFI FunCall _Z13base_home_pos8AxisEnum
        BL       _Z13base_home_pos8AxisEnum
        VSUB.F32 S0,S0,S16
        ADD      R0,R6,R4, LSL #+2
        VSTR     S0,[R0, #0]
        VLDR     S0,[R5, #+92]
        VLDR     S1,[R5, #+44]
        VSUB.F32 S0,S0,S1
        VSTR     S0,[SP, #+8]
        LDR      R0,[R6, R4, LSL #+2]
        VMOV     S0,R0
        VLDR.W   S17,??gcode_M428_1  ;; 0xc3480000
        VCMP.F32 S0,S17
        FMSTAT   
        BLT.N    ??gcode_M428_5
        VLDR.W   S1,??gcode_M428_1+0x4  ;; 0x43480001
        VCMP.F32 S0,S1
        FMSTAT   
        BMI.N    ??gcode_M428_6
??gcode_M428_5:
        MOV      R0,R4
        SXTB     R0,R0
          CFI FunCall _Z8home_dir8AxisEnum
        BL       _Z8home_dir8AxisEnum
        CMP      R0,#+1
        BLT.N    ??gcode_M428_6
        ADD      R0,R6,R4, LSL #+2
        VNEG.F32 S0,S16
        VSTR     S0,[R0, #0]
??gcode_M428_6:
        LDR      R0,[R6, R4, LSL #+2]
        VMOV     S0,R0
        VCMP.F32 S0,S17
        FMSTAT   
        BLT.N    ??gcode_M428_7
        VLDR.W   S1,??gcode_M428_1+0x4  ;; 0x43480001
        VCMP.F32 S0,S1
        FMSTAT   
        BMI.N    ??gcode_M428_3
??gcode_M428_7:
        LDR.N    R0,??gcode_M428_1+0xC
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M428_1+0x10
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M428_1+0x14
          CFI FunCall _Z21lcd_setalertstatusPGMPKc
        BL       _Z21lcd_setalertstatusPGMPKc
        B.N      ??gcode_M428_0
??gcode_M428_4:
        MOVS     R4,#+0
        B.N      ??gcode_M428_8
??gcode_M428_9:
        ADD      R0,SP,#+0
        ADD      R0,R0,R4, LSL #+2
        VLDR     S0,[R0, #0]
        MOV      R0,R4
        SXTB     R0,R0
          CFI FunCall _Z15set_home_offset8AxisEnumf
        BL       _Z15set_home_offset8AxisEnumf
        ADDS     R4,R4,#+1
??gcode_M428_8:
        CMP      R4,#+3
        BLT.N    ??gcode_M428_9
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M428_1+0x18
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
??gcode_M428_0:
        ADD      SP,SP,#+16
          CFI CFA R13+24
        VPOP     {D8}
          CFI D8 SameValue
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
        Nop      
        DATA
??gcode_M428_1:
        DC32     0xc3480000
        DC32     0x43480001
        DC32     axis_relative_modes
        DC32     errormagic
        DC32     _ZZ10gcode_M428vEs
        DC32     _ZZ10gcode_M428vEs_0
        DC32     _ZZ10gcode_M428vEs_1
          CFI EndBlock cfiBlock326

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M500v
          CFI Block cfiBlock327 Using cfiCommon0
          CFI Function _Z10gcode_M500v
          CFI FunCall _ZN14MarlinSettings4saveEv
        THUMB
_Z10gcode_M500v:
        B.W      _ZN14MarlinSettings4saveEv
          CFI EndBlock cfiBlock327

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M501v
          CFI Block cfiBlock328 Using cfiCommon0
          CFI Function _Z10gcode_M501v
          CFI FunCall _ZN14MarlinSettings4loadEv
        THUMB
_Z10gcode_M501v:
        B.W      _ZN14MarlinSettings4loadEv
          CFI EndBlock cfiBlock328

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M502v
          CFI Block cfiBlock329 Using cfiCommon0
          CFI Function _Z10gcode_M502v
          CFI FunCall _ZN14MarlinSettings5resetEv
        THUMB
_Z10gcode_M502v:
        B.W      _ZN14MarlinSettings5resetEv
          CFI EndBlock cfiBlock329

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M503v
          CFI Block cfiBlock330 Using cfiCommon0
          CFI Function _Z10gcode_M503v
        THUMB
_Z10gcode_M503v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M503_0
          CFI FunCall _ZN11GCodeParser10value_boolEv
        BL       _ZN11GCodeParser10value_boolEv
        AND      R0,R0,#0x1
        EOR      R0,R0,#0x1
        B.N      ??gcode_M503_1
??gcode_M503_0:
        MOVS     R0,#+0
??gcode_M503_1:
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN14MarlinSettings6reportEb
        B.W      _ZN14MarlinSettings6reportEb
          CFI EndBlock cfiBlock330

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M907v
          CFI Block cfiBlock331 Using cfiCommon0
          CFI Function _Z10gcode_M907v
          CFI NoCalls
        THUMB
_Z10gcode_M907v:
        BX       LR               ;; return
          CFI EndBlock cfiBlock331

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M355v
          CFI Block cfiBlock332 Using cfiCommon0
          CFI Function _Z10gcode_M355v
        THUMB
_Z10gcode_M355v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??gcode_M355_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M355_0+0x4
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
        Nop      
        DATA
??gcode_M355_0:
        DC32     errormagic
        DC32     _ZZ10gcode_M355vEs
          CFI EndBlock cfiBlock332

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M999v
          CFI Block cfiBlock333 Using cfiCommon0
          CFI Function _Z10gcode_M999v
        THUMB
_Z10gcode_M999v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+1
        LDR.N    R1,??gcode_M999_0
        STRB     R0,[R1, #+14]
          CFI FunCall _Z21lcd_reset_alert_levelv
        BL       _Z21lcd_reset_alert_levelv
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7boolvalEc
        BL       _ZN11GCodeParser7boolvalEc
        CMP      R0,#+0
        BNE.N    ??gcode_M999_1
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z24FlushSerialRequestResendv
        B.W      _Z24FlushSerialRequestResendv
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M999_1:
        POP      {R0,PC}          ;; return
        DATA
??gcode_M999_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock333

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z22invalid_extruder_errorh
          CFI Block cfiBlock334 Using cfiCommon0
          CFI Function _Z22invalid_extruder_errorh
        THUMB
_Z22invalid_extruder_errorh:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        LDR.N    R0,??invalid_extruder_error_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R5,??invalid_extruder_error_0+0x4
        MOVS     R1,#+84
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        MOVS     R2,#+10
        MOV      R1,R4
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEhi
        BL       _ZN5Print5printEhi
        MOVS     R1,#+32
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        LDR.N    R1,??invalid_extruder_error_0+0x8
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEPKc
        BL       _ZN5Print5printEPKc
        MOVS     R1,#+10
        MOV      R0,R5
        POP      {R2,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
        Nop      
        DATA
??invalid_extruder_error_0:
        DC32     echomagic
        DC32     Serial6
        DC32     _ZZ22invalid_extruder_errorhEs
          CFI EndBlock cfiBlock334

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z7gcode_Th
          CFI Block cfiBlock335 Using cfiCommon0
          CFI Function _Z7gcode_Th
        THUMB
_Z7gcode_Th:
        MOVS     R1,#+0
        VLDR.W   S0,??gcode_T_0   ;; 0x0
          CFI FunCall _Z11tool_changehfb
        B.W      _Z11tool_changehfb
        Nop      
        DATA
??gcode_T_0:
        DC32     0x0
          CFI EndBlock cfiBlock335

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z37prepare_move_to_destination_cartesianv
          CFI Block cfiBlock336 Using cfiCommon0
          CFI Function _Z37prepare_move_to_destination_cartesianv
        THUMB
_Z37prepare_move_to_destination_cartesianv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??prepare_move_to_destination_cartesian_0
        LDRSH    R1,[R0, #+32]
        VMOV     S0,R1
        VCVT.F32.S32 S0,S0
        VLDR     S1,[R0, #+120]
        VMUL.F32 S0,S0,S1
        VMOV     R0,S0
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??prepare_move_to_destination_cartesian_0+0x4  ;; 0x47ae147b
        LDR.N    R3,??prepare_move_to_destination_cartesian_0+0x8  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        VMOV     S0,R0
          CFI FunCall _Z26buffer_line_to_destinationf
        BL       _Z26buffer_line_to_destinationf
        MOVS     R0,#+0
        POP      {R1,PC}          ;; return
        DATA
??prepare_move_to_destination_cartesian_0:
        DC32     axis_relative_modes
        DC32     0x47ae147b
        DC32     0x3f847ae1
          CFI EndBlock cfiBlock336

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10clr_ticketv
          CFI Block cfiBlock337 Using cfiCommon0
          CFI Function _Z10clr_ticketv
          CFI NoCalls
        THUMB
// __interwork __softfp void clr_ticket()
_Z10clr_ticketv:
        cpsid i
        MOVS     R0,#+0
        LDR.N    R1,??clr_ticket_0
        STR      R0,[R1, #+3228]
        cpsie i
        BX       LR               ;; return
        Nop      
        DATA
??clr_ticket_0:
        DC32     card
          CFI EndBlock cfiBlock337

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z12CRC16_XMODEMPhj
          CFI Block cfiBlock338 Using cfiCommon0
          CFI Function _Z12CRC16_XMODEMPhj
          CFI NoCalls
        THUMB
// __interwork __softfp uint16_t CRC16_XMODEM(unsigned char *, unsigned int)
_Z12CRC16_XMODEMPhj:
        PUSH     {R4}
          CFI R4 Frame(CFA, -4)
          CFI CFA R13+4
        MOVS     R2,#+0
??CRC16_XMODEM_0:
        MOV      R3,R1
        SUBS     R1,R3,#+1
        CMP      R3,#+0
        BEQ.N    ??CRC16_XMODEM_1
        LDRB     R3,[R0], #+1
        EOR      R2,R2,R3, LSL #+8
        MOVS     R3,#+0
        B.N      ??CRC16_XMODEM_2
??CRC16_XMODEM_3:
        MOV      R2,R4
        UXTH     R2,R2
??CRC16_XMODEM_4:
        ADDS     R3,R3,#+1
??CRC16_XMODEM_2:
        CMP      R3,#+8
        BGE.N    ??CRC16_XMODEM_0
        LSLS     R4,R2,#+1
        LSLS     R2,R2,#+16
        BPL.N    ??CRC16_XMODEM_3
        EOR      R2,R4,#0x1000
        EOR      R2,R2,#0x21
        UXTH     R2,R2
        B.N      ??CRC16_XMODEM_4
??CRC16_XMODEM_1:
        MOV      R0,R2
        LSRS     R0,R0,#+8
        ORR      R0,R0,R2, LSL #+8
        UXTH     R0,R0
        POP      {R4}
          CFI R4 SameValue
          CFI CFA R13+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock338

        SECTION `.init_array`:CODE:ROOT(2)
        SECTION_TYPE SHT_INIT_ARRAY, 0
        DATA
        DC32    RELOC_ARM_TARGET1 __sti__routine

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        SECTION __DLIB_PERTHREAD:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        SECTION __DLIB_PERTHREAD_init:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        END
// 15513 
// 15514 
// 
//  5 726 bytes in section .bss
//    640 bytes in section .data
//      4 bytes in section .init_array
//  1 821 bytes in section .rodata
// 41 366 bytes in section .text
// 
// 32 986 bytes of CODE  memory (+ 8 384 bytes shared)
//     62 bytes of CONST memory (+ 1 759 bytes shared)
//  6 168 bytes of DATA  memory (+   198 bytes shared)
//
//Errors: none
//Warnings: 164
