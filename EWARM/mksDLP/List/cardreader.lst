###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        16/Apr/2020  18:38:31
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\cardreader.cpp
#    Command line =  
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\cardreader.cpp
#        -D USE_HAL_DRIVER -D STM32F407xx -D STM32F40_41xxx -D USE_HAL_LIB -D
#        MKS_DLP_BOARD -D TFT35 -D USE_STM32F407VET -lC
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM\mksDLP/List\ -lA
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM\mksDLP/List\
#        --diag_suppress Pa050 -o
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM\mksDLP/Obj\ --no_unroll
#        --no_inline --no_tbaa --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4F -e --char_is_signed --fpu=VFPv4_sp --dlib_config
#        "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Inc\ -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Src\ -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/BSP/variant\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/BSP/Components/ssd2828\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/BSP/Components/lcd\
#        -I D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/libstmf4\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Drivers/libstmf4/include\
#        -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../User/ui\ -I
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../User/ui/Multi_language\
#        -I D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../User/ui/QRENCODE\
#        -I D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Middlewares/GUI\
#        -Om --eec++ -I "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\"
#    List file    =  
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM\mksDLP/List\cardreader.lst
#    Object file  =  
#        D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM\mksDLP/Obj\cardreader.o
#
###############################################################################

D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\cardreader.cpp
      1          /**
      2           * Marlin 3D Printer Firmware
      3           * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
      4           *
      5           * Based on Sprinter and grbl.
      6           * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
      7           *
      8           * This program is free software: you can redistribute it and/or modify
      9           * it under the terms of the GNU General Public License as published by
     10           * the Free Software Foundation, either version 3 of the License, or
     11           * (at your option) any later version.
     12           *
     13           * This program is distributed in the hope that it will be useful,
     14           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     15           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     16           * GNU General Public License for more details.
     17           *
     18           * You should have received a copy of the GNU General Public License
     19           * along with this program.  If not, see <http://www.gnu.org/licenses/>.
     20           *
     21           */
     22          #include "Marlin.h"

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp char const *strstr(char const *, char const *)
   \                     _Z6strstrPKcS0_: (+1)
   \   00000000   0x.... 0x....      B.W      __iar_Strstr

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp char *strchr(char *, int)
   \                     _Z6strchrPci: (+1)
   \   00000000   0x.... 0x....      B.W      __iar_Strchr

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp char *strstr(char *, char const *)
   \                     _Z6strstrPcPKc: (+1)
   \   00000000   0x.... 0x....      B.W      __iar_Strstr

    #define MIN_SOFTWARE_ENDSTOPS mksCfg.min_software_endstops	/*--mks cfg--*/
            ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\Configuration.h",824  Warning[Pe047]: 
          incompatible redefinition of macro "MIN_SOFTWARE_ENDSTOPS" (declared
          at line 819)

    #define MAX_SOFTWARE_ENDSTOPS mksCfg.max_software_endstops	/*--mks cfg--*/
            ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\Configuration.h",834  Warning[Pe047]: 
          incompatible redefinition of macro "MAX_SOFTWARE_ENDSTOPS" (declared
          at line 829)

  #define UNUSED(x) ((void)(x))
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver\Inc\stm32f4xx_hal_def.h",87  Warning[Pe047]: 
          incompatible redefinition of macro "UNUSED" (declared at line 101 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marl
          in\macros.h")

  		volatile volatile float desireBedTempBak;
  		         ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Inc\mks_cfg.h",407  Warning[Pe083]: 
          type qualifier specified more than once

  #define strcpy_P(dest, src) strcpy((dest), (src))
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",23  Warning[Pe047]: 
          incompatible redefinition of macro "strcpy_P" (declared at line 93
          of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marl
          in\Marlin_export.h")

  #define strstr_P(a, b) strstr((a), (b))
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",26  Warning[Pe047]: 
          incompatible redefinition of macro "strstr_P" (declared at line 94
          of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marl
          in\Marlin_export.h")

  #define sprintf_P(s, f, ...) sprintf((s), (f), __VA_ARGS__)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",28  Warning[Pe047]: 
          incompatible redefinition of macro "sprintf_P" (declared at line 95
          of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marl
          in\Marlin_export.h")

  #define pgm_read_word_near(addr) pgm_read_word(addr)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",38  Warning[Pe047]: 
          incompatible redefinition of macro "pgm_read_word_near" (declared at
          line 65 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marl
          in\Marlin_export.h")

  #define IS_IWDG_PRESCALER(PRESCALER) (((PRESCALER) == IWDG_Prescaler_4)  || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_iwdg.h",80  Warning[Pe047]: 
          incompatible redefinition of macro "IS_IWDG_PRESCALER" (declared at
          line 209 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_iwdg.h")

  #define IS_IWDG_RELOAD(RELOAD) ((RELOAD) <= 0xFFF)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_iwdg.h",97  Warning[Pe047]: 
          incompatible redefinition of macro "IS_IWDG_RELOAD" (declared at
          line 222 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_iwdg.h")

  #define IS_FSMC_NORSRAM_BANK(BANK) (((BANK) == FSMC_Bank1_NORSRAM1) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",272  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_NORSRAM_BANK" (declared
          at line 834 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_NAND_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",277  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_NAND_BANK" (declared at
          line 855 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_MUX(MUX) (((MUX) == FSMC_DataAddressMux_Disable) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",298  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_MUX" (declared at line
          839 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_MEMORY(MEMORY) (((MEMORY) == FSMC_MemoryType_SRAM) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",311  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_MEMORY" (declared at
          line 842 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_BURSTMODE(STATE) (((STATE) == FSMC_BurstAccessMode_Disable) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",336  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_BURSTMODE" (declared at
          line 894 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ASYNWAIT(STATE) (((STATE) == FSMC_AsynchronousWait_Disable) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",347  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ASYNWAIT" (declared at
          line 915 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_POLARITY(POLARITY) (((POLARITY) == FSMC_WaitSignalPolarity_Low) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",358  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_POLARITY" (declared
          at line 897 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WRAP_MODE(MODE) (((MODE) == FSMC_WrapMode_Disable) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",369  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WRAP_MODE" (declared at
          line 900 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_SIGNAL_ACTIVE(ACTIVE) (((ACTIVE) == FSMC_WaitSignalActive_BeforeWaitState) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",380  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_SIGNAL_ACTIVE"
          (declared at line 903 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WRITE_OPERATION(OPERATION) (((OPERATION) == FSMC_WriteOperation_Disable) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",391  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WRITE_OPERATION"
          (declared at line 906 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAITE_SIGNAL(SIGNAL) (((SIGNAL) == FSMC_WaitSignal_Disable) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",402  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAITE_SIGNAL" (declared
          at line 909 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_EXTENDED_MODE(MODE) (((MODE) == FSMC_ExtendedMode_Disable) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",414  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_EXTENDED_MODE" (declared
          at line 912 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WRITE_BURST(BURST) (((BURST) == FSMC_WriteBurst_Disable) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",426  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WRITE_BURST" (declared
          at line 920 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ADDRESS_SETUP_TIME(TIME) ((TIME) <= 0xF)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",435  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ADDRESS_SETUP_TIME"
          (declared at line 923 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ADDRESS_HOLD_TIME(TIME) ((TIME) <= 0xF)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",443  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ADDRESS_HOLD_TIME"
          (declared at line 925 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_DATASETUP_TIME(TIME) (((TIME) > 0) && ((TIME) <= 0xFF))
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",451  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_DATASETUP_TIME"
          (declared at line 927 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_TURNAROUND_TIME(TIME) ((TIME) <= 0xF)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",459  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_TURNAROUND_TIME"
          (declared at line 929 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_CLK_DIV(DIV) ((DIV) <= 0xF)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",467  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_CLK_DIV" (declared at
          line 934 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_DATA_LATENCY(LATENCY) ((LATENCY) <= 0xF)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",475  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_DATA_LATENCY" (declared
          at line 918 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ACCESS_MODE(MODE) (((MODE) == FSMC_AccessMode_A) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",487  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ACCESS_MODE" (declared
          at line 850 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_FEATURE(FEATURE) (((FEATURE) == FSMC_Waitfeature_Disable) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",508  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_FEATURE" (declared
          at line 858 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ECC_STATE(STATE) (((STATE) == FSMC_ECC_Disable) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",520  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ECC_STATE" (declared at
          line 864 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_ECCPAGE_SIZE(SIZE) (((SIZE) == FSMC_ECCPageSize_256Bytes) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",535  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_ECCPAGE_SIZE" (declared
          at line 867 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_TCLR_TIME(TIME) ((TIME) <= 0xFF)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",548  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_TCLR_TIME" (declared at
          line 874 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_TAR_TIME(TIME) ((TIME) <= 0xFF)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",556  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_TAR_TIME" (declared at
          line 876 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_SETUP_TIME(TIME) ((TIME) <= 0xFF)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",564  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_SETUP_TIME" (declared at
          line 878 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_WAIT_TIME(TIME) ((TIME) <= 0xFF)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",572  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_WAIT_TIME" (declared at
          line 880 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_HOLD_TIME(TIME) ((TIME) <= 0xFF)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",580  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_HOLD_TIME" (declared at
          line 882 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define IS_FSMC_HIZ_TIME(TIME) ((TIME) <= 0xFF)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",588  Warning[Pe047]: 
          incompatible redefinition of macro "IS_FSMC_HIZ_TIME" (declared at
          line 884 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

  #define FSMC_FLAG_FEMPT                          ((uint32_t)0x00000040)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_fsmc.h",613  Warning[Pe047]: 
          incompatible redefinition of macro "FSMC_FLAG_FEMPT" (declared at
          line 530 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_ll_fsmc.h")

    #define assert_param(expr) ((void)0)        
            ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\stm32f4xx_conf.h",149  Warning[Pe047]: 
          incompatible redefinition of macro "assert_param" (declared at line
          431 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\EWARM/../Inc\stm32f4xx_hal_c
          onf.h")

   \                                 In section .text, align 4
   \   __interwork __softfp void serialprintPGM(char const *)
   \                     _Z14serialprintPGMPKc: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xE003             B.N      ??serialprintPGM_0
   \                     ??serialprintPGM_1: (+1)
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x4803             LDR.N    R0,??serialprintPGM_2
   \   0000000A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??serialprintPGM_0: (+1)
   \   0000000E   0xF914 0x1B01      LDRSB    R1,[R4], #+1
   \   00000012   0x0008             MOVS     R0,R1
   \   00000014   0xD1F7             BNE.N    ??serialprintPGM_1
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
   \                     ??serialprintPGM_2:
   \   00000018   0x........         DC32     Serial6
     23          #include "MarlinConfig.h"
     24          #include "fatfs.h"
     25          #include "mks_cfg.h"
     26          #include "mks_reprint.h"

  #define SD_DETECT_INVERTED false
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\cardreader.h",27  Warning[Pe047]: 
          incompatible redefinition of macro "SD_DETECT_INVERTED" (declared at
          line 512 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marl
          in\Configuration_adv.h")

  #define PSTR(s) s
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\cardreader.h",31  Warning[Pe047]: 
          incompatible redefinition of macro "PSTR" (declared at line 63 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marl
          in\Marlin.h")

  #define pgm_read_byte(x) (*(char*)x)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\cardreader.h",32  Warning[Pe047]: 
          incompatible redefinition of macro "pgm_read_byte" (declared at line
          64 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marl
          in\Marlin_export.h")

      static constexpr int8_t next_block_index(const int8_t block_index) { return BLOCK_MOD(block_index + 1); }
             ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\planner.h",582  Warning[Pe815]: 
          type qualifier on return type is meaningless

      static constexpr int8_t prev_block_index(const int8_t block_index) { return BLOCK_MOD(block_index - 1); }
             ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\planner.h",583  Warning[Pe815]: 
          type qualifier on return type is meaningless

        target_temperature[HOTEND_INDEX] = celsius;
                                         ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\temperature.h",397  Warning[Pa093]: 
          implicit conversion from floating point to integer

  #define LONG_FILENAME_LENGTH (13*MAX_VFAT_ENTRIES+1)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\cardreader.h",61  Warning[Pe047]: 
          incompatible redefinition of macro "LONG_FILENAME_LENGTH" (declared
          at line 119 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marl
          in\SdFatConfig.h")

  #define ALLOW_DEPRECATED_FUNCTIONS 0
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\SdFat.h",635  Warning[Pe047]: 
          incompatible redefinition of macro "ALLOW_DEPRECATED_FUNCTIONS"
          (declared at line 67 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marl
          in\SdFatConfig.h")

  #define SPI_SD_INIT_RATE 11
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\SdFat.h",647  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_SD_INIT_RATE" (declared at
          line 79 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marl
          in\SdFatConfig.h")

   \                                 In section .text, align 2
   \   __code __interwork __softfp SdBaseFile::SdBaseFile()
   \                     _ZN10SdBaseFileC1Ev: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7001             STRB     R1,[R0, #+0]
   \   00000004   0x70C1             STRB     R1,[R0, #+3]
   \   00000006   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp bool CardReader::isFileOpen()
   \                     _ZN10CardReader10isFileOpenEv: (+1)
   \   00000000   0xF8D0 0x0200      LDR      R0,[R0, #+512]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD001             BEQ.N    ??isFileOpen_0
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x4770             BX       LR
   \                     ??isFileOpen_0: (+1)
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
     27          #include "usb_host.h"
     28          
     29          #include "draw_ui.h"

  #define IS_SPI_MODE(MODE) (((MODE) == SPI_Mode_Master) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",173  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_MODE" (declared at line
          511 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_DATASIZE(DATASIZE) (((DATASIZE) == SPI_DataSize_16b) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",185  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_DATASIZE" (declared at
          line 523 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_CPOL(CPOL) (((CPOL) == SPI_CPOL_Low) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",197  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_CPOL" (declared at line
          526 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_CPHA(CPHA) (((CPHA) == SPI_CPHA_1Edge) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",209  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_CPHA" (declared at line
          529 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_NSS(NSS) (((NSS) == SPI_NSS_Soft) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",221  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_NSS" (declared at line
          532 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_BAUDRATE_PRESCALER(PRESCALER) (((PRESCALER) == SPI_BaudRatePrescaler_2) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",239  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_BAUDRATE_PRESCALER"
          (declared at line 536 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_FIRST_BIT(BIT) (((BIT) == SPI_FirstBit_MSB) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",257  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_FIRST_BIT" (declared at
          line 545 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_DIRECTION(DIRECTION) (((DIRECTION) == SPI_Direction_Rx) || \
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",400  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_DIRECTION" (declared at
          line 514 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define SPI_FLAG_CRCERR                 ((uint16_t)0x0010)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",442  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_FLAG_CRCERR" (declared at
          line 293 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define SPI_FLAG_MODF                   ((uint16_t)0x0020)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",443  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_FLAG_MODF" (declared at line
          294 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define IS_SPI_CRC_POLYNOMIAL(POLYNOMIAL) ((POLYNOMIAL) >= 0x1)
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",462  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_CRC_POLYNOMIAL" (declared
          at line 554 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define SPI_IT_TXE                   SPI_I2S_IT_TXE
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",473  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_IT_TXE" (declared at line
          280 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define SPI_IT_RXNE                  SPI_I2S_IT_RXNE
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",474  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_IT_RXNE" (declared at line
          281 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define SPI_IT_ERR                   SPI_I2S_IT_ERR
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",475  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_IT_ERR" (declared at line
          282 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define SPI_FLAG_RXNE                SPI_I2S_FLAG_RXNE
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",477  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_FLAG_RXNE" (declared at line
          290 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define SPI_FLAG_TXE                 SPI_I2S_FLAG_TXE
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",478  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_FLAG_TXE" (declared at line
          291 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define SPI_FLAG_OVR                 SPI_I2S_FLAG_OVR
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",479  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_FLAG_OVR" (declared at line
          295 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

  #define SPI_FLAG_BSY                 SPI_I2S_FLAG_BSY
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\libstmf4\include\stm32f4xx_spi.h",480  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_FLAG_BSY" (declared at line
          292 of
          "D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Drivers\STM32F4xx_HAL_Driver
          \Inc\stm32f4xx_hal_spi.h")

    #define FILAMENT_CHANGE_TEXT_EN				"Please click <Load> \nor <unload>,After \npinter pause."
            ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\User\ui\Multi_language\Language_en.h",175  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_EN"
          (declared at line 153)

  #define DIALOG_UNBIND_PRINTER_CN            "Ëß£Èô§ÁªëÂÆö?"
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\User\ui\Multi_language\Language_s_cn.h",258  Warning[Pe047]: 
          incompatible redefinition of macro "DIALOG_UNBIND_PRINTER_CN"
          (declared at line 253)

    #define FILAMENT_CHANGE_TEXT_T_CN				"ÂæÖÊâìÂç∞Ê©üÊö´ÂÅúÂêé,\nË´ãÊåâ<ÈÄ≤Êñô>Êàñ<ÈÄÄÊñô>"
            ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\User\ui\Multi_language\Language_t_cn.h",167  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_T_CN"
          (declared at line 153)

    #define FILAMENT_CHANGE_TEXT_RU				"Please click <Load> \nor <unload>,After \npinter pause."
            ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\User\ui\Multi_language\Language_ru.h",173  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_RU"
          (declared at line 153)

  #define DIALOG_UNBIND_PRINTER_RU            "Unbind the printer?"
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\User\ui\Multi_language\Language_ru.h",270  Warning[Pe047]: 
          incompatible redefinition of macro "DIALOG_UNBIND_PRINTER_RU"
          (declared at line 265)

    #define FILAMENT_CHANGE_TEXT_FR				"Please click <Load> \nor <unload>,After \npinter pause."
            ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\User\ui\Multi_language\Language_fr.h",173  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_FR"
          (declared at line 153)

  #define DIALOG_UNBIND_PRINTER_FR        "Unbind the printer?"
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\User\ui\Multi_language\Language_fr.h",273  Warning[Pe047]: 
          incompatible redefinition of macro "DIALOG_UNBIND_PRINTER_FR"
          (declared at line 269)

    #define FILAMENT_CHANGE_TEXT_SP				"Please click <Load> \nor <unload>,After \npinter pause."
            ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\User\ui\Multi_language\Language_sp.h",173  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_SP"
          (declared at line 154)

    #define FILAMENT_CHANGE_TEXT_IT				"Please click <Load> \nor <unload>,After \npinter pause."
            ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\User\ui\Multi_language\Language_it.h",173  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_IT"
          (declared at line 153)

  #define DIALOG_UNBIND_PRINTER_IT                "Unbind the printer?"
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\User\ui\Multi_language\Language_it.h",269  Warning[Pe047]: 
          incompatible redefinition of macro "DIALOG_UNBIND_PRINTER_IT"
          (declared at line 264)

  #define FILAMENT_CHANGE_TEXT_JP				"Please click <Load> \nor <unload>,After \npinter pause."
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\User\ui\Multi_language\Multi_language.h",705  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_JP"
          (declared at line 698)

  #define FILAMENT_CHANGE_TEXT_GN				"Please click <Load> \nor <unload>,After \npinter pause."
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\User\ui\Multi_language\Multi_language.h",913  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_GN"
          (declared at line 907)

  #define Simple_Dec"ºı…Ÿ"
                    ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\User\ui\draw_ui.h",499  Warning[Pe1649]: 
          white space is required between the macro name "Simple_Dec" and its
          replacement text

  #define Simple_Speed "ÀŸ∂»"
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\User\ui\draw_ui.h",554  Warning[Pe047]: 
          incompatible redefinition of macro "Simple_Speed" (declared at line
          551)

  #define Complex_Speed "ÀŸ∂»"
          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\User\ui\draw_ui.h",555  Warning[Pe047]: 
          incompatible redefinition of macro "Complex_Speed" (declared at line
          552)
     30          
     31          
     32          #if ENABLED(SDSUPPORT)
     33          
     34          
     35          #include "cardreader.h"
     36          
     37          //#include "ultralcd.h"
     38          //#include "stepper.h"
     39          //#include "language.h"
     40          
     41          //#define LONGEST_FILENAME (longFilename[0] ? longFilename : filename)
     42          

   \                                 In section .text, align 2, keep-with-next
     43          CardReader::CardReader() {
   \                     _ZN10CardReaderC1Ev: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xF504 0x608E      ADD      R0,R4,#+1136
   \   00000008   0x.... 0x....      BL       _ZN10SdBaseFileC1Ev
     44              sdmode = 0;			
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xF884 0x046C      STRB     R0,[R4, #+1132]
     45          	sdprinting = false;
   \   00000012   0xF884 0x09B8      STRB     R0,[R4, #+2488]
     46          	cardOK = false;	
   \   00000016   0xF604 0x10B8      ADDW     R0,R4,#+2488
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x70C1             STRB     R1,[R0, #+3]
     47          	usbOK = false;
   \   0000001E   0x7101             STRB     R1,[R0, #+4]
     48              savetosd = false;
   \   00000020   0xF884 0x146D      STRB     R1,[R4, #+1133]
     49          	udisk_start_tick = 0;
   \   00000024   0x6081             STR      R1,[R0, #+8]
     50          }
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
     51          

   \                                 In section .text, align 2, keep-with-next
     52          void CardReader::automount()	{}
   \                     _ZN10CardReader9automountEv: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
     53          void CardReader::checkautostart(bool force)
     54          {
   \                     _ZN10CardReader14checkautostartEb: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
     55            if(usbOK == false)        //U?®¨??®ÆD1®∞??
   \   00000004   0xF604 0x15B8      ADDW     R5,R4,#+2488
   \   00000008   0x7928             LDRB     R0,[R5, #+4]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD115             BNE.N    ??checkautostart_0
     56            {
     57              if (SD_DET_IP != SD_DETECT_INVERTED)    
     58              {
     59                  if(cardOK || sdprinting)   // Card removed
   \   0000000E   0x78E8             LDRB     R0,[R5, #+3]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD103             BNE.N    ??checkautostart_1
   \   00000014   0xF894 0x09B8      LDRB     R0,[R4, #+2488]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD00E             BEQ.N    ??checkautostart_0
     60                  {
     61          			SERIAL_ECHO_START();
   \                     ??checkautostart_1: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable59_1
   \   00000020   0x.... 0x....      BL       _Z14serialprintPGMPKc
     62          			SERIAL_ECHOLNPGM("SD card removed");
   \   00000024   0x.... 0x....      ADR.W    R0,`?<Constant "SD card removed\\n">`
   \   00000028   0x.... 0x....      BL       _Z14serialprintPGMPKc
     63                      
     64                      FATFS_UnLinkDriver(SD_Path); 
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable59_3
   \   00000030   0x.... 0x....      BL       FATFS_UnLinkDriver
     65                      unmount();
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x.... 0x....      BL       _ZN10CardReader7unmountEv
     66                  }
     67              }
     68              else
     69              {
     70                  if(!cardOK)
     71                  {
     72          			SERIAL_ECHO_START();
     73          			SERIAL_ECHOLNPGM("SD card inserted");
     74                      
     75                      FATFS_LinkDriver(&SD_Driver, SD_Path);
     76                      initsd();
     77                  }
     78              }
     79            }
     80              
     81            if (SD_DET_IP != SD_DETECT_INVERTED)  //?TSD?°ß,?®¨2a¶Ã?U?®¨°Í?1®∞??
     82            {
     83              if((usbOK == false)&& (Appli_state == APPLICATION_READY))
   \                     ??checkautostart_0: (+1)
   \   0000003A   0x.... 0x....      LDR.W    R6,??DataTable59_4
   \   0000003E   0x7928             LDRB     R0,[R5, #+4]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD11C             BNE.N    ??checkautostart_2
   \   00000044   0xF996 0x0000      LDRSB    R0,[R6, #+0]
   \   00000048   0x2802             CMP      R0,#+2
   \   0000004A   0xD118             BNE.N    ??checkautostart_2
     84              {
     85          		SERIAL_ECHO_START();
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable59_1
   \   00000050   0x.... 0x....      BL       _Z14serialprintPGMPKc
     86          		SERIAL_ECHOLNPGM("USB inserted");
   \   00000054   0x.... 0x....      ADR.W    R0,`?<Constant "USB inserted\\n">`
   \   00000058   0x.... 0x....      BL       _Z14serialprintPGMPKc
     87                  
     88                  FATFS_LinkDriver(&USBH_Driver, USBH_Path);
   \   0000005C   0x.... 0x....      LDR.W    R7,??DataTable59_5
   \   00000060   0x4639             MOV      R1,R7
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable59_6
   \   00000066   0x.... 0x....      BL       FATFS_LinkDriver
     89                
     90                  f_mount(&fs, (TCHAR const*)USBH_Path, 0);
   \   0000006A   0x2200             MOVS     R2,#+0
   \   0000006C   0x4639             MOV      R1,R7
   \   0000006E   0xF504 0x700B      ADD      R0,R4,#+556
   \   00000072   0x.... 0x....      BL       f_mount
     91          		usbOK = true;
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0x7128             STRB     R0,[R5, #+4]
     92                  Appli_state = APPLICATION_IDLE;
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x7030             STRB     R0,[R6, #+0]
     93                
     94              }
     95            } 
     96            
     97            if((Appli_state == APPLICATION_DISCONNECT) &&(usbOK == true))     //?®¨2a¶Ã?U?®¨???a°Í?D???
   \                     ??checkautostart_2: (+1)
   \   0000007E   0xF996 0x0000      LDRSB    R0,[R6, #+0]
   \   00000082   0x2803             CMP      R0,#+3
   \   00000084   0xD114             BNE.N    ??checkautostart_3
   \   00000086   0x7928             LDRB     R0,[R5, #+4]
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD011             BEQ.N    ??checkautostart_3
     98            {
     99              //unmount();
    100              sdprinting = false;
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0xF884 0x09B8      STRB     R0,[R4, #+2488]
    101          	usbOK = false;
   \   00000092   0x7128             STRB     R0,[R5, #+4]
    102          	SERIAL_ECHO_START();
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable59_1
   \   00000098   0x.... 0x....      BL       _Z14serialprintPGMPKc
    103          	SERIAL_ECHOLNPGM("USB removed");
   \   0000009C   0x.... 0x....      ADR.W    R0,`?<Constant "USB removed\\n">`
   \   000000A0   0x.... 0x....      BL       _Z14serialprintPGMPKc
    104              
    105              FATFS_UnLinkDriver(USBH_Path);
   \   000000A4   0x.... 0x....      LDR.W    R0,??DataTable59_5
   \   000000A8   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   000000AC   0x.... 0x....      B.W      FATFS_UnLinkDriver
    106            }
    107          }
   \                     ??checkautostart_3: (+1)
   \   000000B0   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    108          
    109          #if 0
    110          void CardReader::checkFilesys(unsigned char filesys)
    111          {
    112          
    113          	switch(filesys)
    114          	{
    115          	case FILE_SYS_SD:
    116          	  //if(filesys == FILE_SYS_SD)        //U?®¨??®ÆD1®∞??
    117          	  {
    118          	      if (SD_DET_IP != SD_DETECT_INVERTED)    
    119          	      {
    120          	        if(cardOK || sdprinting)   // Card removed
    121          	        {
    122          				SERIAL_ECHO_START();
    123          				SERIAL_ECHOLNPGM("SD card removed");
    124          	            
    125          	            FATFS_UnLinkDriver(SD_Path); 
    126          	            unmount();
    127          	        }
    128          	      }
    129          	      else
    130          	      {
    131          	        if(!cardOK)
    132          	        {
    133          				SERIAL_ECHO_START();
    134          				SERIAL_ECHOLNPGM("Select SD file system");
    135          	            FATFS_LinkDriver_sd(&SD_Driver, SD_Path);
    136          	            initsd();
    137          				usbOK = false;
    138          	        }
    139          	      }
    140          	  }
    141          	 break;
    142          	 case FILE_SYS_USB:
    143          	  //if (SD_DET_IP != SD_DETECT_INVERTED)  //?TSD?°ß,?®¨2a¶Ã?U?®¨°Í?1®∞??
    144          		  {
    145          		    if((usbOK == false)&& (Appli_state == APPLICATION_READY))
    146          		    {
    147          				SERIAL_ECHO_START();
    148          				SERIAL_ECHOLNPGM("Select USB file system");
    149          		        FATFS_LinkDriver_usb(&USBH_Driver, USBH_Path);
    150          		      
    151          		        f_mount(&fs, (TCHAR const*)USBH_Path, 0);
    152          				usbOK = true;
    153          				cardOK = false;
    154          		        Appli_state = APPLICATION_IDLE;
    155          		      
    156          		    }
    157          		  } 
    158          	  	  if((Appli_state == APPLICATION_DISCONNECT) &&(usbOK == true))     //?®¨2a¶Ã?U?®¨???a°Í?D???
    159          		  {
    160          		    //unmount();
    161          		    sdprinting = false;
    162          			usbOK = false;
    163          			SERIAL_ECHO_START();
    164          			SERIAL_ECHOLNPGM("USB removed");
    165          		    
    166          		    FATFS_UnLinkDriver(USBH_Path);
    167          		  }
    168          	  break;
    169          	  default:break;
    170          	}
    171          }
    172          #else

   \                                 In section .text, align 4, keep-with-next
    173          void CardReader::udiskReset()
    174          {
   \                     _ZN10CardReader10udiskResetEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    175          	card.usbOK = false;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable59_7
   \   0000000A   0xF881 0x09BC      STRB     R0,[R1, #+2492]
    176          	SERIAL_ECHO_START();
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable59_1
   \   00000012   0x.... 0x....      BL       _Z14serialprintPGMPKc
    177          	SERIAL_ECHOLNPGM("USB Reset!");
   \   00000016   0x.... 0x....      ADR.W    R0,`?<Constant "USB Reset!\\n">`
   \   0000001A   0x.... 0x....      BL       _Z14serialprintPGMPKc
    178          	FATFS_UnLinkDriver(USBH_Path);
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable59_5
   \   00000022   0x.... 0x....      BL       FATFS_UnLinkDriver
    179          	MX_USB_HOST_DeInit();
   \   00000026   0x.... 0x....      BL       MX_USB_HOST_DeInit
    180          	VUSB_ENA_OP = 0;
   \   0000002A   0x.... 0x....      LDR.W    R5,??DataTable59_8  ;; 0x4241828c
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x6028             STR      R0,[R5, #+0]
    181          	HAL_Delay(500);
   \   00000032   0xF44F 0x70FA      MOV      R0,#+500
   \   00000036   0x.... 0x....      BL       HAL_Delay
    182          	VUSB_ENA_OP = 1;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x6028             STR      R0,[R5, #+0]
    183          	MX_USB_HOST_Init();
   \   0000003E   0x.... 0x....      BL       MX_USB_HOST_Init
    184          	HAL_Delay(500);
   \   00000042   0xF44F 0x70FA      MOV      R0,#+500
   \   00000046   0x.... 0x....      BL       HAL_Delay
    185          
    186          #if 0
    187          for(int i=0;i<5000;i++)		//skyblue modify 2018-10
    188          	{
    189          	MX_USB_HOST_Process();
    190          	card.checkFilesys(FILE_SYS_USB);
    191          	if(card.usbOK) 
    192          		break;
    193          	HAL_Delay(1);
    194          	}
    195          if(card.usbOK)
    196          	{
    197          	card.initusb();
    198          	}
    199          #endif
    200          	cli();
   \   0000004A   0xB672             cpsid i
    201          	udisk_start_tick = 0;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xF8C4 0x09C0      STR      R0,[R4, #+2496]
    202          	sei();
   \   00000052   0xB662             cpsie i
    203          
    204          	
    205          }
   \   00000054   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
    206          void CardReader::udiskState_Polling()
    207          {
    208          	if(udisk_start_tick > 3000)
   \                     _ZN10CardReader18udiskState_PollingEv: (+1)
   \   00000000   0xF8D0 0x19C0      LDR      R1,[R0, #+2496]
   \   00000004   0xF640 0x32B9      MOVW     R2,#+3001
   \   00000008   0x4291             CMP      R1,R2
   \   0000000A   0xD305             BCC.N    ??udiskState_Polling_0
    209          		{
    210          		cli();
   \   0000000C   0xB672             cpsid i
    211          		udisk_start_tick = 0;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0xF8C0 0x19C0      STR      R1,[R0, #+2496]
    212          		sei();
   \   00000014   0xB662             cpsie i
    213          		udiskReset();
   \   00000016   0x....             B.N      _ZN10CardReader10udiskResetEv
    214          		}
    215          }
   \                     ??udiskState_Polling_0: (+1)
   \   00000018   0x4770             BX       LR               ;; return
    216          

   \                                 In section .text, align 2, keep-with-next
    217          void CardReader::checkFilesys(unsigned char filesys)
    218          {
   \                     _ZN10CardReader12checkFilesysEh: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    219          
    220          	if((usbOK == false)&& (Appli_state == APPLICATION_READY))
   \   00000004   0xF604 0x15B8      ADDW     R5,R4,#+2488
   \   00000008   0x.... 0x....      LDR.W    R6,??DataTable59_4
   \   0000000C   0x7928             LDRB     R0,[R5, #+4]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD121             BNE.N    ??checkFilesys_0
   \   00000012   0xF996 0x0000      LDRSB    R0,[R6, #+0]
   \   00000016   0x2802             CMP      R0,#+2
   \   00000018   0xD11D             BNE.N    ??checkFilesys_0
    221          		{
    222          			SERIAL_ECHO_START();
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable59_1
   \   0000001E   0x.... 0x....      BL       _Z14serialprintPGMPKc
    223          			SERIAL_ECHOLNPGM("USB inserted");
   \   00000022   0x.... 0x....      ADR.W    R0,`?<Constant "USB inserted\\n">`
   \   00000026   0x.... 0x....      BL       _Z14serialprintPGMPKc
    224          			FATFS_LinkDriver_usb(&USBH_Driver, USBH_Path);
   \   0000002A   0x.... 0x....      LDR.W    R7,??DataTable59_5
   \   0000002E   0x4639             MOV      R1,R7
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable59_6
   \   00000034   0x.... 0x....      BL       FATFS_LinkDriver_usb
    225          		      
    226          			f_mount(&fs, (TCHAR const*)USBH_Path, 0);
   \   00000038   0x2200             MOVS     R2,#+0
   \   0000003A   0x4639             MOV      R1,R7
   \   0000003C   0xF504 0x700B      ADD      R0,R4,#+556
   \   00000040   0x.... 0x....      BL       f_mount
    227          			usbOK = true;
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x7128             STRB     R0,[R5, #+4]
    228          			cardOK = false;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x70E8             STRB     R0,[R5, #+3]
    229          			Appli_state = APPLICATION_IDLE;
   \   0000004C   0x7030             STRB     R0,[R6, #+0]
    230          			card.udisk_start_tick = 0;
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable59_7
   \   00000052   0xF8C1 0x09C0      STR      R0,[R1, #+2496]
    231          		}
    232          	if((Appli_state == APPLICATION_DISCONNECT) &&(usbOK == true))     //?®¨2a¶Ã?U?®¨???a°Í?D???
   \                     ??checkFilesys_0: (+1)
   \   00000056   0xF996 0x0000      LDRSB    R0,[R6, #+0]
   \   0000005A   0x2803             CMP      R0,#+3
   \   0000005C   0xD123             BNE.N    ??checkFilesys_1
   \   0000005E   0x7928             LDRB     R0,[R5, #+4]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD020             BEQ.N    ??checkFilesys_1
    233          		{
    234          			//unmount();
    235          		    sdprinting = false;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xF884 0x09B8      STRB     R0,[R4, #+2488]
    236          			usbOK = false;
   \   0000006A   0x7128             STRB     R0,[R5, #+4]
    237          			SERIAL_ECHO_START();
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable59_1
   \   00000070   0x.... 0x....      BL       _Z14serialprintPGMPKc
    238          			SERIAL_ECHOLNPGM("USB removed");
   \   00000074   0x.... 0x....      ADR.W    R0,`?<Constant "USB removed\\n">`
   \   00000078   0x.... 0x....      BL       _Z14serialprintPGMPKc
    239          		    
    240          		    FATFS_UnLinkDriver(USBH_Path);      //’‚¿Ô…Ë÷√∂œµ„£¨π€≤ÏµΩ Appli_state = APPLICATION_START
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable59_5
   \   00000080   0x.... 0x....      BL       FATFS_UnLinkDriver
    241          			card.udisk_start_tick = 0;			//‘Ÿ¥Œ∞Œ≤ÂU≈Ã≤ª∂¡»°£¨–Ë÷ÿ∆Ù
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x.... 0x....      LDR.W    R1,??DataTable59_7
   \   0000008A   0xF8C1 0x09C0      STR      R0,[R1, #+2496]
    242          
    243          			if(Appli_state == APPLICATION_START)
   \   0000008E   0xF996 0x0000      LDRSB    R0,[R6, #+0]
   \   00000092   0x2801             CMP      R0,#+1
   \   00000094   0xD107             BNE.N    ??checkFilesys_1
    244          				{
    245          				MX_USB_HOST_DeInit();
   \   00000096   0x.... 0x....      BL       MX_USB_HOST_DeInit
    246          				SERIAL_ECHOLNPGM("USB DeInit!");
   \   0000009A   0x.... 0x....      ADR.W    R0,`?<Constant "USB DeInit!\\n">`
   \   0000009E   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   000000A2   0x.... 0x....      B.W      _Z14serialprintPGMPKc
    247          				}
    248          		}
    249          #if 0	
    250          	if(usbOK == false && Appli_state == APPLICATION_START && _dwTickCount>10000)	
    251          		{
    252          			//while(1)
    253          				for(int i=0;i<5000;i++)
    254          				{
    255          				MX_USB_HOST_Process();
    256          				if(Appli_state == APPLICATION_READY)
    257          					break;
    258          				HAL_Delay(1);
    259          				}
    260          				
    261          				if(Appli_state == APPLICATION_START)
    262          					udiskReset();
    263          				
    264          		}
    265          #endif	
    266          }
   \                     ??checkFilesys_1: (+1)
   \   000000A6   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    267          
    268          #endif
    269          #if 0
    270          char *createFilename(char *buffer, const dir_t &p) { //buffer > 12characters
    271            char *pos = buffer;
    272            for (uint8_t i = 0; i < 11; i++) {
    273              if (p.name[i] == ' ') continue;
    274              if (i == 8) *pos++ = '.';
    275              *pos++ = p.name[i];
    276            }
    277            *pos++ = 0;
    278            return buffer;
    279          }
    280          
    281          /**
    282           * Dive into a folder and recurse depth-first to perform a pre-set operation lsAction:
    283           *   LS_Count       - Add +1 to nrFiles for every file within the parent
    284           *   LS_GetFilename - Get the filename of the file indexed by nrFile_index
    285           *   LS_SerialPrint - Print the full path and size of each file to serial output
    286           */
    287          
    288          uint16_t nrFile_index;
    289          
    290          void CardReader::lsDive(const char *prepend, SdFile parent, const char * const match/*=NULL*/) {
    291            dir_t p;
    292            uint8_t cnt = 0;
    293          
    294            // Read the next entry from a directory
    295            while (parent.readDir(p, longFilename) > 0) {
    296          
    297              // If the entry is a directory and the action is LS_SerialPrint
    298              if (DIR_IS_SUBDIR(&p) && lsAction != LS_Count && lsAction != LS_GetFilename) {
    299          
    300                // Get the short name for the item, which we know is a folder
    301                char lfilename[FILENAME_LENGTH];
    302                createFilename(lfilename, p);
    303          
    304                // Allocate enough stack space for the full path to a folder, trailing slash, and nul
    305                bool prepend_is_empty = (prepend[0] == '\0');
    306                int len = (prepend_is_empty ? 1 : strlen(prepend)) + strlen(lfilename) + 1 + 1;
    307                char path[len];
    308          
    309                // Append the FOLDERNAME12/ to the passed string.
    310                // It contains the full path to the "parent" argument.
    311                // We now have the full path to the item in this folder.
    312                strcpy(path, prepend_is_empty ? "/" : prepend); // root slash if prepend is empty
    313                strcat(path, lfilename); // FILENAME_LENGTH-1 characters maximum
    314                strcat(path, "/");       // 1 character
    315          
    316                // Serial.print(path);
    317          
    318                // Get a new directory object using the full path
    319                // and dive recursively into it.
    320                SdFile dir;
    321                if (!dir.open(parent, lfilename, O_READ)) {
    322                  if (lsAction == LS_SerialPrint) {
    323                    SERIAL_ECHO_START();
    324                    SERIAL_ECHOPGM(MSG_SD_CANT_OPEN_SUBDIR);
    325                    SERIAL_ECHOLN(lfilename);
    326                  }
    327                }
    328                lsDive(path, dir);
    329                // close() is done automatically by destructor of SdFile
    330              }
    331              else {
    332                uint8_t pn0 = p.name[0];
    333                if (pn0 == DIR_NAME_FREE) break;
    334                if (pn0 == DIR_NAME_DELETED || pn0 == '.') continue;
    335                if (longFilename[0] == '.') continue;
    336          
    337                if (!DIR_IS_FILE_OR_SUBDIR(&p) || (p.attributes & DIR_ATT_HIDDEN)) continue;
    338          
    339                filenameIsDir = DIR_IS_SUBDIR(&p);
    340          
    341                if (!filenameIsDir && (p.name[8] != 'G' || p.name[9] == '~')) continue;
    342          
    343                switch (lsAction) {  // 1 based file count
    344                  case LS_Count:
    345                    nrFiles++;
    346                    break;
    347          
    348                  case LS_SerialPrint:
    349                    createFilename(filename, p);
    350                    SERIAL_PROTOCOL(prepend);
    351                    SERIAL_PROTOCOL(filename);
    352                    SERIAL_PROTOCOLCHAR(' ');
    353                    SERIAL_PROTOCOLLN(p.fileSize);
    354                    break;
    355          
    356                  case LS_GetFilename:
    357                    createFilename(filename, p);
    358                    if (match != NULL) {
    359                      if (strcasecmp(match, filename) == 0) return;
    360                    }
    361                    else if (cnt == nrFile_index) return;  // 0 based index
    362                    cnt++;
    363                    break;
    364                }
    365          
    366              }
    367            } // while readDir
    368          }
    369          
    370          void CardReader::ls() {
    371            lsAction = LS_SerialPrint;
    372            root.rewind();
    373            lsDive("", root);
    374          }
    375          
    376          #if ENABLED(LONG_FILENAME_HOST_SUPPORT)
    377          
    378            /**
    379             * Get a long pretty path based on a DOS 8.3 path
    380             */
    381            void CardReader::printLongPath(char *path) {
    382              lsAction = LS_GetFilename;
    383          
    384              int i, pathLen = strlen(path);
    385          
    386              // SERIAL_ECHOPGM("Full Path: "); SERIAL_ECHOLN(path);
    387          
    388              // Zero out slashes to make segments
    389              for (i = 0; i < pathLen; i++) if (path[i] == '/') path[i] = '\0';
    390          
    391              SdFile diveDir = root; // start from the root for segment 1
    392              for (i = 0; i < pathLen;) {
    393          
    394                if (path[i] == '\0') i++; // move past a single nul
    395          
    396                char *segment = &path[i]; // The segment after most slashes
    397          
    398                // If a segment is empty (extra-slash) then exit
    399                if (!*segment) break;
    400          
    401                // Go to the next segment
    402                while (path[++i]) { }
    403          
    404                // SERIAL_ECHOPGM("Looking for segment: "); SERIAL_ECHOLN(segment);
    405          
    406                // Find the item, setting the long filename
    407                diveDir.rewind();
    408                lsDive("", diveDir, segment);
    409          
    410                // Print /LongNamePart to serial output
    411                SERIAL_PROTOCOLCHAR('/');
    412                SERIAL_PROTOCOL(longFilename[0] ? longFilename : "???");
    413          
    414                // If the filename was printed then that's it
    415                if (!filenameIsDir) break;
    416          
    417                // SERIAL_ECHOPGM("Opening dir: "); SERIAL_ECHOLN(segment);
    418          
    419                // Open the sub-item as the new dive parent
    420                SdFile dir;
    421                if (!dir.open(diveDir, segment, O_READ)) {
    422                  SERIAL_EOL();
    423                  SERIAL_ECHO_START();
    424                  SERIAL_ECHOPGM(MSG_SD_CANT_OPEN_SUBDIR);
    425                  SERIAL_ECHO(segment);
    426                  break;
    427                }
    428          
    429                diveDir.close();
    430                diveDir = dir;
    431          
    432              } // while i<pathLen
    433          
    434              SERIAL_EOL();
    435            }
    436          
    437          #endif // LONG_FILENAME_HOST_SUPPORT
    438          
    439          void CardReader::setroot() {
    440            /*if (!workDir.openRoot(&volume)) {
    441              SERIAL_ECHOLNPGM(MSG_SD_WORKDIR_FAIL);
    442            }*/
    443            workDir = root;
    444            curDir = &workDir;
    445            #if ENABLED(SDCARD_SORT_ALPHA)
    446              presort();
    447            #endif
    448          }
    449          
    450          #endif

   \                                 In section .text, align 2, keep-with-next
    451          void CardReader::initsd()
    452          {
    453          	FRESULT mksMountState = FR_DISK_ERR;
    454          	cardOK = false;
   \                     _ZN10CardReader6initsdEv: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xF880 0x19BB      STRB     R1,[R0, #+2491]
    455          	
    456          	if( SD_DET_IP != SD_DETECT_INVERTED)
    457          		return;
   \   00000006   0x4770             BX       LR               ;; return
    458          
    459          	if(f_mount(&fs, (TCHAR const*)SD_Path, 0) != FR_OK)	
                 	^
Warning[Pe111]: statement is unreachable

  	FRESULT mksMountState = FR_DISK_ERR;
  	        ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\cardreader.cpp",453  Warning[Pe177]: 
          variable "mksMountState" was declared but never referenced
    460          	{
    461          		SERIAL_ECHO_START();
    462          		SERIAL_ECHOLNPGM(MSG_SD_INIT_FAIL);
    463          	}
    464          	else
    465          	{
    466          		SERIAL_ECHO_START();
    467          		SERIAL_ECHOLNPGM(MSG_SD_CARD_OK);
    468          		cardOK = true;
    469          	}
    470          }
    471          #if 1
    472          

   \                                 In section .text, align 2, keep-with-next
    473          void CardReader::initusb()
    474          {
   \                     _ZN10CardReader7initusbEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    475          	FRESULT mksMountState = FR_DISK_ERR;
                 	        ^
Warning[Pe177]: variable "mksMountState" was declared but never referenced
    476          	usbOK = false;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF884 0x09BC      STRB     R0,[R4, #+2492]
    477          
    478          	if(f_mount(&fs, (TCHAR const*)USBH_Path, 0) != FR_OK)	
   \   0000000A   0x.... 0x....      LDR.W    R5,??DataTable59_1
   \   0000000E   0x4602             MOV      R2,R0
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable59_5
   \   00000014   0xF504 0x700B      ADD      R0,R4,#+556
   \   00000018   0x.... 0x....      BL       f_mount
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0x4628             MOV      R0,R5
   \   00000020   0xD007             BEQ.N    ??initusb_0
    479          	{
    480          		SERIAL_ECHO_START();
   \   00000022   0x.... 0x....      BL       _Z14serialprintPGMPKc
    481          		SERIAL_ECHOLNPGM("USB init fail");
   \   00000026   0x.... 0x....      ADR.W    R0,`?<Constant "USB init fail\\n">`
   \   0000002A   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000002E   0x.... 0x....      B.W      _Z14serialprintPGMPKc
    482          	}
    483          	else
    484          	{
    485          		SERIAL_ECHO_START();
   \                     ??initusb_0: (+1)
   \   00000032   0x.... 0x....      BL       _Z14serialprintPGMPKc
    486          		SERIAL_ECHOLNPGM("USB OK");
   \   00000036   0x.... 0x....      ADR.W    R0,`?<Constant "USB OK\\n">`
   \   0000003A   0x.... 0x....      BL       _Z14serialprintPGMPKc
    487          		usbOK = true;
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0xF884 0x09BC      STRB     R0,[R4, #+2492]
    488          	}
    489          }
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    490          #endif

   \                                 In section .text, align 2, keep-with-next
    491          void CardReader::mount()
    492          {
    493              sdmode = false;	sdprinting = false;
   \                     _ZN10CardReader5mountEv: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xF880 0x146C      STRB     R1,[R0, #+1132]
   \   00000006   0xF880 0x19B8      STRB     R1,[R0, #+2488]
    494              initsd();
   \   0000000A   0x....             B.N      _ZN10CardReader6initsdEv
    495          }
    496          

   \                                 In section .text, align 2, keep-with-next
    497          void CardReader::unmount()
    498          {
    499              sdmode = false;		sdprinting = false;
   \                     _ZN10CardReader7unmountEv: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xF880 0x146C      STRB     R1,[R0, #+1132]
   \   00000006   0xF880 0x19B8      STRB     R1,[R0, #+2488]
    500          	cardOK = false;
   \   0000000A   0xF880 0x19BB      STRB     R1,[R0, #+2491]
    501              savetosd = false;	
   \   0000000E   0xF880 0x146D      STRB     R1,[R0, #+1133]
    502           #if 0   //lite mask   
    503          #if UI_DISPLAY_TYPE!=0 && SDSUPPORT
    504              uid.cwd[0]='/';
    505              uid.cwd[1]=0;
    506              uid.folderLevel=0;
    507          #endif
    508          #endif    //lite mask
    509          }
   \   00000012   0x4770             BX       LR               ;; return
    510          
    511          
    512          

   \                                 In section .text, align 2, keep-with-next
    513          void CardReader::release() {
    514              sdmode = false;		
   \                     _ZN10CardReader7releaseEv: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xF880 0x146C      STRB     R1,[R0, #+1132]
    515          	sdprinting = false;	
   \   00000006   0xF880 0x19B8      STRB     R1,[R0, #+2488]
    516          	cardOK = false;
   \   0000000A   0xF880 0x19BB      STRB     R1,[R0, #+2491]
    517              savetosd = false;	
   \   0000000E   0xF880 0x146D      STRB     R1,[R0, #+1133]
    518          
    519          }
   \   00000012   0x4770             BX       LR               ;; return
    520          #if 0
    521          void CardReader::openAndPrintFile(const char *name) {
    522            char cmd[4 + strlen(name) + 1]; // Room for "M23 ", filename, and null
    523            sprintf_P(cmd, PSTR("M23 %s"), name);
    524            for (char *c = &cmd[4]; *c; c++) *c = tolower(*c);
    525            enqueue_and_echo_command(cmd);
    526            enqueue_and_echo_commands_P(PSTR("M24"));
    527          }
    528          #endif
    529          

   \                                 In section .text, align 2, keep-with-next
    530          void CardReader::startPrint()
    531          {
    532              if(!cardOK) return;
   \                     _ZN10CardReader10startPrintEv: (+1)
   \   00000000   0xF890 0x19BB      LDRB     R1,[R0, #+2491]
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD004             BEQ.N    ??startPrint_0
    533              sdmode = true;	
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0xF880 0x146C      STRB     R1,[R0, #+1132]
    534          	sdprinting = true;
   \   0000000E   0xF880 0x19B8      STRB     R1,[R0, #+2488]
    535          }
   \                     ??startPrint_0: (+1)
   \   00000012   0x4770             BX       LR               ;; return
    536          

   \                                 In section .bss, align 4
    537          volatile int textt;
   \                     textt:
   \   00000000                      DS8 4

   \                                 In section .text, align 2, keep-with-next
    538          void CardReader::startFileprint() {
   \                     _ZN10CardReader14startFileprintEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    539            if (cardOK || usbOK) {
   \   00000002   0xF600 0x11B8      ADDW     R1,R0,#+2488
   \   00000006   0x78CA             LDRB     R2,[R1, #+3]
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD102             BNE.N    ??startFileprint_0
   \   0000000C   0x7909             LDRB     R1,[R1, #+4]
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD019             BEQ.N    ??startFileprint_1
    540              sdprinting = true; sdmode = true;
   \                     ??startFileprint_0: (+1)
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0xF880 0x19B8      STRB     R1,[R0, #+2488]
   \   00000018   0xF880 0x146C      STRB     R1,[R0, #+1132]
    541              #if ENABLED(SDCARD_SORT_ALPHA)
    542                flush_presort();
    543              #endif
    544          
    545          	mksReprint.mks_printer_state = MKS_WORKING;
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable59_9
   \   00000020   0x21A7             MOVS     R1,#+167
   \   00000022   0xF880 0x1058      STRB     R1,[R0, #+88]
    546              //if(gCfgItems.pwroff_save_mode != 1)
    547              {
    548          	    epr_write_data(EPR_SAV_FLAG, (uint8_t *)&mksReprint.mks_printer_state,sizeof(mksReprint.mks_printer_state));
   \   00000026   0x2201             MOVS     R2,#+1
   \   00000028   0xF100 0x0158      ADD      R1,R0,#+88
   \   0000002C   0xF44F 0x707A      MOV      R0,#+1000
   \   00000030   0x.... 0x....      BL       epr_write_data
    549               }
    550              epr_read_data(EPR_SAV_FLAG, (uint8_t *)&textt,sizeof(mksReprint.mks_printer_state));
   \   00000034   0x2201             MOVS     R2,#+1
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable59_10
   \   0000003A   0xF44F 0x707A      MOV      R0,#+1000
   \   0000003E   0xE8BD 0x4008      POP      {R3,LR}
   \   00000042   0x.... 0x....      B.W      epr_read_data
    551            }
    552          }
   \                     ??startFileprint_1: (+1)
   \   00000046   0xBD01             POP      {R0,PC}          ;; return
    553          

   \                                 In section .text, align 2, keep-with-next
    554          void CardReader::pausePrint(bool intern)
    555          {
    556              if(!card.cardOK) return;
   \                     _ZN10CardReader10pausePrintEb: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable59_7
   \   00000004   0xF891 0x19BB      LDRB     R1,[R1, #+2491]
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD002             BEQ.N    ??pausePrint_0
    557              sdmode = 2; // finish running line
   \   0000000C   0x2102             MOVS     R1,#+2
   \   0000000E   0xF880 0x146C      STRB     R1,[R0, #+1132]
    558          
    559          	/*...*/
    560          	
    561          }
   \                     ??pausePrint_0: (+1)
   \   00000012   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    562          void CardReader::pauseSDPrint()
    563          {
    564            if(sdprinting)
   \                     _ZN10CardReader12pauseSDPrintEv: (+1)
   \   00000000   0xF890 0x19B8      LDRB     R1,[R0, #+2488]
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD005             BEQ.N    ??pauseSDPrint_0
    565            {
    566              sdprinting = false;	sdmode = 2;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0xF880 0x19B8      STRB     R1,[R0, #+2488]
   \   0000000E   0x2102             MOVS     R1,#+2
   \   00000010   0xF880 0x146C      STRB     R1,[R0, #+1132]
    567            }
    568          }
   \                     ??pauseSDPrint_0: (+1)
   \   00000014   0x4770             BX       LR               ;; return
    569          
    570          

   \                                 In section .text, align 2, keep-with-next
    571          void CardReader::continuePrint(bool intern)
    572          {
    573              if(!card.cardOK) return;
    574          #if 0
    575              if(intern) {
    576                 // GCode::executeFString(PSTR(PAUSE_END_COMMANDS));
    577                  Printer::GoToMemoryPosition(true, true, false, false, Printer::maxFeedrate[X_AXIS]);
    578                  Printer::GoToMemoryPosition(false, false, true, false, Printer::maxFeedrate[Z_AXIS] / 2.0f);
    579                  Printer::GoToMemoryPosition(false, false, false, true, Printer::maxFeedrate[E_AXIS] / 2.0f);
    580              }
    581              //Printer::setMenuMode(MENU_MODE_SD_PAUSED, false);
    582              sdmode = 1;
    583              FALA_5V_CTRL = FALA_ON;    // °‰®∞?a°§°ß®§-¶Ã?®®Y
    584          #endif    
    585          }
   \                     _ZN10CardReader13continuePrintEb: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    586          void CardReader::stopSDPrint() {
   \                     _ZN10CardReader11stopSDPrintEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    587            sdprinting = false;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF884 0x09B8      STRB     R0,[R4, #+2488]
    588            if (isFileOpen()) closefile();
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       _ZN10CardReader10isFileOpenEv
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD004             BEQ.N    ??stopSDPrint_0
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001C   0x....             B.N      _ZN10CardReader9closefileEb
    589          }
   \                     ??stopSDPrint_0: (+1)
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
    590          void CardReader::stopPrint()
    591          {
    592              if(!card.cardOK) return;
   \                     _ZN10CardReader9stopPrintEv: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable59_7
   \   00000004   0xF891 0x19BB      LDRB     R1,[R1, #+2491]
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD004             BEQ.N    ??stopPrint_0
    593              sdmode = 0;	sdprinting = false;	
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0xF880 0x146C      STRB     R1,[R0, #+1132]
   \   00000012   0xF880 0x19B8      STRB     R1,[R0, #+2488]
    594          }
   \                     ??stopPrint_0: (+1)
   \   00000016   0x4770             BX       LR               ;; return
    595          

   \                                 In section .text, align 2, keep-with-next
    596          void CardReader::operatePrint()
    597          {
    598               
    599          }
   \                     _ZN10CardReader12operatePrintEv: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    600          char *CardReader::createFilename(char *buffer,const dir_t &p)
    601          {
   \                     _ZN10CardReader14createFilenameEPcRK14directoryEntry: (+1)
   \   00000000   0xB410             PUSH     {R4}
    602              char *pos = buffer,*src = (char*)p.name;
    603              for (uint8_t i = 0; i < 11; i++,src++)
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0xE00D             B.N      ??createFilename_0
    604              {
    605                  if (*src == ' ') continue;
   \                     ??createFilename_1: (+1)
   \   00000006   0xF992 0x4000      LDRSB    R4,[R2, #+0]
   \   0000000A   0x2C20             CMP      R4,#+32
   \   0000000C   0xD007             BEQ.N    ??createFilename_2
    606                  if (i == 8)
   \   0000000E   0x2B08             CMP      R3,#+8
   \   00000010   0xD102             BNE.N    ??createFilename_3
    607                      *pos++ = '.';
   \   00000012   0x232E             MOVS     R3,#+46
   \   00000014   0xF801 0x3B01      STRB     R3,[R1], #+1
    608                  *pos++ = *src;
   \                     ??createFilename_3: (+1)
   \   00000018   0x7813             LDRB     R3,[R2, #+0]
   \   0000001A   0xF801 0x3B01      STRB     R3,[R1], #+1
    609              }
   \                     ??createFilename_2: (+1)
   \   0000001E   0x1C40             ADDS     R0,R0,#+1
   \   00000020   0x1C52             ADDS     R2,R2,#+1
   \                     ??createFilename_0: (+1)
   \   00000022   0xB2C0             UXTB     R0,R0
   \   00000024   0x4603             MOV      R3,R0
   \   00000026   0x2B0B             CMP      R3,#+11
   \   00000028   0xDBED             BLT.N    ??createFilename_1
    610              *pos = 0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
    611              return pos;
   \   0000002E   0x4608             MOV      R0,R1
   \   00000030   0xBC10             POP      {R4}
   \   00000032   0x4770             BX       LR               ;; return
    612          }

   \                                 In section .text, align 2, keep-with-next
    613          bool CardReader::showFilename(const uint8_t *name)
    614          {
    615              if (*name == DIR_NAME_DELETED || *name == '.') return false;
   \                     _ZN10CardReader12showFilenameEPKh: (+1)
   \   00000000   0x7808             LDRB     R0,[R1, #+0]
   \   00000002   0x28E5             CMP      R0,#+229
   \   00000004   0xD001             BEQ.N    ??showFilename_0
   \   00000006   0x282E             CMP      R0,#+46
   \   00000008   0xD101             BNE.N    ??showFilename_1
   \                     ??showFilename_0: (+1)
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x4770             BX       LR
    616              return true;
   \                     ??showFilename_1: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x4770             BX       LR               ;; return
    617          }
    618          

   \                                 In section .text, align 2, keep-with-next
    619          int8_t RFstricmp(const char* s1, const char* s2)
    620          {
   \                     _Z9RFstricmpPKcS0_: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0xE001             B.N      ??RFstricmp_0
    621              while(*s1 && (tolower(*s1) == tolower(*s2)))
    622                  s1++,s2++;
   \                     ??RFstricmp_1: (+1)
   \   00000008   0x1C64             ADDS     R4,R4,#+1
   \   0000000A   0x1C6D             ADDS     R5,R5,#+1
   \                     ??RFstricmp_0: (+1)
   \   0000000C   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD008             BEQ.N    ??RFstricmp_2
   \   00000014   0x.... 0x....      BL       tolower
   \   00000018   0x4606             MOV      R6,R0
   \   0000001A   0xF995 0x0000      LDRSB    R0,[R5, #+0]
   \   0000001E   0x.... 0x....      BL       tolower
   \   00000022   0x4286             CMP      R6,R0
   \   00000024   0xD0F0             BEQ.N    ??RFstricmp_1
    623              return (const uint8_t)tolower(*s1)-(const uint8_t)tolower(*s2);
                             ^
Warning[Pe191]: type qualifier is meaningless on cast type

      return (const uint8_t)tolower(*s1)-(const uint8_t)tolower(*s2);
                                          ^
"D:\DLP_proj\DLP_github\MKS-DLP-FIRMWARE\Middlewares\Third_Party\Marlin\cardreader.cpp",623  Warning[Pe191]: 
          type qualifier is meaningless on cast type
   \                     ??RFstricmp_2: (+1)
   \   00000026   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   0000002A   0x.... 0x....      BL       tolower
   \   0000002E   0x4604             MOV      R4,R0
   \   00000030   0xF995 0x0000      LDRSB    R0,[R5, #+0]
   \   00000034   0x.... 0x....      BL       tolower
   \   00000038   0x1A20             SUBS     R0,R4,R0
   \   0000003A   0xB240             SXTB     R0,R0
   \   0000003C   0xBD70             POP      {R4-R6,PC}       ;; return
    624          }
    625          

   \                                 In section .text, align 2, keep-with-next
    626          int8_t RFstrnicmp(const char* s1, const char* s2, size_t n)
    627          {
   \                     _Z10RFstrnicmpPKcS0_j: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0xE001             B.N      ??RFstrnicmp_0
    628              while(n--)
    629              {
    630                  if(tolower(*s1)!=tolower(*s2))
    631                      return (uint8_t)tolower(*s1) - (uint8_t)tolower(*s2);
    632                  s1++;
   \                     ??RFstrnicmp_1: (+1)
   \   0000000A   0x1C64             ADDS     R4,R4,#+1
    633                  s2++;
   \   0000000C   0x1C6D             ADDS     R5,R5,#+1
   \                     ??RFstrnicmp_0: (+1)
   \   0000000E   0x4630             MOV      R0,R6
   \   00000010   0x1E46             SUBS     R6,R0,#+1
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD016             BEQ.N    ??RFstrnicmp_2
   \   00000016   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   0000001A   0x.... 0x....      BL       tolower
   \   0000001E   0x4607             MOV      R7,R0
   \   00000020   0xF995 0x0000      LDRSB    R0,[R5, #+0]
   \   00000024   0x.... 0x....      BL       tolower
   \   00000028   0x4287             CMP      R7,R0
   \   0000002A   0xD0EE             BEQ.N    ??RFstrnicmp_1
   \   0000002C   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   00000030   0x.... 0x....      BL       tolower
   \   00000034   0x4604             MOV      R4,R0
   \   00000036   0xF995 0x0000      LDRSB    R0,[R5, #+0]
   \   0000003A   0x.... 0x....      BL       tolower
   \   0000003E   0x1A20             SUBS     R0,R4,R0
   \   00000040   0xB240             SXTB     R0,R0
   \   00000042   0xBDF2             POP      {R1,R4-R7,PC}
    634              }
    635              return 0;
   \                     ??RFstrnicmp_2: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    636          }
    637          

   \                                 In section .text, align 2, keep-with-next
    638          void CardReader::ls()
    639          {
    640              if ((SD_DET_IP == SD_DETECT_INVERTED)&&(usbOK == false))
    641                get_file_list(SD_Path);
    642              else
    643                get_file_list(USBH_Path);
   \                     _ZN10CardReader2lsEv: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable59_5
   \   00000004   0x....             B.N      _ZN10CardReader13get_file_listEPc
    644          }
    645          

   \                                 In section .text, align 2, keep-with-next
    646          bool CardReader::selectFile(char *filename, bool silent){}
                                                                          ^
Warning[Pe940]: missing return statement at end of non-void function
          "CardReader::selectFile"
   \                     _ZN10CardReader10selectFileEPcb: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    647          

   \                                 In section .text, align 2, keep-with-next
    648          bool CardReader::openFile(char* filename,bool silent, bool replace_current/*=true*/)
    649          {
   \                     _ZN10CardReader8openFileEPcbb: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB092             SUB      SP,SP,#+72
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    650              SdBaseFile parent;
   \   00000008   0xA808             ADD      R0,SP,#+32
   \   0000000A   0x.... 0x....      BL       _ZN10SdBaseFileC1Ev
    651              char *oldP;
                           ^
Warning[Pe177]: variable "oldP" was declared but never referenced
    652              boolean bFound;
                             ^
Warning[Pe177]: variable "bFound" was declared but never referenced
    653              
    654              char newname[30]={0};
   \   0000000E   0xA800             ADD      R0,SP,#+0
   \   00000010   0x2120             MOVS     R1,#+32
   \   00000012   0x.... 0x....      BL       __aeabi_memclr4
    655                
    656          	  if(sdprinting)			return false;
   \   00000016   0xF894 0x09B8      LDRB     R0,[R4, #+2488]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD001             BEQ.N    ??openFile_0
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE05A             B.N      ??openFile_1
    657          	  f_close(&curFile);
   \                     ??openFile_0: (+1)
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       f_close
    658          
    659            if(filename[2] != '/')     //???t??2?°‰??®¨°§??°§??
   \   00000028   0xF995 0x0002      LDRSB    R0,[R5, #+2]
   \   0000002C   0x282F             CMP      R0,#+47
   \   0000002E   0xD00A             BEQ.N    ??openFile_2
    660            {    
    661             if(card.cardOK)
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable59_7
   \   00000034   0xF890 0x19BB      LDRB     R1,[R0, #+2491]
   \   00000038   0x2900             CMP      R1,#+0
   \   0000003A   0xD033             BEQ.N    ??openFile_3
    662          	   strcat(newname,SD_Path);
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable59_3
   \   00000040   0xA800             ADD      R0,SP,#+0
   \   00000042   0x.... 0x....      BL       strcat
    663             else if(card.usbOK)
    664          	   strcat(newname,USBH_Path);
    665             else
    666                    return false;
    667            }
    668          	strcat(newname,filename);
   \                     ??openFile_2: (+1)
   \   00000046   0x4629             MOV      R1,R5
   \   00000048   0xA800             ADD      R0,SP,#+0
   \   0000004A   0x.... 0x....      BL       strcat
    669          
    670             mks_saveFileName(newname);
   \   0000004E   0x.... 0x....      BL       mks_saveFileName
    671          
    672          	if(f_open(&curFile, (const TCHAR *)newname, FA_OPEN_EXISTING | FA_READ) == FR_OK)					
   \   00000052   0x.... 0x....      LDR.W    R6,??DataTable59_11
   \   00000056   0x2201             MOVS     R2,#+1
   \   00000058   0xA900             ADD      R1,SP,#+0
   \   0000005A   0x4620             MOV      R0,R4
   \   0000005C   0x.... 0x....      BL       f_open
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD12B             BNE.N    ??openFile_4
    673                {
    674          
    675                  if(!silent)
    676                  {
    677                  }
    678          		
    679                  sdpos = 0;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xF8C4 0x0460      STR      R0,[R4, #+1120]
    680                  filesize = curFile.fsize;
   \   0000006A   0xF8D4 0x020C      LDR      R0,[R4, #+524]
   \   0000006E   0xF8C4 0x045C      STR      R0,[R4, #+1116]
    681                  SERIAL_PROTOCOLPAIR(MSG_SD_FILE_OPENED, filename);
   \   00000072   0x4629             MOV      R1,R5
   \   00000074   0x.... 0x....      ADR.W    R0,`?<Constant "File opened: ">`
   \   00000078   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
    682          		SERIAL_PROTOCOLPGM(MSG_SD_SIZE);
   \   0000007C   0x.... 0x....      ADR.W    R0,`?<Constant " Size: ">`
   \   00000080   0x.... 0x....      BL       _Z14serialprintPGMPKc
    683          		SERIAL_PROTOCOL(filesize);
   \   00000084   0x220A             MOVS     R2,#+10
   \   00000086   0xF8D4 0x145C      LDR      R1,[R4, #+1116]
   \   0000008A   0x4630             MOV      R0,R6
   \   0000008C   0x.... 0x....      BL       _ZN5Print5printEji
    684                  SERIAL_EOL();
   \   00000090   0x210A             MOVS     R1,#+10
   \   00000092   0x4630             MOV      R0,R6
   \   00000094   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    685          		SERIAL_PROTOCOLLNPGM(MSG_SD_FILE_SELECTED);
   \   00000098   0x.... 0x....      ADR.W    R0,`?<Constant "File selected\\n">`
   \   0000009C   0x.... 0x....      BL       _Z14serialprintPGMPKc
    686                  return true;
   \   000000A0   0x2001             MOVS     R0,#+1
   \   000000A2   0xE019             B.N      ??openFile_1
    687              }
   \                     ??openFile_3: (+1)
   \   000000A4   0xF890 0x09BC      LDRB     R0,[R0, #+2492]
   \   000000A8   0x2800             CMP      R0,#+0
   \   000000AA   0xD005             BEQ.N    ??openFile_5
   \   000000AC   0x.... 0x....      LDR.W    R1,??DataTable59_5
   \   000000B0   0xA800             ADD      R0,SP,#+0
   \   000000B2   0x.... 0x....      BL       strcat
   \   000000B6   0xE7C6             B.N      ??openFile_2
   \                     ??openFile_5: (+1)
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0xE00D             B.N      ??openFile_1
    688              else
    689              {
    690          		SERIAL_PROTOCOLPAIR(MSG_SD_OPEN_FILE_FAIL, filename);
   \                     ??openFile_4: (+1)
   \   000000BC   0x4629             MOV      R1,R5
   \   000000BE   0x.... 0x....      ADR.W    R0,`?<Constant "open failed, File: ">`
   \   000000C2   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
    691          		SERIAL_PROTOCOLCHAR('.');
   \   000000C6   0x212E             MOVS     R1,#+46
   \   000000C8   0x4630             MOV      R0,R6
   \   000000CA   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    692          		SERIAL_EOL();
   \   000000CE   0x210A             MOVS     R1,#+10
   \   000000D0   0x4630             MOV      R0,R6
   \   000000D2   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    693              
    694                  if(!silent){}
    695             //         Com::printFLN(Com::tFileOpenFailed);
    696                  return false;
   \   000000D6   0x2000             MOVS     R0,#+0
   \                     ??openFile_1: (+1)
   \   000000D8   0xB012             ADD      SP,SP,#+72
   \   000000DA   0xBD70             POP      {R4-R6,PC}       ;; return
    697              }
    698          }

   \                                 In section .text, align 2, keep-with-next
    699          bool CardReader::open_CBD_File(char* filename)
    700          {
   \                     _ZN10CardReader13open_CBD_FileEPc: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB0A3             SUB      SP,SP,#+140
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    701              SdBaseFile parent;
   \   00000008   0xA819             ADD      R0,SP,#+100
   \   0000000A   0x.... 0x....      BL       _ZN10SdBaseFileC1Ev
    702              char *oldP;
                           ^
Warning[Pe177]: variable "oldP" was declared but never referenced
    703              boolean bFound;
                             ^
Warning[Pe177]: variable "bFound" was declared but never referenced
    704              
    705              char newname[100]={0};
   \   0000000E   0xA800             ADD      R0,SP,#+0
   \   00000010   0x2164             MOVS     R1,#+100
   \   00000012   0x.... 0x....      BL       __aeabi_memclr4
    706            
    707          	f_close(&curFile);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       f_close
    708          
    709            if(filename[2] != '/') 
   \   0000001C   0xF995 0x0002      LDRSB    R0,[R5, #+2]
   \   00000020   0x282F             CMP      R0,#+47
   \   00000022   0xD00A             BEQ.N    ??open_CBD_File_0
    710            {    
    711             if(card.cardOK)
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable59_7
   \   00000028   0xF890 0x19BB      LDRB     R1,[R0, #+2491]
   \   0000002C   0x2900             CMP      R1,#+0
   \   0000002E   0xD018             BEQ.N    ??open_CBD_File_1
    712          	   strcat(newname,SD_Path);
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable59_3
   \   00000034   0xA800             ADD      R0,SP,#+0
   \   00000036   0x.... 0x....      BL       strcat
    713             else if(card.usbOK)
    714          	   strcat(newname,USBH_Path);
    715             else
    716                    return false;
    717            }
    718          	strcat(newname,filename);
   \                     ??open_CBD_File_0: (+1)
   \   0000003A   0x4629             MOV      R1,R5
   \   0000003C   0xA800             ADD      R0,SP,#+0
   \   0000003E   0x.... 0x....      BL       strcat
    719          
    720          	if(f_open(&curFile, (const TCHAR *)newname, FA_OPEN_EXISTING | FA_READ) == FR_OK)					
   \   00000042   0x2201             MOVS     R2,#+1
   \   00000044   0xA900             ADD      R1,SP,#+0
   \   00000046   0x4620             MOV      R0,R4
   \   00000048   0x.... 0x....      BL       f_open
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD114             BNE.N    ??open_CBD_File_2
    721              {
    722          		
    723                  sdpos = 0;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xF8C4 0x0460      STR      R0,[R4, #+1120]
    724                  filesize = curFile.fsize;
   \   00000056   0xF8D4 0x020C      LDR      R0,[R4, #+524]
   \   0000005A   0xF8C4 0x045C      STR      R0,[R4, #+1116]
    725                  return true;
   \   0000005E   0x2001             MOVS     R0,#+1
   \   00000060   0xE00C             B.N      ??open_CBD_File_3
    726              }
   \                     ??open_CBD_File_1: (+1)
   \   00000062   0xF890 0x09BC      LDRB     R0,[R0, #+2492]
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD005             BEQ.N    ??open_CBD_File_4
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable59_5
   \   0000006E   0xA800             ADD      R0,SP,#+0
   \   00000070   0x.... 0x....      BL       strcat
   \   00000074   0xE7E1             B.N      ??open_CBD_File_0
   \                     ??open_CBD_File_4: (+1)
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xE000             B.N      ??open_CBD_File_3
    727          	return false;
   \                     ??open_CBD_File_2: (+1)
   \   0000007A   0x2000             MOVS     R0,#+0
   \                     ??open_CBD_File_3: (+1)
   \   0000007C   0xB023             ADD      SP,SP,#+140
   \   0000007E   0xBD30             POP      {R4,R5,PC}       ;; return
    728          }

   \                                 In section .text, align 2, keep-with-next
    729          void CardReader::close_CBD_File()
    730          {
    731          	f_close(&curFile);
   \                     _ZN10CardReader14close_CBD_FileEv: (+1)
   \   00000000   0x.... 0x....      B.W      f_close
    732          }
    733          

   \                                 In section .text, align 2, keep-with-next
    734          void CardReader::printStatus()
    735          {
    736          #if 0
    737              if(sdactive)
    738              {
    739                  Com::printF(Com::tSDPrintingByte, sdpos);
    740                  Com::printFLN(Com::tSlash, filesize);
    741              }
    742              else
    743              {
    744                  Com::printFLN(Com::tNotSDPrinting);
    745              }
    746          #endif	
    747          
    748          }
   \                     _ZN10CardReader11printStatusEv: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    749          

   \                                 In section .text, align 2, keep-with-next
    750          void CardReader::getStatus()
    751          {
   \                     _ZN10CardReader9getStatusEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    752            if(cardOK || usbOK){
   \   00000004   0xF894 0x09BB      LDRB     R0,[R4, #+2491]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD103             BNE.N    ??getStatus_0
   \   0000000C   0xF894 0x09BC      LDRB     R0,[R4, #+2492]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD01A             BEQ.N    ??getStatus_1
    753              SERIAL_PROTOCOLPGM(MSG_SD_PRINTING_BYTE);
   \                     ??getStatus_0: (+1)
   \   00000014   0x.... 0x....      ADR.W    R0,`?<Constant "SD printing byte ">`
   \   00000018   0x.... 0x....      BL       _Z14serialprintPGMPKc
    754              SERIAL_PROTOCOL(sdpos);
   \   0000001C   0x.... 0x....      LDR.W    R5,??DataTable59_11
   \   00000020   0x220A             MOVS     R2,#+10
   \   00000022   0xF8D4 0x1460      LDR      R1,[R4, #+1120]
   \   00000026   0x4628             MOV      R0,R5
   \   00000028   0x.... 0x....      BL       _ZN5Print5printEji
    755              SERIAL_PROTOCOLPGM("/");
   \   0000002C   0x....             ADR.N    R0,??DataTable56  ;; "/"
   \   0000002E   0x.... 0x....      BL       _Z14serialprintPGMPKc
    756              SERIAL_PROTOCOLLN(filesize);
   \   00000032   0x220A             MOVS     R2,#+10
   \   00000034   0xF8D4 0x145C      LDR      R1,[R4, #+1116]
   \   00000038   0x4628             MOV      R0,R5
   \   0000003A   0x.... 0x....      BL       _ZN5Print5printEji
   \   0000003E   0x210A             MOVS     R1,#+10
   \   00000040   0x4628             MOV      R0,R5
   \   00000042   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000046   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
    757            }
    758            else{
    759              SERIAL_PROTOCOLLNPGM(MSG_SD_NOT_PRINTING);
   \                     ??getStatus_1: (+1)
   \   0000004A   0x.... 0x....      ADR.W    R0,`?<Constant "Not SD printing\\n">`
   \   0000004E   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000052   0x.... 0x....      B.W      _Z14serialprintPGMPKc
    760            }
    761          }
    762          
    763          

   \                                 In section .text, align 2, keep-with-next
    764          void CardReader::startWrite(char *filename)
    765          {
   \                     _ZN10CardReader10startWriteEPc: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    766           //char sdFileName[100];
    767            //memset(sdFileName,0,sizeof(sdFileName));
    768            
    769              if(!cardOK && ! usbOK) return;
   \   00000006   0xF604 0x10B8      ADDW     R0,R4,#+2488
   \   0000000A   0x78C1             LDRB     R1,[R0, #+3]
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD102             BNE.N    ??startWrite_0
   \   00000010   0x7900             LDRB     R0,[R0, #+4]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD012             BEQ.N    ??startWrite_1
    770                f_close(&card.curFile);
   \                     ??startWrite_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable59_7
   \   0000001A   0x.... 0x....      BL       f_close
    771              sdmode = false;    sdprinting = false;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xF884 0x046C      STRB     R0,[R4, #+1132]
   \   00000024   0xF884 0x09B8      STRB     R0,[R4, #+2488]
    772              
    773              //fat.chdir();
    774          	
    775              //if(!file.open(filename, O_CREAT | O_APPEND | O_WRITE | O_TRUNC))
    776                  //strcat(sdFileName,SD_Path);
    777                  //strcat(sdFileName,filename);
    778          	if(f_open(&curFile, (const TCHAR *)filename, FA_CREATE_ALWAYS | FA_WRITE | FA_READ)  != FR_OK)
   \   00000028   0x220B             MOVS     R2,#+11
   \   0000002A   0x4629             MOV      R1,R5
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       f_open
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD102             BNE.N    ??startWrite_1
    779              {
    780               ///   Com::printFLN(Com::tOpenFailedFile,filename);
    781              }
    782              else
    783              {
    784            ///      UI_STATUS(UI_TEXT_UPLOADING);
    785                  savetosd = true;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xF884 0x046D      STRB     R0,[R4, #+1133]
    786             ///     Com::printFLN(Com::tWritingToFile,filename);
    787              }
    788          }
   \                     ??startWrite_1: (+1)
   \   0000003C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    789          

   \                                 In section .text, align 2, keep-with-next
    790          void CardReader::finishWrite()
    791          {
   \                     _ZN10CardReader11finishWriteEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    792              if(!savetosd) return; // already closed or never opened
   \   00000004   0xF894 0x046D      LDRB     R0,[R4, #+1133]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD008             BEQ.N    ??finishWrite_0
    793              //file.sync();
    794              //file.close();
    795              f_sync(&curFile);
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       f_sync
    796          	f_close(&curFile);
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       f_close
    797              savetosd = false;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF884 0x046D      STRB     R0,[R4, #+1133]
    798           ///   Com::printFLN(Com::tDoneSavingFile);
    799              //UI_CLEAR_STATUS;
    800          }
   \                     ??finishWrite_0: (+1)
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    801          
    802          

   \                                 In section .text, align 2, keep-with-next
    803          void CardReader::deleteFile(char *filename)	{}
   \                     _ZN10CardReader10deleteFileEPc: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    804          void CardReader::removeFile(char* filename) 
    805          {
   \                     _ZN10CardReader10removeFileEPc: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    806              if(!cardOK && !usbOK) return;
   \   00000006   0xF604 0x10B8      ADDW     R0,R4,#+2488
   \   0000000A   0x78C1             LDRB     R1,[R0, #+3]
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD102             BNE.N    ??removeFile_0
   \   00000010   0x7900             LDRB     R0,[R0, #+4]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD02B             BEQ.N    ??removeFile_1
    807              sdmode = false; sdprinting = false;
   \                     ??removeFile_0: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF884 0x046C      STRB     R0,[R4, #+1132]
   \   0000001C   0xF884 0x09B8      STRB     R0,[R4, #+2488]
    808          	
    809              f_close(&curFile);
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       f_close
    810              /*if(fat.remove(filename))
    811              {
    812                  Com::printFLN(Com::tFileDeleted);
    813              }
    814              else
    815              {
    816                  if(fat.rmdir(filename))
    817                      Com::printFLN(Com::tFileDeleted);
    818                  else
    819                      Com::printFLN(Com::tDeletionFailed);
    820              }*/
    821              if(f_unlink((const TCHAR *)filename) == FR_OK)
   \   00000026   0x.... 0x....      LDR.W    R6,??DataTable59_11
   \   0000002A   0x4628             MOV      R0,R5
   \   0000002C   0x.... 0x....      BL       f_unlink
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD10F             BNE.N    ??removeFile_2
    822          	{
    823            ///      Com::printFLN(Com::tFileDeleted);
    824            	SERIAL_PROTOCOLPGM("File deleted:");
   \   00000034   0x.... 0x....      ADR.W    R0,`?<Constant "File deleted:">`
   \   00000038   0x.... 0x....      BL       _Z14serialprintPGMPKc
    825            	SERIAL_PROTOCOLLN(filename);
   \   0000003C   0x4629             MOV      R1,R5
   \   0000003E   0x4630             MOV      R0,R6
   \   00000040   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   00000044   0x210A             MOVS     R1,#+10
   \   00000046   0x4630             MOV      R0,R6
   \   00000048   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    826            	sdpos = 0;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xF8C4 0x0460      STR      R0,[R4, #+1120]
   \   00000052   0xBD70             POP      {R4-R6,PC}
    827            
    828              }
    829          	else
    830          	{
    831          ///		Com::printFLN(Com::tDeletionFailed);
    832          	SERIAL_PROTOCOLPGM("Deletion failed, File: ");
   \                     ??removeFile_2: (+1)
   \   00000054   0x.... 0x....      ADR.W    R0,`?<Constant "Deletion failed, File: ">`
   \   00000058   0x.... 0x....      BL       _Z14serialprintPGMPKc
    833          	SERIAL_PROTOCOL(filename);
   \   0000005C   0x4629             MOV      R1,R5
   \   0000005E   0x4630             MOV      R0,R6
   \   00000060   0x.... 0x....      BL       _ZN5Print5printEPKc
    834          	SERIAL_PROTOCOLLNPGM(".");
   \   00000064   0x....             ADR.N    R0,??DataTable56_1  ;; 0x2E, 0x0A, 0x00, 0x00
   \   00000066   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000006A   0x.... 0x....      B.W      _Z14serialprintPGMPKc
    835          
    836          	}
    837          }
   \                     ??removeFile_1: (+1)
   \   0000006E   0xBD70             POP      {R4-R6,PC}       ;; return
    838          

   \                                 In section .text, align 2, keep-with-next
    839          void CardReader::makeDirectory(char *filename)
    840          {
   \                     _ZN10CardReader13makeDirectoryEPc: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
    841              if(!cardOK && !usbOK) return;
   \   00000004   0xF600 0x11B8      ADDW     R1,R0,#+2488
   \   00000008   0x78CA             LDRB     R2,[R1, #+3]
   \   0000000A   0x2A00             CMP      R2,#+0
   \   0000000C   0xD102             BNE.N    ??makeDirectory_0
   \   0000000E   0x7909             LDRB     R1,[R1, #+4]
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD023             BEQ.N    ??makeDirectory_1
    842              sdmode = false;	sdprinting = false;
   \                     ??makeDirectory_0: (+1)
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0xF880 0x146C      STRB     R1,[R0, #+1132]
   \   0000001A   0xF880 0x19B8      STRB     R1,[R0, #+2488]
    843              //file.close();
    844              f_close(&curFile);
   \   0000001E   0x.... 0x....      BL       f_close
    845              //if(fat.mkdir(filename))
    846              if(f_mkdir((const TCHAR *)filename) == FR_OK)
   \   00000022   0x.... 0x....      LDR.W    R5,??DataTable59_11
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       f_mkdir
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD10A             BNE.N    ??makeDirectory_2
    847              {
    848           ///       Com::printFLN(Com::tDirectoryCreated);
    849           		SERIAL_PROTOCOLLN("Directory created");
   \   00000030   0x.... 0x....      ADR.W    R1,`?<Constant "Directory created">`
   \   00000034   0x4628             MOV      R0,R5
   \   00000036   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   0000003A   0x210A             MOVS     R1,#+10
   \   0000003C   0x4628             MOV      R0,R5
   \   0000003E   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000042   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
    850              }
    851              else
    852              {
    853            ///      Com::printFLN(Com::tCreationFailed);
    854            SERIAL_PROTOCOLLN("Creation failed");
   \                     ??makeDirectory_2: (+1)
   \   00000046   0x.... 0x....      ADR.W    R1,`?<Constant "Creation failed">`
   \   0000004A   0x4628             MOV      R0,R5
   \   0000004C   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   00000050   0x210A             MOVS     R1,#+10
   \   00000052   0x4628             MOV      R0,R5
   \   00000054   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000058   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
    855              }
    856          }
   \                     ??makeDirectory_1: (+1)
   \   0000005C   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
    857          void CardReader::get_file_list(char *path)
    858          {
    859          	if( path == 0)
   \                     _ZN10CardReader13get_file_listEPc: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0xD001             BEQ.N    ??get_file_list_0
    860          	{
    861          		return;
    862          	}
    863          
    864          	Explore_Disk(path, 0);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x....             B.N      _ZN10CardReader12Explore_DiskEPch
   \                     ??get_file_list_0: (+1)
   \   00000008   0x4770             BX       LR               ;; return
    865          	
    866          	
    867          }
    868          

   \                                 In section .text, align 2, keep-with-next
    869          uint8_t CardReader::Explore_Disk (char* path , uint8_t recu_level)
    870          {
   \                     _ZN10CardReader12Explore_DiskEPch: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xF5AD 0x7D76      SUB      SP,SP,#+984
   \   00000008   0x460C             MOV      R4,R1
   \   0000000A   0x4615             MOV      R5,R2
    871          
    872            FILINFO fno;
    873            DIR dir;
    874           // SD_CardInfo cardinfo;
    875            TCHAR *fn;
    876            char tmp[200];
    877            char Fstream[200];
    878          	int local_offset;
    879          	int file_offset = 0;
   \   0000000C   0x2700             MOVS     R7,#+0
    880          	FRESULT res;
    881          	
    882            #if _USE_LFN
    883              static TCHAR lfn[_MAX_LFN + 1];
    884              fno.lfname = lfn;
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable59_12
   \   00000012   0x9106             STR      R1,[SP, #+24]
    885              fno.lfsize = sizeof(lfn);
   \   00000014   0xF44F 0x7180      MOV      R1,#+256
   \   00000018   0x9107             STR      R1,[SP, #+28]
    886          #endif
    887          
    888          	if(path == 0)
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0xD101             BNE.N    ??Explore_Disk_0
    889          		return 0;
   \   0000001E   0x4638             MOV      R0,R7
   \   00000020   0xE019             B.N      ??Explore_Disk_1
    890          /*
    891          	if(path[0] == '0')               //skyblue 2016-12-13
    892          		f_mount(0, &fs);
    893          	else if(path[0] == '1')
    894          		f_mount(1, &fs);
    895          	else
    896          		return;
    897          */	
    898                  f_mount(&fs, (char *)path, 0);     //skyblue 2016-12-13
   \                     ??Explore_Disk_0: (+1)
   \   00000022   0x463A             MOV      R2,R7
   \   00000024   0x4621             MOV      R1,R4
   \   00000026   0xF500 0x700B      ADD      R0,R0,#+556
   \   0000002A   0x.... 0x....      BL       f_mount
   \   0000002E   0xE008             B.N      ??Explore_Disk_2
    899                  
    900          	for(;;)
    901          	{
    902          		local_offset = 0;
    903          		
    904          		if (f_opendir(&dir, (const TCHAR *)path) == FR_OK) 
    905          	  	{
    906          
    907          		    while(1)
    908          		    {
    909          				res = f_readdir(&dir, &fno);
    910          				if (res != FR_OK || fno.fname[0] == 0) 
    911          				{
    912          					return;
                 					      ^
Warning[Pe117]: non-void function "CardReader::Explore_Disk" should return a
          value
    913          				}
    914          				if (fno.fname[0] == '.')
    915          				{
    916          					continue;
    917          				}
    918          
    919          				
    920          
    921          
    922          				if(local_offset >= file_offset)
    923          				{
    924          					file_offset++;
    925          					break;
    926          				}
    927          
    928          				local_offset++;
    929          		    }
    930          			
    931          		    if ((fno.lfname[0] == 0) || (fno.lfname == 0))
    932          				fn = fno.fname;
    933          			else
    934          				fn = fno.lfname;
    935          				
    936          		      	if((strstr((const char *)fn, ".gco")) || (strstr((const char *)fn, ".GCO")) || (strstr(fn, ".mdl"))|| (strstr(fn, ".MDL"))|| (fno.fattrib & AM_DIR))
    937          				{
    938          					  
    939          					  tmp[0] = '\0';
    940          					 // strcpy(tmp, path);
    941          					 // strcat(tmp, "/");
    942          					  strcat((char *)tmp, (char *)fn);
    943          
    944          					memset(Fstream, 0, sizeof(Fstream));
    945          					strcpy(Fstream, tmp);
    946          					  if((fno.fattrib & AM_DIR)&&(recu_level <= 10))
    947          				      {
    948          				      //  Explore_Disk(tmp, recu_level + 1);
    949          				      	
    950          						
    951          						strcat(Fstream, ".DIR\r\n");
   \                     ??Explore_Disk_3: (+1)
   \   00000030   0x.... 0x....      ADR.W    R1,`?<Constant ".DIR\\r\\n">`
   \   00000034   0x.... 0x....      BL       strcat
    952          						//send_to_wifi(Fstream, strlen(Fstream));
    953          					//Com::print(Fstream);
    954                             	//Com::printF(Com::tSlash);
    955          					
    956          						SERIAL_PROTOCOL(Fstream);
   \   00000038   0xA908             ADD      R1,SP,#+32
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable59_11
   \   0000003E   0x.... 0x....      BL       _ZN5Print5printEPKc
    957          						//SERIAL_PROTOCOLLNPGM("/");
    958          
    959          
    960          				      }
   \                     ??Explore_Disk_2: (+1)
   \   00000042   0xF04F 0x0800      MOV      R8,#+0
   \   00000046   0x4621             MOV      R1,R4
   \   00000048   0xA86C             ADD      R0,SP,#+432
   \   0000004A   0x.... 0x....      BL       f_opendir
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD007             BEQ.N    ??Explore_Disk_4
    961          					  else
    962          					  {					
    963          						strcat(Fstream, "\r\n");
    964          						//send_to_wifi(Fstream, strlen(Fstream));
    965          ///						Com::print(Fstream);
    966          ///                     	Com::printF(Com::tSlash);
    967          						SERIAL_PROTOCOL(Fstream);
    968          						//SERIAL_PROTOCOLLNPGM("/");
    969          
    970          					  }
    971          				}
    972          		  
    973          		      
    974          
    975          		     
    976          		    }
    977          				else
    978          					break;
    979          	
    980            	
    981          	}
    982           return res;
   \   00000052   0x4630             MOV      R0,R6
   \   00000054   0xB2C0             UXTB     R0,R0
   \                     ??Explore_Disk_1: (+1)
   \   00000056   0xF50D 0x7D76      ADD      SP,SP,#+984
   \   0000005A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   \                     ??Explore_Disk_5: (+1)
   \   0000005E   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??Explore_Disk_4: (+1)
   \   00000062   0xA900             ADD      R1,SP,#+0
   \   00000064   0xA86C             ADD      R0,SP,#+432
   \   00000066   0x.... 0x....      BL       f_readdir
   \   0000006A   0x0006             MOVS     R6,R0
   \   0000006C   0xD1F3             BNE.N    ??Explore_Disk_1
   \   0000006E   0xF99D 0x0009      LDRSB    R0,[SP, #+9]
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD0EF             BEQ.N    ??Explore_Disk_1
   \   00000076   0x282E             CMP      R0,#+46
   \   00000078   0xD0F3             BEQ.N    ??Explore_Disk_4
   \   0000007A   0x45B8             CMP      R8,R7
   \   0000007C   0xDBEF             BLT.N    ??Explore_Disk_5
   \   0000007E   0x1C7F             ADDS     R7,R7,#+1
   \   00000080   0xF8DD 0x8018      LDR      R8,[SP, #+24]
   \   00000084   0xF998 0x0000      LDRSB    R0,[R8, #+0]
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD002             BEQ.N    ??Explore_Disk_6
   \   0000008C   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000090   0xD101             BNE.N    ??Explore_Disk_7
   \                     ??Explore_Disk_6: (+1)
   \   00000092   0xF10D 0x0809      ADD      R8,SP,#+9
   \                     ??Explore_Disk_7: (+1)
   \   00000096   0x.... 0x....      ADR.W    R1,`?<Constant ".gco">`
   \   0000009A   0x4640             MOV      R0,R8
   \   0000009C   0x.... 0x....      BL       _Z6strstrPKcS0_
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD118             BNE.N    ??Explore_Disk_8
   \   000000A4   0x.... 0x....      ADR.W    R1,`?<Constant ".GCO">`
   \   000000A8   0x4640             MOV      R0,R8
   \   000000AA   0x.... 0x....      BL       _Z6strstrPKcS0_
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD111             BNE.N    ??Explore_Disk_8
   \   000000B2   0x.... 0x....      ADR.W    R1,`?<Constant ".mdl">`
   \   000000B6   0x4640             MOV      R0,R8
   \   000000B8   0x.... 0x....      BL       _Z6strstrPcPKc
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD10A             BNE.N    ??Explore_Disk_8
   \   000000C0   0x.... 0x....      ADR.W    R1,`?<Constant ".MDL">`
   \   000000C4   0x4640             MOV      R0,R8
   \   000000C6   0x.... 0x....      BL       _Z6strstrPcPKc
   \   000000CA   0x2800             CMP      R0,#+0
   \   000000CC   0xD103             BNE.N    ??Explore_Disk_8
   \   000000CE   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000000D2   0x06C0             LSLS     R0,R0,#+27
   \   000000D4   0xD5B5             BPL.N    ??Explore_Disk_2
   \                     ??Explore_Disk_8: (+1)
   \   000000D6   0x2000             MOVS     R0,#+0
   \   000000D8   0xF88D 0x00E8      STRB     R0,[SP, #+232]
   \   000000DC   0x4641             MOV      R1,R8
   \   000000DE   0xA83A             ADD      R0,SP,#+232
   \   000000E0   0x.... 0x....      BL       strcat
   \   000000E4   0x22C8             MOVS     R2,#+200
   \   000000E6   0x2100             MOVS     R1,#+0
   \   000000E8   0xA808             ADD      R0,SP,#+32
   \   000000EA   0x.... 0x....      BL       memset
   \   000000EE   0xA93A             ADD      R1,SP,#+232
   \   000000F0   0xA808             ADD      R0,SP,#+32
   \   000000F2   0x.... 0x....      BL       strcpy
   \   000000F6   0xF89D 0x1008      LDRB     R1,[SP, #+8]
   \   000000FA   0x06C9             LSLS     R1,R1,#+27
   \   000000FC   0xD501             BPL.N    ??Explore_Disk_9
   \   000000FE   0x2D0B             CMP      R5,#+11
   \   00000100   0xDB96             BLT.N    ??Explore_Disk_3
   \                     ??Explore_Disk_9: (+1)
   \   00000102   0x....             ADR.N    R1,??DataTable58  ;; 0x0D, 0x0A, 0x00, 0x00
   \   00000104   0xA808             ADD      R0,SP,#+32
   \   00000106   0x.... 0x....      BL       strcat
   \   0000010A   0xA908             ADD      R1,SP,#+32
   \   0000010C   0x.... 0x....      LDR.W    R0,??DataTable59_11
   \   00000110   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   00000114   0xE795             B.N      ??Explore_Disk_2
    983          }

   \                                 In section .bss, align 4
   \                     ??lfn:
   \   00000000                      DS8 256
    984          

   \                                 In section .text, align 2, keep-with-next
    985          void CardReader::ShowSDFiles(void)
    986          	{
   \                     _ZN10CardReader11ShowSDFilesEv: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xF5AD 0x7D44      SUB      SP,SP,#+784
   \   00000008   0x4604             MOV      R4,R0
    987          	  FILINFO fno;
    988          	  DIR dir;
    989          	  TCHAR *fn;
    990                const TCHAR gFileName[5] = {'.', 'g', 'c', 'o', '\0'};
                                   ^
Warning[Pe177]: variable "gFileName" was declared but never referenced
    991                const TCHAR gFileNameCap[5] = {'.', 'G', 'C', 'O', '\0'};
                                   ^
Warning[Pe177]: variable "gFileNameCap" was declared but never referenced
    992          	  TCHAR tmp[200];
    993          	  int res;
    994          	
    995            #if _USE_LFN
    996          		static TCHAR lfn[_MAX_LFN + 1];
    997            		memset(lfn,0,sizeof(lfn));
   \   0000000A   0x....             LDR.N    R5,??DataTable59_13
   \   0000000C   0xF44F 0x7280      MOV      R2,#+256
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x4628             MOV      R0,R5
   \   00000014   0x.... 0x....      BL       memset
    998          		fno.lfname = lfn;
   \   00000018   0x9506             STR      R5,[SP, #+24]
    999          		fno.lfsize = _MAX_LFN + 1;
   \   0000001A   0xF44F 0x7080      MOV      R0,#+256
   \   0000001E   0x9007             STR      R0,[SP, #+28]
   1000          #endif
   1001          	 
   1002          	
   1003          	 //f_mount(1, &fs);
   1004          	 #if 0//
   1005                    if ((SD_DET_IP == SD_DETECT_INVERTED)&&(usbOK == false))                 
   1006                      f_mount(&fs, (TCHAR const*)SD_Path, 0);     //skyblue 2016-12-13
   1007                    else
   1008                      f_mount(&fs, (TCHAR const*)USBH_Path, 0);
   1009          	#else  
   1010          	if (gCfgItems.fileSysType == FILE_SYS_SD)                 
   \   00000020   0xF504 0x700B      ADD      R0,R4,#+556
   \   00000024   0x....             LDR.N    R1,??DataTable59_14
   \   00000026   0xF991 0x10DA      LDRSB    R1,[R1, #+218]
   \   0000002A   0x2901             CMP      R1,#+1
   \   0000002C   0xD104             BNE.N    ??ShowSDFiles_0
   1011                   f_mount(&fs, (TCHAR const*)SD_Path, 0);     //skyblue 2016-12-13
   \   0000002E   0x2200             MOVS     R2,#+0
   \   00000030   0x....             LDR.N    R1,??DataTable59_3
   \   00000032   0x.... 0x....      BL       f_mount
   \   00000036   0xE003             B.N      ??ShowSDFiles_1
   1012               else
   1013                   f_mount(&fs, (TCHAR const*)USBH_Path, 0);	
   \                     ??ShowSDFiles_0: (+1)
   \   00000038   0x2200             MOVS     R2,#+0
   \   0000003A   0x....             LDR.N    R1,??DataTable59_5
   \   0000003C   0x.... 0x....      BL       f_mount
   1014          	 #endif
   1015          	 if (f_opendir(&dir, gCurDir) == FR_OK) 
   \                     ??ShowSDFiles_1: (+1)
   \   00000040   0xF604 0x15B6      ADDW     R5,R4,#+2486
   \   00000044   0xF204 0x479C      ADDW     R7,R4,#+1180
   \   00000048   0x4639             MOV      R1,R7
   \   0000004A   0xA83A             ADD      R0,SP,#+232
   \   0000004C   0x.... 0x....      BL       f_opendir
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xF040 0x80E7      BNE.W    ??ShowSDFiles_2
   1016          	  {
   1017          		Sd_file_cnt = 0;
   \   00000056   0xF204 0x4894      ADDW     R8,R4,#+1172
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xF8C8 0x0004      STR      R0,[R8, #+4]
   1018          			gcodeFileList.listVaild= 2;
   \   00000060   0x2002             MOVS     R0,#+2
   \   00000062   0x7068             STRB     R0,[R5, #+1]
   \   00000064   0xE002             B.N      ??ShowSDFiles_3
   1019          		for (;;) 
   1020          		{
   1021          			res = f_readdir(&dir, &fno);
   1022          			if (res != FR_OK || fno.fname[0] == 0) 
   1023          			{
   1024          				gcodeFileList.listVaild= 2;
   1025          				break;
   1026          			}
   1027          			if ( fno.fname[0] == '.') 
   1028          				continue;
   1029          			if ((fno.lfname[0] == 0) || (fno.lfname == 0))
   1030          				fn = fno.fname;
   1031          			else
   1032          				fn = fno.lfname;
   1033          			if((strstr(fn,"System Volume Information")!=NULL)
   1034          				&&(fno.fattrib & AM_DIR))//≤ªœ‘ æsdø®µƒ“˛≤ÿŒƒº˛º–"System Volume Information"
   1035          				continue;
   1036          
   1037          			/*	 if (fno.fattrib & AM_DIR) 
   1038          			{
   1039          			continue;
   1040          			} 
   1041          			else */
   1042          			if(Sd_file_cnt == Sd_file_offset)
   1043          			{
   1044          				//Sd_file_offset++;
   1045          				#if _LFN_UNICODE
   1046          				if((wcsstr((const wchar_t *)fn, (const wchar_t *)gFileName)) || (wcsstr((const wchar_t *)fn, (const wchar_t *)gFileNameCap)) || (fno.fattrib & AM_DIR))
   1047          				#else
   1048          					if((strstr(fn, ".gco")&&(*(strstr(fn, ".gcode")+5+1)==NULL)) 
   1049          						|| (strstr(fn, ".GCO")&&(*(strstr(fn, ".GCODE")+5+1)==NULL)) 
   1050          						|| (strstr(fn, ".mdl")&&(*(strstr(fn, ".mdlp")+4+1)==NULL))
   1051          						|| (strstr(fn, ".MDL")&&(*(strstr(fn, ".mdlp")+4+1)==NULL))
   1052          						|| (strstr(fn, ".pho")&&(*(strstr(fn, ".photon")+6+1)==NULL))
   1053          						|| (strstr(fn, ".PHO")&&(*(strstr(fn, ".PHOTON")+6+1)==NULL))
   1054          						|| (strstr(fn, ".cbd")&&(*(strstr(fn, ".cbddlp")+6+1)==NULL))
   1055          						|| (strstr(fn, ".CBD")&&(*(strstr(fn, ".CBDDLP")+6+1)==NULL))
   1056          						|| (fno.fattrib & AM_DIR))
   1057          				#endif
   1058          				{
   1059          					  //Sd_display_file_cnt++;
   1060          					  
   1061          					  tmp[0] = '\0';
   1062          					  strcpy(tmp, (char const*)gCurDir);
   1063          					  strcat(tmp, "/");
   1064          					  #if _LFN_UNICODE
   1065          					  wcscat((wchar_t *)tmp, (const wchar_t *)fn);
   1066          					  #else
   1067          					  strcat(tmp, fn);
   1068          					  #endif
   1069          	
   1070          					  gcodeFileList.listVaild= 1;
   1071          	
   1072          					if(fno.fattrib & AM_DIR)
   1073          					{
   1074          						gcodeFileList.fileAttr[gcodeFileList.index] = 1;
   1075          					}
   1076          					else
   1077          					{
   1078          						gcodeFileList.fileAttr[gcodeFileList.index] = 0;
   1079          					}
   1080          	
   1081          					#if _LFN_UNICODE
   1082          					wcscpy((wchar_t *)gcodeFileList.fileName[gcodeFileList.index], (const wchar_t *)tmp);
   1083          					#else
   1084          					strcpy((char *)gcodeFileList.fileName[gcodeFileList.index], (const char *)tmp);
   1085          					#endif
   1086          					gcodeFileList.index++;
   1087          					
   1088          					
   1089          				}
   1090          				else
   1091          				{
   1092          					gcodeFileList.listVaild= 0;
   1093          				}
   1094          				break;
   1095          			}
   1096          			
   1097          			Sd_file_cnt++;
   \                     ??ShowSDFiles_4: (+1)
   \   00000066   0x1C40             ADDS     R0,R0,#+1
   \   00000068   0xF8C8 0x0004      STR      R0,[R8, #+4]
   \                     ??ShowSDFiles_3: (+1)
   \   0000006C   0xA900             ADD      R1,SP,#+0
   \   0000006E   0xA83A             ADD      R0,SP,#+232
   \   00000070   0x.... 0x....      BL       f_readdir
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xF040 0x80D5      BNE.W    ??ShowSDFiles_2
   \   0000007A   0xF99D 0x0009      LDRSB    R0,[SP, #+9]
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xF000 0x80D0      BEQ.W    ??ShowSDFiles_2
   \   00000084   0x282E             CMP      R0,#+46
   \   00000086   0xD0F1             BEQ.N    ??ShowSDFiles_3
   \   00000088   0x9E06             LDR      R6,[SP, #+24]
   \   0000008A   0xF996 0x0000      LDRSB    R0,[R6, #+0]
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD001             BEQ.N    ??ShowSDFiles_5
   \   00000092   0x2E00             CMP      R6,#+0
   \   00000094   0xD101             BNE.N    ??ShowSDFiles_6
   \                     ??ShowSDFiles_5: (+1)
   \   00000096   0xF10D 0x0609      ADD      R6,SP,#+9
   \                     ??ShowSDFiles_6: (+1)
   \   0000009A   0x.... 0x....      ADR.W    R1,`?<Constant "System Volume Informa...">`
   \   0000009E   0x4630             MOV      R0,R6
   \   000000A0   0x.... 0x....      BL       _Z6strstrPcPKc
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD003             BEQ.N    ??ShowSDFiles_7
   \   000000A8   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000000AC   0x06C0             LSLS     R0,R0,#+27
   \   000000AE   0xD4DD             BMI.N    ??ShowSDFiles_3
   \                     ??ShowSDFiles_7: (+1)
   \   000000B0   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   000000B4   0xF8D4 0x1494      LDR      R1,[R4, #+1172]
   \   000000B8   0x4288             CMP      R0,R1
   \   000000BA   0xD1D4             BNE.N    ??ShowSDFiles_4
   \   000000BC   0x.... 0x....      ADR.W    R1,`?<Constant ".gco">`
   \   000000C0   0x4630             MOV      R0,R6
   \   000000C2   0x.... 0x....      BL       _Z6strstrPcPKc
   \   000000C6   0x2800             CMP      R0,#+0
   \   000000C8   0xD008             BEQ.N    ??ShowSDFiles_8
   \   000000CA   0x.... 0x....      ADR.W    R1,`?<Constant ".gcode">`
   \   000000CE   0x4630             MOV      R0,R6
   \   000000D0   0x.... 0x....      BL       _Z6strstrPcPKc
   \   000000D4   0xF990 0x0006      LDRSB    R0,[R0, #+6]
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0xD073             BEQ.N    ??ShowSDFiles_9
   \                     ??ShowSDFiles_8: (+1)
   \   000000DC   0x.... 0x....      ADR.W    R1,`?<Constant ".GCO">`
   \   000000E0   0x4630             MOV      R0,R6
   \   000000E2   0x.... 0x....      BL       _Z6strstrPcPKc
   \   000000E6   0x2800             CMP      R0,#+0
   \   000000E8   0xD008             BEQ.N    ??ShowSDFiles_10
   \   000000EA   0x.... 0x....      ADR.W    R1,`?<Constant ".GCODE">`
   \   000000EE   0x4630             MOV      R0,R6
   \   000000F0   0x.... 0x....      BL       _Z6strstrPcPKc
   \   000000F4   0xF990 0x0006      LDRSB    R0,[R0, #+6]
   \   000000F8   0x2800             CMP      R0,#+0
   \   000000FA   0xD063             BEQ.N    ??ShowSDFiles_9
   \                     ??ShowSDFiles_10: (+1)
   \   000000FC   0x.... 0x....      ADR.W    R1,`?<Constant ".mdl">`
   \   00000100   0x4630             MOV      R0,R6
   \   00000102   0x.... 0x....      BL       _Z6strstrPcPKc
   \   00000106   0x2800             CMP      R0,#+0
   \   00000108   0xD008             BEQ.N    ??ShowSDFiles_11
   \   0000010A   0x.... 0x....      ADR.W    R1,`?<Constant ".mdlp">`
   \   0000010E   0x4630             MOV      R0,R6
   \   00000110   0x.... 0x....      BL       _Z6strstrPcPKc
   \   00000114   0xF990 0x0005      LDRSB    R0,[R0, #+5]
   \   00000118   0x2800             CMP      R0,#+0
   \   0000011A   0xD053             BEQ.N    ??ShowSDFiles_9
   \                     ??ShowSDFiles_11: (+1)
   \   0000011C   0x.... 0x....      ADR.W    R1,`?<Constant ".MDL">`
   \   00000120   0x4630             MOV      R0,R6
   \   00000122   0x.... 0x....      BL       _Z6strstrPcPKc
   \   00000126   0x2800             CMP      R0,#+0
   \   00000128   0xD008             BEQ.N    ??ShowSDFiles_12
   \   0000012A   0x.... 0x....      ADR.W    R1,`?<Constant ".mdlp">`
   \   0000012E   0x4630             MOV      R0,R6
   \   00000130   0x.... 0x....      BL       _Z6strstrPcPKc
   \   00000134   0xF990 0x0005      LDRSB    R0,[R0, #+5]
   \   00000138   0x2800             CMP      R0,#+0
   \   0000013A   0xD043             BEQ.N    ??ShowSDFiles_9
   \                     ??ShowSDFiles_12: (+1)
   \   0000013C   0x.... 0x....      ADR.W    R1,`?<Constant ".pho">`
   \   00000140   0x4630             MOV      R0,R6
   \   00000142   0x.... 0x....      BL       _Z6strstrPcPKc
   \   00000146   0x2800             CMP      R0,#+0
   \   00000148   0xD008             BEQ.N    ??ShowSDFiles_13
   \   0000014A   0x.... 0x....      ADR.W    R1,`?<Constant ".photon">`
   \   0000014E   0x4630             MOV      R0,R6
   \   00000150   0x.... 0x....      BL       _Z6strstrPcPKc
   \   00000154   0xF990 0x0007      LDRSB    R0,[R0, #+7]
   \   00000158   0x2800             CMP      R0,#+0
   \   0000015A   0xD033             BEQ.N    ??ShowSDFiles_9
   \                     ??ShowSDFiles_13: (+1)
   \   0000015C   0x.... 0x....      ADR.W    R1,`?<Constant ".PHO">`
   \   00000160   0x4630             MOV      R0,R6
   \   00000162   0x.... 0x....      BL       _Z6strstrPcPKc
   \   00000166   0x2800             CMP      R0,#+0
   \   00000168   0xD008             BEQ.N    ??ShowSDFiles_14
   \   0000016A   0x.... 0x....      ADR.W    R1,`?<Constant ".PHOTON">`
   \   0000016E   0x4630             MOV      R0,R6
   \   00000170   0x.... 0x....      BL       _Z6strstrPcPKc
   \   00000174   0xF990 0x0007      LDRSB    R0,[R0, #+7]
   \   00000178   0x2800             CMP      R0,#+0
   \   0000017A   0xD023             BEQ.N    ??ShowSDFiles_9
   \                     ??ShowSDFiles_14: (+1)
   \   0000017C   0x.... 0x....      ADR.W    R1,`?<Constant ".cbd">`
   \   00000180   0x4630             MOV      R0,R6
   \   00000182   0x.... 0x....      BL       _Z6strstrPcPKc
   \   00000186   0x2800             CMP      R0,#+0
   \   00000188   0xD008             BEQ.N    ??ShowSDFiles_15
   \   0000018A   0x.... 0x....      ADR.W    R1,`?<Constant ".cbddlp">`
   \   0000018E   0x4630             MOV      R0,R6
   \   00000190   0x.... 0x....      BL       _Z6strstrPcPKc
   \   00000194   0xF990 0x0007      LDRSB    R0,[R0, #+7]
   \   00000198   0x2800             CMP      R0,#+0
   \   0000019A   0xD013             BEQ.N    ??ShowSDFiles_9
   \                     ??ShowSDFiles_15: (+1)
   \   0000019C   0x.... 0x....      ADR.W    R1,`?<Constant ".CBD">`
   \   000001A0   0x4630             MOV      R0,R6
   \   000001A2   0x.... 0x....      BL       _Z6strstrPcPKc
   \   000001A6   0x2800             CMP      R0,#+0
   \   000001A8   0xD008             BEQ.N    ??ShowSDFiles_16
   \   000001AA   0x.... 0x....      ADR.W    R1,`?<Constant ".CBDDLP">`
   \   000001AE   0x4630             MOV      R0,R6
   \   000001B0   0x.... 0x....      BL       _Z6strstrPcPKc
   \   000001B4   0xF990 0x0007      LDRSB    R0,[R0, #+7]
   \   000001B8   0x2800             CMP      R0,#+0
   \   000001BA   0xD003             BEQ.N    ??ShowSDFiles_9
   \                     ??ShowSDFiles_16: (+1)
   \   000001BC   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000001C0   0x06C0             LSLS     R0,R0,#+27
   \   000001C2   0xD52C             BPL.N    ??ShowSDFiles_17
   \                     ??ShowSDFiles_9: (+1)
   \   000001C4   0x2000             MOVS     R0,#+0
   \   000001C6   0xF88D 0x0020      STRB     R0,[SP, #+32]
   \   000001CA   0x4639             MOV      R1,R7
   \   000001CC   0xA808             ADD      R0,SP,#+32
   \   000001CE   0x.... 0x....      BL       strcpy
   \   000001D2   0x....             ADR.N    R1,??DataTable59  ;; "/"
   \   000001D4   0x.... 0x....      BL       strcat
   \   000001D8   0x4631             MOV      R1,R6
   \   000001DA   0xA808             ADD      R0,SP,#+32
   \   000001DC   0x.... 0x....      BL       strcat
   \   000001E0   0x2001             MOVS     R0,#+1
   \   000001E2   0x7068             STRB     R0,[R5, #+1]
   \   000001E4   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000001E8   0xF000 0x0010      AND      R0,R0,#0x10
   \   000001EC   0x1E41             SUBS     R1,R0,#+1
   \   000001EE   0x4189             SBCS     R1,R1,R1
   \   000001F0   0x43C9             MVNS     R1,R1
   \   000001F2   0x0FC9             LSRS     R1,R1,#+31
   \   000001F4   0xF894 0x09B6      LDRB     R0,[R4, #+2486]
   \   000001F8   0x1900             ADDS     R0,R0,R4
   \   000001FA   0xF880 0x19B0      STRB     R1,[R0, #+2480]
   \   000001FE   0xA908             ADD      R1,SP,#+32
   \   00000200   0xF894 0x09B6      LDRB     R0,[R4, #+2486]
   \   00000204   0x22C8             MOVS     R2,#+200
   \   00000206   0xFB12 0x4000      SMLABB   R0,R2,R0,R4
   \   0000020A   0xF500 0x60A0      ADD      R0,R0,#+1280
   \   0000020E   0x.... 0x....      BL       strcpy
   \   00000212   0xF894 0x09B6      LDRB     R0,[R4, #+2486]
   \   00000216   0x1C40             ADDS     R0,R0,#+1
   \   00000218   0xF884 0x09B6      STRB     R0,[R4, #+2486]
   \   0000021C   0xE004             B.N      ??ShowSDFiles_18
   \                     ??ShowSDFiles_17: (+1)
   \   0000021E   0x2000             MOVS     R0,#+0
   \   00000220   0x7068             STRB     R0,[R5, #+1]
   \   00000222   0xE001             B.N      ??ShowSDFiles_18
   1098          			
   1099          			 
   1100          		}
   1101          #if 0
   1102          		while (f_readdir(&dirs, &finfo) == FR_OK)  
   1103          		{
   1104          		  if (finfo.fattrib & AM_ARC) 
   1105          		  {
   1106          			if(!finfo.fname[0]) 
   1107          			  break;		 
   1108          			  printf("\n\r file name is: %s\n",finfo.fname);
   1109          			  printf("\n\r file size is: %d ", finfo.fsize); 
   1110          	
   1111          			  if(File_type_Check( (u8 *)finfo.fname, "txt"))
   1112          			  { 
   1113          				BufferSet(buffer, 0, 100);
   1114          				res = f_open(&fsrc, finfo.fname, FA_OPEN_EXISTING | FA_READ);
   1115          				res = f_read(&fsrc, buffer, 100, &br);
   1116          				printf("\n\r file contex is: \n\r%s\n\r", buffer); 
   1117          				f_close(&fsrc); 							  
   1118          			  }
   1119          		  }
   1120          		  else
   1121          		  {
   1122          			printf("\n\r Path name is: %s", finfo.fname); 
   1123          			continue;//break;
   1124          		  }
   1125          		} 
   1126          		  res = f_open(&fsrc, "armjishu.txt", FA_CREATE_ALWAYS | FA_WRITE);
   1127          		  res = f_write(&fsrc, &armjishu, sizeof(armjishu), &bw);
   1128          		  f_close(&fsrc);
   1129          	#endif
   1130          	  
   1131          	 }
   1132          	 else
   1133          		 gcodeFileList.listVaild= 2;
   \                     ??ShowSDFiles_2: (+1)
   \   00000224   0x2002             MOVS     R0,#+2
   \   00000226   0x7068             STRB     R0,[R5, #+1]
   1134          	 
   1135          	}
   \                     ??ShowSDFiles_18: (+1)
   \   00000228   0xF50D 0x7D44      ADD      SP,SP,#+784
   \   0000022C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .bss, align 4
   \                     ??lfn_1:
   \   00000000                      DS8 256
   1136          

   \                                 In section .text, align 2, keep-with-next
   1137          int CardReader::ascii2dec(char *ascii, char width)
   1138          {
   \                     _ZN10CardReader9ascii2decEPcc: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   1139          	int i = 0;
   \   00000002   0x2300             MOVS     R3,#+0
   1140          	int result = 0;
   \   00000004   0x4618             MOV      R0,R3
   1141          
   1142          	if(ascii == 0)
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD105             BNE.N    ??ascii2dec_0
   1143          		return 0;
   1144          	
   1145          	while(i < width)
   1146          	{		
   1147          		result = result << 4;
   1148          		
   1149          		if(*(ascii + i) >= '0' && *(ascii + i) <= '9')
   1150          			result += *(ascii + i) - '0';
   1151          		else if(*(ascii + i) >= 'a' && *(ascii + i) <= 'f')
   1152          			result += *(ascii + i) - 'a' + 0x0a;
   1153          		else if(*(ascii + i) >= 'A' && *(ascii + i) <= 'F')
   1154          			result += *(ascii + i) - 'A' + 0x0a;
   1155          		else
   1156          			return 0;
   \                     ??ascii2dec_1: (+1)
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xE01A             B.N      ??ascii2dec_2
   \                     ??ascii2dec_3: (+1)
   \   0000000E   0x3C30             SUBS     R4,R4,#+48
   \   00000010   0xEB14 0x1000      ADDS     R0,R4,R0, LSL #+4
   1157          		
   1158          		i++;
   \                     ??ascii2dec_4: (+1)
   \   00000014   0x1C5B             ADDS     R3,R3,#+1
   \                     ??ascii2dec_0: (+1)
   \   00000016   0x4293             CMP      R3,R2
   \   00000018   0xDA14             BGE.N    ??ascii2dec_2
   \   0000001A   0x565C             LDRSB    R4,[R3, R1]
   \   0000001C   0x4625             MOV      R5,R4
   \   0000001E   0xF1A5 0x0630      SUB      R6,R5,#+48
   \   00000022   0x2E0A             CMP      R6,#+10
   \   00000024   0xD3F3             BCC.N    ??ascii2dec_3
   \   00000026   0xF1A5 0x0661      SUB      R6,R5,#+97
   \   0000002A   0x2E06             CMP      R6,#+6
   \   0000002C   0xD203             BCS.N    ??ascii2dec_5
   \   0000002E   0x3C57             SUBS     R4,R4,#+87
   \   00000030   0xEB14 0x1000      ADDS     R0,R4,R0, LSL #+4
   \   00000034   0xE7EE             B.N      ??ascii2dec_4
   \                     ??ascii2dec_5: (+1)
   \   00000036   0x3D41             SUBS     R5,R5,#+65
   \   00000038   0x2D06             CMP      R5,#+6
   \   0000003A   0xD2E6             BCS.N    ??ascii2dec_1
   \   0000003C   0x3C37             SUBS     R4,R4,#+55
   \   0000003E   0xEB14 0x1000      ADDS     R0,R4,R0, LSL #+4
   \   00000042   0xE7E7             B.N      ??ascii2dec_4
   1159          	}
   1160          	return result;
   \                     ??ascii2dec_2: (+1)
   \   00000044   0xBC70             POP      {R4-R6}
   \   00000046   0x4770             BX       LR               ;; return
   1161          }
   1162          
   1163          /*---------------------------------mks add begin-------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   1164          uint32_t CardReader::getsdpos()
   1165          {
   1166          	//sdpos = file.curPosition();
   1167          	return sdpos;
   \                     _ZN10CardReader8getsdposEv: (+1)
   \   00000000   0xF8D0 0x0460      LDR      R0,[R0, #+1120]
   \   00000004   0x4770             BX       LR               ;; return
   1168          }

   \                                 In section .text, align 2, keep-with-next
   1169          void CardReader::printingHasFinished()
   1170          {
   \                     _ZN10CardReader19printingHasFinishedEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1171              stepper.synchronize();
   \   00000004   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   1172          	f_close(&curFile);
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0x.... 0x....      BL       f_close
   1173          
   1174              sdprinting = false;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF884 0x09B8      STRB     R0,[R4, #+2488]
   1175          	sdmode = 0;
   \   00000014   0xF884 0x046C      STRB     R0,[R4, #+1132]
   1176              if (SD_FINISHED_STEPPERRELEASE)
   1177                enqueue_and_echo_commands_P(PSTR(SD_FINISHED_RELEASECOMMAND));
   \   00000018   0x.... 0x....      ADR.W    R0,`?<Constant "M84 X Y Z E">`
   \   0000001C   0x.... 0x....      BL       _Z27enqueue_and_echo_commands_PPKc
   1178              print_job_timer.stop();
   \   00000020   0x....             LDR.N    R4,??DataTable59_15
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       _ZN9Stopwatch4stopEv
   1179          
   1180              if (print_job_timer.duration() > 60)
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       _ZN9Stopwatch8durationEv
   \   0000002E   0x283D             CMP      R0,#+61
   \   00000030   0xD304             BCC.N    ??printingHasFinished_0
   1181                enqueue_and_echo_commands_P(PSTR("M31"));
   \   00000032   0x....             ADR.N    R0,??DataTable59_2  ;; "M31"
   \   00000034   0xE8BD 0x4010      POP      {R4,LR}
   \   00000038   0x.... 0x....      B.W      _Z27enqueue_and_echo_commands_PPKc
   1182          }
   \                     ??printingHasFinished_0: (+1)
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
   1183          
   1184          
   1185          
   1186          
   1187          
   1188          

   \                                 In section .text, align 2, keep-with-next
   1189          void CardReader::closefile(bool store_location)
   1190          {
   \                     _ZN10CardReader9closefileEb: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1191            f_close(&curFile);
   \   00000004   0x.... 0x....      BL       f_close
   1192            saving = false;  
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF884 0x09B9      STRB     R0,[R4, #+2489]
   1193            logging = false;
   \   0000000E   0xF884 0x09BA      STRB     R0,[R4, #+2490]
   1194            
   1195          }
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
   1196          

   \                                 In section .text, align 2, keep-with-next
   1197          void CardReader::openLogFile(char* name)
   1198          {
   1199            logging = true;
   \                     _ZN10CardReader11openLogFileEPc: (+1)
   \   00000000   0x2201             MOVS     R2,#+1
   \   00000002   0xF880 0x29BA      STRB     R2,[R0, #+2490]
   1200            openFile(name, false);
   \   00000006   0x4613             MOV      R3,R2
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x....             B.N      _ZN10CardReader8openFileEPcbb
   1201          }
   1202          

   \                                 In section .text, align 2, keep-with-next
   1203          void CardReader::write_command(char *buf)
   1204          {
   \                     _ZN10CardReader13write_commandEPc: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   1205            unsigned int lastBufferEntry = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x9001             STR      R0,[SP, #+4]
   1206            FRESULT writeStatus;
   1207            char* begin = buf;
   1208            char* npos = 0;
   1209            char* end = buf + strlen(buf) - 1;
   \   0000000C   0x4628             MOV      R0,R5
   \   0000000E   0x.... 0x....      BL       strlen
   \   00000012   0x1940             ADDS     R0,R0,R5
   \   00000014   0x1E46             SUBS     R6,R0,#+1
   1210          	
   1211          	memset(&writeStatus, 0, sizeof(FRESULT));
   \   00000016   0x2201             MOVS     R2,#+1
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0xA800             ADD      R0,SP,#+0
   \   0000001C   0x.... 0x....      BL       memset
   1212          
   1213            if((npos = strchr(buf, 'N')) != NULL)
   \   00000020   0x214E             MOVS     R1,#+78
   \   00000022   0x4628             MOV      R0,R5
   \   00000024   0x.... 0x....      BL       _Z6strchrPci
   \   00000028   0x0007             MOVS     R7,R0
   \   0000002A   0xD008             BEQ.N    ??write_command_0
   1214            {
   1215              begin = strchr(npos, ' ') + 1;
   \   0000002C   0x2120             MOVS     R1,#+32
   \   0000002E   0x.... 0x....      BL       _Z6strchrPci
   \   00000032   0x1C45             ADDS     R5,R0,#+1
   1216              end = strchr(npos, '*') - 1;
   \   00000034   0x212A             MOVS     R1,#+42
   \   00000036   0x4638             MOV      R0,R7
   \   00000038   0x.... 0x....      BL       _Z6strchrPci
   \   0000003C   0x1E46             SUBS     R6,R0,#+1
   1217            }
   1218            end[1] = '\r';
   \                     ??write_command_0: (+1)
   \   0000003E   0x200D             MOVS     R0,#+13
   \   00000040   0x7070             STRB     R0,[R6, #+1]
   1219            end[2] = '\n';
   \   00000042   0x200A             MOVS     R0,#+10
   \   00000044   0x70B0             STRB     R0,[R6, #+2]
   1220            
   1221            writeStatus = f_write(&curFile, begin, &(end[2]) - begin + 1, &lastBufferEntry);
   \   00000046   0x1CB0             ADDS     R0,R6,#+2
   \   00000048   0x1B40             SUBS     R0,R0,R5
   \   0000004A   0x1C46             ADDS     R6,R0,#+1
   \   0000004C   0xAB01             ADD      R3,SP,#+4
   \   0000004E   0x4632             MOV      R2,R6
   \   00000050   0x4629             MOV      R1,R5
   \   00000052   0x4620             MOV      R0,R4
   \   00000054   0x.... 0x....      BL       f_write
   \   00000058   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1222            if( 	(writeStatus != FR_OK) ||
   1223          		(lastBufferEntry != (unsigned int)(&(end[2]) - begin + 1)))
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD102             BNE.N    ??write_command_1
   \   00000060   0x9801             LDR      R0,[SP, #+4]
   \   00000062   0x42B0             CMP      R0,R6
   \   00000064   0xD006             BEQ.N    ??write_command_2
   1224            {
   1225              SERIAL_ERROR_START();
   \                     ??write_command_1: (+1)
   \   00000066   0x....             LDR.N    R0,??DataTable59_16
   \   00000068   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1226              SERIAL_ERRORLNPGM(MSG_SD_ERR_WRITE_TO_FILE);
   \   0000006C   0x.... 0x....      ADR.W    R0,`?<Constant "error writing to file\\n">`
   \   00000070   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1227            }
   1228          }
   \                     ??write_command_2: (+1)
   \   00000074   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "M31">`:
   \   00000000   0x4D 0x33          DC8 "M31"
   \              0x31 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {'\\000'}>`:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {'\\000'}>_1`:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000021   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000031   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000041   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000051   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "/">`:
   \   00000000   0x2F 0x00          DC8 "/"

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant ".\\n">`:
   \   00000000   0x2E 0x0A          DC8 ".\012"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "\\r\\n">`:
   \   00000000   0x0D 0x0A          DC8 "\015\012"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp CardReader::subobject CardReader()
   \                     _ZN10CardReaderC2Ev: (+1)
   \   00000000   0xBF00             Nop      
   \   00000002                      REQUIRE _ZN10CardReaderC1Ev
   \   00000002                      ;; // Fall through to label CardReader::CardReader()

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable56:
   \   00000000   0x2F 0x00          DC8      "/",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable56_1:
   \   00000000   0x2E 0x0A          DC8      0x2E, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable58:
   \   00000000   0x0D 0x0A          DC8      0x0D, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59:
   \   00000000   0x2F 0x00          DC8      "/",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_1:
   \   00000000   0x........         DC32     echomagic

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_2:
   \   00000000   0x4D 0x33          DC8      "M31"
   \              0x31 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_3:
   \   00000000   0x........         DC32     SD_Path

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_4:
   \   00000000   0x........         DC32     Appli_state

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_5:
   \   00000000   0x........         DC32     USBH_Path

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_6:
   \   00000000   0x........         DC32     USBH_Driver

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_7:
   \   00000000   0x........         DC32     card

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_8:
   \   00000000   0x4241828C         DC32     0x4241828c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_9:
   \   00000000   0x........         DC32     mksReprint

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_10:
   \   00000000   0x........         DC32     textt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_11:
   \   00000000   0x........         DC32     Serial6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_12:
   \   00000000   0x........         DC32     ??lfn

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_13:
   \   00000000   0x........         DC32     ??lfn_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_14:
   \   00000000   0x........         DC32     gCfgItems

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_15:
   \   00000000   0x........         DC32     print_job_timer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_16:
   \   00000000   0x........         DC32     errormagic

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "USB init fail\\n">`:
   \   00000000   0x55 0x53          DC8 "USB init fail\012"
   \              0x42 0x20    
   \              0x69 0x6E    
   \              0x69 0x74    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x0A    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "USB OK\\n">`:
   \   00000000   0x55 0x53          DC8 "USB OK\012"
   \              0x42 0x20    
   \              0x4F 0x4B    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "M84 X Y Z E">`:
   \   00000000   0x4D 0x38          DC8 "M84 X Y Z E"
   \              0x34 0x20    
   \              0x58 0x20    
   \              0x59 0x20    
   \              0x5A 0x20    
   \              0x45 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "SD card removed\\n">`:
   \   00000000   0x53 0x44          DC8 "SD card removed\012"
   \              0x20 0x63    
   \              0x61 0x72    
   \              0x64 0x20    
   \              0x72 0x65    
   \              0x6D 0x6F    
   \              0x76 0x65    
   \              0x64 0x0A    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "USB inserted\\n">`:
   \   00000000   0x55 0x53          DC8 "USB inserted\012"
   \              0x42 0x20    
   \              0x69 0x6E    
   \              0x73 0x65    
   \              0x72 0x74    
   \              0x65 0x64    
   \              0x0A 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "USB removed\\n">`:
   \   00000000   0x55 0x53          DC8 "USB removed\012"
   \              0x42 0x20    
   \              0x72 0x65    
   \              0x6D 0x6F    
   \              0x76 0x65    
   \              0x64 0x0A    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "USB DeInit!\\n">`:
   \   00000000   0x55 0x53          DC8 "USB DeInit!\012"
   \              0x42 0x20    
   \              0x44 0x65    
   \              0x49 0x6E    
   \              0x69 0x74    
   \              0x21 0x0A    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "File opened: ">`:
   \   00000000   0x46 0x69          DC8 "File opened: "
   \              0x6C 0x65    
   \              0x20 0x6F    
   \              0x70 0x65    
   \              0x6E 0x65    
   \              0x64 0x3A    
   \              0x20 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Size: ">`:
   \   00000000   0x20 0x53          DC8 " Size: "
   \              0x69 0x7A    
   \              0x65 0x3A    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "File selected\\n">`:
   \   00000000   0x46 0x69          DC8 "File selected\012"
   \              0x6C 0x65    
   \              0x20 0x73    
   \              0x65 0x6C    
   \              0x65 0x63    
   \              0x74 0x65    
   \              0x64 0x0A    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "open failed, File: ">`:
   \   00000000   0x6F 0x70          DC8 "open failed, File: "
   \              0x65 0x6E    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x2C    
   \              0x20 0x46    
   \              0x69 0x6C    
   \              0x65 0x3A    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "SD printing byte ">`:
   \   00000000   0x53 0x44          DC8 "SD printing byte "
   \              0x20 0x70    
   \              0x72 0x69    
   \              0x6E 0x74    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x62 0x79    
   \              0x74 0x65    
   \              0x20 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Not SD printing\\n">`:
   \   00000000   0x4E 0x6F          DC8 "Not SD printing\012"
   \              0x74 0x20    
   \              0x53 0x44    
   \              0x20 0x70    
   \              0x72 0x69    
   \              0x6E 0x74    
   \              0x69 0x6E    
   \              0x67 0x0A    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "File deleted:">`:
   \   00000000   0x46 0x69          DC8 "File deleted:"
   \              0x6C 0x65    
   \              0x20 0x64    
   \              0x65 0x6C    
   \              0x65 0x74    
   \              0x65 0x64    
   \              0x3A 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Deletion failed, File: ">`:
   \   00000000   0x44 0x65          DC8 "Deletion failed, File: "
   \              0x6C 0x65    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x2C    
   \              0x20 0x46    
   \              0x69 0x6C    
   \              0x65 0x3A    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "error writing to file\\n">`:
   \   00000000   0x65 0x72          DC8 "error writing to file\012"
   \              0x72 0x6F    
   \              0x72 0x20    
   \              0x77 0x72    
   \              0x69 0x74    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x74 0x6F    
   \              0x20 0x66    
   \              0x69 0x6C    
   \              0x65 0x0A    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "USB Reset!\\n">`:
   \   00000000   0x55 0x53          DC8 "USB Reset!\012"
   \              0x42 0x20    
   \              0x52 0x65    
   \              0x73 0x65    
   \              0x74 0x21    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Directory created">`:
   \   00000000   0x44 0x69          DC8 "Directory created"
   \              0x72 0x65    
   \              0x63 0x74    
   \              0x6F 0x72    
   \              0x79 0x20    
   \              0x63 0x72    
   \              0x65 0x61    
   \              0x74 0x65    
   \              0x64 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Creation failed">`:
   \   00000000   0x43 0x72          DC8 "Creation failed"
   \              0x65 0x61    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant ".gco">`:
   \   00000000   0x2E 0x67          DC8 ".gco"
   \              0x63 0x6F    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant ".GCO">`:
   \   00000000   0x2E 0x47          DC8 ".GCO"
   \              0x43 0x4F    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant ".mdl">`:
   \   00000000   0x2E 0x6D          DC8 ".mdl"
   \              0x64 0x6C    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant ".MDL">`:
   \   00000000   0x2E 0x4D          DC8 ".MDL"
   \              0x44 0x4C    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant ".DIR\\r\\n">`:
   \   00000000   0x2E 0x44          DC8 ".DIR\015\012"
   \              0x49 0x52    
   \              0x0D 0x0A    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "System Volume Informa...">`:
   \   00000000   0x53 0x79          DC8 "System Volume Information"
   \              0x73 0x74    
   \              0x65 0x6D    
   \              0x20 0x56    
   \              0x6F 0x6C    
   \              0x75 0x6D    
   \              0x65 0x20    
   \              0x49 0x6E    
   \              0x66 0x6F    
   \              0x72 0x6D    
   \              0x61 0x74    
   \              0x69 0x6F    
   \              0x6E 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant ".gcode">`:
   \   00000000   0x2E 0x67          DC8 ".gcode"
   \              0x63 0x6F    
   \              0x64 0x65    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant ".GCODE">`:
   \   00000000   0x2E 0x47          DC8 ".GCODE"
   \              0x43 0x4F    
   \              0x44 0x45    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant ".mdlp">`:
   \   00000000   0x2E 0x6D          DC8 ".mdlp"
   \              0x64 0x6C    
   \              0x70 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant ".pho">`:
   \   00000000   0x2E 0x70          DC8 ".pho"
   \              0x68 0x6F    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant ".photon">`:
   \   00000000   0x2E 0x70          DC8 ".photon"
   \              0x68 0x6F    
   \              0x74 0x6F    
   \              0x6E 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant ".PHO">`:
   \   00000000   0x2E 0x50          DC8 ".PHO"
   \              0x48 0x4F    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant ".PHOTON">`:
   \   00000000   0x2E 0x50          DC8 ".PHOTON"
   \              0x48 0x4F    
   \              0x54 0x4F    
   \              0x4E 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant ".cbd">`:
   \   00000000   0x2E 0x63          DC8 ".cbd"
   \              0x62 0x64    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant ".cbddlp">`:
   \   00000000   0x2E 0x63          DC8 ".cbddlp"
   \              0x62 0x64    
   \              0x64 0x6C    
   \              0x70 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant ".CBD">`:
   \   00000000   0x2E 0x43          DC8 ".CBD"
   \              0x42 0x44    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant ".CBDDLP">`:
   \   00000000   0x2E 0x43          DC8 ".CBDDLP"
   \              0x42 0x44    
   \              0x44 0x4C    
   \              0x50 0x00    
   1229          
   1230          #if 0
   1231          void CardReader::openLogFile(char* name) {
   1232            logging = true;
   1233            openFile(name, false);
   1234          }
   1235          
   1236          void appendAtom(SdFile &file, char *& dst, uint8_t &cnt) {
   1237            file.getFilename(dst);
   1238            while (*dst && cnt < MAXPATHNAMELENGTH) { dst++; cnt++; }
   1239            if (cnt < MAXPATHNAMELENGTH) { *dst = '/'; dst++; cnt++; }
   1240          }
   1241          
   1242          void CardReader::getAbsFilename(char *t) {
   1243            *t++ = '/';                                               // Root folder
   1244            uint8_t cnt = 1;
   1245          
   1246            for (uint8_t i = 0; i < workDirDepth; i++)                // Loop to current work dir
   1247              appendAtom(workDirParents[i], t, cnt);
   1248          
   1249            if (cnt < MAXPATHNAMELENGTH - (FILENAME_LENGTH)) {
   1250              appendAtom(file, t, cnt);
   1251              --t;
   1252            }
   1253            *t = '\0';
   1254          }
   1255          
   1256          void CardReader::openFile(char* name, const bool read, const bool subcall/*=false*/) {
   1257          
   1258            if (!cardOK) return;
   1259          
   1260            uint8_t doing = 0;
   1261            if (isFileOpen()) {                     // Replacing current file or doing a subroutine
   1262              if (subcall) {
   1263                if (file_subcall_ctr > SD_PROCEDURE_DEPTH - 1) {
   1264                  SERIAL_ERROR_START();
   1265                  SERIAL_ERRORPGM("trying to call sub-gcode files with too many levels. MAX level is:");
   1266                  SERIAL_ERRORLN(SD_PROCEDURE_DEPTH);
   1267                  kill(PSTR(MSG_KILLED));
   1268                  return;
   1269                }
   1270          
   1271                // Store current filename (based on workDirParents) and position
   1272                getAbsFilename(proc_filenames[file_subcall_ctr]);
   1273                filespos[file_subcall_ctr] = sdpos;
   1274          
   1275                SERIAL_ECHO_START();
   1276                SERIAL_ECHOPAIR("SUBROUTINE CALL target:\"", name);
   1277                SERIAL_ECHOPAIR("\" parent:\"", proc_filenames[file_subcall_ctr]);
   1278                SERIAL_ECHOLNPAIR("\" pos", sdpos);
   1279                file_subcall_ctr++;
   1280              }
   1281              else
   1282                doing = 1;
   1283            }
   1284            else if (subcall) {     // Returning from a subcall?
   1285              SERIAL_ECHO_START();
   1286              SERIAL_ECHOLNPGM("END SUBROUTINE");
   1287            }
   1288            else {                  // Opening fresh file
   1289              doing = 2;
   1290              file_subcall_ctr = 0; // Reset procedure depth in case user cancels print while in procedure
   1291            }
   1292          
   1293            if (doing) {
   1294              SERIAL_ECHO_START();
   1295              SERIAL_ECHOPGM("Now ");
   1296              serialprintPGM(doing == 1 ? PSTR("doing") : PSTR("fresh"));
   1297              SERIAL_ECHOLNPAIR(" file: ", name);
   1298            }
   1299          
   1300            stopSDPrint();
   1301          
   1302            SdFile myDir;
   1303            curDir = &root;
   1304            char *fname = name;
   1305            char *dirname_start, *dirname_end;
   1306          
   1307            if (name[0] == '/') {
   1308              dirname_start = &name[1];
   1309              while (dirname_start != NULL) {
   1310                dirname_end = strchr(dirname_start, '/');
   1311                //SERIAL_ECHOPGM("start:");SERIAL_ECHOLN((int)(dirname_start - name));
   1312                //SERIAL_ECHOPGM("end  :");SERIAL_ECHOLN((int)(dirname_end - name));
   1313                if (dirname_end != NULL && dirname_end > dirname_start) {
   1314                  char subdirname[FILENAME_LENGTH];
   1315                  strncpy(subdirname, dirname_start, dirname_end - dirname_start);
   1316                  subdirname[dirname_end - dirname_start] = '\0';
   1317                  if (!myDir.open(curDir, subdirname, O_READ)) {
   1318                    SERIAL_PROTOCOLPGM(MSG_SD_OPEN_FILE_FAIL);
   1319                    SERIAL_PROTOCOL(subdirname);
   1320                    SERIAL_PROTOCOLCHAR('.');
   1321                    return;
   1322                  }
   1323                  else {
   1324                    //SERIAL_ECHOLNPGM("dive ok");
   1325                  }
   1326          
   1327                  curDir = &myDir;
   1328                  dirname_start = dirname_end + 1;
   1329                }
   1330                else { // the remainder after all /fsa/fdsa/ is the filename
   1331                  fname = dirname_start;
   1332                  //SERIAL_ECHOLNPGM("remainder");
   1333                  //SERIAL_ECHOLN(fname);
   1334                  break;
   1335                }
   1336              }
   1337            }
   1338            else
   1339              curDir = &workDir; // Relative paths start in current directory
   1340          
   1341            if (read) {
   1342              if (file.open(curDir, fname, O_READ)) {
   1343                filesize = file.fileSize();
   1344                sdpos = 0;
   1345                SERIAL_PROTOCOLPAIR(MSG_SD_FILE_OPENED, fname);
   1346                SERIAL_PROTOCOLLNPAIR(MSG_SD_SIZE, filesize);
   1347                SERIAL_PROTOCOLLNPGM(MSG_SD_FILE_SELECTED);
   1348                getfilename(0, fname);
   1349                lcd_setstatus(longFilename[0] ? longFilename : fname);
   1350              }
   1351              else {
   1352                SERIAL_PROTOCOLPAIR(MSG_SD_OPEN_FILE_FAIL, fname);
   1353                SERIAL_PROTOCOLCHAR('.');
   1354                SERIAL_EOL();
   1355              }
   1356            }
   1357            else { //write
   1358              if (!file.open(curDir, fname, O_CREAT | O_APPEND | O_WRITE | O_TRUNC)) {
   1359                SERIAL_PROTOCOLPAIR(MSG_SD_OPEN_FILE_FAIL, fname);
   1360                SERIAL_PROTOCOLCHAR('.');
   1361                SERIAL_EOL();
   1362              }
   1363              else {
   1364                saving = true;
   1365                SERIAL_PROTOCOLLNPAIR(MSG_SD_WRITE_TO_FILE, name);
   1366                lcd_setstatus(fname);
   1367              }
   1368            }
   1369          }
   1370          
   1371          void CardReader::removeFile(const char * const name) {
   1372            if (!cardOK) return;
   1373          
   1374            stopSDPrint();
   1375          
   1376            SdFile myDir;
   1377            curDir = &root;
   1378            const char *fname = name;
   1379          
   1380            char *dirname_start, *dirname_end;
   1381            if (name[0] == '/') {
   1382              dirname_start = strchr(name, '/') + 1;
   1383              while (dirname_start != NULL) {
   1384                dirname_end = strchr(dirname_start, '/');
   1385                //SERIAL_ECHOPGM("start:");SERIAL_ECHOLN((int)(dirname_start - name));
   1386                //SERIAL_ECHOPGM("end  :");SERIAL_ECHOLN((int)(dirname_end - name));
   1387                if (dirname_end != NULL && dirname_end > dirname_start) {
   1388                  char subdirname[FILENAME_LENGTH];
   1389                  strncpy(subdirname, dirname_start, dirname_end - dirname_start);
   1390                  subdirname[dirname_end - dirname_start] = 0;
   1391                  SERIAL_ECHOLN(subdirname);
   1392                  if (!myDir.open(curDir, subdirname, O_READ)) {
   1393                    SERIAL_PROTOCOLPAIR(MSG_SD_OPEN_FILE_FAIL, subdirname);
   1394                    SERIAL_PROTOCOLCHAR('.');
   1395                    SERIAL_EOL();
   1396                    return;
   1397                  }
   1398          
   1399                  curDir = &myDir;
   1400                  dirname_start = dirname_end + 1;
   1401                }
   1402                else {
   1403                  fname = dirname_start;
   1404                  break;
   1405                }
   1406              }
   1407            }
   1408            else // Relative paths are rooted in the current directory
   1409              curDir = &workDir;
   1410          
   1411            if (file.remove(curDir, fname)) {
   1412              SERIAL_PROTOCOLPGM("File deleted:");
   1413              SERIAL_PROTOCOLLN(fname);
   1414              sdpos = 0;
   1415              #if ENABLED(SDCARD_SORT_ALPHA)
   1416                presort();
   1417              #endif
   1418            }
   1419            else {
   1420              SERIAL_PROTOCOLPGM("Deletion failed, File: ");
   1421              SERIAL_PROTOCOL(fname);
   1422              SERIAL_PROTOCOLCHAR('.');
   1423            }
   1424          }
   1425          
   1426          void CardReader::getStatus() {
   1427            if (cardOK) {
   1428              SERIAL_PROTOCOLPGM(MSG_SD_PRINTING_BYTE);
   1429              SERIAL_PROTOCOL(sdpos);
   1430              SERIAL_PROTOCOLCHAR('/');
   1431              SERIAL_PROTOCOLLN(filesize);
   1432            }
   1433            else
   1434              SERIAL_PROTOCOLLNPGM(MSG_SD_NOT_PRINTING);
   1435          }
   1436          
   1437          void CardReader::write_command(char *buf) {
   1438            char* begin = buf;
   1439            char* npos = NULL;
   1440            char* end = buf + strlen(buf) - 1;
   1441          
   1442            file.writeError = false;
   1443            if ((npos = strchr(buf, 'N')) != NULL) {
   1444              begin = strchr(npos, ' ') + 1;
   1445              end = strchr(npos, '*') - 1;
   1446            }
   1447            end[1] = '\r';
   1448            end[2] = '\n';
   1449            end[3] = '\0';
   1450            file.write(begin);
   1451            if (file.writeError) {
   1452              SERIAL_ERROR_START();
   1453              SERIAL_ERRORLNPGM(MSG_SD_ERR_WRITE_TO_FILE);
   1454            }
   1455          }
   1456          
   1457          void CardReader::checkautostart(bool force) {
   1458            if (!force && (!autostart_stilltocheck || PENDING(millis(), next_autostart_ms)))
   1459              return;
   1460          
   1461            autostart_stilltocheck = false;
   1462          
   1463            if (!cardOK) {
   1464              initsd();
   1465              if (!cardOK) return; // fail
   1466            }
   1467          
   1468            char autoname[10];
   1469            sprintf_P(autoname, PSTR("auto%i.g"), autostart_index);
   1470            for (int8_t i = 0; i < (int8_t)strlen(autoname); i++) autoname[i] = tolower(autoname[i]);
   1471          
   1472            dir_t p;
   1473          
   1474            root.rewind();
   1475          
   1476            bool found = false;
   1477            while (root.readDir(p, NULL) > 0) {
   1478              for (int8_t i = (int8_t)strlen((char*)p.name); i--;) p.name[i] = tolower(p.name[i]);
   1479              if (p.name[9] != '~' && strncmp((char*)p.name, autoname, 5) == 0) {
   1480                openAndPrintFile(autoname);
   1481                found = true;
   1482              }
   1483            }
   1484            if (!found)
   1485              autostart_index = -1;
   1486            else
   1487              autostart_index++;
   1488          }
   1489          
   1490          void CardReader::closefile(bool store_location) {
   1491            file.sync();
   1492            file.close();
   1493            saving = logging = false;
   1494          
   1495            if (store_location) {
   1496              //future: store printer state, filename and position for continuing a stopped print
   1497              // so one can unplug the printer and continue printing the next day.
   1498            }
   1499          }
   1500          
   1501          /**
   1502           * Get the name of a file in the current directory by index
   1503           */
   1504          void CardReader::getfilename(uint16_t nr, const char * const match/*=NULL*/) {
   1505            #if ENABLED(SDSORT_CACHE_NAMES)
   1506              if (match != NULL) {
   1507                while (nr < sort_count) {
   1508                  if (strcasecmp(match, sortshort[nr]) == 0) break;
   1509                  nr++;
   1510                }
   1511              }
   1512              if (nr < sort_count) {
   1513                strcpy(filename, sortshort[nr]);
   1514                strcpy(longFilename, sortnames[nr]);
   1515                filenameIsDir = TEST(isDir[nr>>3], nr & 0x07);
   1516                return;
   1517              }
   1518            #endif // SDSORT_CACHE_NAMES
   1519            curDir = &workDir;
   1520            lsAction = LS_GetFilename;
   1521            nrFile_index = nr;
   1522            curDir->rewind();
   1523            lsDive("", *curDir, match);
   1524          }
   1525          
   1526          uint16_t CardReader::getnrfilenames() {
   1527            curDir = &workDir;
   1528            lsAction = LS_Count;
   1529            nrFiles = 0;
   1530            curDir->rewind();
   1531            lsDive("", *curDir);
   1532            //SERIAL_ECHOLN(nrFiles);
   1533            return nrFiles;
   1534          }
   1535          
   1536          void CardReader::chdir(const char * relpath) {
   1537            SdFile newDir;
   1538            SdFile *parent = &root;
   1539          
   1540            if (workDir.isOpen()) parent = &workDir;
   1541          
   1542            if (!newDir.open(*parent, relpath, O_READ)) {
   1543              SERIAL_ECHO_START();
   1544              SERIAL_ECHOPGM(MSG_SD_CANT_ENTER_SUBDIR);
   1545              SERIAL_ECHOLN(relpath);
   1546            }
   1547            else {
   1548              workDir = newDir;
   1549              if (workDirDepth < MAX_DIR_DEPTH)
   1550                workDirParents[workDirDepth++] = workDir;
   1551              #if ENABLED(SDCARD_SORT_ALPHA)
   1552                presort();
   1553              #endif
   1554            }
   1555          }
   1556          
   1557          int8_t CardReader::updir() {
   1558            if (workDirDepth > 0) {                                               // At least 1 dir has been saved
   1559              workDir = --workDirDepth ? workDirParents[workDirDepth - 1] : root; // Use parent, or root if none
   1560              #if ENABLED(SDCARD_SORT_ALPHA)
   1561                presort();
   1562              #endif
   1563            }
   1564            return workDirDepth;
   1565          }
   1566          
   1567          
   1568          #if ENABLED(SDCARD_SORT_ALPHA)
   1569          
   1570            /**
   1571             * Get the name of a file in the current directory by sort-index
   1572             */
   1573            void CardReader::getfilename_sorted(const uint16_t nr) {
   1574              getfilename(
   1575                #if ENABLED(SDSORT_GCODE)
   1576                  sort_alpha &&
   1577                #endif
   1578                (nr < sort_count) ? sort_order[nr] : nr
   1579              );
   1580            }
   1581          
   1582            /**
   1583             * Read all the files and produce a sort key
   1584             *
   1585             * We can do this in 3 ways...
   1586             *  - Minimal RAM: Read two filenames at a time sorting along...
   1587             *  - Some RAM: Buffer the directory just for this sort
   1588             *  - Most RAM: Buffer the directory and return filenames from RAM
   1589             */
   1590            void CardReader::presort() {
   1591          
   1592              // Sorting may be turned off
   1593              #if ENABLED(SDSORT_GCODE)
   1594                if (!sort_alpha) return;
   1595              #endif
   1596          
   1597              // Throw away old sort index
   1598              flush_presort();
   1599          
   1600              // If there are files, sort up to the limit
   1601              uint16_t fileCnt = getnrfilenames();
   1602              if (fileCnt > 0) {
   1603          
   1604                // Never sort more than the max allowed
   1605                // If you use folders to organize, 20 may be enough
   1606                if (fileCnt > SDSORT_LIMIT) fileCnt = SDSORT_LIMIT;
   1607          
   1608                // Sort order is always needed. May be static or dynamic.
   1609                #if ENABLED(SDSORT_DYNAMIC_RAM)
   1610                  sort_order = new uint8_t[fileCnt];
   1611                #endif
   1612          
   1613                // Use RAM to store the entire directory during pre-sort.
   1614                // SDSORT_LIMIT should be set to prevent over-allocation.
   1615                #if ENABLED(SDSORT_USES_RAM)
   1616          
   1617                  // If using dynamic ram for names, allocate on the heap.
   1618                  #if ENABLED(SDSORT_CACHE_NAMES)
   1619                    #if ENABLED(SDSORT_DYNAMIC_RAM)
   1620                      sortshort = new char*[fileCnt];
   1621                      sortnames = new char*[fileCnt];
   1622                    #endif
   1623                  #elif ENABLED(SDSORT_USES_STACK)
   1624                    char sortnames[fileCnt][SORTED_LONGNAME_MAXLEN];
   1625                  #endif
   1626          
   1627                  // Folder sorting needs 1 bit per entry for flags.
   1628                  #if HAS_FOLDER_SORTING
   1629                    #if ENABLED(SDSORT_DYNAMIC_RAM)
   1630                      isDir = new uint8_t[(fileCnt + 7) >> 3];
   1631                    #elif ENABLED(SDSORT_USES_STACK)
   1632                      uint8_t isDir[(fileCnt + 7) >> 3];
   1633                    #endif
   1634                  #endif
   1635          
   1636                #else // !SDSORT_USES_RAM
   1637          
   1638                  // By default re-read the names from SD for every compare
   1639                  // retaining only two filenames at a time. This is very
   1640                  // slow but is safest and uses minimal RAM.
   1641                  char name1[LONG_FILENAME_LENGTH + 1];
   1642          
   1643                #endif
   1644          
   1645                if (fileCnt > 1) {
   1646          
   1647                  // Init sort order.
   1648                  for (uint16_t i = 0; i < fileCnt; i++) {
   1649                    sort_order[i] = i;
   1650                    // If using RAM then read all filenames now.
   1651                    #if ENABLED(SDSORT_USES_RAM)
   1652                      getfilename(i);
   1653                      #if ENABLED(SDSORT_DYNAMIC_RAM)
   1654                        // Use dynamic method to copy long filename
   1655                        sortnames[i] = strdup(LONGEST_FILENAME);
   1656                        #if ENABLED(SDSORT_CACHE_NAMES)
   1657                          // When caching also store the short name, since
   1658                          // we're replacing the getfilename() behavior.
   1659                          sortshort[i] = strdup(filename);
   1660                        #endif
   1661                      #else
   1662                        // Copy filenames into the static array
   1663                        #if SORTED_LONGNAME_MAXLEN != LONG_FILENAME_LENGTH
   1664                          strncpy(sortnames[i], LONGEST_FILENAME, SORTED_LONGNAME_MAXLEN);
   1665                          sortnames[i][SORTED_LONGNAME_MAXLEN - 1] = '\0';
   1666                        #else
   1667                          strncpy(sortnames[i], LONGEST_FILENAME, SORTED_LONGNAME_MAXLEN);
   1668                        #endif
   1669                        #if ENABLED(SDSORT_CACHE_NAMES)
   1670                          strcpy(sortshort[i], filename);
   1671                        #endif
   1672                      #endif
   1673                      // char out[30];
   1674                      // sprintf_P(out, PSTR("---- %i %s %s"), i, filenameIsDir ? "D" : " ", sortnames[i]);
   1675                      // SERIAL_ECHOLN(out);
   1676                      #if HAS_FOLDER_SORTING
   1677                        const uint16_t bit = i & 0x07, ind = i >> 3;
   1678                        if (bit == 0) isDir[ind] = 0x00;
   1679                        if (filenameIsDir) isDir[ind] |= _BV(bit);
   1680                      #endif
   1681                    #endif
   1682                  }
   1683          
   1684                  // Bubble Sort
   1685                  for (uint16_t i = fileCnt; --i;) {
   1686                    bool didSwap = false;
   1687                    for (uint16_t j = 0; j < i; ++j) {
   1688                      const uint16_t o1 = sort_order[j], o2 = sort_order[j + 1];
   1689          
   1690                      // Compare names from the array or just the two buffered names
   1691                      #if ENABLED(SDSORT_USES_RAM)
   1692                        #define _SORT_CMP_NODIR() (strcasecmp(sortnames[o1], sortnames[o2]) > 0)
   1693                      #else
   1694                        #define _SORT_CMP_NODIR() (strcasecmp(name1, name2) > 0)
   1695                      #endif
   1696          
   1697                      #if HAS_FOLDER_SORTING
   1698                        #if ENABLED(SDSORT_USES_RAM)
   1699                          // Folder sorting needs an index and bit to test for folder-ness.
   1700                          const uint8_t ind1 = o1 >> 3, bit1 = o1 & 0x07,
   1701                                        ind2 = o2 >> 3, bit2 = o2 & 0x07;
   1702                          #define _SORT_CMP_DIR(fs) \
   1703                            (((isDir[ind1] & _BV(bit1)) != 0) == ((isDir[ind2] & _BV(bit2)) != 0) \
   1704                              ? _SORT_CMP_NODIR() \
   1705                              : (isDir[fs > 0 ? ind1 : ind2] & (fs > 0 ? _BV(bit1) : _BV(bit2))) != 0)
   1706                        #else
   1707                          #define _SORT_CMP_DIR(fs) ((dir1 == filenameIsDir) ? _SORT_CMP_NODIR() : (fs > 0 ? dir1 : !dir1))
   1708                        #endif
   1709                      #endif
   1710          
   1711                      // The most economical method reads names as-needed
   1712                      // throughout the loop. Slow if there are many.
   1713                      #if DISABLED(SDSORT_USES_RAM)
   1714                        getfilename(o1);
   1715                        strcpy(name1, LONGEST_FILENAME); // save (or getfilename below will trounce it)
   1716                        #if HAS_FOLDER_SORTING
   1717                          bool dir1 = filenameIsDir;
   1718                        #endif
   1719                        getfilename(o2);
   1720                        char *name2 = LONGEST_FILENAME; // use the string in-place
   1721                      #endif // !SDSORT_USES_RAM
   1722          
   1723                      // Sort the current pair according to settings.
   1724                      if (
   1725                        #if HAS_FOLDER_SORTING
   1726                          #if ENABLED(SDSORT_GCODE)
   1727                            sort_folders ? _SORT_CMP_DIR(sort_folders) : _SORT_CMP_NODIR()
   1728                          #else
   1729                            _SORT_CMP_DIR(FOLDER_SORTING)
   1730                          #endif
   1731                        #else
   1732                          _SORT_CMP_NODIR()
   1733                        #endif
   1734                      ) {
   1735                        sort_order[j] = o2;
   1736                        sort_order[j + 1] = o1;
   1737                        didSwap = true;
   1738                      }
   1739                    }
   1740                    if (!didSwap) break;
   1741                  }
   1742                  // Using RAM but not keeping names around
   1743                  #if ENABLED(SDSORT_USES_RAM) && DISABLED(SDSORT_CACHE_NAMES)
   1744                    #if ENABLED(SDSORT_DYNAMIC_RAM)
   1745                      for (uint16_t i = 0; i < fileCnt; ++i) free(sortnames[i]);
   1746                      #if HAS_FOLDER_SORTING
   1747                        free(isDir);
   1748                      #endif
   1749                    #endif
   1750                  #endif
   1751                }
   1752                else {
   1753                  sort_order[0] = 0;
   1754                  #if ENABLED(SDSORT_USES_RAM) && ENABLED(SDSORT_CACHE_NAMES)
   1755                    getfilename(0);
   1756                    #if ENABLED(SDSORT_DYNAMIC_RAM)
   1757                      sortnames = new char*[1];
   1758                      sortnames[0] = strdup(LONGEST_FILENAME); // malloc
   1759                      #if ENABLED(SDSORT_CACHE_NAMES)
   1760                        sortshort = new char*[1];
   1761                        sortshort[0] = strdup(filename);       // malloc
   1762                      #endif
   1763                      isDir = new uint8_t[1];
   1764                    #else
   1765                      #if SORTED_LONGNAME_MAXLEN != LONG_FILENAME_LENGTH
   1766                        strncpy(sortnames[0], LONGEST_FILENAME, SORTED_LONGNAME_MAXLEN);
   1767                        sortnames[0][SORTED_LONGNAME_MAXLEN - 1] = '\0';
   1768                      #else
   1769                        strncpy(sortnames[0], LONGEST_FILENAME, SORTED_LONGNAME_MAXLEN);
   1770                      #endif
   1771                      #if ENABLED(SDSORT_CACHE_NAMES)
   1772                        strcpy(sortshort[0], filename);
   1773                      #endif
   1774                    #endif
   1775                    isDir[0] = filenameIsDir ? 0x01 : 0x00;
   1776                  #endif
   1777                }
   1778          
   1779                sort_count = fileCnt;
   1780              }
   1781            }
   1782          
   1783            void CardReader::flush_presort() {
   1784              if (sort_count > 0) {
   1785                #if ENABLED(SDSORT_DYNAMIC_RAM)
   1786                  delete sort_order;
   1787                  #if ENABLED(SDSORT_CACHE_NAMES)
   1788                    for (uint8_t i = 0; i < sort_count; ++i) {
   1789                      free(sortshort[i]); // strdup
   1790                      free(sortnames[i]); // strdup
   1791                    }
   1792                    delete sortshort;
   1793                    delete sortnames;
   1794                  #endif
   1795                #endif
   1796                sort_count = 0;
   1797              }
   1798            }
   1799          
   1800          #endif // SDCARD_SORT_ALPHA
   1801          
   1802          uint16_t CardReader::get_num_Files() {
   1803            return
   1804              #if ENABLED(SDCARD_SORT_ALPHA) && SDSORT_USES_RAM && SDSORT_CACHE_NAMES
   1805                nrFiles // no need to access the SD card for filenames
   1806              #else
   1807                getnrfilenames()
   1808              #endif
   1809            ;
   1810          }
   1811          
   1812          void CardReader::printingHasFinished() {
   1813            stepper.synchronize();
   1814            file.close();
   1815            if (file_subcall_ctr > 0) { // Heading up to a parent file that called current as a procedure.
   1816              file_subcall_ctr--;
   1817              openFile(proc_filenames[file_subcall_ctr], true, true);
   1818              setIndex(filespos[file_subcall_ctr]);
   1819              startFileprint();
   1820            }
   1821            else {
   1822              sdprinting = false;
   1823              #if ENABLED(SD_FINISHED_STEPPERRELEASE) && defined(SD_FINISHED_RELEASECOMMAND)
   1824                stepper.cleaning_buffer_counter = 1; // The command will fire from the Stepper ISR
   1825              #endif
   1826              print_job_timer.stop();
   1827              if (print_job_timer.duration() > 60)
   1828                enqueue_and_echo_commands_P(PSTR("M31"));
   1829              #if ENABLED(SDCARD_SORT_ALPHA)
   1830                presort();
   1831              #endif
   1832          
   1833              #if ENABLED(SD_REPRINT_LAST_SELECTED_FILE)
   1834                lcd_reselect_last_file();
   1835              #endif
   1836            }
   1837          }
   1838          #endif
   1839          
   1840          #endif // SDSUPPORT

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   CardReader::CardReader()
         8   -> SdBaseFile::SdBaseFile()
    1008   CardReader::Explore_Disk(char *, uint8_t)
      1008   -> Print::print(char const *)
      1008   -> f_mount
      1008   -> f_opendir
      1008   -> f_readdir
      1008   -> memset
      1008   -> strcat
      1008   -> strcpy
      1008   -> strstr(char *, char const *)
      1008   -> strstr(char const *, char const *)
     808   CardReader::ShowSDFiles()
       808   -> f_mount
       808   -> f_opendir
       808   -> f_readdir
       808   -> memset
       808   -> strcat
       808   -> strcpy
       808   -> strstr(char *, char const *)
      12   CardReader::ascii2dec(char *, char)
       0   CardReader::automount()
      24   CardReader::checkFilesys(unsigned char)
        24   -> FATFS_LinkDriver_usb
        24   -> FATFS_UnLinkDriver
        24   -> MX_USB_HOST_DeInit
        24   -> f_mount
         0   -> serialprintPGM(char const *)
        24   -> serialprintPGM(char const *)
      24   CardReader::checkautostart(bool)
        24   -> CardReader::unmount()
        24   -> FATFS_LinkDriver
         0   -> FATFS_UnLinkDriver
        24   -> FATFS_UnLinkDriver
        24   -> f_mount
        24   -> serialprintPGM(char const *)
       0   CardReader::close_CBD_File()
         0   -> f_close
       8   CardReader::closefile(bool)
         8   -> f_close
       0   CardReader::continuePrint(bool)
       4   CardReader::createFilename(char *, dir_t const &)
       0   CardReader::deleteFile(char *)
       8   CardReader::finishWrite()
         8   -> f_close
         8   -> f_sync
      16   CardReader::getStatus()
        16   -> Print::print(unsigned int, int)
         0   -> USARTClass::write(uint8_t)
         0   -> serialprintPGM(char const *)
        16   -> serialprintPGM(char const *)
       0   CardReader::get_file_list(char *)
         0   -> CardReader::Explore_Disk(char *, uint8_t)
       0   CardReader::getsdpos()
       0   CardReader::initsd()
      16   CardReader::initusb()
        16   -> f_mount
         0   -> serialprintPGM(char const *)
        16   -> serialprintPGM(char const *)
       0   CardReader::isFileOpen()
       0   CardReader::ls()
         0   -> CardReader::get_file_list(char *)
      16   CardReader::makeDirectory(char *)
        16   -> Print::print(char const *)
         0   -> USARTClass::write(uint8_t)
        16   -> f_close
        16   -> f_mkdir
       0   CardReader::mount()
         0   -> CardReader::initsd()
      88   CardReader::openFile(char *, bool, bool)
        88   -> Print::print(unsigned int, int)
        88   -> SdBaseFile::SdBaseFile()
        88   -> USARTClass::write(uint8_t)
        88   -> __aeabi_memclr4
        88   -> f_close
        88   -> f_open
        88   -> mks_saveFileName
        88   -> serial_echopair_P(char const *, char const *)
        88   -> serialprintPGM(char const *)
        88   -> strcat
       0   CardReader::openLogFile(char *)
         0   -> CardReader::openFile(char *, bool, bool)
     152   CardReader::open_CBD_File(char *)
       152   -> SdBaseFile::SdBaseFile()
       152   -> __aeabi_memclr4
       152   -> f_close
       152   -> f_open
       152   -> strcat
       0   CardReader::operatePrint()
       0   CardReader::pausePrint(bool)
       0   CardReader::pauseSDPrint()
       0   CardReader::printStatus()
       8   CardReader::printingHasFinished()
         8   -> Stepper::synchronize()
         8   -> Stopwatch::duration()
         8   -> Stopwatch::stop()
         0   -> enqueue_and_echo_commands_P(char const *)
         8   -> enqueue_and_echo_commands_P(char const *)
         8   -> f_close
       0   CardReader::release()
      16   CardReader::removeFile(char *)
        16   -> Print::print(char const *)
        16   -> USARTClass::write(uint8_t)
        16   -> f_close
        16   -> f_unlink
         0   -> serialprintPGM(char const *)
        16   -> serialprintPGM(char const *)
       0   CardReader::selectFile(char *, bool)
       0   CardReader::showFilename(uint8_t const *)
       8   CardReader::startFileprint()
         0   -> epr_read_data
         8   -> epr_write_data
       0   CardReader::startPrint()
      16   CardReader::startWrite(char *)
        16   -> f_close
        16   -> f_open
       0   CardReader::stopPrint()
       8   CardReader::stopSDPrint()
         0   -> CardReader::closefile(bool)
         8   -> CardReader::isFileOpen()
       0   CardReader::subobject CardReader()
         0   -> CardReader::CardReader()
      16   CardReader::udiskReset()
        16   -> FATFS_UnLinkDriver
        16   -> HAL_Delay
        16   -> MX_USB_HOST_DeInit
        16   -> MX_USB_HOST_Init
        16   -> serialprintPGM(char const *)
       0   CardReader::udiskState_Polling()
         0   -> CardReader::udiskReset()
       0   CardReader::unmount()
      32   CardReader::write_command(char *)
        32   -> f_write
        32   -> memset
        32   -> serialprintPGM(char const *)
        32   -> strchr(char *, int)
        32   -> strlen
      16   RFstricmp(char const *, char const *)
        16   -> tolower
      24   RFstrnicmp(char const *, char const *, size_t)
        24   -> tolower
       0   SdBaseFile::SdBaseFile()
       8   serialprintPGM(char const *)
         8   -> USARTClass::write(uint8_t)
       0   strchr(char *, int)
         0   -> __iar_Strchr
       0   strstr(char *, char const *)
         0   -> __iar_Strstr
       0   strstr(char const *, char const *)
         0   -> __iar_Strstr


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?<Constant " Size: ">
       8  ?<Constant ".CBD">
       8  ?<Constant ".CBDDLP">
       8  ?<Constant ".DIR\r\n">
       8  ?<Constant ".GCO">
       8  ?<Constant ".GCODE">
       8  ?<Constant ".MDL">
       8  ?<Constant ".PHO">
       8  ?<Constant ".PHOTON">
       4  ?<Constant ".\n">
       8  ?<Constant ".cbd">
       8  ?<Constant ".cbddlp">
       8  ?<Constant ".gco">
       8  ?<Constant ".gcode">
       8  ?<Constant ".mdl">
       8  ?<Constant ".mdlp">
       8  ?<Constant ".pho">
       8  ?<Constant ".photon">
       2  ?<Constant "/">
      16  ?<Constant "Creation failed">
      24  ?<Constant "Deletion failed, File: ">
      20  ?<Constant "Directory created">
      16  ?<Constant "File deleted:">
      16  ?<Constant "File opened: ">
      16  ?<Constant "File selected\n">
       4  ?<Constant "M31">
      12  ?<Constant "M84 X Y Z E">
      20  ?<Constant "Not SD printing\n">
      20  ?<Constant "SD card removed\n">
      20  ?<Constant "SD printing byte ">
      28  ?<Constant "System Volume Informa...">
      16  ?<Constant "USB DeInit!\n">
       8  ?<Constant "USB OK\n">
      12  ?<Constant "USB Reset!\n">
      16  ?<Constant "USB init fail\n">
      16  ?<Constant "USB inserted\n">
      16  ?<Constant "USB removed\n">
       4  ?<Constant "\r\n">
      24  ?<Constant "error writing to file\n">
      20  ?<Constant "open failed, File: ">
      32  ?<Constant {'\000'}>
     100  ?<Constant {'\000'}>_1
       4  ??DataTable56
       4  ??DataTable56_1
       4  ??DataTable58
       4  ??DataTable59
       4  ??DataTable59_1
       4  ??DataTable59_10
       4  ??DataTable59_11
       4  ??DataTable59_12
       4  ??DataTable59_13
       4  ??DataTable59_14
       4  ??DataTable59_15
       4  ??DataTable59_16
       4  ??DataTable59_2
       4  ??DataTable59_3
       4  ??DataTable59_4
       4  ??DataTable59_5
       4  ??DataTable59_6
       4  ??DataTable59_7
       4  ??DataTable59_8
       4  ??DataTable59_9
      42  CardReader::CardReader()
     278  CardReader::Explore_Disk(char *, uint8_t)
     560  CardReader::ShowSDFiles()
      72  CardReader::ascii2dec(char *, char)
       2  CardReader::automount()
     168  CardReader::checkFilesys(unsigned char)
     178  CardReader::checkautostart(bool)
       4  CardReader::close_CBD_File()
      20  CardReader::closefile(bool)
       2  CardReader::continuePrint(bool)
      52  CardReader::createFilename(char *, dir_t const &)
       2  CardReader::deleteFile(char *)
      32  CardReader::finishWrite()
      86  CardReader::getStatus()
      10  CardReader::get_file_list(char *)
       6  CardReader::getsdpos()
       8  CardReader::initsd()
      70  CardReader::initusb()
      16  CardReader::isFileOpen()
       6  CardReader::ls()
      94  CardReader::makeDirectory(char *)
      12  CardReader::mount()
     220  CardReader::openFile(char *, bool, bool)
      12  CardReader::openLogFile(char *)
     128  CardReader::open_CBD_File(char *)
       2  CardReader::operatePrint()
      20  CardReader::pausePrint(bool)
      22  CardReader::pauseSDPrint()
       2  CardReader::printStatus()
      62  CardReader::printingHasFinished()
      20  CardReader::release()
     112  CardReader::removeFile(char *)
       2  CardReader::selectFile(char *, bool)
      18  CardReader::showFilename(uint8_t const *)
      72  CardReader::startFileprint()
      20  CardReader::startPrint()
      62  CardReader::startWrite(char *)
      24  CardReader::stopPrint()
      32  CardReader::stopSDPrint()
       2  CardReader::subobject CardReader()
      86  CardReader::udiskReset()
      26  CardReader::udiskState_Polling()
      20  CardReader::unmount()
     118  CardReader::write_command(char *)
      62  RFstricmp(char const *, char const *)
      72  RFstrnicmp(char const *, char const *, size_t)
       8  SdBaseFile::SdBaseFile()
     256  lfn
     256  lfn
      28  serialprintPGM(char const *)
       4  strchr(char *, int)
       4  strstr(char *, char const *)
       4  strstr(char const *, char const *)
       4  textt
       1  -- Other

 
   516 bytes in section .bss
   147 bytes in section .rodata
 3 536 bytes in section .text
 
 3 472 bytes of CODE  memory (+ 64 bytes shared)
   146 bytes of CONST memory (+  1 byte  shared)
   516 bytes of DATA  memory

Errors: none
Warnings: 96
